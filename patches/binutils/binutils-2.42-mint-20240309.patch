diff --git a/bfd/Makefile.am b/bfd/Makefile.am
index 4f67b59585d..bc78f51c115 100644
--- a/bfd/Makefile.am
+++ b/bfd/Makefile.am
@@ -79,7 +79,7 @@ BFD32_LIBS = \
 	coff-bfd.lo compress.lo corefile.lo elf-properties.lo format.lo \
 	hash.lo libbfd.lo linker.lo merge.lo opncls.lo reloc.lo \
 	section.lo simple.lo stab-syms.lo stabs.lo syms.lo targets.lo \
-	binary.lo ihex.lo srec.lo tekhex.lo verilog.lo
+	binary.lo ihex.lo srec.lo tekhex.lo verilog.lo stat64.lo
 
 BFD64_LIBS = archive64.lo
 
@@ -88,7 +88,7 @@ BFD32_LIBS_CFILES = \
 	compress.c corefile.c elf-properties.c format.c hash.c \
 	libbfd.c linker.c merge.c opncls.c reloc.c \
 	section.c simple.c stab-syms.c stabs.c syms.c targets.c \
-	binary.c ihex.c srec.c tekhex.c verilog.c
+	binary.c ihex.c srec.c tekhex.c verilog.c stat64.c
 
 BFD64_LIBS_CFILES = archive64.c
 
@@ -267,6 +267,7 @@ ALL_MACHINES_CFILES = \
 BFD32_BACKENDS = \
 	aout-cris.lo \
 	aout-ns32k.lo \
+	aout0.lo \
 	aout32.lo \
 	cf-i386lynx.lo \
 	coff-go32.lo \
@@ -299,6 +300,7 @@ BFD32_BACKENDS = \
 	elf32-am33lin.lo \
 	elf32-arc.lo \
 	elf32-arm.lo \
+	elf32-atariprg.lo \
 	elf32-avr.lo \
 	elf32-bfin.lo \
 	elf32-cr16.lo \
@@ -386,6 +388,7 @@ BFD32_BACKENDS = \
 	peigen.lo \
 	plugin.lo \
 	ppcboot.lo \
+	prg-mint.lo \
 	reloc16.lo \
 	som.lo \
 	vax1knetbsd.lo \
@@ -402,6 +405,7 @@ BFD32_BACKENDS = \
 BFD32_BACKENDS_CFILES = \
 	aout-cris.c \
 	aout-ns32k.c \
+	aout0.c \
 	aout32.c \
 	cf-i386lynx.c \
 	coff-go32.c \
@@ -434,6 +438,7 @@ BFD32_BACKENDS_CFILES = \
 	elf32-am33lin.c \
 	elf32-arc.c \
 	elf32-arm.c \
+	elf32-atariprg.c \
 	elf32-avr.c \
 	elf32-bfin.c \
 	elf32-cr16.c \
@@ -520,6 +525,7 @@ BFD32_BACKENDS_CFILES = \
 	pei-sh.c \
 	plugin.c \
 	ppcboot.c \
+	prg-mint.c \
 	reloc16.c \
 	som.c \
 	vax1knetbsd.c \
@@ -702,11 +708,11 @@ CFILES = $(SOURCE_CFILES) $(BUILD_CFILES)
 ## This is a list of all .h files in the source tree minus those that
 ## are processed to produce other .h files
 SOURCE_HFILES = \
-	aout-target.h aoutx.h arc-got.h arc-plt.h \
+	aout-target.h aoutf1.h aoutx.h arc-got.h arc-plt.h \
 	coff-arm.h coff-bfd.h coffcode.h coffswap.h \
 	cpu-aarch64.h cpu-arm.h cpu-h8300.h cpu-m68k.h cpu-riscv.h \
 	ecoff-bfd.h ecoffswap.h \
-	elf32-arm.h elf32-avr.h elf32-bfin.h elf32-cr16.h elf32-csky.h \
+	elf32-arm.h elf32-atariprg.h elf32-avr.h elf32-bfin.h elf32-cr16.h elf32-csky.h \
 	elf32-dlx.h elf32-hppa.h elf32-m68hc1x.h elf32-m68k.h \
 	elf32-metag.h elf32-nds32.h elf32-nios2.h elf32-ppc.h \
 	elf32-rx.h elf32-score.h elf32-sh-relocs.h elf32-spu.h \
@@ -994,11 +1000,6 @@ bfdver.h: $(srcdir)/version.h $(srcdir)/development.sh $(srcdir)/Makefile.in
 	bfd_version_package="\"$(PKGVERSION)\"" ;\
 	report_bugs_to="\"$(REPORT_BUGS_TO)\"" ;\
 	. $(srcdir)/development.sh ;\
-	if test "$$development" = true ; then \
-	  bfd_version_date=`$(SED) -n -e 's/.*DATE //p' < $(srcdir)/version.h` ;\
-	  bfd_version_string="\"$(VERSION).$${bfd_version_date}\"" ;\
-	  bfd_soversion="$(VERSION).$${bfd_version_date}" ;\
-	fi ;\
 	$(SED) -e "s,@bfd_version@,$$bfd_version," \
 	    -e "s,@bfd_version_string@,$$bfd_version_string," \
 	    -e "s,@bfd_version_package@,$$bfd_version_package," \
diff --git a/bfd/Makefile.in b/bfd/Makefile.in
index faaa0c424b8..d21db6937b4 100644
--- a/bfd/Makefile.in
+++ b/bfd/Makefile.in
@@ -183,7 +183,7 @@ am__objects_1 = archive.lo archures.lo bfd.lo bfdio.lo bfdwin.lo \
 	cache.lo coff-bfd.lo compress.lo corefile.lo elf-properties.lo \
 	format.lo hash.lo libbfd.lo linker.lo merge.lo opncls.lo \
 	reloc.lo section.lo simple.lo stab-syms.lo stabs.lo syms.lo \
-	targets.lo binary.lo ihex.lo srec.lo tekhex.lo verilog.lo
+	targets.lo binary.lo ihex.lo srec.lo tekhex.lo verilog.lo stat64.lo
 am_libbfd_la_OBJECTS = $(am__objects_1)
 libbfd_la_OBJECTS = $(am_libbfd_la_OBJECTS)
 AM_V_lt = $(am__v_lt_@AM_V@)
@@ -546,7 +546,7 @@ BFD32_LIBS = \
 	coff-bfd.lo compress.lo corefile.lo elf-properties.lo format.lo \
 	hash.lo libbfd.lo linker.lo merge.lo opncls.lo reloc.lo \
 	section.lo simple.lo stab-syms.lo stabs.lo syms.lo targets.lo \
-	binary.lo ihex.lo srec.lo tekhex.lo verilog.lo
+	binary.lo ihex.lo srec.lo tekhex.lo verilog.lo stat64.lo
 
 BFD64_LIBS = archive64.lo
 BFD32_LIBS_CFILES = \
@@ -554,7 +554,7 @@ BFD32_LIBS_CFILES = \
 	compress.c corefile.c elf-properties.c format.c hash.c \
 	libbfd.c linker.c merge.c opncls.c reloc.c \
 	section.c simple.c stab-syms.c stabs.c syms.c targets.c \
-	binary.c ihex.c srec.c tekhex.c verilog.c
+	binary.c ihex.c srec.c tekhex.c verilog.c stat64.c
 
 BFD64_LIBS_CFILES = archive64.c
 
@@ -734,6 +734,7 @@ ALL_MACHINES_CFILES = \
 BFD32_BACKENDS = \
 	aout-cris.lo \
 	aout-ns32k.lo \
+	aout0.lo \
 	aout32.lo \
 	cf-i386lynx.lo \
 	coff-go32.lo \
@@ -766,6 +767,7 @@ BFD32_BACKENDS = \
 	elf32-am33lin.lo \
 	elf32-arc.lo \
 	elf32-arm.lo \
+	elf32-atariprg.lo \
 	elf32-avr.lo \
 	elf32-bfin.lo \
 	elf32-cr16.lo \
@@ -853,6 +855,7 @@ BFD32_BACKENDS = \
 	peigen.lo \
 	plugin.lo \
 	ppcboot.lo \
+	prg-mint.lo \
 	reloc16.lo \
 	som.lo \
 	vax1knetbsd.lo \
@@ -869,6 +872,7 @@ BFD32_BACKENDS = \
 BFD32_BACKENDS_CFILES = \
 	aout-cris.c \
 	aout-ns32k.c \
+	aout0.c \
 	aout32.c \
 	cf-i386lynx.c \
 	coff-go32.c \
@@ -901,6 +905,7 @@ BFD32_BACKENDS_CFILES = \
 	elf32-am33lin.c \
 	elf32-arc.c \
 	elf32-arm.c \
+	elf32-atariprg.c \
 	elf32-avr.c \
 	elf32-bfin.c \
 	elf32-cr16.c \
@@ -987,6 +992,7 @@ BFD32_BACKENDS_CFILES = \
 	pei-sh.c \
 	plugin.c \
 	ppcboot.c \
+	prg-mint.c \
 	reloc16.c \
 	som.c \
 	vax1knetbsd.c \
@@ -1166,11 +1172,11 @@ BUILD_CFILES = \
 
 CFILES = $(SOURCE_CFILES) $(BUILD_CFILES)
 SOURCE_HFILES = \
-	aout-target.h aoutx.h arc-got.h arc-plt.h \
+	aout-target.h aoutf1.h aoutx.h arc-got.h arc-plt.h \
 	coff-arm.h coff-bfd.h coffcode.h coffswap.h \
 	cpu-aarch64.h cpu-arm.h cpu-h8300.h cpu-m68k.h cpu-riscv.h \
 	ecoff-bfd.h ecoffswap.h \
-	elf32-arm.h elf32-avr.h elf32-bfin.h elf32-cr16.h elf32-csky.h \
+	elf32-arm.h elf32-atariprg.h elf32-avr.h elf32-bfin.h elf32-cr16.h elf32-csky.h \
 	elf32-dlx.h elf32-hppa.h elf32-m68hc1x.h elf32-m68k.h \
 	elf32-metag.h elf32-nds32.h elf32-nios2.h elf32-ppc.h \
 	elf32-rx.h elf32-score.h elf32-sh-relocs.h elf32-spu.h \
@@ -1448,6 +1454,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/aix5ppc-core.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/aout-cris.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/aout-ns32k.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/aout0.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/aout32.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/aout64.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/archive.Plo@am__quote@
@@ -1580,6 +1587,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-am33lin.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-arc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-arm.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-atariprg.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-avr.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-bfin.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-cr16.Plo@am__quote@
@@ -1728,6 +1736,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pex64igen.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/plugin.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ppcboot.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/prg-mint.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/reloc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/reloc16.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rs6000-core.Plo@am__quote@
@@ -2470,11 +2479,6 @@ bfdver.h: $(srcdir)/version.h $(srcdir)/development.sh $(srcdir)/Makefile.in
 	bfd_version_package="\"$(PKGVERSION)\"" ;\
 	report_bugs_to="\"$(REPORT_BUGS_TO)\"" ;\
 	. $(srcdir)/development.sh ;\
-	if test "$$development" = true ; then \
-	  bfd_version_date=`$(SED) -n -e 's/.*DATE //p' < $(srcdir)/version.h` ;\
-	  bfd_version_string="\"$(VERSION).$${bfd_version_date}\"" ;\
-	  bfd_soversion="$(VERSION).$${bfd_version_date}" ;\
-	fi ;\
 	$(SED) -e "s,@bfd_version@,$$bfd_version," \
 	    -e "s,@bfd_version_string@,$$bfd_version_string," \
 	    -e "s,@bfd_version_package@,$$bfd_version_package," \
diff --git a/bfd/acinclude.m4 b/bfd/acinclude.m4
index 0ba7957760d..68674e32782 100644
--- a/bfd/acinclude.m4
+++ b/bfd/acinclude.m4
@@ -21,7 +21,7 @@ AC_DEFUN([BFD_BINARY_FOPEN],
 [AC_REQUIRE([AC_CANONICAL_TARGET])
 case "${host}" in
 changequote(,)dnl
-*-*-msdos* | *-*-go32* | *-*-mingw32* | *-*-cygwin* | *-*-windows*)
+*-*-msdos* | *-*-go32* | *-*-mingw* | *-*-cygwin* | *-*-windows* | *-*-mint*)
 changequote([,])dnl
   AC_DEFINE(USE_BINARY_FOPEN, 1, [Use b modifier when opening binary files?]) ;;
 esac])dnl
diff --git a/bfd/aout0.c b/bfd/aout0.c
new file mode 100644
index 00000000000..890dce6de14
--- /dev/null
+++ b/bfd/aout0.c
@@ -0,0 +1,38 @@
+/* BFD backend for SunOS style a.out with flags set to 0
+   Copyright (C) 1990-2018 Free Software Foundation, Inc.
+   Written by Cygnus Support.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#define TARGETNAME "a.out-zero-big"
+
+/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
+   remove whitespace added here, and thus will fail to concatenate
+   the tokens.  */
+#define MY(OP) CONCAT2 (aout0_be_,OP)
+
+#include "sysdep.h"
+#include "bfd.h"
+
+#define MY_exec_hdr_flags 0
+
+#define MACHTYPE_OK(mtype) \
+  ((mtype) == M_UNKNOWN || (mtype) == M_68010 || (mtype) == M_68020)
+
+/* Include the usual a.out support.  */
+#include "aoutf1.h"
diff --git a/bfd/aoutf1.h b/bfd/aoutf1.h
new file mode 100644
index 00000000000..cf646e46e25
--- /dev/null
+++ b/bfd/aoutf1.h
@@ -0,0 +1,510 @@
+/* A.out "format 1" file handling code for BFD.
+   Copyright (C) 1990-2018 Free Software Foundation, Inc.
+   Written by Cygnus Support.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+
+#include "aout/sun4.h"
+#include "libaout.h"		/* BFD a.out internal data structures.  */
+
+#include "aout/aout64.h"
+#include "aout/stab_gnu.h"
+#include "aout/ar.h"
+
+/* This is needed to reject a NewsOS file, e.g. in
+   gdb/testsuite/gdb.t10/crossload.exp. <kingdon@cygnus.com>
+   I needed to add M_UNKNOWN to recognize a 68000 object, so this will
+   probably no longer reject a NewsOS object.  <ian@cygnus.com>.  */
+#ifndef MACHTYPE_OK
+#define MACHTYPE_OK(mtype) \
+  (((mtype) == M_SPARC && bfd_lookup_arch (bfd_arch_sparc, 0) != NULL) \
+   || (((mtype) == M_UNKNOWN || (mtype) == M_68010 || (mtype) == M_68020) \
+       && bfd_lookup_arch (bfd_arch_m68k, 0) != NULL))
+#endif
+
+/* The file @code{aoutf1.h} contains the code for BFD's
+   a.out back end.  Control over the generated back end is given by these
+   two preprocessor names:
+   @table @code
+   @item ARCH_SIZE
+   This value should be either 32 or 64, depending upon the size of an
+   int in the target format. It changes the sizes of the structs which
+   perform the memory/disk mapping of structures.
+
+   The 64 bit backend may only be used if the host compiler supports 64
+   ints (eg long long with gcc), by defining the name @code{BFD_HOST_64_BIT} in @code{bfd.h}.
+   With this name defined, @emph{all} bfd operations are performed with 64bit
+   arithmetic, not just those to a 64bit target.
+
+   @item TARGETNAME
+   The name put into the target vector.
+   @item
+   @end table.  */
+
+#if ARCH_SIZE == 64
+#define sunos_set_arch_mach sunos_64_set_arch_mach
+#define sunos_write_object_contents aout_64_sunos4_write_object_contents
+#else
+#define sunos_set_arch_mach sunos_32_set_arch_mach
+#define sunos_write_object_contents aout_32_sunos4_write_object_contents
+#endif
+
+/* Merge backend data into the output file.
+   This is necessary on sparclet-aout where we want the resultant machine
+   number to be M_SPARCLET if any input file is M_SPARCLET.  */
+
+#define MY_bfd_merge_private_bfd_data sunos_merge_private_bfd_data
+
+static bool
+sunos_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
+{
+  bfd *obfd = info->output_bfd;
+  if (bfd_get_flavour (ibfd) != bfd_target_aout_flavour
+      || bfd_get_flavour (obfd) != bfd_target_aout_flavour)
+    return true;
+
+  if (bfd_get_arch (obfd) == bfd_arch_sparc)
+    {
+      if (bfd_get_mach (obfd) < bfd_get_mach (ibfd))
+	bfd_set_arch_mach (obfd, bfd_arch_sparc, bfd_get_mach (ibfd));
+    }
+
+  return true;
+}
+
+/* This is either sunos_32_set_arch_mach or sunos_64_set_arch_mach,
+   depending upon ARCH_SIZE.  */
+
+static void
+sunos_set_arch_mach (bfd *abfd, enum machine_type machtype)
+{
+  /* Determine the architecture and machine type of the object file.  */
+  enum bfd_architecture arch;
+  unsigned long machine;
+
+  switch (machtype)
+    {
+    case M_UNKNOWN:
+      /* Some Sun3s make magic numbers without cpu types in them, so
+	 we'll default to the 68000.  */
+      arch = bfd_arch_m68k;
+      machine = bfd_mach_m68000;
+      break;
+
+    case M_68010:
+    case M_HP200:
+      arch = bfd_arch_m68k;
+      machine = bfd_mach_m68010;
+      break;
+
+    case M_68020:
+    case M_HP300:
+      arch = bfd_arch_m68k;
+      machine = bfd_mach_m68020;
+      break;
+
+    case M_SPARC:
+      arch = bfd_arch_sparc;
+      machine = 0;
+      break;
+
+    case M_SPARCLET:
+      arch = bfd_arch_sparc;
+      machine = bfd_mach_sparc_sparclet;
+      break;
+
+    case M_SPARCLITE_LE:
+      arch = bfd_arch_sparc;
+      machine = bfd_mach_sparc_sparclite_le;
+      break;
+
+    case M_386:
+    case M_386_DYNIX:
+      arch = bfd_arch_i386;
+      machine = 0;
+      break;
+
+    case M_HPUX:
+      arch = bfd_arch_m68k;
+      machine = 0;
+      break;
+
+    default:
+      arch = bfd_arch_obscure;
+      machine = 0;
+      break;
+    }
+  bfd_set_arch_mach (abfd, arch, machine);
+}
+
+#define SET_ARCH_MACH(ABFD, EXECP) \
+  NAME(sunos,set_arch_mach) (ABFD, N_MACHTYPE (EXECP)); \
+  choose_reloc_size(ABFD);
+
+/* Determine the size of a relocation entry, based on the architecture.  */
+
+static void
+choose_reloc_size (bfd *abfd)
+{
+  switch (bfd_get_arch (abfd))
+    {
+    case bfd_arch_sparc:
+      obj_reloc_entry_size (abfd) = RELOC_EXT_SIZE;
+      break;
+    default:
+      obj_reloc_entry_size (abfd) = RELOC_STD_SIZE;
+      break;
+    }
+}
+
+/* Write an object file in SunOS format.  Section contents have
+   already been written.  We write the file header, symbols, and
+   relocation.  The real name of this function is either
+   aout_64_sunos4_write_object_contents or
+   aout_32_sunos4_write_object_contents, depending upon ARCH_SIZE.  */
+
+static bool
+sunos_write_object_contents (bfd *abfd)
+{
+  struct external_exec exec_bytes;
+  struct internal_exec *execp = exec_hdr (abfd);
+
+  /* Magic number, maestro, please!  */
+  switch (bfd_get_arch (abfd))
+    {
+    case bfd_arch_m68k:
+      switch (bfd_get_mach (abfd))
+	{
+	case bfd_mach_m68000:
+	  N_SET_MACHTYPE (execp, M_UNKNOWN);
+	  break;
+	case bfd_mach_m68010:
+	  N_SET_MACHTYPE (execp, M_68010);
+	  break;
+	default:
+	case bfd_mach_m68020:
+	  N_SET_MACHTYPE (execp, M_68020);
+	  break;
+	}
+      break;
+    case bfd_arch_sparc:
+      switch (bfd_get_mach (abfd))
+	{
+	case bfd_mach_sparc_sparclet:
+	  N_SET_MACHTYPE (execp, M_SPARCLET);
+	  break;
+	case bfd_mach_sparc_sparclite_le:
+	  N_SET_MACHTYPE (execp, M_SPARCLITE_LE);
+	  break;
+	default:
+	  N_SET_MACHTYPE (execp, M_SPARC);
+	  break;
+	}
+      break;
+    case bfd_arch_i386:
+      N_SET_MACHTYPE (execp, M_386);
+      break;
+    default:
+      N_SET_MACHTYPE (execp, M_UNKNOWN);
+    }
+
+  choose_reloc_size (abfd);
+
+  N_SET_FLAGS (execp, aout_backend_info (abfd)->exec_hdr_flags);
+
+  N_SET_DYNAMIC (execp, (long)(bfd_get_file_flags (abfd) & DYNAMIC));
+
+  WRITE_HEADERS (abfd, execp);
+
+  return true;
+}
+
+/* Core files.  */
+
+#define CORE_MAGIC   0x080456
+#define CORE_NAMELEN 16
+
+/* The core structure is taken from the Sun documentation.
+  Unfortunately, they don't document the FPA structure, or at least I
+  can't find it easily.  Fortunately the core header contains its own
+  length.  So this shouldn't cause problems, except for c_ucode, which
+  so far we don't use but is easy to find with a little arithmetic.  */
+
+/* But the reg structure can be gotten from the SPARC processor handbook.
+  This really should be in a GNU include file though so that gdb can use
+  the same info.  */
+struct regs
+{
+  int r_psr;
+  int r_pc;
+  int r_npc;
+  int r_y;
+  int r_g1;
+  int r_g2;
+  int r_g3;
+  int r_g4;
+  int r_g5;
+  int r_g6;
+  int r_g7;
+  int r_o0;
+  int r_o1;
+  int r_o2;
+  int r_o3;
+  int r_o4;
+  int r_o5;
+  int r_o6;
+  int r_o7;
+};
+
+/* Taken from Sun documentation: */
+
+/* FIXME:  It's worse than we expect.  This struct contains TWO substructs
+  neither of whose size we know, WITH STUFF IN BETWEEN THEM!  We can't
+  even portably access the stuff in between!  */
+
+struct external_sparc_core
+{
+  int c_magic;				/* Corefile magic number.  */
+  int c_len;				/* Sizeof (struct core).  */
+#define	SPARC_CORE_LEN	432
+  struct regs c_regs;			/* General purpose registers -- MACHDEP SIZE.  */
+  struct external_exec c_aouthdr;	/* A.out header.  */
+  int c_signo;				/* Killing signal, if any.  */
+  int c_tsize;				/* Text size (bytes).  */
+  int c_dsize;				/* Data size (bytes).  */
+  int c_ssize;				/* Stack size (bytes).  */
+  char c_cmdname[CORE_NAMELEN + 1];	/* Command name.  */
+  double fp_stuff[1];			/* External FPU state (size unknown by us).  */
+  /* The type "double" is critical here, for alignment.
+     SunOS declares a struct here, but the struct's
+     alignment is double since it contains doubles.  */
+  int c_ucode;				/* Exception no. from u_code.  */
+  /* This member is not accessible by name since
+     we don't portably know the size of fp_stuff.  */
+};
+
+/* Core files generated by the BCP (the part of Solaris which allows
+   it to run SunOS4 a.out files).  */
+struct external_solaris_bcp_core
+{
+  int c_magic;				/* Corefile magic number.  */
+  int c_len;				/* Sizeof (struct core).  */
+#define	SOLARIS_BCP_CORE_LEN	456
+  struct regs c_regs;			/* General purpose registers -- MACHDEP SIZE.  */
+  int c_exdata_vp;			/* Exdata structure.  */
+  int c_exdata_tsize;
+  int c_exdata_dsize;
+  int c_exdata_bsize;
+  int c_exdata_lsize;
+  int c_exdata_nshlibs;
+  short c_exdata_mach;
+  short c_exdata_mag;
+  int c_exdata_toffset;
+  int c_exdata_doffset;
+  int c_exdata_loffset;
+  int c_exdata_txtorg;
+  int c_exdata_datorg;
+  int c_exdata_entloc;
+  int c_signo;				/* Killing signal, if any.  */
+  int c_tsize;				/* Text size (bytes).  */
+  int c_dsize;				/* Data size (bytes).  */
+  int c_ssize;				/* Stack size (bytes).  */
+  char c_cmdname[CORE_NAMELEN + 1];	/* Command name.  */
+  double fp_stuff[1];			/* External FPU state (size unknown by us).  */
+  /* The type "double" is critical here, for alignment.
+     SunOS declares a struct here, but the struct's
+     alignment is double since it contains doubles.  */
+  int c_ucode;				/* Exception no. from u_code.  */
+  /* This member is not accessible by name since
+     we don't portably know the size of fp_stuff.  */
+};
+
+struct external_sun3_core
+{
+  int c_magic;				/* Corefile magic number.  */
+  int c_len;				/* Sizeof (struct core).  */
+#define	SUN3_CORE_LEN	826		/* As of SunOS 4.1.1.  */
+  int c_regs[18];			/* General purpose registers -- MACHDEP SIZE.  */
+  struct external_exec c_aouthdr;	/* A.out header.  */
+  int c_signo;				/* Killing signal, if any.  */
+  int c_tsize;				/* Text size (bytes).  */
+  int c_dsize;				/* Data size (bytes).  */
+  int c_ssize;				/* Stack size (bytes).  */
+  char c_cmdname[CORE_NAMELEN + 1];	/* Command name.  */
+  double fp_stuff[1];			/* External FPU state (size unknown by us).  */
+  /* The type "double" is critical here, for alignment.
+     SunOS declares a struct here, but the struct's
+     alignment is double since it contains doubles.  */
+  int c_ucode;				/* Exception no. from u_code.  */
+  /* This member is not accessible by name since
+     we don't portably know the size of fp_stuff.  */
+};
+
+struct internal_sunos_core
+{
+  int c_magic;				/* Corefile magic number.  */
+  int c_len;				/* Sizeof (struct core).  */
+  long c_regs_pos;			/* File offset of General purpose registers.  */
+  int c_regs_size;			/* Size of General purpose registers.  */
+  struct internal_exec c_aouthdr;	/* A.out header.  */
+  int c_signo;				/* Killing signal, if any.  */
+  int c_tsize;				/* Text size (bytes).  */
+  int c_dsize;				/* Data size (bytes).  */
+  bfd_vma c_data_addr;			/* Data start (address).  */
+  int c_ssize;				/* Stack size (bytes).  */
+  bfd_vma c_stacktop;			/* Stack top (address).  */
+  char c_cmdname[CORE_NAMELEN + 1];	/* Command name.  */
+  long fp_stuff_pos;			/* File offset of external FPU state (regs).  */
+  int fp_stuff_size;			/* Size of it.  */
+  int c_ucode;				/* Exception no. from u_code.  */
+};
+
+/* Need this cast because ptr is really void *.  */
+#define core_hdr(bfd)      ((bfd)->tdata.sun_core_data)
+#define core_datasec(bfd)  (core_hdr (bfd)->data_section)
+#define core_stacksec(bfd) (core_hdr (bfd)->stack_section)
+#define core_regsec(bfd)   (core_hdr (bfd)->reg_section)
+#define core_reg2sec(bfd)  (core_hdr (bfd)->reg2_section)
+
+/* These are stored in the bfd's tdata.  */
+struct sun_core_struct
+{
+  struct internal_sunos_core *hdr;	/* Core file header.  */
+  asection *data_section;
+  asection *stack_section;
+  asection *reg_section;
+  asection *reg2_section;
+};
+
+static char *
+sunos4_core_file_failing_command (bfd *abfd)
+{
+  return core_hdr (abfd)->hdr->c_cmdname;
+}
+
+static int
+sunos4_core_file_failing_signal (bfd *abfd)
+{
+  return core_hdr (abfd)->hdr->c_signo;
+}
+
+static bool
+sunos4_core_file_matches_executable_p (bfd *core_bfd, bfd *exec_bfd)
+{
+  if (core_bfd->xvec != exec_bfd->xvec)
+    {
+      bfd_set_error (bfd_error_system_call);
+      return false;
+    }
+
+  /* Solaris core files do not include an aouthdr.  */
+  if ((core_hdr (core_bfd)->hdr)->c_len == SOLARIS_BCP_CORE_LEN)
+    return true;
+
+  return memcmp ((char *) &((core_hdr (core_bfd)->hdr)->c_aouthdr),
+		 (char *) exec_hdr (exec_bfd),
+		 sizeof (struct internal_exec)) == 0;
+}
+
+#define MY_set_sizes sunos4_set_sizes
+
+static bool
+sunos4_set_sizes (bfd *abfd)
+{
+  switch (bfd_get_arch (abfd))
+    {
+    default:
+      return false;
+    case bfd_arch_sparc:
+      adata (abfd).page_size = 0x2000;
+      adata (abfd).segment_size = 0x2000;
+      adata (abfd).exec_bytes_size = EXEC_BYTES_SIZE;
+      return true;
+    case bfd_arch_m68k:
+      adata (abfd).page_size = 0x2000;
+      adata (abfd).segment_size = 0x20000;
+      adata (abfd).exec_bytes_size = EXEC_BYTES_SIZE;
+      return true;
+    }
+}
+
+/* We default to setting the toolversion field to 1, as is required by
+   SunOS.  */
+#ifndef MY_exec_hdr_flags
+#define MY_exec_hdr_flags 1
+#endif
+
+#ifndef MY_entry_is_text_address
+#define MY_entry_is_text_address 0
+#endif
+#ifndef MY_add_dynamic_symbols
+#define MY_add_dynamic_symbols 0
+#endif
+#ifndef MY_add_one_symbol
+#define MY_add_one_symbol 0
+#endif
+#ifndef MY_link_dynamic_object
+#define MY_link_dynamic_object 0
+#endif
+#ifndef MY_write_dynamic_symbol
+#define MY_write_dynamic_symbol 0
+#endif
+#ifndef MY_check_dynamic_reloc
+#define MY_check_dynamic_reloc 0
+#endif
+#ifndef MY_finish_dynamic_link
+#define MY_finish_dynamic_link 0
+#endif
+
+static const struct aout_backend_data sunos4_aout_backend =
+{
+  0,				/* Zmagic files are not contiguous.  */
+  1,				/* Text includes header.  */
+  MY_entry_is_text_address,
+  MY_exec_hdr_flags,
+  0,				/* Default text vma.  */
+  sunos4_set_sizes,
+  0,				/* Header is counted in zmagic text.  */
+  MY_add_dynamic_symbols,
+  MY_add_one_symbol,
+  MY_link_dynamic_object,
+  MY_write_dynamic_symbol,
+  MY_check_dynamic_reloc,
+  MY_finish_dynamic_link
+};
+
+#define	MY_core_file_failing_command	sunos4_core_file_failing_command
+#define	MY_core_file_failing_signal	sunos4_core_file_failing_signal
+#define	MY_core_file_matches_executable_p sunos4_core_file_matches_executable_p
+
+#define MY_bfd_debug_info_start		_bfd_void_bfd
+#define MY_bfd_debug_info_end		_bfd_void_bfd
+#define MY_bfd_debug_info_accumulate	_bfd_void_bfd_asection
+#define MY_core_file_p			_bfd_dummy_target
+#define MY_write_object_contents	NAME(aout, sunos4_write_object_contents)
+#define MY_backend_data			& sunos4_aout_backend
+
+#ifndef TARGET_IS_LITTLE_ENDIAN_P
+#define TARGET_IS_BIG_ENDIAN_P
+#endif
+
+#include "aout-target.h"
diff --git a/bfd/aoutx.h b/bfd/aoutx.h
index 545285c823c..3900657741a 100644
--- a/bfd/aoutx.h
+++ b/bfd/aoutx.h
@@ -480,7 +480,10 @@ NAME (aout, some_aout_object_p) (bfd *abfd,
   oldrawptr = abfd->tdata.aout_data;
   abfd->tdata.aout_data = rawptr;
 
-  /* Copy the contents of the old tdata struct.  */
+  /* Copy the contents of the old tdata struct.
+     In particular, we want the subformat, since for hpux it was set in
+     hp300hpux.c:swap_exec_header_in and will be used in
+     hp300hpux.c:callback.  */
   if (oldrawptr != NULL)
     *abfd->tdata.aout_data = *oldrawptr;
 
@@ -760,6 +763,17 @@ NAME (aout, machine_type) (enum bfd_architecture arch,
 	arch_flags = M_SPARCLET;
       break;
 
+    case bfd_arch_m68k:
+      switch (machine)
+	{
+	case 0:		      arch_flags = M_68010; break;
+	case bfd_mach_m68000: arch_flags = M_UNKNOWN; *unknown = false; break;
+	case bfd_mach_m68010: arch_flags = M_68010; break;
+	case bfd_mach_m68020: arch_flags = M_68020; break;
+	default:	      arch_flags = M_UNKNOWN; break;
+	}
+      break;
+
     case bfd_arch_i386:
       if (machine == 0
 	  || machine == bfd_mach_i386_i386
@@ -1284,6 +1298,8 @@ NAME (aout, set_section_contents) (bfd *abfd,
 static bool
 aout_get_external_symbols (bfd *abfd)
 {
+  if (bfd_get_flavour(abfd) != bfd_target_aout_flavour)
+    return false;
   if (obj_aout_external_syms (abfd) == NULL)
     {
       bfd_size_type count;
@@ -1847,13 +1863,32 @@ emit_stringtab (bfd *abfd, struct bfd_strtab_hash *tab)
 {
   bfd_byte buffer[BYTES_IN_WORD];
   size_t amt = BYTES_IN_WORD;
+  bfd_size_type odd;
+
+  /* The MiNT backend writes past the string table.  It therefore has to
+     know about the table size.  */
+  obj_aout_external_string_size (abfd) = _bfd_stringtab_size (tab) +
+    BYTES_IN_WORD;
+  /* For MiNT atleast, the size of the string table should be even,
+     or the TPA relocation (and its first longword) will start on
+     an odd address */
+  odd = obj_aout_external_string_size (abfd) & 1;
+  obj_aout_external_string_size (abfd) += odd;
 
   /* The string table starts with the size.  */
-  PUT_WORD (abfd, _bfd_stringtab_size (tab) + BYTES_IN_WORD, buffer);
+  PUT_WORD (abfd, obj_aout_external_string_size (abfd), buffer);
   if (bfd_write (buffer, amt, abfd) != amt)
     return false;
 
-  return _bfd_stringtab_emit (abfd, tab);
+  if (_bfd_stringtab_emit (abfd, tab) == false)
+    return false;
+  if (odd)
+    {
+      buffer[0] = 0;
+      if (bfd_write (buffer, 1, abfd) != 1)
+        return false;
+    }
+  return true;
 }
 
 bool
@@ -4281,10 +4316,17 @@ aout_link_input_section_std (struct aout_final_link_info *flaginfo,
 		(flaginfo->info, name, input_bfd, input_section, r_addr, true);
 	    }
 
+#ifdef MY_final_link_relocate_rel
+	  r = MY_final_link_relocate_rel (howto,
+					  input_bfd, input_section,
+					  contents, r_addr, relocation,
+					  (bfd_vma) 0, rel);
+#else
 	  r = MY_final_link_relocate (howto,
 				      input_bfd, input_section,
 				      contents, r_addr, relocation,
 				      (bfd_vma) 0);
+#endif
 	}
 
       if (r != bfd_reloc_ok)
@@ -5482,7 +5524,8 @@ NAME (aout, final_link) (bfd *abfd,
      FIXME: At this point we do not know how much space the symbol
      table will require.  This will not work for any (nonstandard)
      a.out target that needs to know the symbol table size before it
-     can compute the relocation file positions.  */
+     can compute the relocation file positions.  This may or may not
+     be the case for the hp300hpux target, for example.  */
   (*callback) (abfd, &aout_info.treloff, &aout_info.dreloff,
 	       &aout_info.symoff);
   obj_textsec (abfd)->rel_filepos = aout_info.treloff;
diff --git a/bfd/archive.c b/bfd/archive.c
index 9f3fbce9bc9..e9438db6bdc 100644
--- a/bfd/archive.c
+++ b/bfd/archive.c
@@ -936,7 +936,7 @@ bfd_generic_archive_p (bfd *abfd)
       return NULL;
     }
 
-  if (abfd->target_defaulted && bfd_has_map (abfd))
+  if (bfd_has_map (abfd))
     {
       bfd *first;
       unsigned int save;
@@ -961,7 +961,14 @@ bfd_generic_archive_p (bfd *abfd)
 	  first->target_defaulted = false;
 	  if (bfd_check_format (first, bfd_object)
 	      && first->xvec != abfd->xvec)
-	    bfd_set_error (bfd_error_wrong_object_format);
+	    {
+	      bfd_set_error (bfd_error_wrong_object_format);
+	      if (abfd->is_linker_input)
+	        {
+	          bfd_ardata (abfd) = tdata_hold;
+	          return NULL;
+	        }
+	    }
 	  bfd_close (first);
 	}
     }
@@ -1249,6 +1256,13 @@ bfd_slurp_armap (bfd *abfd)
   return true;
 }
 
+/* Returns FALSE on error, TRUE otherwise.  */
+/* Flavor 2 of a bsd armap, similar to bfd_slurp_bsd_armap except the
+   header is in a slightly different order and the map name is '/'.
+   This flavour is used by hp300hpux.  */
+
+#define HPUX_SYMDEF_COUNT_SIZE 2
+
 /** Extended name table.
 
   Normally archives support only 14-character filenames.
diff --git a/bfd/bfd-in.h b/bfd/bfd-in.h
index 0ff1e2f3ed5..af40a08e6f0 100644
--- a/bfd/bfd-in.h
+++ b/bfd/bfd-in.h
@@ -23,11 +23,6 @@
 #ifndef __BFD_H_SEEN__
 #define __BFD_H_SEEN__
 
-/* PR 14072: Ensure that config.h is included first.  */
-#if !defined PACKAGE && !defined PACKAGE_VERSION
-#error config.h must be included before this header
-#endif
-
 #ifdef __cplusplus
 extern "C" {
 #endif
diff --git a/bfd/bfd-in2.h b/bfd/bfd-in2.h
index dbafcf8da36..fa8ce01dd76 100644
--- a/bfd/bfd-in2.h
+++ b/bfd/bfd-in2.h
@@ -2251,6 +2251,7 @@ struct bfd
       struct tekhex_data_struct *tekhex_data;
       struct elf_obj_tdata *elf_obj_data;
       struct mmo_data_struct *mmo_data;
+      struct sun_core_struct *sun_core_data;
       struct trad_core_struct *trad_core_data;
       struct som_data_struct *som_data;
       struct hpux_core_struct *hpux_core_data;
@@ -2771,6 +2772,15 @@ ATTRIBUTE_WARN_UNUSED_RESULT;
 
 time_t bfd_get_current_time (time_t now);
 
+/* MiNT executable support routines for the linker.  */
+
+extern bool bfd_m68kmint_set_extended_flags
+  (bfd *, flagword);
+extern bool bfd_m68kmint_set_stack_size
+  (bfd *, bfd_signed_vma);
+extern bool bfd_m68kmint_add_tpa_relocation_entry
+  (bfd *, bfd_vma);
+
 /* Extracted from bfdwin.c.  */
 struct _bfd_window_internal;
 
diff --git a/bfd/bfd.c b/bfd/bfd.c
index 0776145af52..27fdda5bc87 100644
--- a/bfd/bfd.c
+++ b/bfd/bfd.c
@@ -662,6 +662,7 @@ EXTERNAL
 #include "libecoff.h"
 #undef obj_symbols
 #include "elf-bfd.h"
+#include "elf32-atariprg.h"
 
 #ifndef EXIT_FAILURE
 #define EXIT_FAILURE 1
@@ -730,6 +731,11 @@ CODE_FRAGMENT
 .
 */
 
+#if !defined(TLS) || defined(__MINT__)
+#undef TLS
+#define TLS
+#endif
+
 static TLS bfd_error_type bfd_error;
 static TLS bfd_error_type input_error;
 static TLS bfd *input_bfd;
@@ -1746,6 +1752,8 @@ bfd_init (void)
   _bfd_error_internal = error_handler_fprintf;
   _bfd_assert_handler = _bfd_default_assert_handler;
 
+  bfd_elf32_atariprg_init ();
+
   return BFD_INIT_MAGIC;
 }
 
diff --git a/bfd/compress.c b/bfd/compress.c
index 8bc44de813b..97f32e4378c 100644
--- a/bfd/compress.c
+++ b/bfd/compress.c
@@ -751,7 +751,7 @@ bfd_get_full_section_contents (bfd *abfd, sec_ptr sec, bfd_byte **ptr)
     case COMPRESS_SECTION_NONE:
       if (p == NULL)
 	{
-	  p = (bfd_byte *) bfd_malloc (allocsz);
+	  p = (bfd_byte *) bfd_zmalloc (allocsz);
 	  if (p == NULL)
 	    {
 	      /* PR 20801: Provide a more helpful error message.  */
@@ -797,7 +797,7 @@ bfd_get_full_section_contents (bfd *abfd, sec_ptr sec, bfd_byte **ptr)
 	goto fail_compressed;
 
       if (p == NULL)
-	p = (bfd_byte *) bfd_malloc (allocsz);
+	p = (bfd_byte *) bfd_zmalloc (allocsz);
       if (p == NULL)
 	goto fail_compressed;
 
@@ -828,7 +828,7 @@ bfd_get_full_section_contents (bfd *abfd, sec_ptr sec, bfd_byte **ptr)
 	return false;
       if (p == NULL)
 	{
-	  p = (bfd_byte *) bfd_malloc (allocsz);
+	  p = (bfd_byte *) bfd_zmalloc (allocsz);
 	  if (p == NULL)
 	    return false;
 	  *ptr = p;
diff --git a/bfd/config.bfd b/bfd/config.bfd
index bbf12447517..0ab477094f1 100644
--- a/bfd/config.bfd
+++ b/bfd/config.bfd
@@ -78,6 +78,9 @@ case $targ in
  mips*-*-irix5* | mips*-*-irix6*)
     # Not obsolete
     ;;
+ m68*-*-mint*)
+    # Not obsolete
+    ;;
  *-adobe-* | \
  *-go32-rtems* | \
  *-sony-* | \
@@ -855,6 +858,16 @@ case "${targ}" in
     targ_selvecs="m68hc11_elf32_vec m68hc12_elf32_vec"
     ;;
 
+  m68*-*-mintelf*)
+    targ_defvec=m68k_elf32_vec
+    targ_selvecs="m68k_elf32_vec m68k_elf32_atariprg_vec"
+    ;;
+  m68*-*-mint*)
+    targ_defvec=aout0_be_vec
+    targ_selvecs=m68k_aout_mintprg_vec
+    targ_underscore=yes
+    ;;
+
   m68*-*-*)
     targ_defvec=m68k_elf32_vec
     ;;
diff --git a/bfd/config.in b/bfd/config.in
index 7458362922c..d5c82be8bab 100644
--- a/bfd/config.in
+++ b/bfd/config.in
@@ -384,3 +384,5 @@
 
 /* Use structured /proc on Solaris. */
 #undef _STRUCTURED_PROC
+
+#include "libcwrap.h"
diff --git a/bfd/configure b/bfd/configure
index acbac2f364a..fe9793427c3 100755
--- a/bfd/configure
+++ b/bfd/configure
@@ -15179,7 +15179,7 @@ _ACEOF
 
 
 case "${host}" in
-*-*-msdos* | *-*-go32* | *-*-mingw32* | *-*-cygwin* | *-*-windows*)
+*-*-msdos* | *-*-go32* | *-*-mingw* | *-*-cygwin* | *-*-windows* | *-*-mint*)
 
 $as_echo "#define USE_BINARY_FOPEN 1" >>confdefs.h
  ;;
@@ -15927,6 +15927,8 @@ do
     m68hc11_elf32_vec)		 tb="$tb elf32-m68hc11.lo elf32-m68hc1x.lo elf32.lo $elf" ;;
     m68hc12_elf32_vec)		 tb="$tb elf32-m68hc12.lo elf32-m68hc1x.lo elf32.lo $elf" ;;
     m68k_elf32_vec)		 tb="$tb elf32-m68k.lo elf32.lo $elf" ;;
+    m68k_aout_mintprg_vec)	 tb="$tb prg-mint.lo aout32.lo" ;;
+    m68k_elf32_atariprg_vec)	 tb="$tb elf32-atariprg.lo elf32-m68k.lo elf32.lo $elf" ;;
     s12z_elf32_vec)		 tb="$tb elf32-s12z.lo elf32.lo $elf" ;;
     mach_o_be_vec)		 tb="$tb mach-o.lo dwarf2.lo" ;;
     mach_o_le_vec)		 tb="$tb mach-o.lo dwarf2.lo" ;;
diff --git a/bfd/configure.ac b/bfd/configure.ac
index 7fcc5d4a947..f75e3ca0878 100644
--- a/bfd/configure.ac
+++ b/bfd/configure.ac
@@ -512,6 +512,8 @@ do
     m68hc11_elf32_vec)		 tb="$tb elf32-m68hc11.lo elf32-m68hc1x.lo elf32.lo $elf" ;;
     m68hc12_elf32_vec)		 tb="$tb elf32-m68hc12.lo elf32-m68hc1x.lo elf32.lo $elf" ;;
     m68k_elf32_vec)		 tb="$tb elf32-m68k.lo elf32.lo $elf" ;;
+    m68k_aout_mintprg_vec)	 tb="$tb prg-mint.lo aout32.lo" ;;
+    m68k_elf32_atariprg_vec)	 tb="$tb elf32-atariprg.lo elf32-m68k.lo elf32.lo $elf" ;;
     s12z_elf32_vec)		 tb="$tb elf32-s12z.lo elf32.lo $elf" ;;
     mach_o_be_vec)		 tb="$tb mach-o.lo dwarf2.lo" ;;
     mach_o_le_vec)		 tb="$tb mach-o.lo dwarf2.lo" ;;
diff --git a/bfd/doc/bfd.texi b/bfd/doc/bfd.texi
index 60061d52b6e..e177100561f 100644
--- a/bfd/doc/bfd.texi
+++ b/bfd/doc/bfd.texi
@@ -199,7 +199,6 @@ IEEE-695.
 * typedef bfd::
 * Error reporting::
 * Initialization::
-* Threading::
 * Miscellaneous::
 * Memory Usage::
 * Sections::
diff --git a/bfd/elf.c b/bfd/elf.c
index 8bffd3c5141..9acf434a020 100644
--- a/bfd/elf.c
+++ b/bfd/elf.c
@@ -44,6 +44,7 @@ SECTION
 #include "libiberty.h"
 #include "safe-ctype.h"
 #include "elf-linux-core.h"
+#include "elf32-atariprg.h"
 
 #ifdef CORE_HEADER
 #include CORE_HEADER
@@ -5979,6 +5980,9 @@ assign_file_positions_for_load_sections (bfd *abfd,
   Elf_Internal_Phdr *phdrs;
   Elf_Internal_Phdr *p;
   file_ptr off;  /* Octets.  */
+  file_ptr vma_off = 0; /* File offset of memory start.  */
+#define VMA (off - vma_off) /* Current memory offset.  */
+  bfd_size_type sizeof_extra_header = 0; /* Size of extra header before ELF header in segment.  */
   bfd_size_type maxpagesize;
   unsigned int alloc, actual;
   unsigned int i, j;
@@ -5989,13 +5993,25 @@ assign_file_positions_for_load_sections (bfd *abfd,
       && !_bfd_elf_map_sections_to_segments (abfd, link_info, NULL))
     return false;
 
+  off = 0; /* Current file offset */
+
+  if (abfd->xvec == &m68k_elf32_atariprg_vec)
+    {
+      /* There is an extra header before the ELF file header.  */
+      bfd_elf32_atariprg_get_extra_header_info (abfd, &vma_off, &sizeof_extra_header);
+      off = vma_off + sizeof_extra_header;
+    }
+
+  /* Sections must map to file offsets past the ELF file header.  */
+  off += bed->s->sizeof_ehdr;
+
   alloc = 0;
   for (m = elf_seg_map (abfd); m != NULL; m = m->next)
     m->idx = alloc++;
 
   if (alloc)
     {
-      elf_elfheader (abfd)->e_phoff = bed->s->sizeof_ehdr;
+      elf_elfheader (abfd)->e_phoff = off;
       elf_elfheader (abfd)->e_phentsize = bed->s->sizeof_phdr;
     }
   else
@@ -6022,7 +6038,7 @@ assign_file_positions_for_load_sections (bfd *abfd,
 
   if (alloc == 0)
     {
-      elf_next_file_pos (abfd) = bed->s->sizeof_ehdr;
+      elf_next_file_pos (abfd) = off;
       return true;
     }
 
@@ -6073,8 +6089,6 @@ assign_file_positions_for_load_sections (bfd *abfd,
 	maxpagesize = bed->maxpagesize;
     }
 
-  /* Sections must map to file offsets past the ELF file header.  */
-  off = bed->s->sizeof_ehdr;
   /* And if one of the PT_LOAD headers doesn't include the program
      headers then we'll be mapping program headers in the usual
      position after the ELF file header.  */
@@ -6112,6 +6126,7 @@ assign_file_positions_for_load_sections (bfd *abfd,
       p->p_flags = m->p_flags;
       p_align = bed->p_align;
       p_align_p = false;
+      p->p_offset = vma_off;
 
       if (m->count == 0)
 	p->p_vaddr = m->p_vaddr_offset * opb;
@@ -6219,7 +6234,7 @@ assign_file_positions_for_load_sections (bfd *abfd,
 		break;
 	      }
 
-	  off_adjust = vma_page_aligned_bias (p->p_vaddr, off, align * opb);
+	  off_adjust = vma_page_aligned_bias (p->p_vaddr, VMA, align * opb);
 
 	  /* Broken hardware and/or kernel require that files do not
 	     map the same page with different permissions on some hppa
@@ -6268,15 +6283,15 @@ assign_file_positions_for_load_sections (bfd *abfd,
 	{
 	  if (!m->p_flags_valid)
 	    p->p_flags |= PF_R;
-	  p->p_filesz = bed->s->sizeof_ehdr;
-	  p->p_memsz = bed->s->sizeof_ehdr;
+	  p->p_filesz = sizeof_extra_header + bed->s->sizeof_ehdr;
+	  p->p_memsz = sizeof_extra_header + bed->s->sizeof_ehdr;
 	  if (p->p_type == PT_LOAD)
 	    {
 	      if (m->count > 0)
 		{
-		  if (p->p_vaddr < (bfd_vma) off
+		  if (p->p_vaddr < (bfd_vma) VMA
 		      || (!m->p_paddr_valid
-			  && p->p_paddr < (bfd_vma) off))
+			  && p->p_paddr < (bfd_vma) VMA))
 		    {
 		      _bfd_error_handler
 			(_("%pB: not enough room for program headers,"
@@ -6285,9 +6300,9 @@ assign_file_positions_for_load_sections (bfd *abfd,
 		      bfd_set_error (bfd_error_bad_value);
 		      return false;
 		    }
-		  p->p_vaddr -= off;
+		  p->p_vaddr -= VMA;
 		  if (!m->p_paddr_valid)
-		    p->p_paddr -= off;
+		    p->p_paddr -= VMA;
 		}
 	    }
 	  else if (sorted_seg_map[0]->includes_filehdr)
@@ -6320,9 +6335,9 @@ assign_file_positions_for_load_sections (bfd *abfd,
 	      else if (phdr_load_seg != NULL)
 		{
 		  Elf_Internal_Phdr *phdr = phdrs + phdr_load_seg->idx;
-		  bfd_vma phdr_off = 0;  /* Octets.  */
+		  bfd_vma phdr_off = sizeof_extra_header;  /* Octets.  */
 		  if (phdr_load_seg->includes_filehdr)
-		    phdr_off = bed->s->sizeof_ehdr;
+		    phdr_off += bed->s->sizeof_ehdr;
 		  p->p_vaddr = phdr->p_vaddr + phdr_off;
 		  if (!m->p_paddr_valid)
 		    p->p_paddr = phdr->p_paddr + phdr_off;
@@ -6483,7 +6498,7 @@ assign_file_positions_for_load_sections (bfd *abfd,
 		     also makes the PT_TLS header have the same
 		     p_offset value.  */
 		  bfd_vma adjust = vma_page_aligned_bias (this_hdr->sh_addr,
-							  off, align);
+							  VMA, align);
 		  this_hdr->sh_offset = sec->filepos = off + adjust;
 		}
 
@@ -6640,6 +6655,7 @@ assign_file_positions_for_load_sections (bfd *abfd,
     }
 
   return true;
+#undef VMA
 }
 
 /* Determine if a bfd is a debuginfo file.  Unfortunately there
@@ -6695,6 +6711,15 @@ assign_file_positions_for_non_load_sections (bfd *abfd,
   i_shdrpp = elf_elfsections (abfd);
   end_hdrpp = i_shdrpp + elf_numsections (abfd);
   off = elf_next_file_pos (abfd);
+
+  if (abfd->xvec == &m68k_elf32_atariprg_vec)
+    {
+      /* Align the size of the DATA segment.
+	 The first non-load section will be placed just after.  */
+      off = align_file_position (off, 1 << bed->s->log_file_align);
+      bfd_elf32_atariprg_set_nonload_pos (abfd, off);
+    }
+
   for (hdrpp = i_shdrpp + 1; hdrpp < end_hdrpp; hdrpp++)
     {
       Elf_Internal_Shdr *hdr;
@@ -7954,6 +7979,7 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd, bfd_vma maxpagesize)
 	      && !bed->want_p_paddr_set_to_zero)
 	    {
 	      bfd_vma hdr_size = 0;
+	      BFD_ASSERT(obfd->xvec != &m68k_elf32_atariprg_vec);
 	      if (map->includes_filehdr)
 		hdr_size = iehdr->e_ehsize;
 	      if (map->includes_phdrs)
@@ -7996,6 +8022,7 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd, bfd_vma maxpagesize)
 	  if (map->includes_filehdr)
 	    {
 	      bfd_vma align = (bfd_vma) 1 << matching_lma->alignment_power;
+	      BFD_ASSERT(obfd->xvec != &m68k_elf32_atariprg_vec);
 	      map->p_paddr -= iehdr->e_ehsize;
 	      /* We've subtracted off the size of headers from the
 		 first section lma, but there may have been some
@@ -8216,6 +8243,14 @@ copy_elf_program_header (bfd *ibfd, bfd *obfd)
   bool p_paddr_valid;
   bool p_palign_valid;
   unsigned int opb = bfd_octets_per_byte (ibfd, NULL);
+  file_ptr vma_off = 0; /* File offset of memory start.  */
+  bfd_size_type sizeof_extra_header = 0; /* Size of extra header before ELF header in segment.  */
+
+  if (obfd->xvec == &m68k_elf32_atariprg_vec)
+    {
+      /* There is an extra header before the ELF file header.  */
+      bfd_elf32_atariprg_get_extra_header_info (obfd, &vma_off, &sizeof_extra_header);
+    }
 
   iehdr = elf_elfheader (ibfd);
 
@@ -8299,7 +8334,7 @@ copy_elf_program_header (bfd *ibfd, bfd *obfd)
 
       /* Determine if this segment contains the ELF file header
 	 and if it contains the program headers themselves.  */
-      map->includes_filehdr = (segment->p_offset == 0
+      map->includes_filehdr = ((file_ptr) segment->p_offset == vma_off
 			       && segment->p_filesz >= iehdr->e_ehsize);
 
       map->includes_phdrs = 0;
@@ -8361,7 +8396,7 @@ copy_elf_program_header (bfd *ibfd, bfd *obfd)
 	  /* Account for padding before the first section in the segment.  */
 	  bfd_vma hdr_size = 0;
 	  if (map->includes_filehdr)
-	    hdr_size = iehdr->e_ehsize;
+	    hdr_size = sizeof_extra_header + iehdr->e_ehsize;
 	  if (map->includes_phdrs)
 	    hdr_size += iehdr->e_phnum * iehdr->e_phentsize;
 
@@ -8471,6 +8506,14 @@ copy_private_bfd_data (bfd *ibfd, bfd *obfd)
     }
 
  rewrite:
+  if (obfd->xvec == &m68k_elf32_atariprg_vec)
+    {
+      /* Are we going to support that some day?  */
+      _bfd_error_handler ("error: target %s doesn't support rewriting ELF program headers", obfd->xvec->name);
+       bfd_set_error (bfd_error_invalid_operation);
+       return false;
+    }
+
   maxpagesize = 0;
   if (ibfd->xvec == obfd->xvec)
     {
@@ -8934,7 +8977,7 @@ swap_out_syms (bfd *abfd,
 	  sym.st_size = value;
 	  if (type_ptr == NULL
 	      || type_ptr->internal_elf_sym.st_value == 0)
-	    sym.st_value = value >= 16 ? 16 : (1 << bfd_log2 (value));
+	    sym.st_value = value >= 2 ? 2 : (1 << bfd_log2 (value));
 	  else
 	    sym.st_value = type_ptr->internal_elf_sym.st_value;
 	  sym.st_shndx = _bfd_elf_section_from_bfd_section
@@ -9310,7 +9353,12 @@ _bfd_elf_canonicalize_symtab (bfd *abfd, asymbol **allocation)
   long symcount = bed->s->slurp_symbol_table (abfd, allocation, false);
 
   if (symcount >= 0)
-    abfd->symcount = symcount;
+    {
+      abfd->symcount = symcount;
+      /* Cache symbols for the generic linker.  */
+      abfd->outsymbols = allocation;
+    }
+    
   return symcount;
 }
 
diff --git a/bfd/elf32-atariprg.c b/bfd/elf32-atariprg.c
new file mode 100644
index 00000000000..c5c878dc210
--- /dev/null
+++ b/bfd/elf32-atariprg.c
@@ -0,0 +1,1053 @@
+/* Support for Atari TOS PRG/ELF binaries.
+   ELF-specific code written by Vincent Riviere, 2023.
+   Based on the original a.out patch by Guido Flohr, 1998.
+   Copyright (C) 1998-2024 Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+#include "elf32-atariprg.h"
+#include "elf-bfd.h"
+#include "elf/m68k.h"
+
+/* Set this to 1 to enable debug traces.  */
+#if 0
+# define TRACE(fmt, ...) printf (fmt, __VA_ARGS__)
+#else
+# define TRACE(fmt, ...)
+#endif
+#define TRACE0(msg) TRACE ("%s", msg)
+
+/* To display well-formatted addresses.  */
+#define ADR_F "0x%08" PRIx32
+typedef uint32_t adr_t;
+
+/* Test if an integer is even.  */
+#define IS_EVEN(x) (((x) & 1) == 0)
+
+/* The main idea here is to reuse the elf32-m68k target, but with a few
+   overrides to add a PRG extended header before ELF data, and a PRG relocation
+   table just after.  So the ELF executable is actually embedded into a standard
+   PRG executable.  ELF Program Headers are specially tailored to fit the GEMDOS
+   process TEXT/DATA/BSS segments.  TEXT segment starts with an extra header
+   to support custom entry point and adjustable stack size.  Next comes the ELF
+   File Header followed by the ELF Program Headers and the rest of the TEXT
+   segment.  DATA and BSS segments are used normally.  Then non-alloc sections
+   and ELF Section Headers are stored in the PRG symbols table area, so they
+   aren't loaded by TOS at run-time.  Finally, the standard PRG relocation table
+   is appended after ELF data.  */
+
+/* Target vector of our base implementation, for inheritance.  */
+extern const bfd_target m68k_elf32_vec;
+
+/* Our own target vector.  */
+bfd_target m68k_elf32_atariprg_vec;
+static struct elf_backend_data m68k_elf32_atariprg_bed;
+static struct elf_size_info m68k_elf32_atariprg_size_info;
+
+/* Data structure that holds some private information for us.  */
+struct mint_internal_info
+{
+  bfd_byte	*tparel;	     /* Data for TPA relative relocation
+					information.  */
+  file_ptr	nonload_pos;	     /* File position of the first non-load
+					section.  */
+  file_ptr	tparel_pos;	     /* File position of TPA relative
+					relocation information.  */
+  bfd_size_type tparel_size;	     /* Size of TPA relative relocation
+					information.  */
+#define MINT_RELOC_CHUNKSIZE 0x1000
+  adr_t		*relocs;	     /* Array of address relocations.  */
+  unsigned int  relocs_used;	     /* Number of relocation entries
+					already used up.  */
+  unsigned int  relocs_allocated;    /* Number of relocation entries
+					allocated.  */
+
+  file_ptr	stkpos; 	     /* File offset of _stksize variable.  */
+
+  uint32_t	prg_flags;	     /* Standard GEMDOS flags.  */
+
+  bool		override_stack_size; /* true if the executable stack size
+					must be overridden with stack_size.  */
+  int32_t	stack_size;
+};
+
+#define PRG_MAGIC 0x601a 		/* PRG file identifier */
+
+/* Nice macros to determine various offsets.  */
+#define PRGELF_PHNUM 3 /* Number of ELF Program Headers */
+#define FILE_OFFSET_PRGELF_HEADER 0
+#define VMA_TEXT 0
+#define FILE_OFFSET_ELF_HEADER (FILE_OFFSET_PRGELF_HEADER + sizeof (PRGELF_HEADER))
+#define PRGELF_RESERVED (0x454c4600 /* ELF0 */ + FILE_OFFSET_ELF_HEADER)
+#define FILE_OFFSET_E_ENTRY (FILE_OFFSET_ELF_HEADER + offsetof(Elf32_External_Ehdr, e_entry))
+#define FILE_OFFSET_TRAMPOLINE (FILE_OFFSET_PRGELF_HEADER + offsetof(PRGELF_HEADER, trampoline))
+#define E_ENTRY_PCREL (FILE_OFFSET_E_ENTRY - (FILE_OFFSET_TRAMPOLINE + 2))
+#define TEXT_PCREL (FILE_OFFSET_TEXT - (FILE_OFFSET_TRAMPOLINE + 6))
+
+/* We need to store extra information in a bfd. As this target will never be
+   used for core dumps, just hijack the core pointer for us.  */
+
+static void
+set_mint_internal_info (bfd *abfd, struct mint_internal_info *myinfo)
+{
+  BFD_ASSERT (elf_tdata (abfd)->core == NULL);
+  elf_tdata (abfd)->core = (struct core_elf_obj_tdata *) myinfo;
+}
+
+static struct mint_internal_info *
+get_mint_internal_info_maybe_null (bfd *abfd)
+{
+  struct mint_internal_info *myinfo;
+
+  if (abfd->xvec != &m68k_elf32_atariprg_vec)
+    return NULL;
+  if (elf_tdata (abfd) == NULL)
+    return NULL;
+  myinfo = (struct mint_internal_info *) elf_tdata (abfd)->core;
+
+  return myinfo;
+}
+
+static struct mint_internal_info *
+get_mint_internal_info (bfd *abfd)
+{
+  struct mint_internal_info *myinfo = get_mint_internal_info_maybe_null (abfd);
+
+  BFD_ASSERT (myinfo != NULL);
+
+  return myinfo;
+}
+
+/* Allocate a new bfd_object for output or input.  */
+
+static bool
+m68k_elf32_atariprg_make_object (bfd *abfd)
+{
+  struct mint_internal_info *myinfo;
+
+  TRACE ("m68k_elf32_atariprg_make_object %s %s\n", abfd->xvec->name, abfd->filename);
+
+  if (! m68k_elf32_vec._bfd_set_format[bfd_object] (abfd))
+    return false;
+
+  /* Allocate our private BFD data.  */
+  myinfo = bfd_zalloc (abfd, sizeof (struct mint_internal_info));
+  if (myinfo == NULL)
+    return false;
+
+  set_mint_internal_info (abfd, myinfo);
+
+  return true;
+}
+
+/* Can we read this input file?
+   If not, other targets will be asked.  **/
+
+static bfd_cleanup
+m68k_elf32_atariprg_object_p (bfd *abfd)
+{
+  PRGELF_HEADER ph_ext;
+  bfd_size_type amt;
+  uint16_t magic;
+  uint32_t reserved;
+  struct mint_internal_info *myinfo;
+  bfd_cleanup ret;
+  uint32_t text, data, symbols;
+
+  TRACE ("m68k_elf32_atariprg_object_p %s %s\n", abfd->xvec->name, abfd->filename);
+
+  /* Read the PRG extended header from the file.  */
+  amt = sizeof (PRGELF_HEADER);
+  if (bfd_read (&ph_ext, amt, abfd) != amt)
+    {
+      if (bfd_get_error () != bfd_error_system_call)
+	bfd_set_error (bfd_error_wrong_format);
+      return NULL;
+    }
+
+  /* Is this a PRG?  */
+  magic = H_GET_16 (abfd, ph_ext.prg_header.magic);
+  if (magic != PRG_MAGIC)
+    {
+      bfd_set_error (bfd_error_wrong_format);
+      return NULL;
+    }
+
+  /* Is this a PRG/ELF?  */
+  reserved = H_GET_32 (abfd, ph_ext.prg_header.reserved);
+  if (reserved != PRGELF_RESERVED)
+    {
+      bfd_set_error (bfd_error_wrong_format);
+      return NULL;
+    }
+
+  /* Seek to the ELF File Header position.  */
+  if (bfd_seek (abfd, FILE_OFFSET_ELF_HEADER, SEEK_SET) != 0)
+    {
+      bfd_set_error (bfd_error_wrong_format);
+      return NULL;
+    }
+
+  /* Continue with the standard ELF implementation.  */
+  ret = m68k_elf32_vec._bfd_check_format[bfd_object] (abfd);
+  if (ret == NULL)
+    return NULL;
+
+  /* The base implementation has called m68k_elf32_atariprg_make_object (),
+     so our internal info has just been allocated.  */
+  myinfo = get_mint_internal_info (abfd);
+
+  /* Store extra header information.  */
+  myinfo->prg_flags = H_GET_32 (abfd, ph_ext.prg_header.flags);
+  myinfo->stkpos = H_GET_32 (abfd, ph_ext.g_stkpos);
+  /* Other header fields will be regenerated on write.  */
+
+  /* We read these values just to determine the TPA relocation position.  */
+  text = H_GET_32 (abfd, ph_ext.prg_header.text);
+  data = H_GET_32 (abfd, ph_ext.prg_header.data);
+  symbols = H_GET_32 (abfd, ph_ext.prg_header.symbols);
+  myinfo->tparel_pos = sizeof (PRG_HEADER) + text + data + symbols;
+
+  return ret;
+}
+
+/* Determine the size of the file headers for the linker SIZEOF_HEADERS.  */
+
+static int
+m68k_elf32_atariprg_sizeof_headers (bfd *abfd, struct bfd_link_info *info)
+{
+  int ret = SIZEOF_PRG_EXTRA_HEADER
+	    + m68k_elf32_vec._bfd_sizeof_headers (abfd, info);
+
+  TRACE ("m68k_elf32_atariprg_sizeof_headers %s %s %d\n", abfd->xvec->name, abfd->filename, ret);
+
+  return ret;
+}
+
+/* Set the GEMDOS executable flags.
+   Called by the linker emulation script.  */
+
+bool
+bfd_elf32_atariprg_set_extended_flags (bfd *abfd, uint32_t prg_flags)
+{
+  struct mint_internal_info *myinfo = get_mint_internal_info (abfd);
+
+  TRACE ("bfd_elf32_atariprg_set_extended_flags %s %s " ADR_F "\n", abfd->xvec->name, abfd->filename, (adr_t) prg_flags);
+
+  myinfo->prg_flags = prg_flags;
+
+  return true;
+}
+
+/* Override the stack size.
+   Called by the linker emulation script.  */
+
+bool
+bfd_elf32_atariprg_set_stack_size (bfd *abfd, int32_t stack_size)
+{
+  struct mint_internal_info *myinfo = get_mint_internal_info (abfd);
+
+  TRACE ("bfd_elf32_atariprg_set_stack_size %s %s " ADR_F "\n", abfd->xvec->name, abfd->filename, (adr_t) stack_size);
+
+  myinfo->stack_size = stack_size;
+  myinfo->override_stack_size = true;
+
+  return true;
+}
+
+/* Determine extra header information before the ELF File Header.
+   Called from elf.c.  */
+
+void
+bfd_elf32_atariprg_get_extra_header_info (bfd *abfd ATTRIBUTE_UNUSED,
+					  file_ptr *vma_offp,
+					  bfd_size_type *sizeof_extra_headerp)
+{
+  /* File offset of memory start.  */
+  *vma_offp = FILE_OFFSET_TEXT;
+
+  /* Size of extra header before ELF header in segment.  */
+  *sizeof_extra_headerp = SIZEOF_PRG_EXTRA_HEADER;
+
+  TRACE ("bfd_elf32_atariprg_get_extra_header_info %s %s " ADR_F " %lu\n", abfd->xvec->name, abfd->filename, (adr_t) *vma_offp, *sizeof_extra_headerp);
+}
+
+/* Record the file offset of the first non-load section.
+   This will be the beginning of the PRG symbol table.
+   Called from elf.c.  */
+
+void
+bfd_elf32_atariprg_set_nonload_pos (bfd *abfd, file_ptr nonload_pos)
+{
+  struct mint_internal_info *myinfo = get_mint_internal_info (abfd);
+
+  TRACE ("bfd_elf32_atariprg_set_nonload_pos %s %s " ADR_F "\n", abfd->xvec->name, abfd->filename, (adr_t) nonload_pos);
+
+  myinfo->nonload_pos = nonload_pos;
+}
+
+static unsigned int
+bfd_read_4byte_int (bfd *abfd, file_ptr pos)
+{
+  bfd_byte buffer[4];
+  file_ptr offset;
+  unsigned int val;
+
+  offset = bfd_tell(abfd);
+  if (bfd_seek(abfd, pos, SEEK_SET) != 0
+      || bfd_read (buffer, (bfd_size_type) 4, abfd) != 4)
+    {
+      return -1;
+    }
+  val = bfd_get_32 (abfd, buffer);
+  if (bfd_seek(abfd, offset, SEEK_SET) != 0)
+    return -1;
+  return val;
+}
+
+/* Add a TPA relocation entry.
+   Called for each absolute address in TEXT/DATA segments.
+   Actual relocation will be performed by the OS at load time.  */
+
+static bool
+add_tpa_relocation_entry (bfd *abfd, bfd *input_bfd, adr_t address)
+{
+  struct mint_internal_info *myinfo = get_mint_internal_info (abfd);
+
+  if (address & 1)
+    {
+      _bfd_error_handler ("%pB(%pB): TPA relocation at odd address: " ADR_F,
+			  abfd, input_bfd, (adr_t) address);
+      bfd_set_error (bfd_error_bad_value);
+      return false;
+    }
+
+  /* Enlarge the buffer if necessary.  */
+  if (myinfo->relocs_used >= myinfo->relocs_allocated)
+    {
+      adr_t *newbuf;
+      myinfo->relocs_allocated += MINT_RELOC_CHUNKSIZE;
+      newbuf = bfd_realloc (myinfo->relocs, myinfo->relocs_allocated * sizeof (*myinfo->relocs));
+      if (newbuf == NULL)
+	return false;
+
+      myinfo->relocs = newbuf;
+    }
+
+  /* The TPA relative relocation actually just adds the address of
+     the text segment (i. e. beginning of the executable in memory)
+     to the addresses at the specified locations.  This allows an
+     executable to be loaded everywhere in the address space without
+     memory management.  */
+  myinfo->relocs[myinfo->relocs_used++] = address;
+
+  return true;
+}
+
+/* The RELOCATE_SECTION function is called by the ELF backend linker
+   to handle the relocations for a section.  */
+
+static int
+m68k_elf32_atariprg_relocate_section (bfd *output_bfd,
+				      struct bfd_link_info *info,
+				      bfd *input_bfd,
+				      asection *input_section,
+				      bfd_byte *contents,
+				      Elf_Internal_Rela *relocs,
+				      Elf_Internal_Sym *local_syms,
+				      asection **local_sections)
+{
+  int ret;
+  Elf_Internal_Rela *rel;
+  Elf_Internal_Rela *relend;
+
+  TRACE ("m68k_elf32_atariprg_relocate_section %s %s %s %s\n", output_bfd->xvec->name, output_bfd->filename, input_bfd->filename, input_section->name);
+
+  /* First, call the base implementation.  */
+  ret = xvec_get_elf_backend_data (&m68k_elf32_vec)->elf_backend_relocate_section (output_bfd,
+    info, input_bfd, input_section, contents, relocs, local_syms, local_sections);
+  if (! ret)
+    return ret;
+
+  /* Non-load sections have no TPA relocations.  */
+  if (! (input_section->output_section->flags & SEC_LOAD))
+    return ret;
+
+  /* Walk all ELF relocations to determine if a TPA relocation is needed.  */
+  rel = relocs;
+  relend = relocs + input_section->reloc_count;
+  for (; rel < relend; rel++)
+    {
+      int r_type;
+
+      r_type = ELF32_R_TYPE (rel->r_info);
+      switch (r_type)
+	{
+	  case R_68K_32:
+	    {
+	      /* Absolute 32-bit address.  */
+	      bfd_vma offset = _bfd_elf_section_offset(output_bfd, info, input_section, rel->r_offset);
+	      if (offset != (bfd_vma) -1 && offset != (bfd_vma) -2)
+		{
+		  bfd_vma relocation = input_section->output_section->vma + input_section->output_offset + offset;
+		  if (! add_tpa_relocation_entry (output_bfd, input_bfd, relocation))
+		    return false;
+		}
+	    }
+	    break;
+
+	  case R_68K_16:
+	  case R_68K_8:
+	    /* PRG format doesn't support short absolute relocations.  */
+	    _bfd_error_handler("%pB: invalid relocation type %d for target %s",
+			       output_bfd, r_type, output_bfd->xvec->name);
+	    bfd_set_error (bfd_error_bad_value);
+	    return false;
+
+	  default:
+	    /* Ignore PC-relative relocations.  */
+	    break;
+	}
+    }
+
+  return ret;
+}
+
+/* Do a link based on the link_order structures attached to each
+   section of the BFD.
+   After calling the base implementation, this is a good place to examine the
+   contents of the newly linked executable.
+   The symbol lookup is inspired from elf_link_output_extsym ().  */
+
+static bool
+m68k_elf32_atariprg_final_link (bfd *abfd, struct bfd_link_info *info)
+{
+  struct mint_internal_info *myinfo = get_mint_internal_info (info->output_bfd);
+  struct elf_link_hash_entry *h;
+
+  TRACE ("m68k_elf32_atariprg_final_link %s %s\n", abfd->xvec->name, abfd->filename);
+
+  /* First, call the base implementation.  */
+  if (! m68k_elf32_vec._bfd_final_link (abfd, info))
+    return false;
+
+  TRACE ("m68k_elf32_atariprg_final_link END %s %s\n", abfd->xvec->name, abfd->filename);
+
+  /* Remember the address of the stack size variable.  */
+  h = (struct elf_link_hash_entry *) bfd_hash_lookup (&info->hash->table, info->output_bfd->xvec->symbol_leading_char ? "__stksize" : "_stksize", false, false);
+  if (h != NULL && h->root.type == bfd_link_hash_defined && h->type == STT_OBJECT)
+    {
+      asection *input_sec;
+      bfd_vma vma;
+
+      input_sec = h->root.u.def.section;
+      vma = input_sec->output_section->vma + input_sec->output_offset + h->root.u.def.value;
+      TRACE ("h=%p %s %s " ADR_F "\n", h, input_sec->name, h->root.root.string, (adr_t) vma);
+      myinfo->stkpos = FILE_OFFSET_TEXT + vma;
+    }
+
+  return true;
+}
+
+/* Check and adjust the ELF Program Headers.
+   - Ensure that the p_vaddr, p_paddr and p_offset fields are always set.
+   - Ensure that segments are contiguous.
+   - Ensure that addresses are consistent with offsets.
+   This is a requirement for write_prgelf_header ().  */
+
+static bool
+fix_phdrs (bfd *abfd)
+{
+  Elf_Internal_Ehdr *i_ehdrp = elf_elfheader (abfd);
+  unsigned int phnum = i_ehdrp->e_phnum;
+  struct elf_obj_tdata *tdata = elf_tdata (abfd);
+  Elf_Internal_Phdr *phdr_text, *phdr_data, *phdr_bss;
+  struct mint_internal_info *myinfo = get_mint_internal_info (abfd);
+  bfd_vma real_vaddr_data_end;
+  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
+  struct elf_segment_map *mtext = elf_seg_map (abfd);
+
+  TRACE ("fix_phdrs %s %s\n", abfd->xvec->name, abfd->filename);
+
+  if (phnum != PRGELF_PHNUM)
+    {
+      _bfd_error_handler ("%pB: number of Program Headers %u must be exactly %u for segments TEXT, DATA and BSS",
+			  abfd, phnum, PRGELF_PHNUM);
+      bfd_set_error (bfd_error_bad_value);
+      return false;
+    }
+
+  BFD_ASSERT(mtext->idx == 0); /* TEXT */
+  phdr_text = &tdata->phdr[0];
+  phdr_data = &tdata->phdr[1];
+  phdr_bss  = &tdata->phdr[2];
+
+  /* Fix TEXT segment address.  */
+  if (phdr_text->p_memsz == 0)
+    {
+      phdr_text->p_vaddr = 0;
+      phdr_text->p_paddr = phdr_text->p_vaddr;
+      phdr_text->p_offset = FILE_OFFSET_TEXT + phdr_text->p_vaddr;
+    }
+
+  /* Check TEXT segment address.  */
+  if (mtext->includes_filehdr && phdr_text->p_vaddr != VMA_TEXT)
+    {
+      _bfd_error_handler ("%pB: TEXT segment start address " ADR_F " must be " ADR_F,
+			  abfd, (adr_t) phdr_text->p_vaddr, (adr_t) VMA_TEXT);
+      bfd_set_error (bfd_error_bad_value);
+      return false;
+    }
+
+  /* Fix DATA segment address.  */
+  BFD_ASSERT (myinfo->nonload_pos > 0);
+  real_vaddr_data_end = myinfo->nonload_pos - FILE_OFFSET_TEXT;
+  if (phdr_data->p_memsz == 0)
+    {
+      phdr_data->p_vaddr = real_vaddr_data_end;
+      phdr_data->p_paddr = phdr_data->p_vaddr;
+      phdr_data->p_offset = FILE_OFFSET_TEXT + phdr_data->p_vaddr;
+    }
+
+  /* Fix DATA segment size.  */
+  phdr_data->p_memsz = real_vaddr_data_end - phdr_data->p_vaddr;
+  phdr_data->p_filesz = phdr_data->p_memsz;
+
+  /* Fix TEXT segment size.  */
+  phdr_text->p_memsz = phdr_data->p_vaddr - phdr_text->p_vaddr;
+  phdr_text->p_filesz = phdr_text->p_memsz;
+
+  /* Fix BSS segment address.  */
+  if (phdr_bss->p_memsz == 0)
+    {
+      phdr_bss->p_vaddr = phdr_data->p_vaddr + phdr_data->p_memsz;
+      phdr_bss->p_paddr = phdr_bss->p_vaddr;
+    }
+  else
+    {
+      /* To satisfy the alignment of some variables, the linker might try to
+	 align the BSS segment after the end of the DATA segment. As this isn't
+	 possible with TOS, we extend the front of the BSS segment so it
+	 precisely matches the end of the DATA segment. This doesn't matter
+	 because the VMA of the .bss section doesn't change.  */
+      uint32_t expected_bss_vaddr = phdr_data->p_vaddr + phdr_data->p_memsz;
+      if (phdr_bss->p_vaddr > expected_bss_vaddr)
+	{
+	  uint32_t offset = phdr_bss->p_vaddr - expected_bss_vaddr;
+	  phdr_bss->p_vaddr -= offset;
+	  phdr_bss->p_paddr -= offset;
+	  phdr_bss->p_memsz += offset;
+	}
+    }
+  phdr_bss->p_offset = FILE_OFFSET_TEXT + phdr_bss->p_vaddr;
+
+  /* Fix BSS segment size.  */
+  phdr_bss->p_memsz = BFD_ALIGN (phdr_bss->p_memsz, 1 << bed->s->log_file_align);
+  BFD_ASSERT (phdr_bss->p_filesz == 0);
+
+  /* Check that DATA segment directly follows TEXT segment.  */
+  if (phdr_data->p_vaddr != phdr_text->p_vaddr + phdr_text->p_memsz)
+    {
+      _bfd_error_handler ("%pB: DATA segment start address " ADR_F " must directly follow TEXT segment at " ADR_F,
+			  abfd, (adr_t) phdr_data->p_vaddr,
+			  (adr_t) (phdr_text->p_vaddr + phdr_text->p_memsz));
+      bfd_set_error (bfd_error_bad_value);
+      return false;
+    }
+
+  /* Check that BSS segment directly follows DATA segment.  */
+  if (phdr_bss->p_vaddr != phdr_data->p_vaddr + phdr_data->p_memsz)
+    {
+      _bfd_error_handler ("%pB: BSS segment start address " ADR_F " must directly follow DATA segment at " ADR_F,
+			  abfd, (adr_t) phdr_bss->p_vaddr,
+			  (adr_t) (phdr_data->p_vaddr + phdr_data->p_memsz));
+      bfd_set_error (bfd_error_bad_value);
+      return false;
+    }
+
+  /* Check that VMA of TEXT segment matches its file offset.  */
+  if (phdr_text->p_offset != 0 && phdr_text->p_vaddr != phdr_text->p_offset - FILE_OFFSET_TEXT)
+    {
+      _bfd_error_handler ("%pB: TEXT segment start address " ADR_F " must be " ADR_F " to match its file offset",
+			  abfd, (adr_t) phdr_text->p_vaddr,
+			  (adr_t) (phdr_text->p_offset - FILE_OFFSET_TEXT));
+      bfd_set_error (bfd_error_bad_value);
+      return false;
+    }
+
+  /* Check that VMA of DATA segment matches its file offset.  */
+  if (phdr_data->p_offset != 0 && phdr_data->p_vaddr != phdr_data->p_offset - FILE_OFFSET_TEXT)
+    {
+      _bfd_error_handler ("%pB: DATA segment start address " ADR_F " must be " ADR_F " to match its file offset",
+			  abfd, (adr_t) phdr_data->p_vaddr,
+			  (adr_t) (phdr_data->p_offset - FILE_OFFSET_TEXT));
+      bfd_set_error (bfd_error_bad_value);
+      return false;
+    }
+
+  /* Check that VMA of BSS segment matches its file offset.  */
+  if (phdr_bss->p_offset != 0 && phdr_bss->p_vaddr != phdr_bss->p_offset - FILE_OFFSET_TEXT)
+    {
+      _bfd_error_handler ("%pB: BSS segment start address " ADR_F " must be " ADR_F " to match its file offset",
+			  abfd, (adr_t) phdr_bss->p_vaddr,
+			  (adr_t) (phdr_bss->p_offset - FILE_OFFSET_TEXT));
+      bfd_set_error (bfd_error_bad_value);
+      return false;
+    }
+
+  /* As we may have modified the Program Headers, write them again.  */
+  if (bfd_seek (abfd, i_ehdrp->e_phoff, SEEK_SET) != 0
+      || bed->s->write_out_phdrs (abfd, tdata->phdr, phnum) != 0)
+    return false;
+
+  return true;
+}
+
+/* Write the PRG extended header before ELF data.  */
+
+static bool
+write_prgelf_header (bfd *abfd)
+{
+  struct mint_internal_info *myinfo = get_mint_internal_info (abfd);
+  Elf_Internal_Phdr *phdrs = elf_tdata (abfd)->phdr;
+  unsigned int phnum = elf_elfheader (abfd)->e_phnum;
+  Elf_Internal_Phdr *phdr_text, *phdr_data, *phdr_bss;
+  uint32_t prg_text_size, prg_data_size, prg_bss_size, prg_symbols_size;
+  PRGELF_HEADER ph_ext;
+
+  TRACE ("write_prgelf_header %s %s\n", abfd->xvec->name, abfd->filename);
+
+  BFD_ASSERT (phnum == PRGELF_PHNUM);
+  phdr_text = &phdrs[0];
+  phdr_data = &phdrs[1];
+  phdr_bss  = &phdrs[2];
+
+  /* The segment sizes have been fixed, so we can trust them.  */
+  prg_text_size = phdr_text->p_vaddr + phdr_text->p_filesz;
+  prg_data_size = phdr_data->p_filesz;
+  prg_bss_size = phdr_bss->p_memsz;
+
+  /* We will write the TPA relocation table right after the ELF data.  */
+  myinfo->tparel_pos = elf_next_file_pos (abfd);
+  BFD_ASSERT (IS_EVEN (myinfo->tparel_pos));
+
+  /* Compute the size of the PRG symbol table.  */
+  prg_symbols_size = myinfo->tparel_pos - myinfo->nonload_pos;
+
+  /* Prepare the PRG/ELF header.  */
+  memset (&ph_ext, 0, sizeof ph_ext);
+
+  /* Standard PRG header.  */
+  H_PUT_16 (abfd, PRG_MAGIC, &ph_ext.prg_header.magic);
+  H_PUT_32 (abfd, prg_text_size, &ph_ext.prg_header.text);
+  H_PUT_32 (abfd, prg_data_size, &ph_ext.prg_header.data);
+  H_PUT_32 (abfd, prg_bss_size, &ph_ext.prg_header.bss);
+  H_PUT_32 (abfd, prg_symbols_size, &ph_ext.prg_header.symbols);
+  H_PUT_32 (abfd, PRGELF_RESERVED, &ph_ext.prg_header.reserved);
+  H_PUT_32 (abfd, myinfo->prg_flags, &ph_ext.prg_header.flags);
+
+  /* Extended PRG header.  */
+  H_PUT_16 (abfd, 0x203a, &ph_ext.trampoline[0]); /* move.l e_entry(pc),d0 */
+  H_PUT_16 (abfd, E_ENTRY_PCREL, &ph_ext.trampoline[1]);
+  H_PUT_16 (abfd, 0x4efb, &ph_ext.trampoline[2]); /* jmp VMA_TEXT(pc,d0.l) */
+  H_PUT_16 (abfd, 0x0800 | ((uint8_t) TEXT_PCREL) , &ph_ext.trampoline[3]);
+  H_PUT_32 (abfd, myinfo->stkpos, &ph_ext.g_stkpos); /* stack size address */
+
+  /* Write the PRG/ELF header.  */
+  if (bfd_seek (abfd, 0, SEEK_SET) != 0)
+    return false;
+  if (bfd_write (&ph_ext, sizeof ph_ext, abfd) != sizeof ph_ext)
+    return false;
+
+  /* Override the stack size.  */
+  if (myinfo->override_stack_size)
+    {
+      bfd_byte big_endian_stack_size[4];
+
+      if (myinfo->stkpos == 0)
+	{
+	  _bfd_error_handler ("%pB: unable to determine the _stksize position",
+			      abfd);
+	  bfd_set_error (bfd_error_invalid_operation);
+	  return false;
+	}
+
+      bfd_put_32 (abfd, myinfo->stack_size, &big_endian_stack_size);
+
+      if (bfd_seek (abfd, myinfo->stkpos, SEEK_SET) != 0)
+	return false;
+      if (bfd_write (big_endian_stack_size, 4, abfd) != 4)
+	return false;
+  }
+
+  return true;
+}
+
+/* This is used by qsort() to sort the TPA relocation table.  */
+
+static int
+vma_cmp (const void *v1, const void *v2)
+{
+  return (int) ((*((adr_t *) v1)) - (*((adr_t *) v2)));
+}
+
+/* Alloc and fill the TPA relocation table.  */
+
+static bool
+fill_tparel (bfd *abfd)
+{
+  struct mint_internal_info *myinfo = get_mint_internal_info (abfd);
+  unsigned int i;
+  bfd_size_type bytes;
+  bfd_byte *ptr;
+  unsigned int val;
+  adr_t last;
+  unsigned int errors;
+
+  TRACE ("fill_tparel %s %s\n", abfd->xvec->name, abfd->filename);
+
+  BFD_ASSERT (myinfo->tparel == NULL);
+  BFD_ASSERT (myinfo->tparel_size == 0);
+
+  /* Sort the relocation info.  */
+  if (myinfo->relocs != NULL)
+    qsort (myinfo->relocs, myinfo->relocs_used, sizeof (*myinfo->relocs), vma_cmp);
+
+  /* Now calculate the number of bytes we need.  The relocation info
+     is encoded as follows:  The first entry is a 32-bit value
+     denoting the first offset to relocate.  All following entries
+     are relative to the preceding one.  For relative offsets of
+     more than 254 bytes a value of 1 is used.  The OS will then
+     add 254 bytes to the current offset.  The list is then terminated
+     with the byte 0.  */
+  bytes = 4; /* First entry is a long.  */
+  errors = 0;
+  for (i = 1; i < myinfo->relocs_used; i++)
+    {
+      adr_t diff = myinfo->relocs[i] - myinfo->relocs[i - 1];
+      /* No backward relocation.  */
+      if (myinfo->relocs[i] <= myinfo->relocs[i - 1] + 2)
+	{
+	  _bfd_error_handler ("%pB: duplicate relocation: " ADR_F " <= " ADR_F,
+	    abfd,
+	    (adr_t)myinfo->relocs[i], (adr_t)myinfo->relocs[i - 1]);
+	  errors++;
+	}
+      BFD_ASSERT (! (diff & 1)); /* No relocation to odd address.  */
+      bytes += (diff + 253) / 254;
+    }
+  if (errors != 0)
+    {
+      bfd_set_error (bfd_error_bad_value);
+      return false;
+    }
+  /* Last entry is (bfd_byte) 0 if there are some relocations.  */
+  if (myinfo->relocs_used > 0)
+    bytes++;
+  myinfo->tparel_size = bytes;
+
+  /* Allocate the TPA relocation table.  */
+  myinfo->tparel = bfd_alloc (abfd, bytes);
+  if (myinfo->tparel == NULL)
+    return false;
+
+  /* Write the first entry. Always 32-bit.  */
+  ptr = myinfo->tparel;
+  i = 1;
+  last = 0;
+  if (myinfo->relocs != NULL)
+    {
+      last = myinfo->relocs[0];
+      while (bfd_read_4byte_int(abfd, last + FILE_OFFSET_TEXT) == 0 && i < myinfo->relocs_used)
+	{
+	  last = myinfo->relocs[i];
+	  i++;
+	}
+    }
+  bfd_put_32 (abfd, last, ptr);
+  ptr += 4;
+
+  /* Write next entries.  Always 8-bit.  */
+  for (; i < myinfo->relocs_used; i++)
+    {
+      adr_t diff;
+
+      /*
+       * Do not add an entry, if the address to be relocated is zero.
+       * This can happen with weak symbols.
+       */
+      val = bfd_read_4byte_int(abfd, myinfo->relocs[i] + FILE_OFFSET_TEXT);
+      if (val == 0)
+	{
+	  continue;
+	}
+      diff = myinfo->relocs[i] - last;
+      last = myinfo->relocs[i];
+      while (diff > 254)
+	{
+	  *ptr++ = 1;
+	  diff -= 254;
+	}
+      *ptr++ = (bfd_byte) diff;
+    }
+  if (myinfo->relocs_used > 0)
+    *ptr = 0;
+
+  return true;
+}
+
+/* Write out the TPA relocation table.  */
+
+static bool
+write_tparel (bfd *abfd)
+{
+  struct mint_internal_info *myinfo = get_mint_internal_info (abfd);
+
+  TRACE ("write_tparel %s %s\n", abfd->xvec->name, abfd->filename);
+
+  BFD_ASSERT (myinfo->tparel != NULL);
+  BFD_ASSERT (myinfo->tparel_size > 0);
+
+  if (bfd_seek (abfd, myinfo->tparel_pos, SEEK_SET) != 0)
+    return false;
+
+  if (bfd_write (myinfo->tparel, myinfo->tparel_size, abfd) != myinfo->tparel_size)
+    return false;
+
+  return true;
+}
+
+/* Write out the section headers and the ELF File Header.  */
+
+static bool
+m68k_elf32_atariprg_write_shdrs_and_ehdr (bfd *abfd)
+{
+  struct mint_internal_info *myinfo = get_mint_internal_info (abfd);
+
+  TRACE ("m68k_elf32_atariprg_write_shdrs_and_ehdr %s %s\n", abfd->xvec->name, abfd->filename);
+
+  /* Now we have all the required information to fix the Program Headers.
+     We can't do that in modify_headers because we need to know the offset of
+     the Section Headers, and it isn't known yet at that time.  */
+  if (! fix_phdrs(abfd))
+    return false;
+
+  /* Write out the PRG/ELF extended header.  */
+  if (! write_prgelf_header (abfd))
+    return false;
+
+  /* Write out the Section Headers and the ELF File Header.  */
+  if (! xvec_get_elf_backend_data (&m68k_elf32_vec)->s->write_shdrs_and_ehdr (abfd))
+    return false;
+
+  /* The TPA relocation table already exists if it has been read from an input
+     file with objcopy/strip.  */
+  if (myinfo->tparel_size == 0)
+    {
+      /* Generate the PRG relocation table.  */
+      if (! fill_tparel (abfd))
+	return false;
+    }
+
+  /* Write out the PRG relocation table.  */
+  if (! write_tparel (abfd))
+    return false;
+
+  return true;
+}
+
+/* Called when the BFD is being closed to do any necessary cleanup.  */
+
+static bool
+m68k_elf32_atariprg_close_and_cleanup (bfd *abfd)
+{
+  struct mint_internal_info *myinfo = get_mint_internal_info_maybe_null (abfd);
+
+  TRACE ("m68k_elf32_atariprg_close_and_cleanup %s %s\n", abfd->xvec->name, abfd->filename);
+
+  if (myinfo != NULL && myinfo->relocs != NULL)
+    {
+      free (myinfo->relocs);
+      myinfo->relocs = NULL;
+    }
+
+  /* myinfo itself has been allocated by bfd_zalloc()
+     so will be automatically freed along with the BFD.
+     Same for myinfo->tparel.  */
+
+  return m68k_elf32_vec._close_and_cleanup (abfd);
+}
+
+/* objcopy/strip support.
+   Sections are loaded from the input file, then written individually to the
+   output file. During the process, some of them might be dropped. Headers are
+   recreated from scratch. We must copy all extra data manually in order to
+   generate the output file identically.  */
+
+/* Copy private header information.  */
+
+static bool
+m68k_elf32_atariprg_copy_private_header_data (bfd *ibfd, bfd *obfd)
+{
+  struct mint_internal_info *myinfo_in;
+  struct mint_internal_info *myinfo_out;
+
+  TRACE ("m68k_elf32_atariprg_copy_private_header_data %s %s %s %s\n", ibfd->xvec->name, ibfd->filename, obfd->xvec->name, obfd->filename);
+
+  /* First, call the base implementation.  */
+  if (! m68k_elf32_vec._bfd_copy_private_header_data (ibfd, obfd))
+    return false;
+
+  /* obfd uses our file format, ibfd may be foreign.  */
+  if (ibfd->xvec != &m68k_elf32_atariprg_vec)
+    return true;
+
+  myinfo_in = get_mint_internal_info (ibfd);
+  myinfo_out = get_mint_internal_info (obfd);
+
+  /* Copy extra header data.  */
+  myinfo_out->prg_flags = myinfo_in->prg_flags;
+  myinfo_out->stkpos = myinfo_in->stkpos;
+
+  return true;
+}
+
+/* Read the TPA relocation table.  */
+
+static bool read_tparel (bfd *abfd)
+{
+  struct mint_internal_info *myinfo = get_mint_internal_info (abfd);
+#define TPAREL_CHUNK_SIZE 4096
+  bfd_size_type alloc_size;
+  bfd_size_type already_read;
+  bfd_size_type amt;
+
+  TRACE ("read_tparel %s %s\n", abfd->xvec->name, abfd->filename);
+
+  BFD_ASSERT (myinfo->tparel == NULL);
+
+  /* The TPA relocation position was determined when reading the PRG header.  */
+  BFD_ASSERT (myinfo->tparel_pos > 0);
+  if (bfd_seek (abfd, myinfo->tparel_pos, SEEK_SET) != 0)
+    return false;
+
+  /* We don't know the size of the TPA relocation table in advance. So just
+     read chunks up to the end of file.  */
+
+  alloc_size = TPAREL_CHUNK_SIZE;
+  myinfo->tparel = bfd_malloc (alloc_size);
+  if (myinfo->tparel == NULL)
+    return false;
+
+  already_read = 0;
+
+  for (;;)
+    {
+      amt = bfd_read (myinfo->tparel + already_read, TPAREL_CHUNK_SIZE, abfd);
+      if (amt == (bfd_size_type) -1)
+	return false;
+
+      already_read += amt;
+
+      if (amt < TPAREL_CHUNK_SIZE)
+	{
+	  myinfo->tparel_size = already_read;
+	  return true;
+	}
+
+      alloc_size += TPAREL_CHUNK_SIZE;
+      myinfo->tparel = bfd_realloc (myinfo->tparel, alloc_size);
+      if (myinfo->tparel == NULL)
+	return false;
+    }
+}
+
+/* Copy the program header and other data from one object module to
+   another.  */
+
+static bool
+m68k_elf32_atariprg_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
+{
+  struct mint_internal_info *myinfo_in;
+  struct mint_internal_info *myinfo_out;
+
+  TRACE ("m68k_elf32_atariprg_copy_private_bfd_data %s %s %s %s\n", ibfd->xvec->name, ibfd->filename, obfd->xvec->name, obfd->filename);
+
+  /* First, call the base implementation.  */
+  if (! m68k_elf32_vec._bfd_copy_private_bfd_data (ibfd, obfd))
+      return false;
+
+  /* obfd uses our file format, ibfd may be foreign.  */
+  if (ibfd->xvec != &m68k_elf32_atariprg_vec)
+    return true;
+
+  myinfo_in = get_mint_internal_info (ibfd);
+  myinfo_out = get_mint_internal_info (obfd);
+
+  /* Read the input TPA relocation table.  */
+  if (! read_tparel (ibfd))
+    return false;
+
+  /* Allocate the output relocation table.  */
+  myinfo_out->tparel_size = myinfo_in->tparel_size;
+  myinfo_out->tparel = bfd_alloc (obfd, myinfo_out->tparel_size);
+  if (myinfo_out->tparel == NULL)
+    return false;
+
+  /* Copy the TPA relocation table.  */
+  memcpy (myinfo_out->tparel, myinfo_in->tparel, myinfo_out->tparel_size);
+
+  return true;
+}
+
+/* Initialize our target.
+   Called by bfd_init ().  */
+
+void
+bfd_elf32_atariprg_init (void)
+{
+  TRACE0 ("bfd_elf32_atariprg_init\n");
+
+  /* Out target is basically the same as elf32-m68k...  */
+  m68k_elf32_atariprg_vec = m68k_elf32_vec;
+  m68k_elf32_atariprg_vec.name = "elf32-atariprg";
+
+  /* ... but with a few overrides.  */
+  m68k_elf32_atariprg_vec._bfd_check_format[bfd_object] = m68k_elf32_atariprg_object_p;
+  m68k_elf32_atariprg_vec._bfd_set_format[bfd_object] = m68k_elf32_atariprg_make_object;
+  m68k_elf32_atariprg_vec._bfd_sizeof_headers = m68k_elf32_atariprg_sizeof_headers;
+  m68k_elf32_atariprg_vec._close_and_cleanup = m68k_elf32_atariprg_close_and_cleanup;
+  m68k_elf32_atariprg_vec._bfd_copy_private_header_data = m68k_elf32_atariprg_copy_private_header_data;
+  m68k_elf32_atariprg_vec._bfd_copy_private_bfd_data = m68k_elf32_atariprg_copy_private_bfd_data;
+  m68k_elf32_atariprg_vec._bfd_final_link = m68k_elf32_atariprg_final_link;
+
+  /* ELF backend data.  */
+  m68k_elf32_atariprg_bed = *xvec_get_elf_backend_data(&m68k_elf32_atariprg_vec);
+  m68k_elf32_atariprg_vec.backend_data = &m68k_elf32_atariprg_bed;
+  m68k_elf32_atariprg_bed.maxpagesize = 2; /* Align segments on this.  */
+  m68k_elf32_atariprg_bed.elf_backend_relocate_section = m68k_elf32_atariprg_relocate_section;
+
+  /* ELF size info.  */
+  m68k_elf32_atariprg_size_info = *m68k_elf32_atariprg_bed.s;
+  m68k_elf32_atariprg_bed.s = &m68k_elf32_atariprg_size_info;
+  m68k_elf32_atariprg_size_info.log_file_align = 1; /* 2**1 = 2 */
+  m68k_elf32_atariprg_size_info.write_shdrs_and_ehdr = m68k_elf32_atariprg_write_shdrs_and_ehdr;
+}
diff --git a/bfd/elf32-atariprg.h b/bfd/elf32-atariprg.h
new file mode 100644
index 00000000000..393c191c517
--- /dev/null
+++ b/bfd/elf32-atariprg.h
@@ -0,0 +1,74 @@
+/* Support for Atari TOS PRG/ELF binaries.
+   Copyright (C) 1998-2024 Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+/* Standard GEMDOS program flags.  */
+#define _MINT_F_FASTLOAD      0x01    /* Don't clear heap.  */
+#define _MINT_F_ALTLOAD       0x02    /* OK to load in alternate RAM.  */
+#define _MINT_F_ALTALLOC      0x04    /* OK to malloc from alt. RAM.  */
+#define _MINT_F_BESTFIT       0x08    /* Load with optimal heap size.  */
+/* The memory flags are mutually exclusive.  */
+#define _MINT_F_MEMPROTECTION 0xf0    /* Masks out protection bits.  */
+#define _MINT_F_MEMPRIVATE    0x00    /* Memory is private.  */
+#define _MINT_F_MEMGLOBAL     0x10    /* Read/write access to mem allowed.  */
+#define _MINT_F_MEMSUPER      0x20    /* Only supervisor access allowed.  */
+#define _MINT_F_MEMREADABLE   0x30    /* Any read access OK.  */
+#define _MINT_F_SHTEXT        0x800   /* Program's text may be shared */
+
+extern bfd_target m68k_elf32_atariprg_vec;
+
+/* Standard PRG header, external format.  */
+typedef struct {
+  unsigned char magic[2];	/* Magic number */
+  unsigned char text[4];	/* Size of TEXT segment */
+  unsigned char data[4];	/* Size of DATA segment */
+  unsigned char bss[4];		/* Size of BSS segment */
+  unsigned char symbols[4];	/* Size of the symbols table */
+  unsigned char reserved[4];	/* Used as file-format identifier */
+  unsigned char flags[4];	/* Program flags */
+  unsigned char absflag[2];	/* Must be 0 for relocatable PRG */
+} PRG_HEADER;
+
+/* Extended PRG/ELF header, external format.  */
+typedef struct {
+  /* Standard PRG header */
+  PRG_HEADER prg_header;
+  /* Extra PRG header */
+  unsigned char trampoline[4][2];	/* Jump to entry point */
+  unsigned char g_stkpos[4];		/* File offset of stack size variable */
+} PRGELF_HEADER;
+
+#define FILE_OFFSET_TEXT sizeof (PRG_HEADER)
+#define SIZEOF_PRG_EXTRA_HEADER (sizeof (PRGELF_HEADER) - sizeof (PRG_HEADER))
+
+/* Called by bfd_init ().  */
+extern void bfd_elf32_atariprg_init
+  (void);
+
+/* Called by elf.c.  */
+extern void bfd_elf32_atariprg_get_extra_header_info
+  (bfd *, file_ptr *, bfd_size_type *);
+extern void bfd_elf32_atariprg_set_nonload_pos
+  (bfd *, file_ptr);
+
+/* Called by the linker.  */
+extern bool bfd_elf32_atariprg_set_extended_flags
+  (bfd *, uint32_t);
+extern bool bfd_elf32_atariprg_set_stack_size
+  (bfd *, int32_t);
diff --git a/bfd/elf64-x86-64.c b/bfd/elf64-x86-64.c
index 2ed120af780..ca10fe3b5c3 100644
--- a/bfd/elf64-x86-64.c
+++ b/bfd/elf64-x86-64.c
@@ -48,127 +48,127 @@ static reloc_howto_type x86_64_elf_howto_table[] =
 	bfd_elf_generic_reloc, "R_X86_64_NONE",	false, 0, 0x00000000,
 	false),
   HOWTO(R_X86_64_64, 0, 8, 64, false, 0, complain_overflow_dont,
-	bfd_elf_generic_reloc, "R_X86_64_64", false, 0, MINUS_ONE,
+	bfd_elf_generic_reloc, "R_X86_64_64", false, MINUS_ONE, MINUS_ONE,
 	false),
   HOWTO(R_X86_64_PC32, 0, 4, 32, true, 0, complain_overflow_signed,
-	bfd_elf_generic_reloc, "R_X86_64_PC32", false, 0, 0xffffffff,
+	bfd_elf_generic_reloc, "R_X86_64_PC32", false, 0xffffffff, 0xffffffff,
 	true),
   HOWTO(R_X86_64_GOT32, 0, 4, 32, false, 0, complain_overflow_signed,
-	bfd_elf_generic_reloc, "R_X86_64_GOT32", false, 0, 0xffffffff,
+	bfd_elf_generic_reloc, "R_X86_64_GOT32", false, 0xffffffff, 0xffffffff,
 	false),
   HOWTO(R_X86_64_PLT32, 0, 4, 32, true, 0, complain_overflow_signed,
-	bfd_elf_generic_reloc, "R_X86_64_PLT32", false, 0, 0xffffffff,
+	bfd_elf_generic_reloc, "R_X86_64_PLT32", false, 0xffffffff, 0xffffffff,
 	true),
   HOWTO(R_X86_64_COPY, 0, 4, 32, false, 0, complain_overflow_bitfield,
-	bfd_elf_generic_reloc, "R_X86_64_COPY", false, 0, 0xffffffff,
+	bfd_elf_generic_reloc, "R_X86_64_COPY", false, 0xffffffff, 0xffffffff,
 	false),
   HOWTO(R_X86_64_GLOB_DAT, 0, 8, 64, false, 0, complain_overflow_dont,
-	bfd_elf_generic_reloc, "R_X86_64_GLOB_DAT", false, 0, MINUS_ONE,
+	bfd_elf_generic_reloc, "R_X86_64_GLOB_DAT", false, MINUS_ONE, MINUS_ONE,
 	false),
   HOWTO(R_X86_64_JUMP_SLOT, 0, 8, 64, false, 0, complain_overflow_dont,
-	bfd_elf_generic_reloc, "R_X86_64_JUMP_SLOT", false, 0, MINUS_ONE,
+	bfd_elf_generic_reloc, "R_X86_64_JUMP_SLOT", false, MINUS_ONE, MINUS_ONE,
 	false),
   HOWTO(R_X86_64_RELATIVE, 0, 8, 64, false, 0, complain_overflow_dont,
-	bfd_elf_generic_reloc, "R_X86_64_RELATIVE", false, 0, MINUS_ONE,
+	bfd_elf_generic_reloc, "R_X86_64_RELATIVE", false, MINUS_ONE, MINUS_ONE,
 	false),
   HOWTO(R_X86_64_GOTPCREL, 0, 4, 32, true, 0, complain_overflow_signed,
-	bfd_elf_generic_reloc, "R_X86_64_GOTPCREL", false, 0, 0xffffffff,
+	bfd_elf_generic_reloc, "R_X86_64_GOTPCREL", false, 0xffffffff, 0xffffffff,
 	true),
   HOWTO(R_X86_64_32, 0, 4, 32, false, 0, complain_overflow_unsigned,
-	bfd_elf_generic_reloc, "R_X86_64_32", false, 0, 0xffffffff,
+	bfd_elf_generic_reloc, "R_X86_64_32", false, 0xffffffff, 0xffffffff,
 	false),
   HOWTO(R_X86_64_32S, 0, 4, 32, false, 0, complain_overflow_signed,
-	bfd_elf_generic_reloc, "R_X86_64_32S", false, 0, 0xffffffff,
+	bfd_elf_generic_reloc, "R_X86_64_32S", false, 0xffffffff, 0xffffffff,
 	false),
   HOWTO(R_X86_64_16, 0, 2, 16, false, 0, complain_overflow_bitfield,
-	bfd_elf_generic_reloc, "R_X86_64_16", false, 0, 0xffff, false),
+	bfd_elf_generic_reloc, "R_X86_64_16", false, 0xffff, 0xffff, false),
   HOWTO(R_X86_64_PC16, 0, 2, 16, true, 0, complain_overflow_bitfield,
-	bfd_elf_generic_reloc, "R_X86_64_PC16", false, 0, 0xffff, true),
+	bfd_elf_generic_reloc, "R_X86_64_PC16", false, 0xffff, 0xffff, true),
   HOWTO(R_X86_64_8, 0, 1, 8, false, 0, complain_overflow_bitfield,
-	bfd_elf_generic_reloc, "R_X86_64_8", false, 0, 0xff, false),
+	bfd_elf_generic_reloc, "R_X86_64_8", false, 0xff, 0xff, false),
   HOWTO(R_X86_64_PC8, 0, 1, 8, true, 0, complain_overflow_signed,
-	bfd_elf_generic_reloc, "R_X86_64_PC8", false, 0, 0xff, true),
+	bfd_elf_generic_reloc, "R_X86_64_PC8", false, 0xff, 0xff, true),
   HOWTO(R_X86_64_DTPMOD64, 0, 8, 64, false, 0, complain_overflow_dont,
-	bfd_elf_generic_reloc, "R_X86_64_DTPMOD64", false, 0, MINUS_ONE,
+	bfd_elf_generic_reloc, "R_X86_64_DTPMOD64", false, MINUS_ONE, MINUS_ONE,
 	false),
   HOWTO(R_X86_64_DTPOFF64, 0, 8, 64, false, 0, complain_overflow_dont,
-	bfd_elf_generic_reloc, "R_X86_64_DTPOFF64", false, 0, MINUS_ONE,
+	bfd_elf_generic_reloc, "R_X86_64_DTPOFF64", false, MINUS_ONE, MINUS_ONE,
 	false),
   HOWTO(R_X86_64_TPOFF64, 0, 8, 64, false, 0, complain_overflow_dont,
-	bfd_elf_generic_reloc, "R_X86_64_TPOFF64", false, 0, MINUS_ONE,
+	bfd_elf_generic_reloc, "R_X86_64_TPOFF64", false, MINUS_ONE, MINUS_ONE,
 	false),
   HOWTO(R_X86_64_TLSGD, 0, 4, 32, true, 0, complain_overflow_signed,
-	bfd_elf_generic_reloc, "R_X86_64_TLSGD", false, 0, 0xffffffff,
+	bfd_elf_generic_reloc, "R_X86_64_TLSGD", false, 0xffffffff, 0xffffffff,
 	true),
   HOWTO(R_X86_64_TLSLD, 0, 4, 32, true, 0, complain_overflow_signed,
-	bfd_elf_generic_reloc, "R_X86_64_TLSLD", false, 0, 0xffffffff,
+	bfd_elf_generic_reloc, "R_X86_64_TLSLD", false, 0xffffffff, 0xffffffff,
 	true),
   HOWTO(R_X86_64_DTPOFF32, 0, 4, 32, false, 0, complain_overflow_signed,
-	bfd_elf_generic_reloc, "R_X86_64_DTPOFF32", false, 0, 0xffffffff,
+	bfd_elf_generic_reloc, "R_X86_64_DTPOFF32", false, 0xffffffff, 0xffffffff,
 	false),
   HOWTO(R_X86_64_GOTTPOFF, 0, 4, 32, true, 0, complain_overflow_signed,
-	bfd_elf_generic_reloc, "R_X86_64_GOTTPOFF", false, 0, 	0xffffffff,
+	bfd_elf_generic_reloc, "R_X86_64_GOTTPOFF", false, 0xffffffff, 0xffffffff,
 	true),
   HOWTO(R_X86_64_TPOFF32, 0, 4, 32, false, 0, complain_overflow_signed,
-	bfd_elf_generic_reloc, "R_X86_64_TPOFF32", false, 0, 0xffffffff,
+	bfd_elf_generic_reloc, "R_X86_64_TPOFF32", false, 0xffffffff, 0xffffffff,
 	false),
   HOWTO(R_X86_64_PC64, 0, 8, 64, true, 0, complain_overflow_dont,
-	bfd_elf_generic_reloc, "R_X86_64_PC64", false, 0, MINUS_ONE,
+	bfd_elf_generic_reloc, "R_X86_64_PC64", false, MINUS_ONE, MINUS_ONE,
 	true),
   HOWTO(R_X86_64_GOTOFF64, 0, 8, 64, false, 0, complain_overflow_dont,
-	bfd_elf_generic_reloc, "R_X86_64_GOTOFF64", false, 0, MINUS_ONE,
+	bfd_elf_generic_reloc, "R_X86_64_GOTOFF64", false, MINUS_ONE, MINUS_ONE,
 	false),
   HOWTO(R_X86_64_GOTPC32, 0, 4, 32, true, 0, complain_overflow_signed,
-	bfd_elf_generic_reloc, "R_X86_64_GOTPC32", false, 0, 0xffffffff,
+	bfd_elf_generic_reloc, "R_X86_64_GOTPC32", false, 0xffffffff, 0xffffffff,
 	true),
   HOWTO(R_X86_64_GOT64, 0, 8, 64, false, 0, complain_overflow_signed,
-	bfd_elf_generic_reloc, "R_X86_64_GOT64", false, 0, MINUS_ONE,
+	bfd_elf_generic_reloc, "R_X86_64_GOT64", false, MINUS_ONE, MINUS_ONE,
 	false),
   HOWTO(R_X86_64_GOTPCREL64, 0, 8, 64, true, 0, complain_overflow_signed,
-	bfd_elf_generic_reloc, "R_X86_64_GOTPCREL64", false, 0, MINUS_ONE,
+	bfd_elf_generic_reloc, "R_X86_64_GOTPCREL64", false, MINUS_ONE, MINUS_ONE,
 	true),
   HOWTO(R_X86_64_GOTPC64, 0, 8, 64, true, 0, complain_overflow_signed,
-	bfd_elf_generic_reloc, "R_X86_64_GOTPC64", false, 0, MINUS_ONE,
+	bfd_elf_generic_reloc, "R_X86_64_GOTPC64", false, MINUS_ONE, MINUS_ONE,
 	true),
   HOWTO(R_X86_64_GOTPLT64, 0, 8, 64, false, 0, complain_overflow_signed,
-	bfd_elf_generic_reloc, "R_X86_64_GOTPLT64", false, 0, MINUS_ONE,
+	bfd_elf_generic_reloc, "R_X86_64_GOTPLT64", false, MINUS_ONE, MINUS_ONE,
 	false),
   HOWTO(R_X86_64_PLTOFF64, 0, 8, 64, false, 0, complain_overflow_signed,
-	bfd_elf_generic_reloc, "R_X86_64_PLTOFF64", false, 0, MINUS_ONE,
+	bfd_elf_generic_reloc, "R_X86_64_PLTOFF64", false, MINUS_ONE, MINUS_ONE,
 	false),
   HOWTO(R_X86_64_SIZE32, 0, 4, 32, false, 0, complain_overflow_unsigned,
-	bfd_elf_generic_reloc, "R_X86_64_SIZE32", false, 0, 0xffffffff,
+	bfd_elf_generic_reloc, "R_X86_64_SIZE32", false, 0xffffffff, 0xffffffff,
 	false),
   HOWTO(R_X86_64_SIZE64, 0, 8, 64, false, 0, complain_overflow_dont,
-	bfd_elf_generic_reloc, "R_X86_64_SIZE64", false, 0, MINUS_ONE,
+	bfd_elf_generic_reloc, "R_X86_64_SIZE64", false, MINUS_ONE, MINUS_ONE,
 	false),
   HOWTO(R_X86_64_GOTPC32_TLSDESC, 0, 4, 32, true, 0,
 	complain_overflow_bitfield, bfd_elf_generic_reloc,
-	"R_X86_64_GOTPC32_TLSDESC", false, 0, 0xffffffff, true),
+	"R_X86_64_GOTPC32_TLSDESC", false, 0xffffffff, 0xffffffff, true),
   HOWTO(R_X86_64_TLSDESC_CALL, 0, 0, 0, false, 0,
 	complain_overflow_dont, bfd_elf_generic_reloc,
 	"R_X86_64_TLSDESC_CALL",
 	false, 0, 0, false),
   HOWTO(R_X86_64_TLSDESC, 0, 8, 64, false, 0,
 	complain_overflow_dont, bfd_elf_generic_reloc,
-	"R_X86_64_TLSDESC", false, 0, MINUS_ONE, false),
+	"R_X86_64_TLSDESC", false, MINUS_ONE, MINUS_ONE, false),
   HOWTO(R_X86_64_IRELATIVE, 0, 8, 64, false, 0, complain_overflow_dont,
-	bfd_elf_generic_reloc, "R_X86_64_IRELATIVE", false, 0, MINUS_ONE,
+	bfd_elf_generic_reloc, "R_X86_64_IRELATIVE", false, MINUS_ONE, MINUS_ONE,
 	false),
   HOWTO(R_X86_64_RELATIVE64, 0, 8, 64, false, 0, complain_overflow_dont,
-	bfd_elf_generic_reloc, "R_X86_64_RELATIVE64", false, 0, MINUS_ONE,
+	bfd_elf_generic_reloc, "R_X86_64_RELATIVE64", false, MINUS_ONE, MINUS_ONE,
 	false),
   HOWTO(R_X86_64_PC32_BND, 0, 4, 32, true, 0, complain_overflow_signed,
-	bfd_elf_generic_reloc, "R_X86_64_PC32_BND", false, 0, 0xffffffff,
+	bfd_elf_generic_reloc, "R_X86_64_PC32_BND", false, 0xffffffff, 0xffffffff,
 	true),
   HOWTO(R_X86_64_PLT32_BND, 0, 4, 32, true, 0, complain_overflow_signed,
-	bfd_elf_generic_reloc, "R_X86_64_PLT32_BND", false, 0, 0xffffffff,
+	bfd_elf_generic_reloc, "R_X86_64_PLT32_BND", false, 0xffffffff, 0xffffffff,
 	true),
   HOWTO(R_X86_64_GOTPCRELX, 0, 4, 32, true, 0, complain_overflow_signed,
-	bfd_elf_generic_reloc, "R_X86_64_GOTPCRELX", false, 0, 0xffffffff,
+	bfd_elf_generic_reloc, "R_X86_64_GOTPCRELX", false, 0xffffffff, 0xffffffff,
 	true),
   HOWTO(R_X86_64_REX_GOTPCRELX, 0, 4, 32, true, 0, complain_overflow_signed,
-	bfd_elf_generic_reloc, "R_X86_64_REX_GOTPCRELX", false, 0, 0xffffffff,
+	bfd_elf_generic_reloc, "R_X86_64_REX_GOTPCRELX", false, 0xffffffff, 0xffffffff,
 	true),
   HOWTO(R_X86_64_CODE_4_GOTPCRELX, 0, 4, 32, true, 0, complain_overflow_signed,
 	bfd_elf_generic_reloc, "R_X86_64_CODE_4_GOTPCRELX", false, 0, 0xffffffff,
@@ -216,7 +216,7 @@ static reloc_howto_type x86_64_elf_howto_table[] =
 
 /* Use complain_overflow_bitfield on R_X86_64_32 for x32.  */
   HOWTO(R_X86_64_32, 0, 4, 32, false, 0, complain_overflow_bitfield,
-	bfd_elf_generic_reloc, "R_X86_64_32", false, 0, 0xffffffff,
+	bfd_elf_generic_reloc, "R_X86_64_32", false, 0xffffffff, 0xffffffff,
 	false)
 };
 
@@ -1915,7 +1915,7 @@ elf_x86_64_convert_load_reloc (bfd *abfd,
 
       if (opcode == 0x8b)
 	{
-	  if (abs_symbol && local_ref && relocx)
+	  if (abs_symbol && local_ref && relocx && rex)
 	    to_reloc_pc32 = false;
 
 	  if (to_reloc_pc32)
@@ -2025,6 +2025,24 @@ elf_x86_64_convert_load_reloc (bfd *abfd,
   return true;
 }
 
+/* Is the instruction before OFFSET in CONTENTS a 32bit relative
+   branch?  */
+
+static bool
+is_32bit_relative_branch (bfd_byte *contents, bfd_vma offset)
+{
+  /* Opcode		Instruction
+     0xe8		call
+     0xe9		jump
+     0x0f 0x8x		conditional jump */
+  return ((offset > 0
+	   && (contents [offset - 1] == 0xe8
+	       || contents [offset - 1] == 0xe9))
+	  || (offset > 1
+	      && contents [offset - 2] == 0x0f
+	      && (contents [offset - 1] & 0xf0) == 0x80));
+}
+
 /* Look through the relocs for a section during the first phase, and
    calculate needed space in the global offset table, and procedure
    linkage table.  */
@@ -3403,9 +3421,6 @@ elf_x86_64_relocate_section (bfd *output_bfd,
 			&& (eh == NULL
 			    || !UNDEFINED_WEAK_RESOLVED_TO_ZERO (info,
 								 eh)))
-		       || (bfd_link_pie (info)
-			   && !SYMBOL_DEFINED_NON_SHARED_P (h)
-			   && h->def_dynamic)
 		       || (no_copyreloc_p
 			   && h->def_dynamic
 			   && !(h->root.u.def.section->flags & SEC_CODE))))
@@ -3414,20 +3429,25 @@ elf_x86_64_relocate_section (bfd *output_bfd,
 		  || bfd_link_dll (info)))
 	    {
 	      bool fail = false;
+	      bool branch
+		= ((r_type == R_X86_64_PC32
+		    || r_type == R_X86_64_PC32_BND)
+		   && is_32bit_relative_branch (contents, rel->r_offset));
+
 	      if (SYMBOL_REFERENCES_LOCAL_P (info, h))
 		{
 		  /* Symbol is referenced locally.  Make sure it is
-		     defined locally.  */
-		  fail = !SYMBOL_DEFINED_NON_SHARED_P (h);
+		     defined locally or for a branch.  */
+		  fail = !SYMBOL_DEFINED_NON_SHARED_P (h) && !branch;
 		}
 	      else if (bfd_link_pie (info))
 		{
 		  /* We can only use PC-relative relocations in PIE
-		     from non-code sections.  */
+		     from non-code sections or branches.  */
 		  if (h->root.type == bfd_link_hash_undefweak
 		      || (h->type == STT_FUNC
 			  && (sec->flags & SEC_CODE) != 0))
-		    fail = true;
+		    fail = !branch;
 		}
 	      else if (no_copyreloc_p || bfd_link_dll (info))
 		{
@@ -3436,9 +3456,10 @@ elf_x86_64_relocate_section (bfd *output_bfd,
 		     relocations against default and protected
 		     symbols since address of protected function
 		     and location of protected data may not be in
-		     the shared object.   */
+		     the shared object.  We do allow branch to symbol
+		     with non-default visibility.  */
 		  fail = (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
-			  || ELF_ST_VISIBILITY (h->other) == STV_PROTECTED);
+			  || !branch);
 		}
 
 	      if (fail)
diff --git a/bfd/elfcode.h b/bfd/elfcode.h
index 1e0784611bc..0926a062901 100644
--- a/bfd/elfcode.h
+++ b/bfd/elfcode.h
@@ -72,6 +72,7 @@
 #include "libbfd.h"
 #include "elf-bfd.h"
 #include "libiberty.h"
+#include "elf32-atariprg.h"
 
 /* Renaming structures, typedefs, macros and functions to be size-specific.  */
 #define Elf_External_Ehdr	NAME(Elf,External_Ehdr)
@@ -1107,10 +1108,20 @@ elf_write_shdrs_and_ehdr (bfd *abfd)
   Elf_Internal_Shdr **i_shdrp;	/* Section header table, internal form */
   unsigned int count;
   size_t amt;
+  file_ptr ehdr_offset = 0;	/* File offset of ELF Header */
 
   i_ehdrp = elf_elfheader (abfd);
   i_shdrp = elf_elfsections (abfd);
 
+  if (abfd->xvec == &m68k_elf32_atariprg_vec)
+    {
+      /* There is an extra header before the ELF file header.  */
+      file_ptr vma_off;
+      bfd_size_type sizeof_extra_header;
+      bfd_elf32_atariprg_get_extra_header_info (abfd, &vma_off, &sizeof_extra_header);
+      ehdr_offset = vma_off + sizeof_extra_header;
+    }
+
   /* swap the header before spitting it out...  */
 
 #if DEBUG & 1
@@ -1118,7 +1129,7 @@ elf_write_shdrs_and_ehdr (bfd *abfd)
 #endif
   elf_swap_ehdr_out (abfd, i_ehdrp, &x_ehdr);
   amt = sizeof (x_ehdr);
-  if (bfd_seek (abfd, 0, SEEK_SET) != 0
+  if (bfd_seek (abfd, ehdr_offset, SEEK_SET) != 0
       || bfd_write (&x_ehdr, amt, abfd) != amt)
     return false;
 
diff --git a/bfd/elflink.c b/bfd/elflink.c
index c2494b3e12e..5369a99c40d 100644
--- a/bfd/elflink.c
+++ b/bfd/elflink.c
@@ -5659,7 +5659,6 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
       free (nondeflt_vers);
       return true;
     }
-
   if (old_tab != NULL)
     {
       if (!(*bed->notice_as_needed) (abfd, info, notice_needed))
@@ -5668,6 +5667,52 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
       old_tab = NULL;
     }
 
+
+  /*
+   * We must call the constructor callback for all entries in .ctors/.dtors sections,
+   * so they are added to the __CTOR_LIST__/__DTOR_LIST__ vectors.
+   */
+  if (info->output_bfd->xvec->flavour == bfd_target_aout_flavour)
+  {
+    const char *name;
+
+    for (s = abfd->sections; s != NULL; s = s->next)
+    {
+        bool is_cons;
+        asymbol **symbols;
+        arelent *reloc;
+        unsigned int j;
+
+        name = bfd_section_name(s);
+        if (strncmp(name, ".ctors", 6) == 0)
+        {
+            is_cons = true;
+        } else if (strncmp(name, ".dtors", 6) == 0)
+        {
+            is_cons = false;
+        } else
+        {
+            continue;
+        }
+        if (s->reloc_count == 0)
+            continue;
+        symbols = (asymbol **)bfd_alloc(abfd, (symcount + 1) * sizeof(*symbols));
+        if (bed->s->slurp_symbol_table(abfd, symbols, dynamic) > 0)
+        {
+	        abfd->symcount = symcount;
+	        if (bed->s->slurp_reloc_table(abfd, s, symbols, dynamic))
+	        {
+		        reloc = s->relocation;
+		        for (j = 0; j < s->reloc_count; j++, reloc++)
+		        {
+		            /* fprintf(stderr, "%u: %s\n", j, (*reloc->sym_ptr_ptr)->name); */
+		            info->callbacks->constructor(info, is_cons, (*reloc->sym_ptr_ptr)->name, abfd, (*reloc->sym_ptr_ptr)->section, (*reloc->sym_ptr_ptr)->value);
+		        }
+		    }
+	    }
+    }
+  }
+
   /* Now that all the symbols from this input file are created, if
      not performing a relocatable link, handle .symver foo, foo@BAR
      such that any relocs against foo become foo@BAR.  */
@@ -6174,6 +6219,7 @@ elf_link_add_archive_symbols (bfd *abfd, struct bfd_link_info *info)
 bool
 bfd_elf_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 {
+
   switch (bfd_get_format (abfd))
     {
     case bfd_object:
@@ -7256,7 +7302,7 @@ error: %s: is triggering the generation of an executable stack (because it has a
 warning: %s: requires executable stack (because the .note.GNU-stack section is executable)"),
 		       bfd_get_filename (noteobj));
 		    }
-		  else if (emptyobj)
+		  else if (emptyobj && (info->output_bfd == NULL || info->output_bfd->xvec == NULL || strcmp(info->output_bfd->xvec->name, "elf32-atariprg") != 0))
 		    {
 		      if (info->error_execstack)
 			{
diff --git a/bfd/format.c b/bfd/format.c
index 47c3e9ba35a..485a5a34acf 100644
--- a/bfd/format.c
+++ b/bfd/format.c
@@ -318,7 +318,7 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
   int match_count, best_count, best_match;
   int ar_match_index;
   unsigned int initial_section_id = _bfd_section_id;
-  struct bfd_preserve preserve, preserve_match;
+  struct bfd_preserve preserve;
   bfd_cleanup cleanup = NULL;
   bfd_error_handler_type orig_error_handler;
   static int in_check_format;
@@ -358,9 +358,10 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
     orig_error_handler = _bfd_set_error_handler_caching (abfd);
   ++in_check_format;
 
-  preserve_match.marker = NULL;
+  preserve.marker = NULL;
   if (!bfd_preserve_save (abfd, &preserve, NULL))
     goto err_ret;
+  preserve.marker = NULL;
 
   /* If the target type was explicitly specified, just check that target.  */
   if (!abfd->target_defaulted)
@@ -401,7 +402,6 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
 
   for (target = bfd_target_vector; *target != NULL; target++)
     {
-      void **high_water;
 
       /* The binary target matches anything, so don't return it when
 	 searching.  Don't match the plugin target if we have another
@@ -419,14 +419,6 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
 	 have sections attached, which will confuse the next
 	 _bfd_check_format call.  */
       bfd_reinit (abfd, initial_section_id, &preserve, cleanup);
-      /* Free bfd_alloc memory too.  If we have matched and preserved
-	 a target then the high water mark is that much higher.  */
-      if (preserve_match.marker)
-	high_water = &preserve_match.marker;
-      else
-	high_water = &preserve.marker;
-      bfd_release (abfd, *high_water);
-      *high_water = bfd_alloc (abfd, 1);
 
       /* Change BFD's target temporarily.  */
       abfd->xvec = *target;
@@ -434,6 +426,12 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
       if (bfd_seek (abfd, 0, SEEK_SET) != 0)
 	goto err_ret;
 
+      /* If _bfd_check_format neglects to set bfd_error, assume
+	 bfd_error_wrong_format.  We didn't used to even pay any
+	 attention to bfd_error, so I suspect that some
+	 _bfd_check_format might have this problem.  */
+      bfd_set_error (bfd_error_wrong_format);
+
       cleanup = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));
       if (cleanup)
 	{
@@ -447,6 +445,10 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
 	    match_priority = (*target)->match_priority;
 #endif
 
+	  match_targ = abfd->xvec;
+	  if (preserve.marker != NULL)
+	    bfd_preserve_finish (abfd, &preserve);
+
 	  if (abfd->format != bfd_archive
 	      || (bfd_has_map (abfd)
 		  && bfd_get_error () != bfd_error_wrong_object_format))
@@ -485,14 +487,12 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
 	      ar_match_index++;
 	    }
 
-	  if (preserve_match.marker == NULL)
-	    {
-	      match_targ = abfd->xvec;
-	      if (!bfd_preserve_save (abfd, &preserve_match, cleanup))
-		goto err_ret;
-	      cleanup = NULL;
-	    }
+	  if (!bfd_preserve_save (abfd, &preserve, cleanup))
+	    goto err_ret;
+	  cleanup = NULL;
 	}
+      else if (bfd_get_error () != bfd_error_wrong_format)
+	goto err_ret;
     }
 
   if (best_count == 1)
@@ -562,8 +562,8 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
      really shouldn't iterate on live bfd's.  Note that saving the
      whole bfd and restoring it would be even worse; the first thing
      you notice is that the cached bfd file position gets out of sync.  */
-  if (preserve_match.marker != NULL)
-    cleanup = bfd_preserve_restore (abfd, &preserve_match);
+  if (preserve.marker != NULL)
+    cleanup = bfd_preserve_restore (abfd, &preserve);
 
   if (match_count == 1)
     {
@@ -578,7 +578,6 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
       if (match_targ != right_targ)
 	{
 	  bfd_reinit (abfd, initial_section_id, &preserve, cleanup);
-	  bfd_release (abfd, preserve.marker);
 	  if (bfd_seek (abfd, 0, SEEK_SET) != 0)
 	    goto err_ret;
 	  cleanup = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));
@@ -595,9 +594,6 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
 	abfd->output_has_begun = true;
 
       free (matching_vector);
-      if (preserve_match.marker != NULL)
-	bfd_preserve_finish (abfd, &preserve_match);
-      bfd_preserve_finish (abfd, &preserve);
       bfd_set_error_handler (orig_error_handler);
 
       struct per_xvec_message **list = _bfd_per_xvec_warn (abfd->xvec, 0);
@@ -647,9 +643,8 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
   if (cleanup)
     cleanup (abfd);
  out:
-  if (preserve_match.marker != NULL)
-    bfd_preserve_finish (abfd, &preserve_match);
-  bfd_preserve_restore (abfd, &preserve);
+  if (preserve.marker != NULL)
+    bfd_preserve_restore (abfd, &preserve);
   bfd_set_error_handler (orig_error_handler);
   struct per_xvec_message **list = _bfd_per_xvec_warn (NULL, 0);
   struct per_xvec_message **one = NULL;
diff --git a/bfd/gen-aout.c b/bfd/gen-aout.c
index 7d5ea1c6b83..35820f535d3 100644
--- a/bfd/gen-aout.c
+++ b/bfd/gen-aout.c
@@ -92,6 +92,9 @@ main (int argc, char** argv)
 
 #ifdef vax
   arch = "vax";
+#endif
+#ifdef m68k
+  arch = "m68k";
 #endif
   if (arch[0] == '1')
     {
diff --git a/bfd/glibc.so b/bfd/glibc.so
new file mode 100644
index 00000000000..408ef8ba856
--- /dev/null
+++ b/bfd/glibc.so
@@ -0,0 +1,3 @@
+/* GNU ld script  */
+OUTPUT_FORMAT(elf64-x86-64)
+GROUP ( /lib64/libdl.so.2 /lib64/libc.so.6 /usr/lib64/libc_nonshared.a AS_NEEDED ( /lib64/ld-linux-x86-64.so.2 ) )
diff --git a/bfd/libaout.h b/bfd/libaout.h
index 11a6f701526..26121d7aec7 100644
--- a/bfd/libaout.h
+++ b/bfd/libaout.h
@@ -102,7 +102,7 @@ struct aout_link_hash_entry
 {
   struct bfd_link_hash_entry root;
   /* Whether this symbol has been written out.  */
-  bool written;
+  int written;
   /* Symbol index in output file.  */
   int indx;
 };
@@ -421,6 +421,10 @@ struct aoutdata
      table, used when linking on SunOS.  This is indexed by the symbol
      index.  */
   bfd_vma *local_got_offsets;
+
+  /* A pointer for data used by aout extensions.  (Currently only used
+     by MiNT executables (see prg-mint.c).  */
+  void *ext;
 };
 
 struct  aout_data_struct
@@ -448,6 +452,7 @@ struct  aout_data_struct
 #define obj_aout_string_window(bfd)	   (adata (bfd).string_window)
 #define obj_aout_sym_hashes(bfd)	   (adata (bfd).sym_hashes)
 #define obj_aout_dynamic_info(bfd)	   (adata (bfd).dynamic_info)
+#define obj_aout_ext(bfd)              (adata (bfd).ext)
 
 /* We take the address of the first element of an asymbol to ensure that the
    macro is only ever applied to an asymbol.  */
diff --git a/bfd/opncls.c b/bfd/opncls.c
index a0a5c40fba8..d6f00c5c519 100644
--- a/bfd/opncls.c
+++ b/bfd/opncls.c
@@ -26,6 +26,9 @@
 #include "libbfd.h"
 #include "libiberty.h"
 #include "elf-bfd.h"
+#include "elf32-atariprg.h"
+
+extern const bfd_target m68k_elf32_vec;
 
 #ifndef S_IXUSR
 #define S_IXUSR 0100	/* Execute by owner.  */
@@ -971,7 +974,14 @@ bfd_create (const char *filename, bfd *templ)
       return NULL;
     }
   if (templ)
-    nbfd->xvec = templ->xvec;
+    {
+      /* This is called by ld plugin_get_ir_dummy_bfd ()
+	 when creating some intermediate object files for LTO.  */
+      if (templ->xvec == &m68k_elf32_atariprg_vec)
+	nbfd->xvec = &m68k_elf32_vec;
+      else
+	nbfd->xvec = templ->xvec;
+    }
   nbfd->direction = no_direction;
   bfd_set_format (nbfd, bfd_object);
 
diff --git a/bfd/prg-mint.c b/bfd/prg-mint.c
new file mode 100644
index 00000000000..3cba36b08b7
--- /dev/null
+++ b/bfd/prg-mint.c
@@ -0,0 +1,1730 @@
+/* BFD backend for traditional MiNT executables.
+   Copyright (C) 1998-2024 Free Software Foundation, Inc.
+   Originally written by Guido Flohr (guido@freemint.de).
+   Modified by Vincent Riviere (vincent.riviere@freesbee.fr).
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+/* The format of executables on Atari is actually not a.out,  it is
+   only chosen as an approach which comes close enough.  The layout of a
+   program image on disk looked like this:
+
+   +-----------------+
+   | 28 Bytes Header |
+   +-----------------+
+   | Text segment    |
+   +-----------------+
+   | Data segment    |
+   +-----------------+
+   | BSS	     |
+   +-----------------+
+   | Symbol table    |
+   +-----------------+
+   | TPA relocation  |
+   +-----------------+
+
+   The 28 byte exec header used to look like this:
+
+   struct old_exec_header
+   {
+     bfd_byte a_magic[2];
+     bfd_byte a_text[4];
+     bfd_byte a_data[4];
+     bfd_byte a_bss[4];
+     bfd_byte a_syms[4];
+     bfd_byte a_resvd[4];
+     bfd_byte a_abs[2];
+   };
+
+   The first two bytes (A_MAGIC) contained an assembler branch
+   instruction to the beginning of the text segment.  Because the
+   exec header had a fixed size and the text entry point was constant
+   this assembler instruction also had a constant value (0x601a).
+   In fact the operating system never really executed the branch
+   instruction but used this value (0x601a) as a magic value.
+
+   TEXT, DATA and BSS were as one would expect them.  The symbol
+   table wasn't.  Several different formats were in use, none of them
+   very efficient, none of them powerful enough to support source
+   level debugging.  I've changed that and the GNU symbol table will
+   now be used instead (unless the --traditional-format option was
+   given to the linker).
+
+   If the last member A_ABS of the exec header is zero the program
+   image contains an additional table with relocation information
+   at the end of the image.  The kernel can load program images at
+   virtually any address in the address space.  In fact it will load
+   it at the start of the biggest block of free memory.  This block
+   is then called the Transient Program Area TPA and the image has
+   to be relocated against the TPA at runtime.  The relocation info
+   itself is in a simply way compressed:  It starts with a four-byte
+   value, the first address within the image to be relocated.  Now
+   following are one-byte offsets to the last address.  The special
+   value of 1 (which is impossible as an offset) signifies that 254
+   has to be added to the next offset.  The table is finished with
+   a zero-byte.
+
+   I now simply extended the header from its old 28 bytes to 256
+   bytes.  The first 28 bytes give home to a standard Atari header,
+   the rest is for extensions.  The extension header starts with
+   a ``real'' assembler instruction, a far jump to the text entry
+   point.  The extension header gives home to a standard a.out
+   exec header (currently NMAGIC) plus some extra
+   more or less useful fields plus space to future extensions.
+   For the OS the extension header will already belong to the text
+   segment, for BFD backends the text segment is 228 (or 0xe4)
+   bytes smaller than for the OS.  This explains for example the
+   funny TEXT_START_ADDR 0xe4.
+
+   The TARGET_PAGE_SIZE is 2 which is only fake.  There is currently
+   no such thing as memory paging on the Atari (and this is why
+   ZMAGICs are disabled for now to allow for future enhancements).
+
+   If you think that this whole file looks quite like a big hack
+   you're probably right.  But the results (mainly the output of
+   the linker) seem to work and they allow to use up-to-date
+   binutils on the Atari until a better executable format (maybe
+   ELF) has been established for this machine.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+
+#define N_HEADER_IN_TEXT(x) 0
+#define BYTES_IN_WORD 4
+#define ENTRY_CAN_BE_ZERO
+#define N_SHARED_LIB(x) 0
+#define TEXT_START_ADDR 0xe4
+#define TARGET_PAGE_SIZE 2
+#define TARGET_IS_BIG_ENDIAN_P
+#define DEFAULT_ARCH bfd_arch_m68k
+#define N_TXTADDR(x) TEXT_START_ADDR
+
+/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
+   remove whitespace added here, and thus will fail to concatenate
+   the tokens.  */
+#define MY(OP) CONCAT2 (m68k_aout_mintprg_,OP)
+#define TARGETNAME "a.out-mintprg"
+#define NAME(x,y) CONCAT3 (mintprg,_32_,y)
+
+/* We have to do quite a lot of magic to make the Atari format
+   for GEMDOS executables fit into the standard a.out format.
+   We start with the original header.  */
+#define external_exec mint_external_exec
+struct mint_external_exec
+{
+  bfd_byte g_branch[2]; 	     /* 0x601a.  */
+  bfd_byte g_text[4];		     /* Length of text section.  */
+  bfd_byte g_data[4];		     /* Length of data section.  */
+  bfd_byte g_bss[4];		     /* Length of bss section.  */
+  bfd_byte g_syms[4];		     /* Length of symbol table.  */
+  bfd_byte g_extmagic[4];	     /* Always 0x4d694e54
+					(in ASCII: ``MiNT'').  */
+  bfd_byte g_flags[4];		     /* Atari special flags.  */
+  bfd_byte g_abs[2];		     /* Non-zero if absolute (no relocation
+					info.  */
+
+  /* We extend this header now to provide the information that the
+     binutils want to see.  Everything following will actually be part
+     of the text segment (from MiNT's point of view).  As a
+     consequence the text section has 228 bytes of redundancy.
+
+     The following eight bytes should be treated as opaque.
+     If the word ``opaque'' always attracts your curiosity in
+     typedefs and structs, here's the explanation:  These eight bytes
+     are really two assembler instructions.  The first one moves
+     the contents of e_entry into register d0, the second one
+     jumps (pc-relative) to the entry point.  See swap_exec_header_out
+     for details.  */
+  bfd_byte g_jump_entry[8];
+
+  /* Now following a standard a.out header.  Note that the values
+     may differ from the one given on top.  The traditional header
+     contains the values that the OS wants to see, the values below
+     are the values that make the binutils work.  */
+  bfd_byte e_info[4];		     /* Magic number and stuff.  */
+  bfd_byte e_text[4];		     /* Length of text section in bytes.  */
+  bfd_byte e_data[4];		     /* Length of data section.  */
+  bfd_byte e_bss[4];		     /* Length of standard symbol
+					table.  */
+  bfd_byte e_syms[4];		     /* Length of symbol table.  */
+  bfd_byte e_entry[4];		     /* Start address.  */
+  bfd_byte e_trsize[4]; 	     /* Length of text relocation
+					info.  */
+  bfd_byte e_drsize[4]; 	     /* Length of data relocation
+					info.  */
+
+  bfd_byte g_tparel_pos[4];	     /* File position of TPA relative
+					relocation info.  */
+  bfd_byte g_tparel_size[4];	     /* Length of TPA relative relocation
+					info.  */
+
+  /* This is for extensions.  */
+  bfd_byte g_stkpos[4]; 	     /* If stacksize is hardcoded into
+					the executable you will find it
+					at file offset g_stkpos.  If
+					not this is NULL.  */
+
+  bfd_byte g_symbol_format[4];	     /* Format of the symbol table.  See
+					definitions for _MINT_SYMBOL_FORMAT*
+					above.  */
+
+  /* Pad with zeros.  */
+  bfd_byte g_pad0[172];
+};
+#define EXEC_BYTES_SIZE 256
+#define GEMDOS_HEADER_SIZE 28
+
+/* The following defines are required by aoutx.h.
+   They are not automatically defined in aout/aout64.h
+   if external_exec is defined.  */
+
+#define OMAGIC 0407	/* Object file or impure executable.  */
+#define NMAGIC 0410	/* Code indicating pure executable.  */
+#define ZMAGIC 0413	/* Code indicating demand-paged executable.  */
+#define BMAGIC 0415	/* Used by a b.out object.  */
+#define QMAGIC 0314	/* Like ZMAGIC but with N_HEADER_IN_TEXT true.  */
+
+/* Files using the following magic flags will not be loaded.  */
+#define N_BADMAG(x)	(N_MAGIC(x) != NMAGIC)
+
+/* For DRI symbol table format.  */
+struct dri_symbol
+{
+  bfd_byte a_name[8];	  /* Symbol name */
+  bfd_byte a_type[2];	  /* Type flag, i.e. A_TEXT etc; see below.  */
+  bfd_byte a_value[4];	  /* value of this symbol (or sdb offset).  */
+};
+#define DRI_SYMBOL_SIZE 14
+
+/* Simple values for a_type.  */
+#define A_UNDF	0
+#define A_BSS	0x0100
+#define A_TEXT	0x0200
+#define A_DATA	0x0400
+#define A_EXT	0x0800	      /* External.  */
+#define A_EQREG 0x1000	      /* Equated register.  */
+#define A_GLOBL 0x2000	      /* Global.  */
+#define A_EQU	0x4000	      /* Equated.  */
+#define A_DEF	0x8000	      /* Defined.  */
+#define A_LNAM	0x0048	      /* GST compatible long name.  */
+			      /* File symbols ala aln.  */
+#define A_TFILE 0x0280	      /* Text file corresponding to object module.  */
+#define A_TFARC 0x02C0	      /* Text file archive.  Unfortunately this
+				 conflicts with the bits in A_LNAM.  */
+
+/* The following include contains the definitions for internal a.out structures
+   as well as the prototypes for the NAME(...) functions defined in aoutx.h.  */
+
+#include "libaout.h"
+
+/* The following function is similar to _bfd_final_link_relocate, except it
+   adds the reloc structure as an additional parameter.
+   It will be used int aoutx.h.  */
+
+static bfd_reloc_status_type
+MY (final_link_relocate_rel) (reloc_howto_type *howto,
+			      bfd *input_bfd,
+			      asection *input_section,
+			      bfd_byte *contents,
+			      bfd_vma address,
+			      bfd_vma value,
+			      bfd_vma addend,
+			      struct reloc_std_external *rel);
+
+#define MY_final_link_relocate_rel MY (final_link_relocate_rel)
+
+/* The following include contains the definitions for the NAME(...) functions.  */
+
+#include "aoutx.h"
+
+/* Data structure that holds some private information for us.  */
+struct mint_internal_info
+{
+  struct bfd_link_info *linkinfo;    /* Remembered from final_link.  */
+  bool	traditional_format;  /* Saved from link info.  */
+  int		symbol_format;	     /* Format of the symbol table.  */
+  void		*tparel;	     /* Data for TPA relative relocation
+					information.  */
+  file_ptr	tparel_pos;	     /* File position of TPA relative
+					relocation information.  */
+  bfd_size_type tparel_size;	     /* Size of TPA relative relocation
+					information.  */
+  bfd_size_type dri_symtab_size;     /* Size of traditional symbol table.  */
+
+#define MINT_RELOC_CHUNKSIZE 0x1000
+  bfd_vma	*relocs;	     /* Array of address relocations.  */
+  unsigned long relocs_used;	     /* Number of relocation entries
+					already used up.  */
+  unsigned long relocs_allocated;    /* Number of relocation entries
+					allocated.  */
+
+  bfd_vma	stkpos; 	     /* File offset to value of _stksize.  */
+
+  flagword	prg_flags;	     /* Standard GEMDOS flags.  */
+
+  bool 	override_stack_size; /* TRUE if the executable stack size
+					must be overriden with stack_size.  */
+  bfd_signed_vma stack_size;
+
+  bool	reloc_error;	     /* TRUE if an unhandled error during
+					relocation occured.  */
+};
+
+/* If --traditional-format was given to the linker an old-style DRI
+   symbol table is written into the executable.  This is with respect
+   to many old debugging tools or disassemblers which expect this format.
+   Although created by the linker, these symbols will be ignored from
+   input files.  */
+#define _MINT_SYMBOL_FORMAT_GNU  0
+#define _MINT_SYMBOL_FORMAT_DRI  1
+
+/* Declarations for the variables and functions
+   defined later in aout-target.h.  */
+
+static bfd_cleanup
+MY (callback) (bfd *abfd);
+
+static void
+MY_final_link_callback (bfd *abfd,
+			file_ptr *ptreloff,
+			file_ptr *pdreloff,
+			file_ptr *psymoff);
+
+extern const bfd_target MY (vec);
+
+/* Initialize a new BFD using our file format.  */
+
+#define MY_mkobject MY (mkobject)
+
+static bool
+MY (mkobject) (bfd *abfd)
+{
+  struct mint_internal_info *myinfo;
+
+  if (!NAME (aout, mkobject (abfd)))
+    return false;
+
+  /* Allocate our private BFD data.  */
+  myinfo = bfd_zalloc (abfd, sizeof (*myinfo));
+  if (myinfo == NULL)
+    return false;
+  obj_aout_ext (abfd) = myinfo;
+
+  return true;
+}
+
+/* Finish up the reading of an a.out file header.  */
+
+#define MY_object_p MY (object_p)
+
+static bfd_cleanup
+MY (object_p) (bfd *abfd)
+{
+  struct external_exec exec_bytes;	/* Raw exec header from file.  */
+  struct internal_exec exec;		/* Cleaned-up exec header.  */
+  bfd_size_type amt = EXEC_BYTES_SIZE;
+  struct mint_internal_info *myinfo;
+
+  /* Read the exec bytesd from the file.  */
+  if (bfd_read (&exec_bytes, amt, abfd) != amt)
+    {
+      if (bfd_get_error () != bfd_error_system_call)
+	bfd_set_error (bfd_error_wrong_format);
+      return NULL;
+    }
+
+  /* Instead of byte-swapping we compare bytes.  */
+  if (exec_bytes.g_branch[0] != 0x60
+      || exec_bytes.g_branch[1] != 0x1a
+      || exec_bytes.g_extmagic[0] != 'M'
+      || exec_bytes.g_extmagic[1] != 'i'
+      || exec_bytes.g_extmagic[2] != 'N'
+      || exec_bytes.g_extmagic[3] != 'T')
+    {
+      bfd_set_error (bfd_error_wrong_format);
+      return NULL;
+    }
+
+  /* Swap the standard a.out fields.  */
+  NAME (aout, swap_exec_header_in) (abfd, &exec_bytes, &exec);
+
+  /* Check a.out magic value.  */
+  if (N_BADMAG (&exec))
+    {
+      bfd_set_error (bfd_error_wrong_format);
+      return NULL;
+    }
+
+  /* Initialize this BFD with the exec values.  */
+  NAME (aout, some_aout_object_p) (abfd, &exec, MY (callback));
+
+  /* Allocate our private BFD data.  */
+  myinfo = bfd_zalloc (abfd, sizeof (*myinfo));
+  if (myinfo == NULL)
+    return NULL;
+  obj_aout_ext (abfd) = myinfo;
+
+  /* Now get the missing information.  */
+  myinfo->prg_flags = bfd_h_get_32 (abfd, exec_bytes.g_flags);
+  myinfo->stkpos = bfd_h_get_32 (abfd, exec_bytes.g_stkpos);
+  myinfo->symbol_format = bfd_h_get_32 (abfd, exec_bytes.g_symbol_format);
+
+  /* TPA relocation information.  */
+  myinfo->tparel_pos = bfd_h_get_32 (abfd, exec_bytes.g_tparel_pos);
+  myinfo->tparel_size = bfd_h_get_32 (abfd, exec_bytes.g_tparel_size);
+
+  /* FIXME:  Currently we always read the TPA relative relocation
+     information.  This is suboptimal because often times there
+     is no need for it.  Read it only if need be!  Maybe this should
+     also depend on abfd->cacheable?  */
+  if (myinfo->tparel_size == 0)
+    myinfo->tparel = bfd_zalloc (abfd, 4);
+  else
+    myinfo->tparel = bfd_alloc (abfd, myinfo->tparel_size);
+
+  if (myinfo->tparel == NULL)
+    return NULL;
+
+  if (myinfo->tparel_size == 0)
+    {
+      myinfo->tparel_size = 4;
+    }
+  else
+    {
+      /* Read the information from the bfd.  */
+      if (bfd_seek (abfd, myinfo->tparel_pos, SEEK_SET) != 0
+	  || (bfd_read (myinfo->tparel, myinfo->tparel_size, abfd)
+	      != myinfo->tparel_size))
+	return NULL;
+    }
+
+  return _bfd_no_cleanup;
+}
+
+/* Free all information we have cached for this BFD.  We can always
+   read it again later if we need it.  */
+
+#define MY_bfd_free_cached_info MY (bfd_free_cached_info)
+
+static bool
+MY (bfd_free_cached_info) (bfd *abfd)
+{
+  struct mint_internal_info *myinfo;
+
+  if (abfd->format == bfd_unknown)
+    return true;
+  myinfo = obj_aout_ext (abfd);
+  if (myinfo != NULL && myinfo->relocs != NULL)
+    {
+      free (myinfo->relocs);
+      myinfo->relocs = NULL;
+    }
+
+  /* myinfo itself has been allocated by bfd_zalloc()
+     so will be automatically freed along with the BFD.
+     Same for myinfo->tparel.  */
+
+  return NAME (aout, bfd_free_cached_info) (abfd);
+}
+
+/* Write a DRI symbol with TYPE and VALUE.  If the NAME of the
+   symbol exceeds 8 characters write a long symbol.  If it
+   exceeds 22 characters truncate the name.  */
+
+static int
+write_dri_symbol (bfd *abfd, const char *name, int type, bfd_vma value)
+{
+  int written_bytes = 0;
+  struct dri_symbol sym;
+  int is_long_name = strlen (name) > sizeof (sym.a_name);
+
+  if (is_long_name)
+    type |= A_LNAM;
+
+  strncpy ((char*)sym.a_name, name, sizeof (sym.a_name));
+  bfd_put_16 (abfd, type, sym.a_type);
+  bfd_put_32 (abfd, value, sym.a_value);
+
+  if (bfd_write (&sym, DRI_SYMBOL_SIZE, abfd) != DRI_SYMBOL_SIZE)
+    return -1;
+  written_bytes += DRI_SYMBOL_SIZE;
+
+  if (is_long_name)
+    {
+      char more_name[DRI_SYMBOL_SIZE + 1];
+
+      strncpy (more_name, name + sizeof (sym.a_name), DRI_SYMBOL_SIZE);
+
+      if (bfd_write (more_name, DRI_SYMBOL_SIZE, abfd) != DRI_SYMBOL_SIZE)
+	return -1;
+      written_bytes += DRI_SYMBOL_SIZE;
+    }
+
+  return written_bytes;
+}
+
+/* Emit a traditional DRI symbol table while linking.
+   Most of this code comes from aout_link_write_symbols() in aoutx.h.  */
+
+static bool
+link_write_traditional_syms (bfd *abfd, struct bfd_link_info *info)
+{
+  bfd			     *input_bfd;
+  enum bfd_link_strip	     strip = info->strip;
+  enum bfd_link_discard      discard = info->discard;
+  struct mint_internal_info  *myinfo = obj_aout_ext (abfd);
+  bfd			     *last_archive = NULL;
+
+  /* Position file pointer.  */
+  if (bfd_seek (abfd, obj_sym_filepos (abfd), SEEK_SET) != 0)
+    return false;
+
+  myinfo->dri_symtab_size = 0;
+
+  for (input_bfd = info->input_bfds; input_bfd != NULL; input_bfd = input_bfd->link.next)
+    {
+      bfd_size_type sym_count = obj_aout_external_sym_count (input_bfd);
+      char *strings = obj_aout_external_strings (input_bfd);
+      struct external_nlist *sym = obj_aout_external_syms (input_bfd);
+      struct external_nlist *sym_end = sym + sym_count;
+      struct aout_link_hash_entry **sym_hash = obj_aout_sym_hashes (input_bfd);
+      bool pass = false;
+      bool skip = false;
+      bool skip_next = false;
+      int written_bytes;
+      int a_type;
+      bool write_archive_name = false;
+      bfd_vma val = 0;
+
+      /* First write out a symbol for the archive if we do not
+	 strip these symbols and if it differs from the last
+	 one.  */
+      if (input_bfd->my_archive != last_archive
+	  && input_bfd->my_archive != NULL)
+	{
+	  write_archive_name = true;
+	  last_archive = input_bfd->my_archive;
+	}
+
+      if (write_archive_name
+	  && strip != strip_all
+	  && (strip != strip_some
+	      || bfd_hash_lookup (info->keep_hash,
+				  input_bfd->my_archive->filename,
+				  false, false) != NULL)
+	  && discard != discard_all)
+	{
+	  asection *section = obj_textsec (input_bfd)->output_section;
+	  val = bfd_section_vma (section) + section->output_offset;
+
+	  written_bytes = write_dri_symbol (abfd,
+					    input_bfd->my_archive->filename,
+					    A_TFILE, val);
+
+	  if (written_bytes < 0)
+	    return false;
+	  else
+	    myinfo->dri_symtab_size += written_bytes;
+	}
+
+      /* Now write out a symbol for the object file if we do not
+	 strip these symbols.  */
+      if (strip != strip_all
+	  && (strip != strip_some
+	      || bfd_hash_lookup (info->keep_hash, input_bfd->filename,
+				  false, false) != NULL)
+	  && discard != discard_all)
+	{
+	  asection *section = obj_textsec (input_bfd)->output_section;
+	  val = bfd_section_vma (section) + section->output_offset;
+
+	  written_bytes = write_dri_symbol (abfd, input_bfd->filename,
+					    A_TFILE, val);
+	  if (written_bytes < 0)
+	    return false;
+	  else
+	    myinfo->dri_symtab_size += written_bytes;
+	}
+
+      /* Now we have a problem.  All symbols that we see have already
+	 been marked written (because we write them a second time
+	 here.  If we would do it the clean way we would have
+	 to traverse the entire symbol map and reset the written
+	 flag.  We hack here instead...  */
+#define mark_written(h) (h->written = 2)
+#define is_written(h) ((int) h->written == 2)
+      for (; sym < sym_end; sym++, sym_hash++)
+	{
+	  const char *name;
+	  int type;
+	  struct aout_link_hash_entry *h;
+	  asection *symsec;
+	  val = 0;
+
+	  type = H_GET_8 (input_bfd, sym->e_type);
+	  name = strings + GET_WORD (input_bfd, sym->e_strx);
+
+	  h = NULL;
+
+	  if (pass)
+	    {
+	      /* Pass this symbol through.  It is the target of an
+	      indirect or warning symbol.  */
+	      val = GET_WORD (input_bfd, sym->e_value);
+	      pass = false;
+	    }
+	  else if (skip_next)
+	    {
+	      /* Skip this symbol, which is the target of an indirect
+		 symbol that we have changed to no longer be an indirect
+		 symbol.  */
+	      skip_next = false;
+	      continue;
+	    }
+	  else
+	    {
+	      struct aout_link_hash_entry *hresolve = *sym_hash;
+
+	      /* We have saved the hash table entry for this symbol, if
+		 there is one.  Note that we could just look it up again
+		 in the hash table, provided we first check that it is an
+		 external symbol. */
+	      h = *sym_hash;
+
+	      /* Use the name from the hash table, in case the symbol was
+		 wrapped.  */
+	    if (h != NULL
+		&& h->root.type != bfd_link_hash_warning)
+		name = h->root.root.string;
+
+	      /* If this is an indirect or warning symbol, then change
+		 hresolve to the base symbol.  */
+	      hresolve = h;
+	      if (h != (struct aout_link_hash_entry *) NULL
+		  && (h->root.type == bfd_link_hash_indirect
+		      || h->root.type == bfd_link_hash_warning))
+		{
+		  hresolve = (struct aout_link_hash_entry*) h->root.u.i.link;
+		  while (hresolve->root.type == bfd_link_hash_indirect
+			 || hresolve->root.type == bfd_link_hash_warning)
+		    hresolve = ((struct aout_link_hash_entry*)
+				hresolve->root.u.i.link);
+		}
+
+	      /* If the symbol has already been written out skip it.  */
+	      if (h != NULL
+		  && is_written (h))
+		{
+		  if ((type & N_TYPE) == N_INDR
+		      || type == N_WARNING)
+		    skip_next = true;
+		  continue;
+		}
+
+	      /* See if we are stripping this symbol.  */
+	      skip = false;
+
+	      /* Skip all debugger symbols.  No way to output them in
+		 DRI format.  This will also reduce a lot of headaches.  */
+	      if ((type & N_STAB) != 0)
+		skip = true;
+
+	      switch (strip)
+		{
+		case strip_none:
+		case strip_debugger:
+		  break;
+		case strip_some:
+		  if (bfd_hash_lookup (info->keep_hash, name, false, false)
+		      == NULL)
+		    skip = true;
+		  break;
+		case strip_all:
+		  skip = true;
+		  break;
+		}
+
+	      if (skip)
+		{
+		  if (h != NULL)
+		    mark_written (h);
+		  continue;
+		}
+
+	      /* Get the value of the symbol.  */
+	      if ((type & N_TYPE) == N_TEXT
+		  || type == N_WEAKT)
+		symsec = obj_textsec (input_bfd);
+	      else if ((type & N_TYPE) == N_DATA
+		       || type == N_WEAKD)
+		symsec = obj_datasec (input_bfd);
+	      else if ((type & N_TYPE) == N_BSS
+		       || type == N_WEAKB)
+		symsec = obj_bsssec (input_bfd);
+	      else if ((type & N_TYPE) == N_ABS
+		       || type == N_WEAKA)
+		symsec = bfd_abs_section_ptr;
+	      else if (((type & N_TYPE) == N_INDR
+			&& (hresolve == NULL
+			    || (hresolve->root.type != bfd_link_hash_defined
+				&& hresolve->root.type != bfd_link_hash_defweak
+				&& hresolve->root.type != bfd_link_hash_common)))
+		       || type == N_WARNING)
+		{
+		  /* Pass the next symbol through unchanged.  The
+		     condition above for indirect symbols is so that if
+		     the indirect symbol was defined, we output it with
+		     the correct definition so the debugger will
+		     understand it.  */
+		  pass = true;
+		  val = GET_WORD (input_bfd, sym->e_value);
+		  symsec = NULL;
+		}
+	      else
+		{
+		  /* If we get here with an indirect symbol, it means that
+		     we are outputting it with a real definition.  In such
+		     a case we do not want to output the next symbol,
+		     which is the target of the indirection.  */
+		  if ((type & N_TYPE) == N_INDR)
+		    skip_next = true;
+
+		  symsec = NULL;
+
+		  /* We need to get the value from the hash table.  We use
+		     hresolve so that if we have defined an indirect
+		     symbol we output the final definition.  */
+		  if (h == NULL)
+		    {
+		      switch (type & N_TYPE)
+			{
+			case N_SETT:
+			  symsec = obj_textsec (input_bfd);
+			  break;
+			case N_SETD:
+			  symsec = obj_datasec (input_bfd);
+			  break;
+			case N_SETB:
+			  symsec = obj_bsssec (input_bfd);
+			  break;
+			case N_SETA:
+			  symsec = bfd_abs_section_ptr;
+			  break;
+			default:
+			  val = 0;
+			  break;
+			}
+		    }
+		  else if (hresolve->root.type == bfd_link_hash_defined
+			   || hresolve->root.type == bfd_link_hash_defweak)
+		    {
+		      asection *input_section;
+		      asection *output_section;
+
+		      /* This case usually means a common symbol which was
+			 turned into a defined symbol.  */
+		      input_section = hresolve->root.u.def.section;
+		      output_section = input_section->output_section;
+		      BFD_ASSERT (bfd_is_abs_section (output_section)
+				  || output_section->owner == abfd);
+
+		      /* The following reference to the output section VMA
+			 is commented out because DRI symbols are relative
+			 to the beginning of the section.  */
+		      val = (hresolve->root.u.def.value
+			     /*+ bfd_section_vma (output_section)*/
+			     + input_section->output_offset);
+
+		      /* TEXT symbols values must be adjusted
+			 by adding the size of the extended header.  */
+		      if (output_section == obj_textsec (abfd))
+			val += TEXT_START_ADDR;
+
+		      /* Get the correct type based on the section.  If
+			 this is a constructed set, force it to be
+			 globally visible.  */
+		      if (type == N_SETT
+			  || type == N_SETD
+			  || type == N_SETB
+			  || type == N_SETA)
+			type |= N_EXT;
+
+		      type &=~ N_TYPE;
+
+		      if (output_section == obj_textsec (abfd))
+			type |= N_TEXT;
+		      else if (output_section == obj_datasec (abfd))
+			type |= N_DATA;
+		      else if (output_section == obj_bsssec (abfd))
+			type |= N_BSS;
+		      else
+			type |= N_ABS;
+		    }
+		  else if (hresolve->root.type == bfd_link_hash_common)
+		    val = hresolve->root.u.c.size;
+		  else if (hresolve->root.type == bfd_link_hash_undefweak)
+		    {
+		      val = 0;
+		      type = N_UNDF;
+		    }
+		  else
+		    val = 0;
+		}
+	      if (symsec != NULL)
+		{
+		  /* The following reference to the output section VMA
+		     is commented out because DRI symbols are relative
+		     to the beginning of the section.  */
+		  val = (/*symsec->output_section->vma
+			 +*/ symsec->output_offset
+			 + (GET_WORD (input_bfd, sym->e_value)
+			 - symsec->vma));
+
+		  /* TEXT symbols values must be adjusted
+		     by adding the size of the extended header.  */
+		  if (symsec == obj_textsec (input_bfd))
+		    val += TEXT_START_ADDR;
+		}
+
+	      /* If this is a global symbol set the written flag, and if
+		 it is a local symbol see if we should discard it.  */
+	      if (h != NULL)
+		{
+		  mark_written (h);
+		}
+	      else if ((type & N_TYPE) != N_SETT
+		       && (type & N_TYPE) != N_SETD
+		       && (type & N_TYPE) != N_SETB
+		       && (type & N_TYPE) != N_SETA)
+		{
+		  switch (discard)
+		    {
+		    case discard_none:
+		    case discard_sec_merge:
+		      break;
+		    case discard_l:
+		      if (bfd_is_local_label_name (input_bfd, name))
+			skip = true;
+		      break;
+		    default:
+		    case discard_all:
+		      skip = true;
+		      break;
+		    }
+		  if (skip)
+		    {
+		      pass = false;
+		      continue;
+		    }
+		}
+	    }
+
+	  /* Now find the nearest type in DRI format.  */
+	  switch (type)
+	    {
+	    case N_ABS:
+	    case N_ABS | N_EXT:
+	    case N_SETA:
+	    case N_SETA | N_EXT:
+	    case N_WEAKA:
+	      a_type = A_EQU | A_DEF | A_GLOBL;
+	      break;
+	    case N_TEXT:
+	    case N_TEXT | N_EXT:
+	    case N_SETT:
+	    case N_SETT | N_EXT:
+	    case N_WEAKT:
+	      a_type = A_TEXT | A_DEF | A_GLOBL;
+	      break;
+	    case N_DATA:
+	    case N_DATA | N_EXT:
+	    case N_SETD:
+	    case N_SETD | N_EXT:
+	    case N_WEAKD:
+	      a_type = A_DATA | A_DEF | A_GLOBL;
+	      break;
+	    case N_BSS:
+	    case N_BSS | N_EXT:
+	    case N_SETB:
+	    case N_SETB | N_EXT:
+	    case N_WEAKB:
+	      a_type = A_BSS | A_DEF | A_GLOBL;
+	      break;
+	    default:
+	      continue;
+	    }
+
+	  written_bytes = write_dri_symbol (abfd, name, a_type, val);
+	  if (written_bytes < 0)
+	    return false;
+
+	  myinfo->dri_symtab_size += written_bytes;
+	}
+    }
+
+  obj_aout_external_string_size (abfd) = 0;
+  return true;
+}
+
+/* This is used for qsort() to sort addresses
+   for the TPA relocation table.  */
+
+static int
+vma_cmp (const void *v1, const void *v2)
+{
+  return (int) ((*((bfd_vma *) v1)) - (*((bfd_vma *) v2)));
+}
+
+/* Alloc and fill the TPA relocation table.  */
+
+static bool
+fill_tparel (bfd *abfd)
+{
+  struct mint_internal_info *myinfo = obj_aout_ext (abfd);
+  unsigned long i;
+  bfd_size_type bytes;
+  unsigned char *ptr;
+
+  /* Sort the relocation info.  */
+  if (myinfo->relocs != NULL)
+    qsort (myinfo->relocs, myinfo->relocs_used, sizeof (bfd_vma),
+	   vma_cmp);
+
+  /* Now calculate the number of bytes we need.  The relocation info
+     is encoded as follows:  The first entry is a 32-bit value
+     denoting the first offset to relocate.  All following entries
+     are relative to the preceding one.  For relative offsets of
+     more than 254 bytes a value of 1 is used.  The OS will then
+     add 254 bytes to the current offset.  The list is then terminated
+     with the byte 0.  */
+  bytes = 4; /* First entry is a long.  */
+  for (i = 1; i < myinfo->relocs_used; i++)
+    {
+      unsigned long diff = myinfo->relocs[i] - myinfo->relocs[i - 1];
+      BFD_ASSERT(diff > 0);
+      bytes += (diff + 253) / 254;
+    }
+  /* Last entry is (bfd_byte) 0 if there are some relocations.  */
+  if (myinfo->relocs_used > 0)
+    bytes++;
+
+  myinfo->tparel_size = bytes;
+  myinfo->tparel = bfd_alloc (abfd, bytes);
+  if (myinfo->tparel == NULL)
+    return false;
+
+  /* Now fill the array.  */
+  ptr = (bfd_byte*) myinfo->tparel;
+  if (myinfo->relocs != NULL)
+    bfd_put_32 (abfd, myinfo->relocs[0], ptr);
+  else
+    bfd_put_32 (abfd, 0, ptr);
+  ptr += 4;
+
+  for (i = 1; i < myinfo->relocs_used; i++)
+    {
+      unsigned long diff = myinfo->relocs[i] - myinfo->relocs[i - 1];
+      while (diff > 254)
+	{
+	  *ptr++ = 1;
+	  diff -= 254;
+	}
+      *ptr++ = (bfd_byte) diff;
+    }
+
+  if (myinfo->relocs_used > 0)
+    *ptr = 0;
+
+  return true;
+}
+
+/* Final link routine.  We need to use a call back to get the correct
+   offsets in the output file.  And we need to malloc some internal
+   buffers.  */
+
+#define MY_bfd_final_link MY (bfd_final_link)
+
+static bool
+MY (bfd_final_link) (bfd *abfd, struct bfd_link_info *info)
+{
+  struct mint_internal_info *myinfo = obj_aout_ext (abfd);
+  struct bfd_link_hash_table *hash = info->hash;
+  enum bfd_link_strip original_strip = info->strip;
+
+  if (bfd_link_relocatable (info))
+    {
+      _bfd_error_handler ("%pB: relocatable output is not supported by format %s",
+	abfd, bfd_get_target (abfd));
+      bfd_set_error (bfd_error_invalid_operation);
+      return false;
+    }
+
+  myinfo->linkinfo = info;
+
+  /* Make sure that for now we never write zmagics.  */
+  abfd->flags &= ~D_PAGED;
+
+  /* Find the __stksize symbol.  This symbol is used for a MiNT
+     special kludge.  The libc defines this symbol in an object file
+     initialized to a default value to make sure it is defined in
+     every output file.  The start-up code in crtinit() then simply
+     sets the stacksize accordingly.  In your programs (if they need
+     an unusual stacksize) you can then simply code:
+
+	   long _stksize = 0x2000;
+
+     This will create a program stack of 2k.  Since MiNT cannot detect
+     a stack overflow this is the only way to prevent program crashes
+     caused by a stack that is too small.
+
+     The ancient linker ignored this feature, the ancient strip
+     program paid heed to it.  By default, strip never stripped this
+     special symbol from the binary.
+
+     Another program called ``printstk'' and its colleague ``fixstk''
+     could be used to either print the current value of the stacksize
+     or to modify it without recompiling and rebuilding.  These
+     programs traversed the symbol table and then took the appropriate
+     measures if the symbol was found.
+
+     Here we do a different approach.  Since we already expanded the
+     standard executable header we now hardcode the address (as a file
+     offset) that the __stksize symbol points to into the header.  We
+     can now let strip safely remove the entry from the symbol table
+     and we're not dependent on a special format of the symbol table.
+     Because the address is kept in the header we will always be able
+     to manipulate the stacksize value later.  */
+  if (hash != NULL)
+    {
+      struct aout_link_hash_entry *h =
+	aout_link_hash_lookup (aout_hash_table (info), "__stksize",
+			       false, false, false);
+      asection *sec;
+
+      if (h != NULL)
+	{
+	  switch (h->root.type)
+	    {
+	    case bfd_link_hash_defined:
+	    case bfd_link_hash_defweak:
+	      sec = h->root.u.def.section->output_section;
+	      BFD_ASSERT (sec->owner == abfd);
+
+	      myinfo->stkpos = (h->root.u.def.value + sec->vma
+				+ h->root.u.def.section->output_offset
+				+ GEMDOS_HEADER_SIZE);
+	      break;
+	    default:  /* Ignore other types.  */
+	      break;
+	    }
+	}
+    }
+
+  if ((abfd->flags & BFD_TRADITIONAL_FORMAT) != 0)
+    {
+      myinfo->traditional_format = true;
+      myinfo->symbol_format = _MINT_SYMBOL_FORMAT_DRI;
+    }
+
+  /* Unconditionally unset the traditional flag.  The only effect in
+     the a.out code is to disable string hashing (with respect to
+     SunOS gdx).  This is not necessary for us.  */
+
+  abfd->flags &= ~BFD_TRADITIONAL_FORMAT;
+
+  /* Do not write GNU symbols in traditional format.  */
+  if (myinfo->traditional_format)
+    info->strip = strip_all;
+
+  if (NAME(aout,final_link) (abfd, info, MY_final_link_callback)
+      == false)
+    return false;
+
+  if (myinfo->reloc_error)
+    return false;
+
+  /* Restore the strip status for the traditional symbols.  */
+  info->strip = original_strip;
+
+  if (myinfo->traditional_format
+      && link_write_traditional_syms (abfd, info) == false)
+    return false;
+
+  if (fill_tparel (abfd) == false)
+    return false;
+
+  return true;
+}
+
+/* Copy private BFD header information from the input BFD.  */
+
+#define MY_bfd_copy_private_header_data MY (bfd_copy_private_header_data)
+
+static bool
+MY (bfd_copy_private_header_data) (bfd *ibfd, bfd *obfd)
+{
+  (void)obfd; /* Unused.  */
+
+  /* We can only copy BFD files using our own file format.  */
+  if (ibfd->xvec != &MY (vec))
+    {
+      _bfd_error_handler ("%pB: cannot convert from format %s to format %s",
+	ibfd, bfd_get_target (ibfd), bfd_get_target (obfd));
+      bfd_set_error (bfd_error_invalid_operation);
+      return false;
+    }
+
+  return true;
+}
+
+/* Copy backend specific data from one object module to another.
+   This function is used by objcopy and strip.  */
+
+#define MY_bfd_copy_private_bfd_data MY (bfd_copy_private_bfd_data)
+
+static bool
+MY (bfd_copy_private_bfd_data) (bfd *ibfd, bfd *obfd)
+{
+  struct mint_internal_info *myinfo_in;
+  struct mint_internal_info *myinfo_out;
+
+  /* obfd uses our file format, ibfd may be foreign.  */
+  if (ibfd->xvec != &MY (vec))
+    return true;
+
+  myinfo_in = obj_aout_ext (ibfd);
+  BFD_ASSERT (myinfo_in != NULL);
+
+  myinfo_out = obj_aout_ext (obfd);
+  BFD_ASSERT (myinfo_out != NULL);
+
+  /* Copy myinfo.  */
+  memcpy (myinfo_out, myinfo_in, sizeof (*myinfo_out));
+
+  /* Copy tparel.  */
+  myinfo_out->tparel = bfd_alloc (obfd, myinfo_out->tparel_size);
+  if (myinfo_out->tparel == NULL)
+    return false;
+  memcpy (myinfo_out->tparel, myinfo_in->tparel, myinfo_out->tparel_size);
+
+  /* Normalize the type of empty symbols.  */
+  if (bfd_get_symcount (obfd) == 0)
+    myinfo_out->symbol_format = _MINT_SYMBOL_FORMAT_GNU;
+
+  return true; /* _bfd_generic_bfd_copy_private_bfd_data (ibfd, obfd); */
+}
+
+/* Merge private BFD information from an input BFD to the output BFD when linking.  */
+
+#define MY_bfd_merge_private_bfd_data MY (merge_private_bfd_data)
+
+static bool
+MY (merge_private_bfd_data) (bfd *ibfd, struct bfd_link_info *info)
+{
+  (void)info; /* Unused.  */
+
+  /* Our file format cannot be used as linker input.  */
+  if (ibfd->xvec == &MY (vec))
+    {
+      _bfd_error_handler ("%pB: file format %s cannot be used as linker input",
+	ibfd, bfd_get_target (ibfd));
+      bfd_set_error (bfd_error_invalid_operation);
+      return false;
+    }
+
+  return true; /* _bfd_generic_bfd_merge_private_bfd_data (ibfd, info); */
+}
+
+/* Find out the symbol name.  */
+
+static const char *
+find_symbol_name (reloc_howto_type *howto, bfd *input_bfd,
+		  bfd_byte *location, struct reloc_std_external *rel)
+{
+  struct external_nlist *syms = obj_aout_external_syms (input_bfd);
+  char *strings = obj_aout_external_strings (input_bfd);
+  struct aout_link_hash_entry **sym_hashes
+    = obj_aout_sym_hashes (input_bfd);
+  struct aout_link_hash_entry *h = NULL;
+  const char *name;
+  bfd_size_type r_index;
+  int r_extern;
+
+  if (bfd_get_reloc_size (howto) != 4)
+    return "(not a symbol)";
+
+  /* The input bfd is always big-endian.  There is no need to
+     call bfd_header_big_endian (input_bfd).  */
+  r_index  = ((rel->r_index[0] << 16)
+	      | (rel->r_index[1] << 8)
+	      | (rel->r_index[2]));
+  r_extern = (0 != (rel->r_type[0] & RELOC_STD_BITS_EXTERN_BIG));
+
+  if (sym_hashes != NULL)
+    h = sym_hashes[r_index];
+
+  if (!r_extern)
+    {
+      bfd_size_type i;
+      bfd_vma wanted_value = bfd_get_32 (input_bfd, location);
+
+      name = NULL;
+      for (i = 0; i < obj_aout_external_sym_count (input_bfd); i++)
+	{
+	  bfd_vma this_value = bfd_get_32 (input_bfd, syms[i].e_value);
+
+	  if (this_value == wanted_value)
+	    {
+	      bfd_byte symtype = bfd_get_8 (input_bfd, syms[i].e_type);
+
+	      /* Skip debug symbols and the like.  */
+	      if ((symtype & N_STAB) != 0)
+		continue;
+
+	      /* This is dirty but preferable to a plethoria of
+		 single comparisons.  */
+	      if (symtype <= (N_BSS | N_EXT)
+		  || (symtype >= N_WEAKU && symtype <= N_COMM))
+		{
+		  name = strings + GET_WORD (input_bfd, syms[i].e_strx);
+		  break;
+		}
+	    }
+	}
+
+      /* FIXME:  If the relocation is against a section there is
+	 probably a symbol for that section floating around somewhere
+	 in the bfd jungle.  */
+      if (name == NULL)
+	{
+	  switch ((r_index & N_TYPE) & ~N_EXT)
+	    {
+	    case N_TEXT:
+	      name = "text section";
+	      break;
+	    case N_DATA:
+	      name = "data section";
+	      break;
+	    case N_BSS:
+	      name = "bss section";
+	      break;
+	    case N_ABS:
+	      name = "absolute section";
+	      break;
+	    default:
+	      name = "unknown section";
+	      break;
+	    }
+	}
+    }
+  else if (h != NULL)
+    name = h->root.root.string;
+  else if (r_index >= obj_aout_external_sym_count (input_bfd))
+    name = "(unknown symbol)";	/* Shouldn't happen.  */
+  else
+    name = strings + GET_WORD (input_bfd, syms[r_index].e_strx);
+
+  return name;
+}
+
+/* This relocation routine is used by some of the backend linkers.
+   They do not construct asymbol or arelent structures, so there is no
+   reason for them to use bfd_perform_relocation.  Also,
+   bfd_perform_relocation is so hacked up it is easier to write a new
+   function than to try to deal with it.
+
+   This routine does a final relocation.  Whether it is useful for a
+   relocatable link depends upon how the object format defines
+   relocations.
+
+   FIXME: This routine ignores any special_function in the HOWTO,
+   since the existing special_function values have been written for
+   bfd_perform_relocation.
+
+   HOWTO is the reloc howto information.
+   INPUT_BFD is the BFD which the reloc applies to.
+   INPUT_SECTION is the section which the reloc applies to.
+   CONTENTS is the contents of the section.
+   ADDRESS is the address of the reloc within INPUT_SECTION.
+   VALUE is the value of the symbol the reloc refers to.
+   ADDEND is the addend of the reloc.  */
+
+/* The additional parameter REL is specific to this backend.
+   This function is derived from _bfd_final_link_relocate()
+   found in reloc.c. It adds additional checking for dangerous
+   relocations in MiNT sharable text sections, then it records
+   the relocated offset in myinfo->relocs[] for further processing.  */
+
+static bfd_reloc_status_type
+MY (final_link_relocate_rel) (reloc_howto_type *howto,
+			      bfd *input_bfd,
+			      asection *input_section,
+			      bfd_byte *contents,
+			      bfd_vma address,
+			      bfd_vma value,
+			      bfd_vma addend,
+			      struct reloc_std_external *rel)
+{
+  bfd_vma relocation;
+  bfd *output_bfd = input_section->output_section->owner;
+  struct mint_internal_info *myinfo = obj_aout_ext (output_bfd);
+  bfd_reloc_status_type retval;
+  int r_index;
+  int r_extern;
+  bool need_tpa_relocation;
+
+  /* The input bfd is always big-endian.  There is no need to
+     call bfd_header_big_endian (input_bfd).  */
+  r_index  = ((rel->r_index[0] << 16)
+	      | (rel->r_index[1] << 8)
+	      | (rel->r_index[2]));
+  r_extern = (0 != (rel->r_type[0] & RELOC_STD_BITS_EXTERN_BIG));
+
+#define _MINT_F_SHTEXT 0x800
+
+  /* Sanity check the address.  */
+  if (address > bfd_get_section_limit (input_bfd, input_section))
+    return bfd_reloc_outofrange;
+
+  /* This function assumes that we are dealing with a basic relocation
+     against a symbol.  We want to compute the value of the symbol to
+     relocate to.  This is just VALUE, the value of the symbol, plus
+     ADDEND, any addend associated with the reloc.  */
+  relocation = value + addend;
+
+  /* Check for dangerous relocations in images with a sharable
+     text section.  */
+  if ((myinfo->prg_flags & _MINT_F_SHTEXT) != 0
+      && bfd_get_reloc_size (howto) == 4)
+    {
+      bool error_found = false;
+      const char *name = NULL;
+
+      if (input_section == obj_textsec (input_bfd))
+	{
+	  if (!r_extern)
+	    {
+	      /* This is a relocation against another section.  Only
+		 relocations against the text section are allowed.  */
+	      if (r_index != N_TEXT && r_index != (N_TEXT | N_EXT))
+		error_found = true;
+	    }
+	  else if (relocation > (input_section->output_section->vma
+			    + input_section->output_section->size))
+	    {
+	      error_found = true;
+	    }
+	  else if (relocation == (input_section->output_section->vma
+				  + input_section->output_section->size))
+	    {
+	      name = find_symbol_name (howto, input_bfd,
+						    contents + address,
+						    rel);
+	      if (strcmp (name, "_etext") == 0)
+		error_found = false;
+	    }
+	}
+
+      if (error_found)
+	{
+	  const struct bfd_link_callbacks *callbacks
+	    = myinfo->linkinfo->callbacks;
+
+	  myinfo->reloc_error = true;
+
+	  if (callbacks->reloc_dangerous != NULL)
+	    {
+	      if (name == NULL)
+		name = find_symbol_name (howto, input_bfd,
+						      contents + address,
+						      rel);
+
+	      callbacks->reloc_dangerous (myinfo->linkinfo, name,
+					  input_bfd,
+					  input_section, address);
+	    }
+	}
+    }
+
+  /* If the relocation is PC relative, we want to set RELOCATION to
+     the distance between the symbol (currently in RELOCATION) and the
+     location we are relocating.  Some targets (e.g., i386-aout)
+     arrange for the contents of the section to be the negative of the
+     offset of the location within the section; for such targets
+     pcrel_offset is FALSE.  Other targets (e.g., m88kbcs or ELF)
+     simply leave the contents of the section as zero; for such
+     targets pcrel_offset is TRUE.  If pcrel_offset is FALSE we do not
+     need to subtract out the offset of the location within the
+     section (which is just ADDRESS).  */
+  if (howto->pc_relative)
+    {
+      relocation -= (input_section->output_section->vma
+		     + input_section->output_offset);
+      if (howto->pcrel_offset)
+	relocation -= address;
+    }
+
+  retval = _bfd_relocate_contents (howto, input_bfd, relocation,
+				   contents + address);
+
+  /* The symbol has to be relocated again iff the length of the relocation
+     is 2 words and it is not pc relative.  */
+  need_tpa_relocation = false;
+  if (!howto->pc_relative && bfd_get_reloc_size (howto) == 4)
+    {
+      if (r_extern)
+	{
+	  struct aout_link_hash_entry **sym_hashes = obj_aout_sym_hashes (input_bfd);
+	  struct aout_link_hash_entry *h = sym_hashes[r_index];
+	  asection *output_section = h->root.u.def.section->output_section;
+
+	  /* Do not relocate absolute symbols.  */
+	  if (output_section == obj_textsec (output_bfd)
+	      || output_section == obj_datasec (output_bfd)
+	      || output_section == obj_bsssec (output_bfd))
+	    {
+	      need_tpa_relocation = true;
+	    }
+	}
+      else
+	{
+	  need_tpa_relocation = true;
+	}
+    }
+
+  /* Here we add the TPA relocation entries for the address references
+     located inside the input sections. Note that if some references
+     to addresses are generated using data statements in the linker
+     script, they will not be relocated here because they do not
+     belong to any input section.  */
+  if (need_tpa_relocation)
+    {
+      bfd_vma tpa_address = input_section->output_section->vma
+	+ input_section->output_offset + address;
+
+      if (!bfd_m68kmint_add_tpa_relocation_entry(output_bfd, tpa_address))
+	return bfd_reloc_other;
+    }
+
+  return retval;
+}
+
+/* Write out the TPA relocation table.  */
+
+static bool
+write_tparel (bfd *abfd, struct internal_exec *execp)
+{
+  struct mint_internal_info* myinfo = obj_aout_ext (abfd);
+
+  if (myinfo->dri_symtab_size == 0)
+    myinfo->tparel_pos = N_STROFF (execp)
+      + obj_aout_external_string_size (abfd);
+  else
+    myinfo->tparel_pos = N_SYMOFF (execp)
+      + myinfo->dri_symtab_size;
+
+  if (bfd_seek (abfd, myinfo->tparel_pos, SEEK_SET) != 0)
+    return false;
+
+  if (bfd_write (myinfo->tparel, myinfo->tparel_size, abfd)
+      != myinfo->tparel_size)
+    return false;
+
+  return true;
+}
+
+/* Write the full exec header.
+   This function must be called last to ensure that we have all the
+   information needed to fill the MiNT-specific header fields.  */
+
+static bool
+write_exec_header (bfd *abfd, struct internal_exec *execp, struct external_exec *exec_bytes)
+{
+  struct mint_internal_info *myinfo = obj_aout_ext (abfd);
+  bfd_size_type symtab_size;
+
+  bfd_h_put_16 (abfd, 0x601a, exec_bytes->g_branch);
+
+  /* The OS will load our extension header fields into the text segment.  */
+  bfd_h_put_32 (abfd, execp->a_text + (EXEC_BYTES_SIZE - GEMDOS_HEADER_SIZE),
+		exec_bytes->g_text);
+  bfd_h_put_32 (abfd, execp->a_data, exec_bytes->g_data);
+  bfd_h_put_32 (abfd, execp->a_bss, exec_bytes->g_bss);
+
+  /* The OS' notion of the size of the symbol table is another than
+     the bfd library's.  We have to fill in the size of the table
+     itself plus the size of the string table but only if we have not written
+     a traditional symbol table.  If we have written a traditional symbol
+     table we know the size.  */
+  if (myinfo->dri_symtab_size != 0)
+    symtab_size = myinfo->dri_symtab_size;
+  else
+    symtab_size = myinfo->tparel_pos - N_SYMOFF (execp);
+
+  bfd_h_put_32 (abfd, symtab_size, exec_bytes->g_syms);
+
+  bfd_h_put_32 (abfd, 0x4d694e54, exec_bytes->g_extmagic);
+  bfd_h_put_32 (abfd, myinfo->prg_flags, exec_bytes->g_flags);
+  bfd_h_put_16 (abfd, 0, exec_bytes->g_abs);
+
+  /* Generate the jump instruction to the entry point.  In m68k
+     assembler mnemnonics it looks more or less like this:
+
+       move.l  exec_bytes->e_entry(pc),d0
+       jmp     -6(pc,d0.l)
+
+     Sorry for the wrong syntax.  As a real assembler addict I
+     never actually use an assembler.  I edit my binaries manually
+     with a hex editor, looks much cooler and it strengthens your
+     abstraction abilities.  */
+
+  exec_bytes->g_jump_entry[0] = 0x20;
+  exec_bytes->g_jump_entry[1] = 0x3a;
+  exec_bytes->g_jump_entry[2] = 0x00;
+  exec_bytes->g_jump_entry[3] = 0x1a;
+  exec_bytes->g_jump_entry[4] = 0x4e;
+  exec_bytes->g_jump_entry[5] = 0xfb;
+  exec_bytes->g_jump_entry[6] = 0x08;
+  exec_bytes->g_jump_entry[7] = 0xfa;
+
+  bfd_h_put_32 (abfd, myinfo->tparel_pos, exec_bytes->g_tparel_pos);
+  bfd_h_put_32 (abfd, myinfo->tparel_size, exec_bytes->g_tparel_size);
+  bfd_h_put_32 (abfd, myinfo->stkpos, exec_bytes->g_stkpos);
+
+  /* If there are no symbols, pretend they are in GNU format.  */
+  if (symtab_size == 0)
+    myinfo->symbol_format = _MINT_SYMBOL_FORMAT_GNU;
+
+  bfd_h_put_32 (abfd, myinfo->symbol_format, exec_bytes->g_symbol_format);
+
+  memset (&exec_bytes->g_pad0, 0, sizeof (exec_bytes->g_pad0));
+
+  /* The standard stuff.  */
+  NAME(aout, swap_exec_header_out) (abfd, execp, exec_bytes);
+  if (myinfo->symbol_format != _MINT_SYMBOL_FORMAT_GNU)
+    PUT_WORD (abfd, 0, exec_bytes->e_syms);
+
+  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
+    return false;
+
+  if (bfd_write (exec_bytes, (bfd_size_type) EXEC_BYTES_SIZE, abfd)
+      != EXEC_BYTES_SIZE)
+    return false;
+
+  /* Override the stack size.  */
+  if (myinfo->override_stack_size && myinfo->stkpos)
+  {
+    bfd_byte big_endian_stack_size[4];
+
+    bfd_put_32 (abfd, myinfo->stack_size, &big_endian_stack_size);
+
+    if (bfd_seek (abfd, (file_ptr) myinfo->stkpos, SEEK_SET) != 0)
+      return false;
+
+    if (bfd_write (big_endian_stack_size, 4, abfd) != 4)
+      return false;
+  }
+
+  return true;
+}
+
+/* Write an object file.
+   Section contents have already been written.  We write the
+   file header, symbols, and relocation.  */
+
+#define MY_write_object_contents MY (write_object_contents)
+
+static bool
+MY (write_object_contents) (bfd *abfd)
+{
+  struct external_exec exec_bytes;
+  struct internal_exec *execp = exec_hdr (abfd);
+
+  BFD_ASSERT (obj_aout_ext (abfd) != NULL);
+
+  obj_reloc_entry_size (abfd) = RELOC_STD_SIZE;
+
+  /* Most of the following code come from the WRITE_HEADERS macro
+     found in libaout.h.  */
+
+  if (adata(abfd).magic == undecided_magic)
+    NAME (aout, adjust_sizes_and_vmas) (abfd);
+
+  execp->a_syms = bfd_get_symcount (abfd) * EXTERNAL_NLIST_SIZE;
+  execp->a_entry = bfd_get_start_address (abfd);
+
+  execp->a_trsize = ((obj_textsec (abfd)->reloc_count) *
+		     obj_reloc_entry_size (abfd));
+  execp->a_drsize = ((obj_datasec (abfd)->reloc_count) *
+		     obj_reloc_entry_size (abfd));
+
+  /* Now write out reloc info, followed by syms and strings.  */
+
+  if (bfd_get_outsymbols (abfd) != NULL
+      && bfd_get_symcount (abfd) != 0)
+    {
+      if (bfd_seek (abfd, (file_ptr) (N_SYMOFF(execp)), SEEK_SET) != 0)
+	return false;
+
+      if (! NAME (aout, write_syms) (abfd))
+	return false;
+    }
+
+  if (bfd_seek (abfd, (file_ptr) (N_TRELOFF (execp)), SEEK_SET) != 0)
+    return false;
+  if (!NAME (aout, squirt_out_relocs) (abfd, obj_textsec (abfd)))
+    return false;
+
+  if (bfd_seek (abfd, (file_ptr) (N_DRELOFF (execp)), SEEK_SET) != 0)
+    return false;
+  if (!NAME (aout, squirt_out_relocs) (abfd, obj_datasec (abfd)))
+    return false;
+
+  if (write_tparel (abfd, execp) == false)
+    return false;
+
+  if (write_exec_header (abfd, execp, &exec_bytes) == false)
+    return false;
+
+  return true;
+}
+
+/* Print private BFD data. Used by objdump -p.  */
+
+#define MY_bfd_print_private_bfd_data MY (print_private_bfd_data)
+
+static bool
+MY (print_private_bfd_data) (bfd *abfd, void *ptr)
+{
+  FILE *file = (FILE *) ptr;
+  struct mint_internal_info *myinfo = obj_aout_ext (abfd);
+  const char* symbol_format;
+  long stksize = 0;
+
+  fprintf (file, "\n");
+
+  fprintf (file, " GEMDOS flags: 0x%08lx\n", (unsigned long) myinfo->prg_flags);
+  fprintf (file, "Start address: 0x%08lx\n", (unsigned long) bfd_get_start_address (abfd));
+
+  /* Stack size.  */
+  if (myinfo->stkpos != 0)
+    {
+      if (bfd_seek (abfd, myinfo->stkpos, SEEK_SET) != 0
+	  || (bfd_read (&stksize, sizeof(long), abfd) != sizeof(long)))
+	return false;
+
+      stksize = bfd_get_signed_32 (abfd, &stksize);
+    }
+  fprintf (file, "   Stack size: %ld\n", stksize);
+
+  /* Symbol format.  */
+  switch (myinfo->symbol_format)
+    {
+      case _MINT_SYMBOL_FORMAT_GNU: symbol_format = "stabs"; break;
+      case _MINT_SYMBOL_FORMAT_DRI: symbol_format = "DRI";   break;
+      default:			    symbol_format = "?";     break;
+    }
+  fprintf (file, "Symbol format: %s\n", symbol_format);
+
+  return true;
+}
+
+/* Special case for NAME (aout, get_section_contents)
+   It is not declared in libaout.h, neither implemented in aoutx.h.
+   Instead, a macro named aout_32_get_section_contents is defined in libaout.h.
+   So the default value of MY_get_section_contents provided by aout-target.h
+   is not correct, it has to be defined here with the right value.  */
+
+#define MY_get_section_contents aout_32_get_section_contents
+
+/* The following include will define MY (vec)
+   and a default implementation for all the MY_ functions
+   not overriden here.  */
+
+#include "aout-target.h"
+
+/* Set the GEMDOS executable flags.
+   It is called by the linker emulation script.  */
+
+bool
+bfd_m68kmint_set_extended_flags (bfd *abfd, flagword prg_flags)
+{
+  struct mint_internal_info *myinfo;
+
+  BFD_ASSERT(abfd->xvec == &MY (vec));
+  myinfo = obj_aout_ext (abfd);
+  BFD_ASSERT(myinfo != NULL);
+
+  myinfo->prg_flags = prg_flags;
+
+  return true;
+}
+
+/* Override the stack size.
+   It is called by the linker emulation script.  */
+
+bool
+bfd_m68kmint_set_stack_size (bfd *abfd, bfd_signed_vma stack_size)
+{
+  struct mint_internal_info *myinfo;
+
+  BFD_ASSERT(abfd->xvec == &MY (vec));
+  myinfo = obj_aout_ext (abfd);
+  BFD_ASSERT(myinfo != NULL);
+
+  myinfo->stack_size = stack_size;
+  myinfo->override_stack_size = true;
+
+  return true;
+}
+
+/* Add a TPA relocation entry.
+   It is called by BFD when linking the input sections, and by the
+   linker when it generates a reference to an address (in particular,
+   when building the constructors list).  */
+
+bool
+bfd_m68kmint_add_tpa_relocation_entry (bfd *abfd, bfd_vma address)
+{
+  struct mint_internal_info *myinfo;
+
+  BFD_ASSERT(abfd->xvec == &MY (vec));
+  myinfo = obj_aout_ext (abfd);
+  BFD_ASSERT(myinfo != NULL);
+
+  /* Enlarge the buffer if necessary.  */
+  if (myinfo->relocs_used * sizeof (bfd_vma) >= myinfo->relocs_allocated)
+    {
+      bfd_vma *newbuf;
+      myinfo->relocs_allocated += MINT_RELOC_CHUNKSIZE;
+      newbuf = bfd_realloc (myinfo->relocs, myinfo->relocs_allocated);
+      if (newbuf == NULL)
+	return false;
+
+      myinfo->relocs = newbuf;
+    }
+
+  /* The TPA relative relocation actually just adds the address of
+     the text segment (i. e. beginning of the executable in memory)
+     to the addresses at the specified locations.  This allows an
+     executable to be loaded everywhere in the address space without
+     memory management.  */
+  myinfo->relocs[myinfo->relocs_used++] = address;
+
+  return true;
+}
diff --git a/bfd/reloc.c b/bfd/reloc.c
index 7583b7fd552..ae3f6d51563 100644
--- a/bfd/reloc.c
+++ b/bfd/reloc.c
@@ -969,6 +969,18 @@ space consuming.  For each target:
 
   data = (bfd_byte *) data + octets;
   apply_reloc (abfd, data, howto, relocation);
+
+  extern const bfd_target m68k_aout_mintprg_vec;
+  if (flag == bfd_reloc_ok
+      && input_section->output_section->owner->xvec == &m68k_aout_mintprg_vec
+      && !howto->pc_relative && howto->size == 4)
+    {
+      bfd_vma tpa_address = input_section->output_section->vma
+	+ input_section->output_offset + reloc_entry->address;
+	
+      bfd_m68kmint_add_tpa_relocation_entry (input_section->output_section->owner, tpa_address);
+    }
+
   return flag;
 }
 
diff --git a/bfd/stat64.c b/bfd/stat64.c
new file mode 100644
index 00000000000..5e77c91c95e
--- /dev/null
+++ b/bfd/stat64.c
@@ -0,0 +1,106 @@
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+#define _FILE_OFFSET_BITS 64
+
+#define __asm__(x)
+#include <sys/stat.h>
+#undef __asm__
+
+#include "libcwrap.h"
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+#ifdef __LINUX_GLIBC_WRAP_H
+
+#if __GLIBC_PREREQ(2, 33)
+
+#include <stdarg.h>
+#include <fcntl.h>
+
+/*
+ * avoid references to stat/lstat/fstat, which are only available in glibc >= 2.33
+ */
+
+extern int __fxstat(int __ver, int __fildes, struct stat *__stat_buf)
+     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
+extern int __xstat(int __ver, const char *__filename,
+      struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
+extern int __lxstat(int __ver, const char *__filename,
+       struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
+extern int __fxstatat (int __ver, int __fildes, const char *__filename,
+         struct stat *__stat_buf, int __flag)
+     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));
+#ifdef __USE_LARGEFILE64
+extern int __xstat64(int __ver, const char *__filename,
+      struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
+extern int __lxstat64(int __ver, const char *__filename,
+       struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
+extern int __fxstat64(int __ver, int __fildes, struct stat64 *__stat_buf)
+     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
+#endif
+
+__attribute__((__nothrow__))
+int stat(const char *__path, struct stat *__statbuf)
+{
+	return __xstat(1, __path, __statbuf);
+}
+
+__attribute__((__nothrow__)) 
+int lstat (const char *__path, struct stat *__statbuf)
+{
+	return __lxstat(1, __path, __statbuf);
+}
+
+__attribute__((__nothrow__)) 
+int fstat(int __fd, struct stat *__statbuf)
+{
+	return __fxstat(1, __fd, __statbuf);
+}
+
+__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)))
+int stat64(const char *__restrict __path, struct stat64 *__restrict __statbuf)
+{
+	return __xstat64(1, __path, __statbuf);
+}
+
+__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)))
+int lstat64 (const char *__restrict __path, struct stat64 *__restrict __statbuf)
+{
+	return __lxstat64(1, __path, __statbuf);
+}
+
+__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)))
+int fstat64(int __fd, struct stat64 *__statbuf)
+{
+	return __fxstat64(1, __fd, __statbuf);
+}
+
+__attribute__((__nothrow__)) 
+int fstatat(int __fd, const char *__restrict __filename, struct stat *__restrict __statbuf, int __flag)
+{
+	return __fxstatat(1, __fd, __filename, __statbuf, __flag);
+}
+
+#undef fcntl
+int fcntl64(int fd, int cmd, ...)
+{
+  va_list ap;
+  void *arg;
+
+  va_start (ap, cmd);
+  arg = va_arg (ap, void *);
+  va_end (ap);
+
+  return fcntl(fd, cmd, arg);
+}
+
+#endif /* __GLIBC_PREREQ */
+
+#endif /* __linux__ */
+
+#if defined (__cplusplus)
+}
+#endif
diff --git a/bfd/targets.c b/bfd/targets.c
index 3addf2fe373..99ff364247f 100644
--- a/bfd/targets.c
+++ b/bfd/targets.c
@@ -692,6 +692,7 @@ extern const bfd_target alpha_vms_vec;
 extern const bfd_target alpha_vms_lib_txt_vec;
 extern const bfd_target am33_elf32_linux_vec;
 extern const bfd_target amdgcn_elf64_le_vec;
+extern const bfd_target aout0_be_vec;
 extern const bfd_target aout_vec;
 extern const bfd_target arc_elf32_be_vec;
 extern const bfd_target arc_elf32_le_vec;
@@ -784,6 +785,8 @@ extern const bfd_target m32r_elf32_linux_le_vec;
 extern const bfd_target m68hc11_elf32_vec;
 extern const bfd_target m68hc12_elf32_vec;
 extern const bfd_target m68k_elf32_vec;
+extern const bfd_target m68k_elf32_atariprg_vec;
+extern const bfd_target m68k_aout_mintprg_vec;
 extern const bfd_target s12z_elf32_vec;
 extern const bfd_target mach_o_be_vec;
 extern const bfd_target mach_o_le_vec;
@@ -1016,6 +1019,7 @@ static const bfd_target * const _bfd_target_vector[] =
 
 	&am33_elf32_linux_vec,
 
+	&aout0_be_vec,
 #if 0
 	/* Since a.out files lack decent magic numbers, no way to recognize
 	   which kind of a.out file it is.  */
@@ -1149,6 +1153,8 @@ static const bfd_target * const _bfd_target_vector[] =
 	&m68hc12_elf32_vec,
 
 	&m68k_elf32_vec,
+	&m68k_elf32_atariprg_vec,
+	&m68k_aout_mintprg_vec,
 
 	&s12z_elf32_vec,
 
diff --git a/binutils/Makefile.am b/binutils/Makefile.am
index ad571b60546..4d6bcabc06c 100644
--- a/binutils/Makefile.am
+++ b/binutils/Makefile.am
@@ -35,7 +35,7 @@ EXEEXT_FOR_BUILD = @EXEEXT_FOR_BUILD@
 YACC = `if [ -f ../bison/bison ]; then echo ../bison/bison -y -L$(srcdir)/../bison/; else echo @YACC@; fi`
 YFLAGS = -d
 LEX = `if [ -f ../flex/flex ]; then echo ../flex/flex; else echo @LEX@; fi`
-LEXLIB = @LEXLIB@
+#LEXLIB = @LEXLIB@
 
 # Automake 1.10+ disables lex and yacc output file regeneration if
 # maintainer mode is disabled.  Avoid this.
@@ -251,7 +251,7 @@ dllwrap_DEPENDENCIES =   $(LIBINTL_DEP) $(LIBIBERTY)
 bfdtest1_DEPENDENCIES =  $(LIBINTL_DEP) $(LIBIBERTY) $(BFDLIB)
 bfdtest2_DEPENDENCIES =  $(LIBINTL_DEP) $(LIBIBERTY) $(BFDLIB)
 
-LDADD = $(BFDLIB) $(LIBIBERTY) $(LIBINTL)
+LDADD = $(BFDLIB) $(LIBIBERTY) $(LIBINTL) $(GLIBC_SO)
 
 size_SOURCES = size.c $(BULIBS)
 
@@ -260,10 +260,10 @@ objcopy_SOURCES = objcopy.c not-strip.c rename.c $(WRITE_DEBUG_SRCS) $(BULIBS)
 strings_SOURCES = strings.c $(BULIBS)
 
 readelf_SOURCES = readelf.c version.c unwind-ia64.c dwarf.c demanguse.c $(ELFLIBS)
-readelf_LDADD   = $(LIBCTF_NOBFD) $(LIBINTL) $(LIBIBERTY) $(ZLIB) $(ZSTD_LIBS) $(DEBUGINFOD_LIBS) $(MSGPACK_LIBS) $(LIBSFRAME)
+readelf_LDADD   = ../bfd/stat64.o $(LIBCTF_NOBFD) $(LIBINTL) $(LIBIBERTY) $(ZLIB) $(ZSTD_LIBS) $(DEBUGINFOD_LIBS) $(MSGPACK_LIBS) $(LIBSFRAME) $(GLIBC_SO)
 
 elfedit_SOURCES = elfedit.c version.c $(ELFLIBS)
-elfedit_LDADD = $(LIBINTL) $(LIBIBERTY)
+elfedit_LDADD = ../bfd/stat64.o $(LIBINTL) $(LIBIBERTY) $(GLIBC_SO)
 
 strip_new_SOURCES = objcopy.c is-strip.c rename.c $(WRITE_DEBUG_SRCS) $(BULIBS)
 
@@ -271,7 +271,7 @@ nm_new_SOURCES = nm.c demanguse.c $(BULIBS)
 
 objdump_SOURCES = objdump.c dwarf.c prdbg.c demanguse.c $(DEBUG_SRCS) $(BULIBS) $(ELFLIBS)
 EXTRA_objdump_SOURCES = od-elf32_avr.c od-macho.c od-xcoff.c od-pe.c
-objdump_LDADD = $(OBJDUMP_PRIVATE_OFILES) $(OPCODES) $(LIBCTF) $(BFDLIB) $(LIBIBERTY) $(LIBINTL) $(DEBUGINFOD_LIBS) $(LIBSFRAME)
+objdump_LDADD = $(OBJDUMP_PRIVATE_OFILES) $(OPCODES) $(LIBCTF) $(BFDLIB) $(LIBIBERTY) $(LIBINTL) $(DEBUGINFOD_LIBS) $(LIBSFRAME) $(GLIBC_SO)
 
 objdump.@OBJEXT@:objdump.c
 if am__fastdepCC
@@ -290,11 +290,11 @@ cxxfilt_SOURCES = cxxfilt.c $(BULIBS)
 ar_SOURCES = arparse.y arlex.l ar.c not-ranlib.c arsup.c rename.c binemul.c \
 	emul_$(EMULATION).c $(BULIBS)
 EXTRA_ar_SOURCES = $(CFILES)
-ar_LDADD = $(BFDLIB) $(LIBIBERTY) $(LEXLIB) $(LIBINTL)
+ar_LDADD = $(BFDLIB) $(LIBIBERTY) $(LEXLIB) $(LIBINTL) $(GLIBC_SO)
 
 ranlib_SOURCES = ar.c is-ranlib.c arparse.y arlex.l arsup.c rename.c \
 	binemul.c emul_$(EMULATION).c $(BULIBS)
-ranlib_LDADD = $(BFDLIB) $(LIBIBERTY) $(LEXLIB) $(LIBINTL)
+ranlib_LDADD = $(BFDLIB) $(LIBIBERTY) $(LEXLIB) $(LIBINTL) $(GLIBC_SO)
 
 addr2line_SOURCES = addr2line.c $(BULIBS)
 
@@ -485,7 +485,7 @@ srconv_SOURCES = srconv.c coffgrok.c $(BULIBS)
 srconv.@OBJEXT@: sysroff.c
 
 dlltool_SOURCES = dlltool.c defparse.y deflex.l $(BULIBS)
-dlltool_LDADD = $(BFDLIB) $(LIBIBERTY) $(LEXLIB) $(LIBINTL)
+dlltool_LDADD = $(BFDLIB) $(LIBIBERTY) $(LEXLIB) $(LIBINTL) $(GLIBC_SO)
 
 dlltool.@OBJEXT@:
 if am__fastdepCC
@@ -518,14 +518,14 @@ sysdump.@OBJEXT@: sysroff.c
 
 windres_SOURCES = windres.c resrc.c rescoff.c resbin.c rcparse.y rclex.c \
 	winduni.c resres.c $(BULIBS)
-windres_LDADD = $(BFDLIB) $(LIBIBERTY) $(LEXLIB) $(LIBINTL) $(LIBICONV)
+windres_LDADD = $(BFDLIB) $(LIBIBERTY) $(LEXLIB) $(LIBINTL) $(LIBICONV) $(GLIBC_SO)
 
 windmc_SOURCES = windmc.c mcparse.y mclex.c \
 	winduni.c $(BULIBS)
-windmc_LDADD = $(BFDLIB) $(LIBIBERTY) $(LEXLIB) $(LIBINTL) $(LIBICONV)
+windmc_LDADD = $(BFDLIB) $(LIBIBERTY) $(LEXLIB) $(LIBINTL) $(LIBICONV) $(GLIBC_SO)
 
 dllwrap_SOURCES = dllwrap.c version.c
-dllwrap_LDADD = $(LIBIBERTY) $(LIBINTL)
+dllwrap_LDADD = $(LIBIBERTY) $(LIBINTL) $(GLIBC_SO)
 
 
 EXTRA_DIST = arparse.c arparse.h arlex.c sysinfo.c sysinfo.h \
diff --git a/binutils/Makefile.in b/binutils/Makefile.in
index 842a6d99b54..5c2282867b2 100644
--- a/binutils/Makefile.in
+++ b/binutils/Makefile.in
@@ -231,7 +231,7 @@ dlltool_OBJECTS = $(am_dlltool_OBJECTS)
 am_dllwrap_OBJECTS = dllwrap.$(OBJEXT) version.$(OBJEXT)
 dllwrap_OBJECTS = $(am_dllwrap_OBJECTS)
 am__objects_2 = elfcomm.$(OBJEXT)
-am_elfedit_OBJECTS = elfedit.$(OBJEXT) version.$(OBJEXT) \
+am_elfedit_OBJECTS = ../bfd/stat64.o elfedit.$(OBJEXT) version.$(OBJEXT) \
 	$(am__objects_2)
 elfedit_OBJECTS = $(am_elfedit_OBJECTS)
 am_nm_new_OBJECTS = nm.$(OBJEXT) demanguse.$(OBJEXT) $(am__objects_1)
@@ -524,7 +524,7 @@ LARGEFILE_CPPFLAGS = @LARGEFILE_CPPFLAGS@
 LD = @LD@
 LDFLAGS = @LDFLAGS@
 LEX = `if [ -f ../flex/flex ]; then echo ../flex/flex; else echo @LEX@; fi`
-LEXLIB = @LEXLIB@
+#LEXLIB = @LEXLIB@
 LEX_OUTPUT_ROOT = @LEX_OUTPUT_ROOT@
 LIBICONV = @LIBICONV@
 LIBINTL = @LIBINTL@
@@ -791,45 +791,45 @@ elfedit_DEPENDENCIES = $(LIBINTL_DEP) $(LIBIBERTY)
 dllwrap_DEPENDENCIES = $(LIBINTL_DEP) $(LIBIBERTY)
 bfdtest1_DEPENDENCIES = $(LIBINTL_DEP) $(LIBIBERTY) $(BFDLIB)
 bfdtest2_DEPENDENCIES = $(LIBINTL_DEP) $(LIBIBERTY) $(BFDLIB)
-LDADD = $(BFDLIB) $(LIBIBERTY) $(LIBINTL)
+LDADD = $(BFDLIB) $(LIBIBERTY) $(LIBINTL) $(GLIBC_SO)
 size_SOURCES = size.c $(BULIBS)
 objcopy_SOURCES = objcopy.c not-strip.c rename.c $(WRITE_DEBUG_SRCS) $(BULIBS)
 strings_SOURCES = strings.c $(BULIBS)
 readelf_SOURCES = readelf.c version.c unwind-ia64.c dwarf.c demanguse.c $(ELFLIBS)
-readelf_LDADD = $(LIBCTF_NOBFD) $(LIBINTL) $(LIBIBERTY) $(ZLIB) $(ZSTD_LIBS) $(DEBUGINFOD_LIBS) $(MSGPACK_LIBS) $(LIBSFRAME)
+readelf_LDADD = $(LIBCTF_NOBFD) $(LIBINTL) $(LIBIBERTY) $(ZLIB) $(ZSTD_LIBS) $(DEBUGINFOD_LIBS) $(MSGPACK_LIBS) $(LIBSFRAME) $(GLIBC_SO)
 elfedit_SOURCES = elfedit.c version.c $(ELFLIBS)
-elfedit_LDADD = $(LIBINTL) $(LIBIBERTY)
+elfedit_LDADD = $(LIBINTL) $(LIBIBERTY) $(GLIBC_SO)
 strip_new_SOURCES = objcopy.c is-strip.c rename.c $(WRITE_DEBUG_SRCS) $(BULIBS)
 nm_new_SOURCES = nm.c demanguse.c $(BULIBS)
 objdump_SOURCES = objdump.c dwarf.c prdbg.c demanguse.c $(DEBUG_SRCS) $(BULIBS) $(ELFLIBS)
 EXTRA_objdump_SOURCES = od-elf32_avr.c od-macho.c od-xcoff.c od-pe.c
-objdump_LDADD = $(OBJDUMP_PRIVATE_OFILES) $(OPCODES) $(LIBCTF) $(BFDLIB) $(LIBIBERTY) $(LIBINTL) $(DEBUGINFOD_LIBS) $(LIBSFRAME)
+objdump_LDADD = $(OBJDUMP_PRIVATE_OFILES) $(OPCODES) $(LIBCTF) $(BFDLIB) $(LIBIBERTY) $(LIBINTL) $(DEBUGINFOD_LIBS) $(LIBSFRAME) $(GLIBC_SO)
 cxxfilt_SOURCES = cxxfilt.c $(BULIBS)
 ar_SOURCES = arparse.y arlex.l ar.c not-ranlib.c arsup.c rename.c binemul.c \
 	emul_$(EMULATION).c $(BULIBS)
 
 EXTRA_ar_SOURCES = $(CFILES)
-ar_LDADD = $(BFDLIB) $(LIBIBERTY) $(LEXLIB) $(LIBINTL)
+ar_LDADD = $(BFDLIB) $(LIBIBERTY) $(LEXLIB) $(LIBINTL) $(GLIBC_SO)
 ranlib_SOURCES = ar.c is-ranlib.c arparse.y arlex.l arsup.c rename.c \
 	binemul.c emul_$(EMULATION).c $(BULIBS)
 
-ranlib_LDADD = $(BFDLIB) $(LIBIBERTY) $(LEXLIB) $(LIBINTL)
+ranlib_LDADD = $(BFDLIB) $(LIBIBERTY) $(LEXLIB) $(LIBINTL) $(GLIBC_SO)
 addr2line_SOURCES = addr2line.c $(BULIBS)
 srconv_SOURCES = srconv.c coffgrok.c $(BULIBS)
 dlltool_SOURCES = dlltool.c defparse.y deflex.l $(BULIBS)
-dlltool_LDADD = $(BFDLIB) $(LIBIBERTY) $(LEXLIB) $(LIBINTL)
+dlltool_LDADD = $(BFDLIB) $(LIBIBERTY) $(LEXLIB) $(LIBINTL) $(GLIBC_SO)
 coffdump_SOURCES = coffdump.c coffgrok.c $(BULIBS)
 sysdump_SOURCES = sysdump.c $(BULIBS)
 windres_SOURCES = windres.c resrc.c rescoff.c resbin.c rcparse.y rclex.c \
 	winduni.c resres.c $(BULIBS)
 
-windres_LDADD = $(BFDLIB) $(LIBIBERTY) $(LEXLIB) $(LIBINTL) $(LIBICONV)
+windres_LDADD = $(BFDLIB) $(LIBIBERTY) $(LEXLIB) $(LIBINTL) $(LIBICONV) $(GLIBC_SO)
 windmc_SOURCES = windmc.c mcparse.y mclex.c \
 	winduni.c $(BULIBS)
 
-windmc_LDADD = $(BFDLIB) $(LIBIBERTY) $(LEXLIB) $(LIBINTL) $(LIBICONV)
+windmc_LDADD = $(BFDLIB) $(LIBIBERTY) $(LEXLIB) $(LIBINTL) $(LIBICONV) $(GLIBC_SO)
 dllwrap_SOURCES = dllwrap.c version.c
-dllwrap_LDADD = $(LIBIBERTY) $(LIBINTL)
+dllwrap_LDADD = $(LIBIBERTY) $(LIBINTL) $(GLIBC_SO)
 EXTRA_DIST = arparse.c arparse.h arlex.c sysinfo.c sysinfo.h \
 	syslex.c deflex.c defparse.h defparse.c rcparse.h rcparse.c \
 	mcparse.h mcparse.c embedspu.sh
diff --git a/binutils/addr2line.c b/binutils/addr2line.c
index b793980d825..1a3ef88df84 100644
--- a/binutils/addr2line.c
+++ b/binutils/addr2line.c
@@ -489,6 +489,8 @@ process_file (const char *file_name, const char *section_name,
   return 0;
 }
 
+#include "libcmain.h"
+
 int
 main (int argc, char **argv)
 {
diff --git a/binutils/ar.c b/binutils/ar.c
index e1f1e965f5c..c90558bc1d2 100644
--- a/binutils/ar.c
+++ b/binutils/ar.c
@@ -588,6 +588,7 @@ decode_options (int argc, char **argv)
           break;
         case 'T':
           make_thin_archive = true;
+          make_thin_archive = false;
           break;
         case 'D':
           deterministic = true;
@@ -706,6 +707,8 @@ ranlib_main (int argc, char **argv)
   xexit (status);
 }
 
+#include "libcmain.h"
+
 int main (int, char **);
 
 int
diff --git a/binutils/bucomm.c b/binutils/bucomm.c
index d51d1349f12..e005e0aad8c 100644
--- a/binutils/bucomm.c
+++ b/binutils/bucomm.c
@@ -620,6 +620,15 @@ get_file_size (const char * file_name)
   if (file_name == NULL)
     return (off_t) -1;
 
+  int f, t;
+  t = -1;
+  f = open (file_name, O_RDONLY | O_BINARY);
+  if (f != 0)
+    {
+      t = isatty (f);
+      close (f);
+    }
+
   if (stat (file_name, &statbuf) < 0)
     {
       if (errno == ENOENT)
@@ -630,8 +639,15 @@ get_file_size (const char * file_name)
     }
   else if (S_ISDIR (statbuf.st_mode))
     non_fatal (_("Warning: '%s' is a directory"), file_name);
-  else if (! S_ISREG (statbuf.st_mode))
-    non_fatal (_("Warning: '%s' is not an ordinary file"), file_name);
+  else if (! S_ISREG (statbuf.st_mode) || t > 0)
+    {
+#ifdef _WIN32
+      /* libtool passes /dev/null and checks for /dev/null in the output */
+      if (stricmp (file_name, "nul") == 0)
+        file_name = "/dev/null";
+#endif
+      non_fatal (_("Warning: '%s' is not an ordinary file"), file_name);
+    }
   else if (statbuf.st_size < 0)
     non_fatal (_("Warning: '%s' has negative size, probably it is too large"),
                file_name);
diff --git a/binutils/config.in b/binutils/config.in
index ee148c756f4..7d497b946ff 100644
--- a/binutils/config.in
+++ b/binutils/config.in
@@ -295,3 +295,5 @@
 
 /* Define to 1 if you need to in order for `stat' and other things to work. */
 #undef _POSIX_SOURCE
+
+#include "libcwrap.h"
diff --git a/binutils/configure b/binutils/configure
index a1092735311..e1342407aad 100755
--- a/binutils/configure
+++ b/binutils/configure
@@ -15901,7 +15901,7 @@ fi
 
 
 case "${host}" in
-*-*-msdos* | *-*-go32* | *-*-mingw32* | *-*-cygwin* | *-*-windows*)
+*-*-msdos* | *-*-go32* | *-*-mingw* | *-*-cygwin* | *-*-windows* | *-*-mint*)
 
 $as_echo "#define USE_BINARY_FOPEN 1" >>confdefs.h
  ;;
diff --git a/binutils/cxxfilt.c b/binutils/cxxfilt.c
index a9fa82b9b93..43ce22dab97 100644
--- a/binutils/cxxfilt.c
+++ b/binutils/cxxfilt.c
@@ -135,6 +135,8 @@ standard_symbol_characters (void)
   return "_$.";
 }
 
+#include "libcmain.h"
+
 extern int main (int, char **);
 
 int
diff --git a/binutils/dlltool.c b/binutils/dlltool.c
index 066c99a4d4f..788bae3495f 100644
--- a/binutils/dlltool.c
+++ b/binutils/dlltool.c
@@ -4256,7 +4256,7 @@ deduce_name (const char *prog_name)
       if (*cp == '-')
 	dash = cp;
       if (
-#if defined(__DJGPP__) || defined (__CYGWIN__) || defined(__WIN32__)
+#if defined(__DJGPP__) || defined (__CYGWIN__) || defined(__WIN32__) || defined(__MINT__)
 	  *cp == ':' || *cp == '\\' ||
 #endif
 	  *cp == '/')
diff --git a/binutils/dllwrap.c b/binutils/dllwrap.c
index bf119cee5d6..02f09eef0df 100644
--- a/binutils/dllwrap.c
+++ b/binutils/dllwrap.c
@@ -256,7 +256,7 @@ deduce_name (const char * name)
 	dash = cp;
 
       if (
-#if defined(__DJGPP__) || defined (__CYGWIN__) || defined(__WIN32__)
+#if defined(__DJGPP__) || defined (__CYGWIN__) || defined(__WIN32__) || defined(__MINT__)
 	  *cp == ':' || *cp == '\\' ||
 #endif
 	  *cp == '/')
diff --git a/binutils/elfedit.c b/binutils/elfedit.c
index 76316365b57..4593a0fb0dc 100644
--- a/binutils/elfedit.c
+++ b/binutils/elfedit.c
@@ -43,6 +43,7 @@
 #include "libiberty.h"
 #include "safe-ctype.h"
 #include "filenames.h"
+#include "elf32-atariprg.h"
 
 char * program_name = "elfedit";
 static long archive_file_offset;
@@ -725,6 +726,14 @@ static int
 check_file (const char *file_name, struct stat *statbuf_p)
 {
   struct stat statbuf;
+  int f, t;
+  t = -1;
+  f = open (file_name, O_RDONLY | O_BINARY);
+  if (f != 0)
+    {
+      t = isatty (f);
+      close (f);
+    }
 
   if (statbuf_p == NULL)
     statbuf_p = &statbuf;
@@ -753,8 +762,13 @@ check_file (const char *file_name, struct stat *statbuf_p)
     }
 #endif
 
-  if (! S_ISREG (statbuf_p->st_mode))
+  if (! S_ISREG (statbuf_p->st_mode) || t > 0)
     {
+#ifdef _WIN32
+      /* libtool passes /dev/null and checks for /dev/null in the output */
+      if (stricmp (file_name, "nul") == 0)
+        file_name = "/dev/null";
+#endif
       error (_("'%s' is not an ordinary file\n"), file_name);
       return 1;
     }
@@ -762,6 +776,18 @@ check_file (const char *file_name, struct stat *statbuf_p)
   return 0;
 }
 
+static bool
+atariprg_get_extra_header_info (FILE *file, size_t *sizeof_extra_headerp)
+{
+  unsigned char rest_of_header[sizeof(PRG_HEADER)];
+  
+  if (fread (&rest_of_header[SARMAG], sizeof(PRG_HEADER) - SARMAG, 1, file) != 1)
+    return false;
+  /* Size of extra header before ELF header in segment.  */
+  *sizeof_extra_headerp = rest_of_header[21];
+  return true;
+}
+
 static int
 process_file (const char *file_name)
 {
@@ -793,7 +819,22 @@ process_file (const char *file_name)
     ret = process_archive (file_name, file, true);
   else
     {
-      rewind (file);
+      if (armag[0] == 0x60 && armag[1] == 0x1a)
+	{
+	  /* This is a PRG/ELF executable with extra header.  */
+	  size_t sizeof_extra_header;
+	  
+	  if (atariprg_get_extra_header_info(file, &sizeof_extra_header) == false ||
+	    fseek(file, sizeof_extra_header, SEEK_SET) != 0)
+	  {
+	  	fclose(file);
+	    return 1;
+	  }
+	}
+      else
+	{
+	  rewind (file);
+	}
       archive_file_size = archive_file_offset = 0;
       ret = process_object (file_name, file);
 #ifdef HAVE_MMAP
@@ -867,6 +908,10 @@ elf_machine (const char *mach)
     return EM_X86_64;
   if (strcasecmp (mach, "x86-64") == 0)
     return EM_X86_64;
+  if (strcasecmp (mach, "m68k") == 0)
+    return EM_68K;
+  if (strcasecmp (mach, "coldfire") == 0)
+    return EM_COLDFIRE;
   if (strcasecmp (mach, "none") == 0)
     return EM_NONE;
 
@@ -945,9 +990,9 @@ usage (FILE *stream, int exit_status)
   fprintf (stream, _(" Update the ELF header of ELF files\n"));
   fprintf (stream, _(" The options are:\n"));
   fprintf (stream, _("\
-  --input-mach [none|i386|iamcu|l1om|k1om|x86_64]\n\
+  --input-mach [none|i386|iamcu|l1om|k1om|x86_64|m68k|coldfire]\n\
                               Set input machine type\n\
-  --output-mach [none|i386|iamcu|l1om|k1om|x86_64]\n\
+  --output-mach [none|i386|iamcu|l1om|k1om|x86_64|m68k|coldfire]\n\
                               Set output machine type\n\
   --input-type [none|rel|exec|dyn]\n\
                               Set input file type\n\
@@ -978,6 +1023,8 @@ usage (FILE *stream, int exit_status)
   exit (exit_status);
 }
 
+#include "libcmain.h"
+
 int
 main (int argc, char ** argv)
 {
diff --git a/binutils/nm.c b/binutils/nm.c
index a8e915bc0b4..a325e04695e 100644
--- a/binutils/nm.c
+++ b/binutils/nm.c
@@ -1960,6 +1960,8 @@ just_print_symbol_name (struct extended_symbol_info *info, bfd *abfd)
   print_symname ("%s", info, NULL, abfd);
 }
 
+#include "libcmain.h"
+
 int
 main (int argc, char **argv)
 {
diff --git a/binutils/objcopy.c b/binutils/objcopy.c
index a85d26203e9..1b0d7b3dde7 100644
--- a/binutils/objcopy.c
+++ b/binutils/objcopy.c
@@ -304,6 +304,9 @@ enum long_section_name_handling
    This is also the only behaviour for 'strip'.  */
 static enum long_section_name_handling long_section_names = KEEP;
 
+/* If input_target is elf32-atariprg, force output_target to elf32-m68k.  */
+static bool force_elf_output = false;
+
 /* 150 isn't special; it's just an arbitrary non-ASCII char value.  */
 enum command_line_switch
 {
@@ -1728,6 +1731,9 @@ filter_symbols (bfd *abfd, bfd *obfd, asymbol **osyms,
       if (keep && is_strip_section (abfd, bfd_asymbol_section (sym)))
 	keep = false;
 
+      if (strip_symbols != STRIP_ALL && (flags & BSF_CONSTRUCTOR))
+         keep = true;
+
       if (keep)
 	{
 	  if (((flags & (BSF_GLOBAL | BSF_GNU_UNIQUE))
@@ -3963,6 +3969,9 @@ copy_file (const char *input_filename, const char *output_filename, int ofd,
       if (output_target == NULL)
 	output_target = bfd_get_target (ibfd);
 
+      if (force_elf_output && strcmp (output_target, "elf32-atariprg") == 0)
+	output_target = "elf32-m68k";
+
       if (ofd >= 0)
 	obfd = bfd_fdopenw (output_filename, output_target, ofd);
       else
@@ -4879,6 +4888,7 @@ strip_main (int argc, char *argv[])
 	  break;
 	case OPTION_ONLY_KEEP_DEBUG:
 	  strip_symbols = STRIP_NONDEBUG;
+	  force_elf_output = true;
 	  break;
 	case OPTION_KEEP_FILE_SYMBOLS:
 	  keep_file_symbols = 1;
@@ -5282,6 +5292,7 @@ copy_main (int argc, char *argv[])
 	case 'j':
 	  find_section_list (optarg, true, SECTION_CONTEXT_COPY);
 	  sections_copied = true;
+	  force_elf_output = true;
 	  break;
 
 	case 'R':
@@ -5318,6 +5329,7 @@ copy_main (int argc, char *argv[])
 
 	case OPTION_ONLY_KEEP_DEBUG:
 	  strip_symbols = STRIP_NONDEBUG;
+	  force_elf_output = true;
 	  break;
 
 	case OPTION_KEEP_FILE_SYMBOLS:
@@ -6125,6 +6137,8 @@ copy_main (int argc, char *argv[])
   return 0;
 }
 
+#include "libcmain.h"
+
 int
 main (int argc, char *argv[])
 {
diff --git a/binutils/objdump.c b/binutils/objdump.c
index 49e944b1dfd..775ed2725f6 100644
--- a/binutils/objdump.c
+++ b/binutils/objdump.c
@@ -5881,6 +5881,8 @@ display_file (char *filename, char *target, bool last_file)
     bfd_close_all_done (file);
 }
 
+#include "libcmain.h"
+
 int
 main (int argc, char **argv)
 {
diff --git a/binutils/od-pe.c b/binutils/od-pe.c
index 5d2b7767477..9cb299a070b 100644
--- a/binutils/od-pe.c
+++ b/binutils/od-pe.c
@@ -411,7 +411,7 @@ dump_pe_file_header (bfd *                            abfd,
       PEPAOUTHDR xhdr;
 
       printf (_("\n  Optional 64-bit AOUT Header (at offset %#lx):\n"),
-	      ihdr_off + sizeof (* ihdr));
+	      ihdr_off + (unsigned long) sizeof (* ihdr));
 
       // Fortunately, it appears that the size and layout of the
       // PEPAOUTHDR header is consistent across all architectures.
@@ -440,7 +440,7 @@ dump_pe_file_header (bfd *                            abfd,
 	  /* There is no data_start field in the PE+ standard header.  */
 
 	  printf (_("\n  Optional PE+ Header (at offset %#lx):\n"),
-		  ihdr_off + sizeof (* ihdr) + sizeof (xhdr.standard));
+		  ihdr_off + (unsigned long) sizeof (* ihdr) + (unsigned long) sizeof (xhdr.standard));
 
 	  printf (_("Image Base:\t\t\t%#lx\n"),
 		  (long) bfd_h_get_32 (abfd, xhdr.ImageBase));
diff --git a/binutils/readelf.c b/binutils/readelf.c
index 5e4ad6ea6ad..12c90a98e1b 100644
--- a/binutils/readelf.c
+++ b/binutils/readelf.c
@@ -69,6 +69,7 @@
 #include "elf/common.h"
 #include "elf/external.h"
 #include "elf/internal.h"
+#include "elf32-atariprg.h"
 
 
 /* Included here, before RELOC_MACROS_GEN_FUNC is defined, so that
@@ -7635,6 +7636,8 @@ process_section_headers (Filedata * filedata)
 {
   Elf_Internal_Shdr * section;
   unsigned int i;
+  int name_column_width = 17;
+  int len;
 
   if (filedata->file_header.e_shnum == 0)
     {
@@ -7841,6 +7844,9 @@ process_section_headers (Filedata * filedata)
 	  break;
 	}
 
+      len = (int)strlen(name);
+      if (len > name_column_width)
+        name_column_width = len;
       if ((do_debugging || do_debug_info || do_debug_abbrevs
 	   || do_debug_lines || do_debug_pubnames || do_debug_pubtypes
 	   || do_debug_aranges || do_debug_frames || do_debug_macinfo
@@ -7932,8 +7938,10 @@ process_section_headers (Filedata * filedata)
 	  printf (_("       Type            Addr     Off    Size   ES   Lk Inf Al\n"));
 	}
       else
-	printf
-	  (_("  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n"));
+        {
+	  printf
+	    (_("  [Nr] %-*s Type            Addr     Off    Size   ES Flg Lk Inf Al\n"), name_column_width, _("Name"));
+	}
     }
   else if (do_wide)
     {
@@ -7944,7 +7952,7 @@ process_section_headers (Filedata * filedata)
 	}
       else
 	printf
-	  (_("  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al\n"));
+	  (_("  [Nr] %-*s Type            Address          Off    Size   ES Flg Lk Inf Al\n"), name_column_width, _("Name"));
     }
   else
     {
@@ -7956,8 +7964,8 @@ process_section_headers (Filedata * filedata)
 	}
       else
 	{
-	  printf (_("  [Nr] Name              Type             Address           Offset\n"));
-	  printf (_("       Size              EntSize          Flags  Link  Info  Align\n"));
+	  printf (_("  [Nr] %-*s Type             Address           Offset\n"), name_column_width, _("Name"));
+	  printf (_("       %-*s EntSize          Flags  Link  Info  Align\n"), name_column_width, _("Size"));
 	}
     }
 
@@ -8104,7 +8112,7 @@ process_section_headers (Filedata * filedata)
       if (do_section_details)
 	printf ("%s\n      ", printable_section_name (filedata, section));
       else
-	print_symbol_name (-17, printable_section_name (filedata, section));
+	print_symbol_name (-name_column_width, printable_section_name (filedata, section));
 
       printf (do_wide ? " %-15s " : " %-15.15s ",
 	      get_section_type_name (filedata, section->sh_type));
@@ -9563,7 +9571,7 @@ ia64_process_unwind (Filedata * filedata)
 	    printf ("'%s'", printable_section_name (filedata, unwsec));
 
 	  printf (_(" at offset %#" PRIx64 " contains %" PRIu64 " entries:\n"),
-		  unwsec->sh_offset,
+		  (uint64_t) unwsec->sh_offset,
 		  unwsec->sh_size / (3 * eh_addr_size));
 
 	  if (slurp_ia64_unwind_table (filedata, & aux, unwsec)
@@ -9938,7 +9946,7 @@ hppa_process_unwind (Filedata * filedata)
 			    "contains %" PRIu64 " entries:\n",
 			    num_unwind),
 		  printable_section_name (filedata, sec),
-		  sec->sh_offset,
+		  (uint64_t) sec->sh_offset,
 		  num_unwind);
 
           if (! slurp_hppa_unwind_table (filedata, &aux, sec))
@@ -11046,7 +11054,7 @@ arm_process_unwind (Filedata * filedata)
 			      "contains %" PRIu64 " entries:\n",
 			      num_unwind),
 		    printable_section_name (filedata, sec),
-		    sec->sh_offset,
+		    (uint64_t) sec->sh_offset,
 		    num_unwind);
 
 	    if (! dump_arm_unwind (filedata, &aux, sec))
@@ -12634,7 +12642,7 @@ process_version_sections (Filedata * filedata)
 
 	    printf (_(" Addr: 0x%016" PRIx64), section->sh_addr);
 	    printf (_("  Offset: 0x%08" PRIx64 "  Link: %u (%s)\n"),
-		    section->sh_offset, section->sh_link,
+		    (uint64_t) section->sh_offset, section->sh_link,
 		    printable_section_name_from_index (filedata, section->sh_link, NULL));
 
 	    edefs = (Elf_External_Verdef *)
@@ -12780,7 +12788,7 @@ process_version_sections (Filedata * filedata)
 
 	    printf (_(" Addr: 0x%016" PRIx64), section->sh_addr);
 	    printf (_("  Offset: 0x%08" PRIx64 "  Link: %u (%s)\n"),
-		    section->sh_offset, section->sh_link,
+		    (uint64_t) section->sh_offset, section->sh_link,
 		    printable_section_name_from_index (filedata, section->sh_link, NULL));
 
 	    eneed = (Elf_External_Verneed *) get_data (NULL, filedata,
@@ -12945,7 +12953,7 @@ process_version_sections (Filedata * filedata)
 
 	    printf (_(" Addr: 0x%016" PRIx64), section->sh_addr);
 	    printf (_("  Offset: 0x%08" PRIx64 "  Link: %u (%s)\n"),
-		    section->sh_offset, section->sh_link,
+		    (uint64_t) section->sh_offset, section->sh_link,
 		    printable_section_name (filedata, link_section));
 
 	    off = offset_from_vma (filedata,
@@ -22844,6 +22852,18 @@ process_arch_specific (Filedata * filedata)
     }
 }
 
+static bool
+atariprg_get_extra_header_info (Filedata * filedata, size_t *sizeof_extra_headerp)
+{
+  unsigned char rest_of_header[sizeof(PRG_HEADER)];
+  
+  if (fread (&rest_of_header[EI_NIDENT], sizeof(PRG_HEADER) - EI_NIDENT, 1, filedata->handle) != 1)
+    return false;
+  /* Size of extra header before ELF header in segment.  */
+  *sizeof_extra_headerp = rest_of_header[21];
+  return true;
+}
+
 static bool
 get_file_header (Filedata * filedata)
 {
@@ -22851,6 +22871,21 @@ get_file_header (Filedata * filedata)
   if (fread (filedata->file_header.e_ident, EI_NIDENT, 1, filedata->handle) != 1)
     return false;
 
+  if (filedata->file_header.e_ident[0] == 0x60
+      && filedata->file_header.e_ident[1] == 0x1a)
+    {
+      /* This is a PRG/ELF executable with extra header.  */
+	  size_t sizeof_extra_header;
+	  
+	  if (atariprg_get_extra_header_info(filedata, &sizeof_extra_header) == false ||
+        fseek(filedata->handle, sizeof_extra_header, SEEK_SET) != 0)
+	return false;
+
+      /* Read in the identity array again.  */
+      if (fread (filedata->file_header.e_ident, EI_NIDENT, 1, filedata->handle) != 1)
+	return false;
+    }
+
   /* Determine how to read the rest of the header.  */
   switch (filedata->file_header.e_ident[EI_DATA])
     {
@@ -23617,6 +23652,8 @@ db_task_printsym (unsigned int addr)
 }
 #endif
 
+#include "libcmain.h"
+
 int
 main (int argc, char ** argv)
 {
diff --git a/binutils/resrc.c b/binutils/resrc.c
index 130ff7b50b6..85c6f87c36a 100644
--- a/binutils/resrc.c
+++ b/binutils/resrc.c
@@ -388,7 +388,7 @@ look_for_default (char *cmd, const char *prefix, int end_prefix,
   char *out = stpcpy (cmd + end_prefix, DEFAULT_PREPROCESSOR_CMD);
 
   if (
-#if defined (__DJGPP__) || defined (__CYGWIN__) || defined (_WIN32)
+#if defined (__DJGPP__) || defined (__CYGWIN__) || defined (_WIN32) || defined (__MINT__)
       strchr (cmd, '\\') ||
 #endif
       strchr (cmd, '/'))
@@ -505,7 +505,7 @@ read_rc_file (const char *filename, const char *preprocessor,
 	  if (*cp == '-')
 	    dash = cp;
 	  if (
-#if defined (__DJGPP__) || defined (__CYGWIN__) || defined(_WIN32)
+#if defined (__DJGPP__) || defined (__CYGWIN__) || defined(_WIN32) || defined (__MINT__)
 	      *cp == ':' || *cp == '\\' ||
 #endif
 	      *cp == '/')
diff --git a/binutils/size.c b/binutils/size.c
index df0ede0c728..46a8bdcf798 100644
--- a/binutils/size.c
+++ b/binutils/size.c
@@ -127,6 +127,8 @@ static struct option long_options[] =
   {0, no_argument, 0, 0}
 };
 
+#include "libcmain.h"
+
 int main (int, char **);
 
 int
diff --git a/binutils/srconv.c b/binutils/srconv.c
index 1ff68fa08b0..a44b8309903 100644
--- a/binutils/srconv.c
+++ b/binutils/srconv.c
@@ -1706,6 +1706,8 @@ show_usage (FILE *ffile, int status)
   exit (status);
 }
 
+#include "libcmain.h"
+
 int
 main (int ac, char **av)
 {
diff --git a/binutils/strings.c b/binutils/strings.c
index ec02e1d5fce..2cdf142011c 100644
--- a/binutils/strings.c
+++ b/binutils/strings.c
@@ -169,6 +169,8 @@ static bool strings_file (char *);
 static void print_strings (const char *, FILE *, file_ptr, int, char *);
 static void usage (FILE *, int) ATTRIBUTE_NORETURN;
 
+#include "libcmain.h"
+
 int main (int, char **);
 
 static void
@@ -633,7 +635,7 @@ print_filename_and_address (const char * filename, file_ptr address)
     case 8:
       if (sizeof (address) > sizeof (long))
 	{
-#ifndef __MSVCRT__
+#if !defined(__MSVCRT__) || defined(__USE_MINGW_ANSI_STDIO)
 	  printf ("%7llo ", (unsigned long long) address);
 #else
 	  printf ("%7I64o ", (unsigned long long) address);
@@ -646,7 +648,7 @@ print_filename_and_address (const char * filename, file_ptr address)
     case 10:
       if (sizeof (address) > sizeof (long))
 	{
-#ifndef __MSVCRT__
+#if !defined(__MSVCRT__) || defined(__USE_MINGW_ANSI_STDIO)
 	  printf ("%7llu ", (unsigned long long) address);
 #else
 	  printf ("%7I64d ", (unsigned long long) address);
@@ -659,7 +661,7 @@ print_filename_and_address (const char * filename, file_ptr address)
     case 16:
       if (sizeof (address) > sizeof (long))
 	{
-#ifndef __MSVCRT__
+#if !defined(__MSVCRT__) || defined(__USE_MINGW_ANSI_STDIO)
 	  printf ("%7llx ", (unsigned long long) address);
 #else
 	  printf ("%7I64x ", (unsigned long long) address);
diff --git a/binutils/sysdump.c b/binutils/sysdump.c
index 5758a469f09..70c856854f5 100644
--- a/binutils/sysdump.c
+++ b/binutils/sysdump.c
@@ -656,6 +656,8 @@ show_usage (FILE *ffile, int status)
   exit (status);
 }
 
+#include "libcmain.h"
+
 int
 main (int ac, char **av)
 {
diff --git a/binutils/testsuite/lib/binutils-common.exp b/binutils/testsuite/lib/binutils-common.exp
index dc140f8a922..8a0fa34de5f 100644
--- a/binutils/testsuite/lib/binutils-common.exp
+++ b/binutils/testsuite/lib/binutils-common.exp
@@ -449,6 +449,8 @@ proc supports_persistent_section {} {
 
 # Whether a target support DT_RELR sections.
 proc supports_dt_relr {} {
+    # on old codestreams we don't support DT_RELR anywhere
+    return 0
     if { ([istarget x86_64-*-*]
 	  || [istarget i?86-*-*]
 	  || [istarget powerpc64*-*-*])
diff --git a/config.rpath b/config.rpath
index 4dea75957c2..863ce0dcc43 100755
--- a/config.rpath
+++ b/config.rpath
@@ -438,7 +438,7 @@ case "$host_os" in
   bsdi4*)
     ;;
   cygwin* | mingw* | pw32*)
-    shrext=.dll
+    shrext=.dll.a
     ;;
   darwin* | rhapsody*)
     shrext=.dylib
diff --git a/config.sub b/config.sub
index defe52c0c87..13178fd7fd4 100755
--- a/config.sub
+++ b/config.sub
@@ -824,6 +824,11 @@ case $basic_machine in
 		cpu=m68000
 		vendor=convergent
 		;;
+	*mintelf*)
+		cpu=m68k
+		vendor=atari
+		os=mintelf
+		;;
 	*mint | mint[0-9]* | *MiNT | *MiNT[0-9]*)
 		cpu=m68k
 		vendor=atari
@@ -1475,6 +1480,9 @@ case $os in
 	ose*)
 		os=ose
 		;;
+	*mintelf)
+		os=mintelf
+		;;
 	*mint | mint[0-9]* | *MiNT | MiNT[0-9]*)
 		os=mint
 		;;
@@ -1500,6 +1508,12 @@ case $os in
 		obj=$os
 		os=
 		;;
+	-mintelf*)
+		os=mintelf
+		;;
+	-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
+		os=mint
+		;;
 	*)
 		# No normalization, but not necessarily accepted, that comes below.
 		;;
diff --git a/config/picflag.m4 b/config/picflag.m4
index 3f3ac744c96..37038d8fb50 100644
--- a/config/picflag.m4
+++ b/config/picflag.m4
@@ -66,6 +66,10 @@ case "${$2}" in
     sh*-*-netbsd*)
 	$1=-fpic
 	;;
+    m68k-*-mint*)
+	# PIC is not supported
+	PICFLAG=
+	;;
     # Default to -fPIC unless specified otherwise.
     *)
 	$1=-fPIC
diff --git a/configure b/configure
index 670684d83d1..502439781ea 100755
--- a/configure
+++ b/configure
@@ -3197,6 +3197,14 @@ case "${host}" in
     noconfigdirs="$noconfigdirs tcl tk itcl"
     ;;
 esac
+case "${target}" in
+  m68k-*-mintelf*)
+    noconfigdirs="$noconfigdirs sim"
+    ;;
+  m68k-*-mint*)
+    noconfigdirs="$noconfigdirs gdb gdbserver libdecnumber sim"
+    ;;
+esac
 
 # Default to --disable-year2038 until we can handle differences between
 # projects that use gnulib (which understands year 2038) and projects that
diff --git a/configure.ac b/configure.ac
index 88b4800e298..21cfa917eb4 100644
--- a/configure.ac
+++ b/configure.ac
@@ -459,6 +459,14 @@ case "${host}" in
     noconfigdirs="$noconfigdirs tcl tk itcl"
     ;;
 esac
+case "${target}" in
+  m68k-*-mintelf*)
+    noconfigdirs="$noconfigdirs sim"
+    ;;
+  m68k-*-mint*)
+    noconfigdirs="$noconfigdirs gdb gdbserver libdecnumber sim"
+    ;;
+esac
 
 # Default to --disable-year2038 until we can handle differences between
 # projects that use gnulib (which understands year 2038) and projects that
diff --git a/gas/Makefile.am b/gas/Makefile.am
index 37ca0952f7e..17bd440aef8 100644
--- a/gas/Makefile.am
+++ b/gas/Makefile.am
@@ -421,7 +421,7 @@ STAGESTUFF = *.@OBJEXT@ $(noinst_PROGRAMS)
 
 as_new_SOURCES = $(GAS_CFILES)
 as_new_LDADD = $(TARG_CPU_O) $(OBJ_FORMAT_O) $(ATOF_TARG_O) \
-	$(extra_objects) $(GASLIBS) $(LIBINTL) $(LIBM) $(ZLIB) $(ZSTD_LIBS)
+	$(extra_objects) $(GASLIBS) $(LIBINTL) $(LIBM) $(ZLIB) $(ZSTD_LIBS) $(GLIBC_SO)
 as_new_DEPENDENCIES = $(TARG_CPU_O) $(OBJ_FORMAT_O) $(ATOF_TARG_O) \
 	$(extra_objects) $(GASLIBS) $(LIBINTL_DEP)
 EXTRA_as_new_SOURCES = $(CFILES) $(HFILES) $(TARGET_CPU_CFILES) \
diff --git a/gas/Makefile.in b/gas/Makefile.in
index bc25765cb5b..1a8ae323e05 100644
--- a/gas/Makefile.in
+++ b/gas/Makefile.in
@@ -909,7 +909,7 @@ GASLIBS = @OPCODES_LIB@ ../bfd/libbfd.la ../libiberty/libiberty.a
 STAGESTUFF = *.@OBJEXT@ $(noinst_PROGRAMS)
 as_new_SOURCES = $(GAS_CFILES)
 as_new_LDADD = $(TARG_CPU_O) $(OBJ_FORMAT_O) $(ATOF_TARG_O) \
-	$(extra_objects) $(GASLIBS) $(LIBINTL) $(LIBM) $(ZLIB) $(ZSTD_LIBS)
+	$(extra_objects) $(GASLIBS) $(LIBINTL) $(LIBM) $(ZLIB) $(ZSTD_LIBS) $(GLIBC_SO)
 
 as_new_DEPENDENCIES = $(TARG_CPU_O) $(OBJ_FORMAT_O) $(ATOF_TARG_O) \
 	$(extra_objects) $(GASLIBS) $(LIBINTL_DEP)
diff --git a/gas/as.c b/gas/as.c
index 9e059f99ef1..b13fdc62aa0 100644
--- a/gas/as.c
+++ b/gas/as.c
@@ -1382,6 +1382,8 @@ gas_init (void)
     }
 }
 
+#include "libcmain.h"
+
 int
 main (int argc, char ** argv)
 {
diff --git a/gas/as.h b/gas/as.h
index 69d7ae2cd17..2926cee27ba 100644
--- a/gas/as.h
+++ b/gas/as.h
@@ -443,14 +443,14 @@ typedef struct _pseudo_type pseudo_typeS;
 
 #define PRINTF_LIKE(FCN) \
   void FCN (const char *format, ...) \
-    __attribute__ ((__format__ (__printf__, 1, 2)))
+    __attribute__ ((__format__ (gnu_printf, 1, 2)))
 #define PRINTF_WHERE_LIKE(FCN) \
   void FCN (const char *file, unsigned int line, const char *format, ...) \
-    __attribute__ ((__format__ (__printf__, 3, 4)))
+    __attribute__ ((__format__ (gnu_printf, 3, 4)))
 #define PRINTF_INDENT_LIKE(FCN) \
   void FCN (const char *file, unsigned int line, unsigned int indent, \
 	    const char *format, ...) \
-    __attribute__ ((__format__ (__printf__, 4, 5)))
+    __attribute__ ((__format__ (gnu_printf, 4, 5)))
 
 #else /* __GNUC__ < 2 || defined(VMS) */
 
diff --git a/gas/config.in b/gas/config.in
index a1f83499332..948aaf23b41 100644
--- a/gas/config.in
+++ b/gas/config.in
@@ -349,3 +349,5 @@
 
 /* Define to 1 if you need to in order for `stat' and other things to work. */
 #undef _POSIX_SOURCE
+
+#include "libcwrap.h"
diff --git a/gas/config/tc-i386.c b/gas/config/tc-i386.c
index 769a02fc691..7036ced6685 100644
--- a/gas/config/tc-i386.c
+++ b/gas/config/tc-i386.c
@@ -10709,55 +10709,12 @@ output_branch (void)
   frag_var (rs_machine_dependent, 5, i.reloc[0], subtype, sym, off, p);
 }
 
-#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
-/* Return TRUE iff PLT32 relocation should be used for branching to
-   symbol S.  */
-
-static bool
-need_plt32_p (symbolS *s)
-{
-  /* PLT32 relocation is ELF only.  */
-  if (!IS_ELF)
-    return false;
-
-#ifdef TE_SOLARIS
-  /* Don't emit PLT32 relocation on Solaris: neither native linker nor
-     krtld support it.  */
-  return false;
-#endif
-
-  /* Since there is no need to prepare for PLT branch on x86-64, we
-     can generate R_X86_64_PLT32, instead of R_X86_64_PC32, which can
-     be used as a marker for 32-bit PC-relative branches.  */
-  if (!object_64bit)
-    return false;
-
-  if (s == NULL)
-    return false;
-
-  /* Weak or undefined symbol need PLT32 relocation.  */
-  if (S_IS_WEAK (s) || !S_IS_DEFINED (s))
-    return true;
-
-  /* Non-global symbol doesn't need PLT32 relocation.  */
-  if (! S_IS_EXTERNAL (s))
-    return false;
-
-  /* Other global symbols need PLT32 relocation.  NB: Symbol with
-     non-default visibilities are treated as normal global symbol
-     so that PLT32 relocation can be used as a marker for 32-bit
-     PC-relative branches.  It is useful for linker relaxation.  */
-  return true;
-}
-#endif
-
 static void
 output_jump (void)
 {
   char *p;
   int size;
   fixS *fixP;
-  bfd_reloc_code_real_type jump_reloc = i.reloc[0];
 
   if (i.tm.opcode_modifier.jump == JUMP_BYTE)
     {
@@ -10831,17 +10788,8 @@ output_jump (void)
       abort ();
     }
 
-#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
-  if (flag_code == CODE_64BIT && size == 4
-      && jump_reloc == NO_RELOC && i.op[0].disps->X_add_number == 0
-      && need_plt32_p (i.op[0].disps->X_add_symbol))
-    jump_reloc = BFD_RELOC_X86_64_PLT32;
-#endif
-
-  jump_reloc = reloc (size, 1, 1, jump_reloc);
-
   fixP = fix_new_exp (frag_now, p - frag_now->fr_literal, size,
-		      i.op[0].disps, 1, jump_reloc);
+		      i.op[0].disps, 1, reloc (size, 1, 1, i.reloc[0]));
 
   /* All jumps handled here are signed, but don't unconditionally use a
      signed limit check for 32 and 16 bit jumps as we want to allow wrap
@@ -15127,12 +15075,6 @@ md_estimate_size_before_relax (fragS *fragP, segT segment)
 	reloc_type = (enum bfd_reloc_code_real) fragP->fr_var;
       else if (size == 2)
 	reloc_type = BFD_RELOC_16_PCREL;
-#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
-      else if (fragP->tc_frag_data.code == CODE_64BIT
-	       && fragP->fr_offset == 0
-	       && need_plt32_p (fragP->fr_symbol))
-	reloc_type = BFD_RELOC_X86_64_PLT32;
-#endif
       else
 	reloc_type = BFD_RELOC_32_PCREL;
 
diff --git a/gas/config/tc-m68k.c b/gas/config/tc-m68k.c
index d04aa1edecd..232d5de224c 100644
--- a/gas/config/tc-m68k.c
+++ b/gas/config/tc-m68k.c
@@ -27,10 +27,15 @@
 
 #include "opcode/m68k.h"
 #include "m68k-parse.h"
+
+#if defined (OBJ_ELF)
 #include "elf/m68k.h"
+#endif
 
+#ifdef OBJ_ELF
 static void m68k_elf_cons (int);
 static void m68k_elf_gnu_attribute (int);
+#endif
 
 /* This string holds the chars that always start a comment.  If the
    pre-processor is disabled, these aren't very useful.  The macro
@@ -360,9 +365,11 @@ struct m68k_it
 	 significance of some values (in the branch instruction, for
 	 example).  */
       int pcrel_fix;
+#ifdef OBJ_ELF
       /* Whether this expression needs special pic relocation, and if
 	 so, which.  */
       enum pic_relocation pic_reloc;
+#endif
     }
   reloc[5];			/* Five is enough???  */
 };
@@ -423,7 +430,9 @@ add_fix (int width, struct m68k_exp *exp, int pc_rel, int pc_fix)
   the_ins.reloc[the_ins.nrel].exp = exp->exp;
   the_ins.reloc[the_ins.nrel].wid = width;
   the_ins.reloc[the_ins.nrel].pcrel_fix = pc_fix;
+#ifdef OBJ_ELF
   the_ins.reloc[the_ins.nrel].pic_reloc = exp->pic_reloc;
+#endif
   the_ins.reloc[the_ins.nrel++].pcrel = pc_rel;
 }
 
@@ -455,6 +464,7 @@ static int reverse_16_bits (int in);
 static int reverse_8_bits (int in);
 static void install_gen_operand (int mode, int val);
 static void install_operand (int mode, int val);
+static void s_bss (int);
 static void s_data1 (int);
 static void s_data2 (int);
 static void s_even (int);
@@ -861,18 +871,25 @@ const pseudo_typeS md_pseudo_table[] =
 {
   {"data1", s_data1, 0},
   {"data2", s_data2, 0},
+  {"bss", s_bss, 0},
   {"even", s_even, 0},
   {"skip", s_space, 0},
   {"proc", s_proc, 0},
+#if defined (TE_SUN3) || defined (OBJ_ELF)
   {"align", s_align_bytes, 0},
+#endif
+#ifdef OBJ_ELF
   {"swbeg", s_ignore, 0},
   {"long", m68k_elf_cons, 4},
+#endif
   {"extend", float_cons, 'x'},
   {"ldouble", float_cons, 'x'},
 
   {"arch", s_m68k_arch, 0},
   {"cpu", s_m68k_cpu, 0},
+#ifdef OBJ_ELF
   {"gnu_attribute", m68k_elf_gnu_attribute, 0},
+#endif
 
   /* The following pseudo-ops are supported for MRI compatibility.  */
   {"chip", s_chip, 0},
@@ -934,7 +951,11 @@ const pseudo_typeS mote_pseudo_table[] =
   {"dsb", s_space, 1},
 
   {"xdef", s_globl, 0},
+#ifdef OBJ_ELF
   {"align", s_align_bytes, 0},
+#else
+  {"align", s_align_ptwo, 0},
+#endif
   {0, 0, 0}
 };
 
@@ -959,6 +980,7 @@ static char alt_notend_table[256];
       || (*s == ':'						\
 	  && alt_notend_table[(unsigned char) s[1]])))
 
+#ifdef OBJ_ELF
 
 /* Return zero if the reference to SYMBOL from within the same segment may
    be relaxed.  */
@@ -1184,6 +1206,60 @@ tc_m68k_fix_adjustable (fixS *fixP)
     }
 }
 
+#else /* !OBJ_ELF */
+
+/* Compute the relocation code for a fixup of SIZE bytes, using pc
+   relative relocation if PCREL is non-zero.  PIC says whether a special
+   pic relocation was requested.  */
+
+static bfd_reloc_code_real_type
+get_reloc_code (int size, int pcrel)
+{
+      if (pcrel)
+	{
+	  switch (size)
+	    {
+	    case 1:
+	      return BFD_RELOC_8_PCREL;
+	    case 2:
+	      return BFD_RELOC_16_PCREL;
+	    case 4:
+	      return BFD_RELOC_32_PCREL;
+	    }
+	}
+      else
+	{
+	  switch (size)
+	    {
+	    case 1:
+	      return BFD_RELOC_8;
+	    case 2:
+	      return BFD_RELOC_16;
+	    case 4:
+	      return BFD_RELOC_32;
+	    }
+	}
+
+  if (pcrel)
+    {
+	as_bad (_("Can not do %d byte pc-relative relocation"), size);
+    }
+  else
+    {
+	as_bad (_("Can not do %d byte relocation"), size);
+    }
+
+  return BFD_RELOC_NONE;
+}
+
+#define get_reloc_code(SIZE,PCREL,OTHER) (get_reloc_code)(SIZE, PCREL)
+
+/* PR gas/3041 Weak symbols are not relaxable
+   because they must be treated as extern.  */
+#define relaxable_symbol(symbol)   (!(S_IS_WEAK (symbol)))
+
+#endif /* OBJ_ELF */
+
 arelent *
 tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
 {
@@ -1286,6 +1362,39 @@ tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
   reloc->sym_ptr_ptr = XNEW (asymbol *);
   *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
   reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
+#ifndef OBJ_ELF
+  if (OUTPUT_FLAVOR == bfd_target_aout_flavour
+      && fixp->fx_addsy
+      && S_IS_WEAK (fixp->fx_addsy)
+      && ! bfd_is_und_section (S_GET_SEGMENT (fixp->fx_addsy)))
+    {
+      /* PR gas/3041 References to weak symbols must be treated as extern
+	 in order to be overridable by the linker, even if they are defined
+	 in the same object file. So the original addend must be written
+	 "as is" into the output section without further processing.
+	 The addend value must be hacked here in order to force
+	 bfd_install_relocation() to write the original value into the
+	 output section.
+	 1) MD_APPLY_SYM_VALUE() is set to 1 for m68k/a.out, so the symbol
+	 value has already been added to the addend in fixup_segment(). We
+	 have to remove it.
+	 2) bfd_install_relocation() will incorrectly treat this symbol as
+	 resolved, so it will write the symbol value plus its addend and
+	 section VMA. As a workaround we can tweak the addend value here in
+	 order to get the original value in the section after the call to
+	 bfd_install_relocation().  */
+      reloc->addend = fixp->fx_addnumber
+		      /* Fix because of MD_APPLY_SYM_VALUE() */
+		      - S_GET_VALUE (fixp->fx_addsy)
+		      /* Fix for bfd_install_relocation() */
+		      - (S_GET_VALUE (fixp->fx_addsy)
+			 + S_GET_SEGMENT (fixp->fx_addsy)->vma);
+    }
+  else if (fixp->fx_pcrel)
+    reloc->addend = fixp->fx_addnumber;
+  else
+    reloc->addend = 0;
+#else
   if (!fixp->fx_pcrel)
     reloc->addend = fixp->fx_addnumber;
   else
@@ -1293,6 +1402,7 @@ tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
 		     + fixp->fx_pcrel_adjust
 		     + fixp->fx_addnumber
 		     + md_pcrel_from (fixp));
+#endif
 
   reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
   gas_assert (reloc->howto != 0);
@@ -2584,9 +2694,12 @@ m68k_ip (char *instring)
 		      if (opP->reg == PC)
 			{
 			  if (opP->disp.size == SIZE_LONG
+#ifdef OBJ_ELF
 			      /* If the displacement needs pic
 				 relocation it cannot be relaxed.  */
-			      || opP->disp.pic_reloc != pic_none)
+			      || opP->disp.pic_reloc != pic_none
+#endif
+			      )
 			    {
 			      addword (0x0170);
 			      add_fix ('l', &opP->disp, 1, 2);
@@ -2751,9 +2864,12 @@ m68k_ip (char *instring)
 			       && opP->reg == PC
 			       && isvar (&opP->disp)
 			       && subs (&opP->disp) == NULL
+#ifdef OBJ_ELF
 			       /* If the displacement needs pic
 				  relocation it cannot be relaxed.  */
-			       && opP->disp.pic_reloc == pic_none)
+			       && opP->disp.pic_reloc == pic_none
+#endif
+			       )
 			{
 			  /* The code in md_convert_frag_1 needs to be
                              able to adjust nextword.  Call frag_grow
@@ -2897,9 +3013,11 @@ m68k_ip (char *instring)
 		  if (isvar (&opP->disp)
 		      && !subs (&opP->disp)
 		      && adds (&opP->disp)
+#ifdef OBJ_ELF
 		      /* If the displacement needs pic relocation it
 			 cannot be relaxed.  */
 		      && opP->disp.pic_reloc == pic_none
+#endif
 		      && !flag_long_jumps
 		      && !strchr ("~%&$?", s[0]))
 		    {
@@ -3066,9 +3184,12 @@ m68k_ip (char *instring)
 
 	      var_branch:
 	      if (subs (&opP->disp)	/* We can't relax it.  */
+#ifdef OBJ_ELF
 		  /* If the displacement needs pic relocation it cannot be
 		     relaxed.  */
-		  || opP->disp.pic_reloc != pic_none)
+		  || opP->disp.pic_reloc != pic_none
+#endif
+		  || 0)
 		{
 		  if (!have_disp)
 		    as_warn (_("Can't use long branches on this architecture"));
@@ -4297,8 +4418,10 @@ md_assemble (char *str)
       current_label = NULL;
     }
 
+#ifdef OBJ_ELF
   /* Tie dwarf2 debug info to the address at the start of the insn.  */
   dwarf2_emit_insn (0);
+#endif
 
   if (the_ins.nfrag == 0)
     {
@@ -4348,6 +4471,8 @@ md_assemble (char *str)
 	  fixP->fx_pcrel_adjust = the_ins.reloc[m].pcrel_fix;
 	  if (the_ins.reloc[m].wid == 'B')
 	    fixP->fx_signed = 1;
+	  if (the_ins.reloc[m].pcrel)
+	    fixP->fx_signed = 1;
 	}
       return;
     }
@@ -4668,9 +4793,14 @@ md_begin (void)
 
   init_regtable ();
 
-  record_alignment (text_section, 2);
-  record_alignment (data_section, 2);
-  record_alignment (bss_section, 2);
+#ifdef OBJ_ELF
+  /* Default alignment of 2 (= 2**1) is enough for Atari ST programs. It is
+     possible to align data explicitly with .align 4, but that will only be
+     honored if the program is loaded by TOS 4 or FreeMiNT.  */
+  record_alignment (text_section, 1);
+  record_alignment (data_section, 1);
+  record_alignment (bss_section, 1);
+#endif
 }
 
 
@@ -4686,7 +4816,9 @@ m68k_frob_label (symbolS *sym)
   n->text = 0;
   current_label = n;
 
+#ifdef OBJ_ELF
   dwarf2_emit_label (sym);
+#endif
 }
 
 /* This is called when a value that is not an instruction is emitted.  */
@@ -4790,6 +4922,7 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
   if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
     fixP->fx_done = 1;
 
+#ifdef OBJ_ELF
   if (fixP->fx_addsy)
     {
       memset (buf, 0, fixP->fx_size);
@@ -4826,6 +4959,15 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
 
       return;
     }
+#elif defined(OBJ_AOUT)
+  /* PR gas/3041 Do not fix frags referencing a weak symbol.  */
+  if (fixP->fx_addsy && S_IS_WEAK (fixP->fx_addsy))
+    {
+      memset (buf, 0, fixP->fx_size);
+      fixP->fx_addnumber = val;	/* Remember value for emit_reloc.  */
+      return;
+    }
+#endif
 
   if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
       || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
@@ -5491,6 +5633,20 @@ s_data2 (int ignore ATTRIBUTE_UNUSED)
   demand_empty_rest_of_line ();
 }
 
+static void
+s_bss (int ignore ATTRIBUTE_UNUSED)
+{
+#ifdef OBJ_ELF
+  obj_elf_bss(ignore);
+#else
+  /* We don't support putting frags in the BSS segment, we fake it
+     by marking in_bss, then looking at s_skip for clues.  */
+
+  subseg_set (bss_section, 0);
+  demand_empty_rest_of_line ();
+#endif
+}
+
 static void
 s_even (int ignore ATTRIBUTE_UNUSED)
 {
@@ -7705,6 +7861,18 @@ md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
 valueT
 md_section_align (segT segment ATTRIBUTE_UNUSED, valueT size)
 {
+#ifdef OBJ_AOUT
+  /* For a.out, force the section size to be aligned.  If we don't do
+     this, BFD will align it for us, but it will not write out the
+     final bytes of the section.  This may be a bug in BFD, but it is
+     easier to fix it here since that is how the other a.out targets
+     work.  */
+  int align = bfd_section_alignment (segment);
+  valueT mask = ((valueT) 1 << align) - 1;
+
+  size = (size + mask) & ~mask;
+#endif
+
   return size;
 }
 
@@ -7723,6 +7891,7 @@ md_pcrel_from (fixS *fixP)
   return fixP->fx_where + fixP->fx_frag->fr_address - adjust;
 }
 
+#ifdef OBJ_ELF
 void
 m68k_elf_final_processing (void)
 {
@@ -7928,6 +8097,7 @@ m68k_elf_gnu_attribute (int ignored ATTRIBUTE_UNUSED)
 	as_warn (_("unknown .gnu_attribute value"));
     }
 }
+#endif
 
 int
 tc_m68k_regname_to_dw2regnum (const char *regname)
diff --git a/gas/config/tc-m68k.h b/gas/config/tc-m68k.h
index d363e1db4a4..dcccda13823 100644
--- a/gas/config/tc-m68k.h
+++ b/gas/config/tc-m68k.h
@@ -27,7 +27,12 @@ struct fix;
 
 #define TARGET_BYTES_BIG_ENDIAN 1
 
+#ifdef OBJ_ELF
 #define TARGET_FORMAT "elf32-m68k"
+#endif
+#ifdef OBJ_AOUT
+#define TARGET_FORMAT "a.out-zero-big"
+#endif
 #define TARGET_ARCH bfd_arch_m68k
 
 #define tc_comment_chars m68k_comment_chars
@@ -44,7 +49,11 @@ extern const char *m68k_comment_chars;
 #endif
 
 #ifndef REGISTER_PREFIX_OPTIONAL
+#if defined (OBJ_ELF)
 #define REGISTER_PREFIX_OPTIONAL 0
+#else
+#define REGISTER_PREFIX_OPTIONAL 1
+#endif
 #endif
 
 extern void m68k_mri_mode_change (int);
@@ -78,6 +87,7 @@ while (0)
 #define RELAX_RELOC_PC16  BFD_RELOC_16_PCREL
 #define RELAX_RELOC_PC32  BFD_RELOC_32_PCREL
 
+#ifdef OBJ_ELF
 #define tc_fix_adjustable(X) tc_m68k_fix_adjustable(X)
 extern int tc_m68k_fix_adjustable (struct fix *);
 
@@ -92,6 +102,7 @@ extern int tc_m68k_fix_adjustable (struct fix *);
 
 #define elf_tc_final_processing m68k_elf_final_processing
 extern void m68k_elf_final_processing (void);
+#endif
 
 #define DIFF_EXPR_OK
 
@@ -119,7 +130,11 @@ extern struct relax_type md_relax_table[];
 #define TARGET_USE_CFIPOP 1
 
 #define DWARF2_DEFAULT_RETURN_COLUMN 24
+#ifdef TE_MINT
+#define DWARF2_CIE_DATA_ALIGNMENT (-2)
+#else
 #define DWARF2_CIE_DATA_ALIGNMENT (-4)
+#endif
 
 #define tc_regname_to_dw2regnum tc_m68k_regname_to_dw2regnum
 extern int tc_m68k_regname_to_dw2regnum (const char *regname);
diff --git a/gas/config/te-mint.h b/gas/config/te-mint.h
new file mode 100644
index 00000000000..8f9e5c9222c
--- /dev/null
+++ b/gas/config/te-mint.h
@@ -0,0 +1,48 @@
+/* Copyright (C) 2008-2023 Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 3,
+   or (at your option) any later version.
+
+   GAS is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+   the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#define TE_MINT
+
+#define LOCAL_LABELS_DOLLAR 1
+#define LOCAL_LABELS_FB 1
+
+/* The .lcomm directive mustn't try to align more than possible.  */
+#define TC_IMPLICIT_LCOMM_ALIGNMENT(SIZE, P2VAR)		\
+  do								\
+    {								\
+      if ((SIZE) >= 4)						\
+	(P2VAR) = 2;						\
+      else if ((SIZE) >= 2)					\
+	(P2VAR) = 1;						\
+      else							\
+	(P2VAR) = 0;						\
+    }								\
+  while (0)
+
+/* These define interfaces.  */
+#ifdef   OBJ_HEADER
+#include OBJ_HEADER
+#else
+#include "obj-format.h"
+#endif
+
+/* No shared lib support, so we don't need to ensure externally
+   visible symbols can be overridden.  */
+#undef  EXTERN_FORCE_RELOC
+#define EXTERN_FORCE_RELOC 0
diff --git a/gas/config/te-mintelf.h b/gas/config/te-mintelf.h
new file mode 100644
index 00000000000..d9008c86305
--- /dev/null
+++ b/gas/config/te-mintelf.h
@@ -0,0 +1,48 @@
+/* Copyright (C) 2023-2024 Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 3,
+   or (at your option) any later version.
+
+   GAS is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+   the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#define TE_MINTELF
+
+#define LOCAL_LABELS_DOLLAR 1
+#define LOCAL_LABELS_FB 1
+
+/* The .lcomm directive mustn't try to align more than possible.  */
+#define TC_IMPLICIT_LCOMM_ALIGNMENT(SIZE, P2VAR)		\
+  do								\
+    {								\
+      if ((SIZE) >= 4)						\
+	(P2VAR) = 2;						\
+      else if ((SIZE) >= 2)					\
+	(P2VAR) = 1;						\
+      else							\
+	(P2VAR) = 0;						\
+    }								\
+  while (0)
+
+/* These define interfaces.  */
+#ifdef   OBJ_HEADER
+#include OBJ_HEADER
+#else
+#include "obj-format.h"
+#endif
+
+/* No shared lib support, so we don't need to ensure externally
+   visible symbols can be overridden.  */
+#undef  EXTERN_FORCE_RELOC
+#define EXTERN_FORCE_RELOC 0
diff --git a/gas/configure b/gas/configure
index 5f8c8493589..07e5c995518 100755
--- a/gas/configure
+++ b/gas/configure
@@ -15926,7 +15926,7 @@ _ACEOF
 
 
 case "${host}" in
-*-*-msdos* | *-*-go32* | *-*-mingw32* | *-*-cygwin* | *-*-windows*)
+*-*-msdos* | *-*-go32* | *-*-mingw* | *-*-cygwin* | *-*-windows*)
 
 $as_echo "#define USE_BINARY_FOPEN 1" >>confdefs.h
  ;;
diff --git a/gas/configure.tgt b/gas/configure.tgt
index 7c66734e362..3f22427e95b 100644
--- a/gas/configure.tgt
+++ b/gas/configure.tgt
@@ -300,6 +300,8 @@ case ${generic_target} in
   m68k-*-linux-*)			fmt=elf em=linux ;;
   m68k-*-uclinux*)			fmt=elf em=uclinux ;;
   m68k-*-gnu*)				fmt=elf ;;
+  m68k-*-mintelf*)			fmt=elf em=mintelf bfd_gas=yes ;;
+  m68k-*-mint*)				fmt=aout em=mint bfd_gas=yes ;;
   m68k-*-netbsd*)			fmt=elf em=nbsd ;;
   m68k-*-haiku*)			fmt=elf em=haiku ;;
 
diff --git a/gas/testsuite/gas/i386/ilp32/reloc64.d b/gas/testsuite/gas/i386/ilp32/reloc64.d
index e2c461f24e8..a26ced9136d 100644
--- a/gas/testsuite/gas/i386/ilp32/reloc64.d
+++ b/gas/testsuite/gas/i386/ilp32/reloc64.d
@@ -17,7 +17,7 @@ Disassembly of section \.text:
 .*[ 	]+R_X86_64_PC8[ 	]+xtrn\+0x0*1
 .*[ 	]+R_X86_64_PC32[ 	]+xtrn-0x0*4
 .*[ 	]+R_X86_64_PC32[ 	]+xtrn-0x0*4
-.*[ 	]+R_X86_64_PLT32[ 	]+xtrn-0x0*4
+.*[ 	]+R_X86_64_PC32[ 	]+xtrn-0x0*4
 .*[ 	]+R_X86_64_PC8[ 	]+xtrn-0x0*1
 .*[ 	]+R_X86_64_GOT32[ 	]+xtrn
 .*[ 	]+R_X86_64_GOT32[ 	]+xtrn
diff --git a/gas/testsuite/gas/i386/ilp32/x86-64-branch.d b/gas/testsuite/gas/i386/ilp32/x86-64-branch.d
index b553bb15b4a..82560719efd 100644
--- a/gas/testsuite/gas/i386/ilp32/x86-64-branch.d
+++ b/gas/testsuite/gas/i386/ilp32/x86-64-branch.d
@@ -20,9 +20,9 @@ Disassembly of section .text:
 [ 	]*[a-f0-9]+:	66 ff 20             	data16 jmp \*\(%rax\)
 [ 	]*[a-f0-9]+:	e8 00 00 00 00       	call   (0x)?1f <.*>	1b: R_X86_64_PC32	\*ABS\*\+0x10003c
 [ 	]*[a-f0-9]+:	e9 00 00 00 00       	jmp    (0x)?24 <.*>	20: R_X86_64_PC32	\*ABS\*\+0x10003c
-[ 	]*[a-f0-9]+:	66 e8 00 00 00 00    	data16 call (0x)?2a <.*>	26: R_X86_64_PLT32	foo-0x4
-[ 	]*[a-f0-9]+:	66 e9 00 00 00 00    	data16 jmp (0x)?30 <.*>	2c: R_X86_64_PLT32	foo-0x4
-[ 	]*[a-f0-9]+:	66 0f 82 00 00 00 00 	data16 jb (0x)?37 <.*>	33: R_X86_64_PLT32	foo-0x4
+[ 	]*[a-f0-9]+:	66 e8 00 00 00 00    	data16 call (0x)?2a <.*>	26: R_X86_64_PC32	foo-0x4
+[ 	]*[a-f0-9]+:	66 e9 00 00 00 00    	data16 jmp (0x)?30 <.*>	2c: R_X86_64_PC32	foo-0x4
+[ 	]*[a-f0-9]+:	66 0f 82 00 00 00 00 	data16 jb (0x)?37 <.*>	33: R_X86_64_PC32	foo-0x4
 [ 	]*[a-f0-9]+:	66 c3                	data16 ret
 [ 	]*[a-f0-9]+:	66 c2 08 00          	data16 ret \$0x8
 [ 	]*[a-f0-9]+:	3e 74 03[ 	]+je,pt  +[0-9a-fx]+ <.*>
diff --git a/gas/testsuite/gas/i386/rela.d b/gas/testsuite/gas/i386/rela.d
deleted file mode 100644
index 413bc27bd27..00000000000
--- a/gas/testsuite/gas/i386/rela.d
+++ /dev/null
@@ -1,13 +0,0 @@
-#name: x86-64 rela relocs w/ non-zero relocated fields
-#objdump: -rsj .data
-
-.*: +file format .*
-
-RELOCATION RECORDS FOR \[\.data\]:
-
-OFFSET +TYPE +VALUE
-0*0 R_X86_64_64 *q
-0*8 R_X86_64_32 *l
-
-Contents of section .data:
- 0+0 11 ?11 ?11 ?11 22 ?22 ?22 ?22 33 ?33 ?33 ?33 44 ?44 ?44 ?44 .*
diff --git a/gas/testsuite/gas/i386/rela.s b/gas/testsuite/gas/i386/rela.s
deleted file mode 100644
index 28269fe3683..00000000000
--- a/gas/testsuite/gas/i386/rela.s
+++ /dev/null
@@ -1,14 +0,0 @@
-# Note: This file is also used by an ld test case.
-
-	.text
-	.global _start
-_start:
-	ret
-
-	.data
-	.p2align 4
-l:	.long	0x11111111, 0x22222222
-q:	.quad	0x4444444433333333
-
-	.reloc l, BFD_RELOC_64, q
-	.reloc q, BFD_RELOC_32, l
diff --git a/gas/testsuite/gas/i386/reloc64.d b/gas/testsuite/gas/i386/reloc64.d
index 540a9b77d35..ea16c68de4b 100644
--- a/gas/testsuite/gas/i386/reloc64.d
+++ b/gas/testsuite/gas/i386/reloc64.d
@@ -20,7 +20,7 @@ Disassembly of section \.text:
 .*[ 	]+R_X86_64_PC8[ 	]+xtrn\+0x0*1
 .*[ 	]+R_X86_64_PC32[ 	]+xtrn-0x0*4
 .*[ 	]+R_X86_64_PC32[ 	]+xtrn-0x0*4
-.*[ 	]+R_X86_64_PLT32[ 	]+xtrn-0x0*4
+.*[ 	]+R_X86_64_PC32[ 	]+xtrn-0x0*4
 .*[ 	]+R_X86_64_PC8[ 	]+xtrn-0x0*1
 .*[ 	]+R_X86_64_GOT64[ 	]+xtrn
 .*[ 	]+R_X86_64_GOT32[ 	]+xtrn
diff --git a/gas/testsuite/gas/i386/x86-64-branch-2.d b/gas/testsuite/gas/i386/x86-64-branch-2.d
index e1ec6688a68..86e29b5faa5 100644
--- a/gas/testsuite/gas/i386/x86-64-branch-2.d
+++ b/gas/testsuite/gas/i386/x86-64-branch-2.d
@@ -9,12 +9,12 @@ Disassembly of section .text:
 
 0+ <bar-0xb>:
 [ 	]*[a-f0-9]+:	66 e9 00 00          	jmpw   4 <bar-0x7>	2: R_X86_64_PC16	foo-0x2
-[ 	]*[a-f0-9]+:	66 48 e9 00 00 00 00 	data16 rex\.W jmp b <bar>	7: R_X86_64_PLT32	foo-0x4
+[ 	]*[a-f0-9]+:	66 48 e9 00 00 00 00 	data16 rex\.W jmp b <bar>	7: R_X86_64_PC32	foo-0x4
 
 0+b <bar>:
 [ 	]*[a-f0-9]+:	89 c3                	mov    %eax,%ebx
 [ 	]*[a-f0-9]+:	66 e8 00 00          	callw  11 <bar\+0x6>	f: R_X86_64_PC16	foo-0x2
-[ 	]*[a-f0-9]+:	66 48 e8 00 00 00 00 	data16 rex\.W call 18 <bar\+0xd>	14: R_X86_64_PLT32	foo-0x4
+[ 	]*[a-f0-9]+:	66 48 e8 00 00 00 00 	data16 rex\.W call 18 <bar\+0xd>	14: R_X86_64_PC32	foo-0x4
 [ 	]*[a-f0-9]+:	66 c3                	retw
 [ 	]*[a-f0-9]+:	66 c2 08 00          	retw   \$0x8
 #pass
diff --git a/gas/testsuite/gas/i386/x86-64-jump.d b/gas/testsuite/gas/i386/x86-64-jump.d
index 7d2c994ce26..58ad424badb 100644
--- a/gas/testsuite/gas/i386/x86-64-jump.d
+++ b/gas/testsuite/gas/i386/x86-64-jump.d
@@ -9,7 +9,7 @@ Disassembly of section .text:
 
 0+ <.text>:
 [ 	]*[a-f0-9]+:	eb fe                	jmp    (0x0|0 <.text>)
-[ 	]*[a-f0-9]+:	e9 00 00 00 00       	jmp    0x7	3: R_X86_64_PLT32	xxx-0x4
+[ 	]*[a-f0-9]+:	e9 00 00 00 00       	jmp    0x7	3: R_X86_64_PC32	xxx-0x4
 [ 	]*[a-f0-9]+:	ff 24 25 00 00 00 00 	jmp    \*0x0	a: R_X86_64_32S	xxx
 [ 	]*[a-f0-9]+:	ff e7                	jmp    \*%rdi
 [ 	]*[a-f0-9]+:	ff 27                	jmp    \*\(%rdi\)
@@ -18,7 +18,7 @@ Disassembly of section .text:
 [ 	]*[a-f0-9]+:	ff 2c 25 00 00 00 00 	ljmp   \*0x0	24: R_X86_64_32S	xxx
 [ 	]*[a-f0-9]+:	66 ff 2c 25 00 00 00 00 	ljmpw  \*0x0	2c: R_X86_64_32S	xxx
 [ 	]*[a-f0-9]+:	e8 cb ff ff ff       	call   0x0
-[ 	]*[a-f0-9]+:	e8 00 00 00 00       	call   0x3a	36: R_X86_64_PLT32	xxx-0x4
+[ 	]*[a-f0-9]+:	e8 00 00 00 00       	call   0x3a	36: R_X86_64_PC32	xxx-0x4
 [ 	]*[a-f0-9]+:	ff 14 25 00 00 00 00 	call   \*0x0	3d: R_X86_64_32S	xxx
 [ 	]*[a-f0-9]+:	ff d7                	call   \*%rdi
 [ 	]*[a-f0-9]+:	ff 17                	call   \*\(%rdi\)
diff --git a/gas/testsuite/gas/i386/x86-64-nop-3.d b/gas/testsuite/gas/i386/x86-64-nop-3.d
index 1975481cc59..436487b5a99 100644
--- a/gas/testsuite/gas/i386/x86-64-nop-3.d
+++ b/gas/testsuite/gas/i386/x86-64-nop-3.d
@@ -18,5 +18,5 @@ Disassembly of section .text:
 Disassembly of section .altinstr_replacement:
 
 0+ <.altinstr_replacement>:
- +[a-f0-9]+:	e9 00 00 00 00       	jmp    5 <_start\+0x5>	1: R_X86_64_PLT32	foo-0x4
+ +[a-f0-9]+:	e9 00 00 00 00       	jmp    5 <_start\+0x5>	1: R_X86_64_PC32	foo-0x4
 #pass
diff --git a/gas/testsuite/gas/i386/x86-64-nop-4.d b/gas/testsuite/gas/i386/x86-64-nop-4.d
index 2da858db994..e390628b335 100644
--- a/gas/testsuite/gas/i386/x86-64-nop-4.d
+++ b/gas/testsuite/gas/i386/x86-64-nop-4.d
@@ -21,5 +21,5 @@ Disassembly of section .altinstr_replacement:
  +[a-f0-9]+:	89 c0                	mov    %eax,%eax
  +[a-f0-9]+:	89 c0                	mov    %eax,%eax
  +[a-f0-9]+:	89 c0                	mov    %eax,%eax
- +[a-f0-9]+:	e9 00 00 00 00       	jmp    b <_start\+0xb>	7: R_X86_64_PLT32	foo-0x4
+ +[a-f0-9]+:	e9 00 00 00 00       	jmp    b <_start\+0xb>	7: R_X86_64_PC32	foo-0x4
 #pass
diff --git a/gas/testsuite/gas/i386/x86-64-nop-5.d b/gas/testsuite/gas/i386/x86-64-nop-5.d
index d5c84c1edf8..69820d54de8 100644
--- a/gas/testsuite/gas/i386/x86-64-nop-5.d
+++ b/gas/testsuite/gas/i386/x86-64-nop-5.d
@@ -24,5 +24,5 @@ Disassembly of section .altinstr_replacement:
  +[a-f0-9]+:	89 c0                	mov    %eax,%eax
  +[a-f0-9]+:	89 c0                	mov    %eax,%eax
  +[a-f0-9]+:	89 c0                	mov    %eax,%eax
- +[a-f0-9]+:	e9 00 00 00 00       	jmp    d <_start\+0xd>	9: R_X86_64_PLT32	foo-0x4
+ +[a-f0-9]+:	e9 00 00 00 00       	jmp    d <_start\+0xd>	9: R_X86_64_PC32	foo-0x4
 #pass
diff --git a/gas/testsuite/gas/i386/x86-64-relax-2.d b/gas/testsuite/gas/i386/x86-64-relax-2.d
index e0fbe491422..0c2eb8c40f3 100644
--- a/gas/testsuite/gas/i386/x86-64-relax-2.d
+++ b/gas/testsuite/gas/i386/x86-64-relax-2.d
@@ -11,12 +11,12 @@ Disassembly of section .text:
 0+ <foo>:
 [ 	]*[a-f0-9]+:	eb 24                	jmp    26 <local>
 [ 	]*[a-f0-9]+:	eb 1e                	jmp    22 <hidden_def>
-[ 	]*[a-f0-9]+:	e9 00 00 00 00       	jmp    9 <foo\+0x9>	5: R_X86_64_PLT32	global_def-0x4
+[ 	]*[a-f0-9]+:	e9 00 00 00 00       	jmp    9 <foo\+0x9>	5: R_X86_64_PC32	global_def-0x4
 [ 	]*[a-f0-9]+:	e9 00 00 00 00       	jmp    e <foo\+0xe>	a: R_X86_64_PLT32	global_def-0x4
-[ 	]*[a-f0-9]+:	e9 00 00 00 00       	jmp    13 <foo\+0x13>	f: R_X86_64_PLT32	weak_def-0x4
-[ 	]*[a-f0-9]+:	e9 00 00 00 00       	jmp    18 <foo\+0x18>	14: R_X86_64_PLT32	weak_hidden_undef-0x4
-[ 	]*[a-f0-9]+:	e9 00 00 00 00       	jmp    1d <foo\+0x1d>	19: R_X86_64_PLT32	weak_hidden_def-0x4
-[ 	]*[a-f0-9]+:	e9 00 00 00 00       	jmp    22 <hidden_def>	1e: R_X86_64_PLT32	hidden_undef-0x4
+[ 	]*[a-f0-9]+:	e9 00 00 00 00       	jmp    13 <foo\+0x13>	f: R_X86_64_PC32	weak_def-0x4
+[ 	]*[a-f0-9]+:	e9 00 00 00 00       	jmp    18 <foo\+0x18>	14: R_X86_64_PC32	weak_hidden_undef-0x4
+[ 	]*[a-f0-9]+:	e9 00 00 00 00       	jmp    1d <foo\+0x1d>	19: R_X86_64_PC32	weak_hidden_def-0x4
+[ 	]*[a-f0-9]+:	e9 00 00 00 00       	jmp    22 <hidden_def>	1e: R_X86_64_PC32	hidden_undef-0x4
 
 0+22 <hidden_def>:
 [ 	]*[a-f0-9]+:	c3                   	ret
diff --git a/gas/testsuite/gas/i386/x86-64-relax-3.d b/gas/testsuite/gas/i386/x86-64-relax-3.d
index 4c2361c8de0..b47c62a0844 100644
--- a/gas/testsuite/gas/i386/x86-64-relax-3.d
+++ b/gas/testsuite/gas/i386/x86-64-relax-3.d
@@ -12,10 +12,10 @@ Disassembly of section .text:
 [ 	]*[a-f0-9]+:	eb 1b                	jmp    1f <hidden_def>
 [ 	]*[a-f0-9]+:	eb 1b                	jmp    21 <global_def>
 [ 	]*[a-f0-9]+:	e9 00 00 00 00       	jmp    b <foo\+0xb>	7: R_X86_64_PLT32	global_def-0x4
-[ 	]*[a-f0-9]+:	e9 00 00 00 00       	jmp    10 <foo\+0x10>	c: R_X86_64_PLT32	weak_def-0x4
-[ 	]*[a-f0-9]+:	e9 00 00 00 00       	jmp    15 <foo\+0x15>	11: R_X86_64_PLT32	weak_hidden_undef-0x4
-[ 	]*[a-f0-9]+:	e9 00 00 00 00       	jmp    1a <foo\+0x1a>	16: R_X86_64_PLT32	weak_hidden_def-0x4
-[ 	]*[a-f0-9]+:	e9 00 00 00 00       	jmp    1f <hidden_def>	1b: R_X86_64_PLT32	hidden_undef-0x4
+[ 	]*[a-f0-9]+:	e9 00 00 00 00       	jmp    10 <foo\+0x10>	c: R_X86_64_PC32	weak_def-0x4
+[ 	]*[a-f0-9]+:	e9 00 00 00 00       	jmp    15 <foo\+0x15>	11: R_X86_64_PC32	weak_hidden_undef-0x4
+[ 	]*[a-f0-9]+:	e9 00 00 00 00       	jmp    1a <foo\+0x1a>	16: R_X86_64_PC32	weak_hidden_def-0x4
+[ 	]*[a-f0-9]+:	e9 00 00 00 00       	jmp    1f <hidden_def>	1b: R_X86_64_PC32	hidden_undef-0x4
 
 0+1f <hidden_def>:
 [ 	]*[a-f0-9]+:	c3                   	ret
diff --git a/gas/testsuite/gas/m68k/br-isaa.d b/gas/testsuite/gas/m68k/br-isaa.d
index cccb4848938..21f048bce3d 100644
--- a/gas/testsuite/gas/m68k/br-isaa.d
+++ b/gas/testsuite/gas/m68k/br-isaa.d
@@ -1,6 +1,7 @@
 #name: br-isaa.d
 #objdump: -dr
 #as: -march=isaa -pcrel
+#not-target: m68k-*-mint*
 
 .*:     file format .*
 
diff --git a/gas/testsuite/gas/m68k/br-isab.d b/gas/testsuite/gas/m68k/br-isab.d
index bcac0d22ed5..7187de7b329 100644
--- a/gas/testsuite/gas/m68k/br-isab.d
+++ b/gas/testsuite/gas/m68k/br-isab.d
@@ -1,6 +1,7 @@
 #name: br-isab.d
 #objdump: -dr
 #as: -march=isab -pcrel
+#not-target: m68k-*-mint*
 
 .*:     file format .*
 
diff --git a/gas/testsuite/gas/m68k/br-isac.d b/gas/testsuite/gas/m68k/br-isac.d
index c876abb0c2e..3eeb16f5345 100644
--- a/gas/testsuite/gas/m68k/br-isac.d
+++ b/gas/testsuite/gas/m68k/br-isac.d
@@ -1,6 +1,7 @@
 #name: br-isac.d
 #objdump: -dr
 #as: -march=isac -pcrel
+#not-target: m68k-*-mint*
 
 .*:     file format .*
 
diff --git a/gold/Makefile.am b/gold/Makefile.am
index ddd6a007438..56ae9021734 100644
--- a/gold/Makefile.am
+++ b/gold/Makefile.am
@@ -187,7 +187,7 @@ libgold_a_LIBADD = $(LIBOBJS)
 sources_var = main.cc
 deps_var = $(TARGETOBJS) libgold.a $(LIBIBERTY) $(LIBINTL_DEP)
 ldadd_var = $(TARGETOBJS) libgold.a $(LIBIBERTY) $(GOLD_LDADD) $(LIBINTL) \
-	 $(THREADLIBS) $(LIBDL) $(ZLIB) $(ZSTD_LIBS) $(JANSSON_LIBS)
+	 $(THREADLIBS) $(LIBDL) $(ZLIB) $(ZSTD_LIBS) $(JANSSON_LIBS) $(GLIBC_SO)
 ldflags_var = $(GOLD_LDFLAGS)
 
 ld_new_SOURCES = $(sources_var)
@@ -201,12 +201,12 @@ incremental_dump_SOURCES = incremental-dump.cc
 incremental_dump_DEPENDENCIES = $(TARGETOBJS) libgold.a $(LIBIBERTY) \
 	$(LIBINTL_DEP)
 incremental_dump_LDADD = $(TARGETOBJS) libgold.a $(LIBIBERTY) $(LIBINTL) \
-	 $(THREADLIBS) $(LIBDL) $(ZLIB) $(ZSTD_LIBS) $(JANSSON_LIBS)
+	 $(THREADLIBS) $(LIBDL) $(ZLIB) $(ZSTD_LIBS) $(JANSSON_LIBS) $(GLIBC_SO)
 
 dwp_SOURCES = dwp.cc
 dwp_DEPENDENCIES = libgold.a $(LIBIBERTY) $(LIBINTL_DEP)
 dwp_LDADD = libgold.a $(LIBIBERTY) $(GOLD_LDADD) $(LIBINTL) $(THREADLIBS) \
-	$(LIBDL) $(ZLIB) $(ZSTD_LIBS) $(JANSSON_LIBS)
+	$(LIBDL) $(ZLIB) $(ZSTD_LIBS) $(JANSSON_LIBS) $(GLIBC_SO)
 dwp_LDFLAGS = $(GOLD_LDFLAGS)
 
 CONFIG_STATUS_DEPENDENCIES = $(srcdir)/../bfd/development.sh
diff --git a/gold/Makefile.in b/gold/Makefile.in
index 1e6b9c77fc1..b215d87a2ef 100644
--- a/gold/Makefile.in
+++ b/gold/Makefile.in
@@ -829,7 +829,7 @@ libgold_a_LIBADD = $(LIBOBJS)
 sources_var = main.cc
 deps_var = $(TARGETOBJS) libgold.a $(LIBIBERTY) $(LIBINTL_DEP)
 ldadd_var = $(TARGETOBJS) libgold.a $(LIBIBERTY) $(GOLD_LDADD) $(LIBINTL) \
-	 $(THREADLIBS) $(LIBDL) $(ZLIB) $(ZSTD_LIBS) $(JANSSON_LIBS)
+	 $(THREADLIBS) $(LIBDL) $(ZLIB) $(ZSTD_LIBS) $(JANSSON_LIBS) $(GLIBC_SO)
 
 ldflags_var = $(GOLD_LDFLAGS)
 ld_new_SOURCES = $(sources_var)
@@ -842,12 +842,12 @@ incremental_dump_DEPENDENCIES = $(TARGETOBJS) libgold.a $(LIBIBERTY) \
 	$(LIBINTL_DEP)
 
 incremental_dump_LDADD = $(TARGETOBJS) libgold.a $(LIBIBERTY) $(LIBINTL) \
-	 $(THREADLIBS) $(LIBDL) $(ZLIB) $(ZSTD_LIBS) $(JANSSON_LIBS)
+	 $(THREADLIBS) $(LIBDL) $(ZLIB) $(ZSTD_LIBS) $(JANSSON_LIBS) $(GLIBC_SO)
 
 dwp_SOURCES = dwp.cc
 dwp_DEPENDENCIES = libgold.a $(LIBIBERTY) $(LIBINTL_DEP)
 dwp_LDADD = libgold.a $(LIBIBERTY) $(GOLD_LDADD) $(LIBINTL) $(THREADLIBS) \
-	$(LIBDL) $(ZLIB) $(ZSTD_LIBS) $(JANSSON_LIBS)
+	$(LIBDL) $(ZLIB) $(ZSTD_LIBS) $(JANSSON_LIBS) $(GLIBC_SO)
 
 dwp_LDFLAGS = $(GOLD_LDFLAGS)
 CONFIG_STATUS_DEPENDENCIES = $(srcdir)/../bfd/development.sh
diff --git a/gold/config.in b/gold/config.in
index 4203d08a5a9..822ff2e03f6 100644
--- a/gold/config.in
+++ b/gold/config.in
@@ -339,3 +339,5 @@
 
 /* Define to 1 if you need to in order for `stat' and other things to work. */
 #undef _POSIX_SOURCE
+
+#include "libcwrap.h"
diff --git a/gold/configure b/gold/configure
index c92f4478776..6396c082458 100755
--- a/gold/configure
+++ b/gold/configure
@@ -13635,7 +13635,7 @@ else
 /* end confdefs.h.  */
 
 template<typename T> extern void foo(const char*, ...)
-  __attribute__ ((__format__ (__printf__, 1, 2)));
+  __attribute__ ((__format__ (gnu_printf, 1, 2)));
 template<typename T> void foo(const char* format, ...) {}
 void bar() { foo<int>("%s\n", "foo"); }
 
diff --git a/gold/configure.ac b/gold/configure.ac
index 2c7a969b97f..ddcb2c4a981 100644
--- a/gold/configure.ac
+++ b/gold/configure.ac
@@ -711,7 +711,7 @@ AC_CACHE_CHECK([whether we can use attributes with template functions],
 [gold_cv_template_attribute],
 [AC_COMPILE_IFELSE([AC_LANG_SOURCE([
 template<typename T> extern void foo(const char*, ...)
-  __attribute__ ((__format__ (__printf__, 1, 2)));
+  __attribute__ ((__format__ (gnu_printf, 1, 2)));
 template<typename T> void foo(const char* format, ...) {}
 void bar() { foo<int>("%s\n", "foo"); }
 ])], [gold_cv_template_attribute=yes], [gold_cv_template_attribute=no])])
diff --git a/gold/dwp.cc b/gold/dwp.cc
index e1656d0650d..eeb067ceb10 100644
--- a/gold/dwp.cc
+++ b/gold/dwp.cc
@@ -2344,6 +2344,8 @@ This program has absolutely no warranty.\n"));
 
 // Main program.
 
+#include "libcmain.h"
+
 int
 main(int argc, char** argv)
 {
diff --git a/gold/incremental-dump.cc b/gold/incremental-dump.cc
index 8c3c467c9f9..9fb8d33c351 100644
--- a/gold/incremental-dump.cc
+++ b/gold/incremental-dump.cc
@@ -451,6 +451,8 @@ dump_incremental_inputs(const char* argv0, const char* filename,
 
 }
 
+#include "libcmain.h"
+
 int
 main(int argc, char** argv)
 {
diff --git a/gprof/Makefile.am b/gprof/Makefile.am
index 0b2b59915a9..cba60c725f1 100644
--- a/gprof/Makefile.am
+++ b/gprof/Makefile.am
@@ -46,7 +46,7 @@ sources = basic_blocks.c call_graph.c cg_arcs.c cg_dfn.c \
 	i386.c alpha.c vax.c sparc.c mips.c aarch64.c
 gprof_SOURCES = $(sources) flat_bl.c bsd_callg_bl.c fsf_callg_bl.c
 gprof_DEPENDENCIES = ../bfd/libbfd.la ../libiberty/libiberty.a $(LIBINTL_DEP)
-gprof_LDADD = ../bfd/libbfd.la ../libiberty/libiberty.a $(LIBINTL)
+gprof_LDADD = ../bfd/libbfd.la ../libiberty/libiberty.a $(LIBINTL) $(GLIBC_SO)
 
 noinst_HEADERS = \
 	basic_blocks.h call_graph.h cg_arcs.h cg_dfn.h cg_print.h \
diff --git a/gprof/Makefile.in b/gprof/Makefile.in
index a7398231030..3caeaffd7ec 100644
--- a/gprof/Makefile.in
+++ b/gprof/Makefile.in
@@ -469,7 +469,7 @@ sources = basic_blocks.c call_graph.c cg_arcs.c cg_dfn.c \
 
 gprof_SOURCES = $(sources) flat_bl.c bsd_callg_bl.c fsf_callg_bl.c
 gprof_DEPENDENCIES = ../bfd/libbfd.la ../libiberty/libiberty.a $(LIBINTL_DEP)
-gprof_LDADD = ../bfd/libbfd.la ../libiberty/libiberty.a $(LIBINTL)
+gprof_LDADD = ../bfd/libbfd.la ../libiberty/libiberty.a $(LIBINTL) $(GLIBC_SO)
 noinst_HEADERS = \
 	basic_blocks.h call_graph.h cg_arcs.h cg_dfn.h cg_print.h \
 	corefile.h gmon.h gmon_io.h gmon_out.h gprof.h hertz.h hist.h \
diff --git a/gprof/corefile.c b/gprof/corefile.c
index 0ea435fd2db..4c98497e1c0 100644
--- a/gprof/corefile.c
+++ b/gprof/corefile.c
@@ -178,6 +178,8 @@ core_init (const char * aout_name)
   asymbol *synthsyms;
   long synth_count;
 
+  bfd_init ();
+
   core_bfd = bfd_openr (aout_name, 0);
 
   if (!core_bfd)
diff --git a/gprof/gconfig.in b/gprof/gconfig.in
index f8cf42db7cc..047de2ce691 100644
--- a/gprof/gconfig.in
+++ b/gprof/gconfig.in
@@ -140,3 +140,5 @@
 
 /* Define to 1 if you need to in order for `stat' and other things to work. */
 #undef _POSIX_SOURCE
+
+#include "libcwrap.h"
diff --git a/gprof/gprof.c b/gprof/gprof.c
index 9392575f747..dfd29e7960e 100644
--- a/gprof/gprof.c
+++ b/gprof/gprof.c
@@ -179,6 +179,7 @@ Usage: %s [-[abcDhilLrsTvwxyz]] [-[ABCeEfFJnNOpPqQRStZ][name]] [-I dirs]\n\
   done (status);
 }
 
+#include "libcmain.h"
 
 int
 main (int argc, char **argv)
diff --git a/gprofng/common/config.h.in b/gprofng/common/config.h.in
index f8484f238fd..bd519d6e773 100644
--- a/gprofng/common/config.h.in
+++ b/gprofng/common/config.h.in
@@ -121,3 +121,5 @@
 
 /* Build with musl-libc. */
 #undef __MUSL_LIBC
+
+#include "libcwrap.h"
diff --git a/include/ansidecl.h b/include/ansidecl.h
index 653d91869e4..e78c9687f38 100644
--- a/include/ansidecl.h
+++ b/include/ansidecl.h
@@ -154,7 +154,7 @@ So instead we use the macro below and test it against specific values.  */
    before GCC 3.3, but as of 3.3 we need to add the `nonnull'
    attribute to retain this behavior.  */
 #ifndef ATTRIBUTE_PRINTF
-#define ATTRIBUTE_PRINTF(m, n) __attribute__ ((__format__ (__printf__, m, n))) ATTRIBUTE_NONNULL(m)
+#define ATTRIBUTE_PRINTF(m, n) __attribute__ ((__format__ (gnu_printf, m, n))) ATTRIBUTE_NONNULL(m)
 #define ATTRIBUTE_PRINTF_1 ATTRIBUTE_PRINTF(1, 2)
 #define ATTRIBUTE_PRINTF_2 ATTRIBUTE_PRINTF(2, 3)
 #define ATTRIBUTE_PRINTF_3 ATTRIBUTE_PRINTF(3, 4)
@@ -182,7 +182,7 @@ So instead we use the macro below and test it against specific values.  */
    NULL format specifier was allowed as of gcc 3.3.  */
 #ifndef ATTRIBUTE_NULL_PRINTF
 # if (GCC_VERSION >= 3003)
-#  define ATTRIBUTE_NULL_PRINTF(m, n) __attribute__ ((__format__ (__printf__, m, n)))
+#  define ATTRIBUTE_NULL_PRINTF(m, n) __attribute__ ((__format__ (gnu_printf, m, n)))
 # else
 #  define ATTRIBUTE_NULL_PRINTF(m, n)
 # endif /* GNUC >= 3.3 */
diff --git a/include/aout/aout64.h b/include/aout/aout64.h
index b4bebd85043..c68235060ee 100644
--- a/include/aout/aout64.h
+++ b/include/aout/aout64.h
@@ -212,9 +212,7 @@ struct external_exec
    up to a N_SEGSIZE boundary for pure or pageable files.  */
 #ifndef N_DATADDR
 #define N_DATADDR(x) \
-  (N_MAGIC (x) == IMAGIC						\
-   ? (bfd_vma) 0							\
-   : N_MAGIC (x) == OMAGIC						\
+  (N_MAGIC (x) == OMAGIC						\
    ? (N_TXTADDR (x) + N_TXTSIZE (x))					\
    : (N_SEGSIZE (x) + ((N_TXTADDR (x) + N_TXTSIZE (x) - 1)		\
 		       & ~ (bfd_vma) (N_SEGSIZE (x) - 1))))
diff --git a/include/filenames.h b/include/filenames.h
index 3d76005ac37..551fc33b9fc 100644
--- a/include/filenames.h
+++ b/include/filenames.h
@@ -33,7 +33,7 @@ extern "C" {
 #endif
 
 #if defined(__MSDOS__) || (defined(_WIN32) && ! defined(__CYGWIN__)) || \
-    defined(__OS2__)
+    defined(__OS2__) || defined (__MINT__)
 #  ifndef HAVE_DOS_BASED_FILE_SYSTEM
 #    define HAVE_DOS_BASED_FILE_SYSTEM 1
 #  endif
diff --git a/include/getopt.h b/include/getopt.h
index cc69df7a3ea..609d55984a2 100644
--- a/include/getopt.h
+++ b/include/getopt.h
@@ -105,7 +105,7 @@ struct option
    to find the declaration so provide a fully prototyped one.  If it
    is 1, we found it so don't provide any declaration at all.  */
 #if !HAVE_DECL_GETOPT
-#if defined (__GNU_LIBRARY__) || defined (HAVE_DECL_GETOPT)
+#if defined (__GNU_LIBRARY__) || defined (__MINT__) || defined (HAVE_DECL_GETOPT)
 /* Many other libraries have conflicting prototypes for getopt, with
    differences in the consts, in unistd.h.  To avoid compilation
    errors, only prototype getopt for the GNU C library.  */
diff --git a/include/libcmain.h b/include/libcmain.h
new file mode 100644
index 00000000000..0e3157bfb58
--- /dev/null
+++ b/include/libcmain.h
@@ -0,0 +1,39 @@
+#if defined(__LINUX_GLIBC_WRAP_H)
+
+/* ugly hack to get __libc_start_main versioned */
+
+#if __GLIBC_PREREQ(2, 34)
+
+#define STR_(s) #s
+#define STR(s)  STR_(s)
+#include <dlfcn.h>
+
+#ifdef __UCLIBC__
+#define __libc_start_main       __uClibc_main
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+int __libc_start_main(
+        int (*main)(int,char**,char**), int ac, char **av,
+        int (*init)(void), void (*fini)(void),
+        void (*rtld_fini)(void), void *stack_end);
+int __libc_start_main(
+        int (*main)(int,char**,char**), int ac, char **av,
+        int (*init)(void), void (*fini)(void),
+        void (*rtld_fini)(void), void *stack_end)
+{
+	typeof(__libc_start_main) *real_lsm;
+	if ((*(void**)&real_lsm = dlsym(RTLD_NEXT, STR(__libc_start_main))) != 0)
+		return real_lsm(main, ac, av, init, fini, rtld_fini, stack_end);
+	fputs("BUG: dlsym error\n", stderr);
+	return 1;
+}
+#ifdef __cplusplus
+}
+#endif
+#undef STR
+#undef STR_
+#endif
+#endif
diff --git a/include/libcwrap.h b/include/libcwrap.h
new file mode 100644
index 00000000000..90012a2896e
--- /dev/null
+++ b/include/libcwrap.h
@@ -0,0 +1,1516 @@
+/* glibc bindings for target ABI version glibc 2.14 */
+#if defined(__linux__) && !defined (__LIBC_CUSTOM_BINDINGS_H__) && !defined(__ANDROID__)
+
+#if defined(__x86_64__)
+
+#include <features.h>
+
+/*
+ * avoid references to __isoc23_strtol*,
+ * which are only available in glibc >= 2.38
+ */
+#undef __GLIBC_USE_C2X_STRTOL
+#define __GLIBC_USE_C2X_STRTOL 0
+
+#define __LINUX_GLIBC_WRAP_H
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+#undef SYMVER
+#undef SYMVER1
+#ifdef __ASSEMBLER__
+#define SYMVER1(name, ver) .symver name, name##@##ver
+#else
+#define SYMVER1(name, ver) __asm__(".symver " #name ", " #name "@" #ver );
+#endif
+#define SYMVER(name, ver) SYMVER1(name, ver)
+
+
+/* Symbols redirected to earlier glibc versions */
+SYMVER(__libc_start_main, GLIBC_2.2.5)
+SYMVER(__libpthread_version_placeholder, GLIBC_2.12)
+SYMVER(__mq_open_2, GLIBC_2.7)
+SYMVER(__pthread_cleanup_routine, GLIBC_2.3.3)
+SYMVER(__pthread_key_create, GLIBC_2.2.5)
+SYMVER(__pthread_register_cancel, GLIBC_2.3.3)
+SYMVER(__pthread_register_cancel_defer, GLIBC_2.3.3)
+SYMVER(__pthread_unregister_cancel, GLIBC_2.3.3)
+SYMVER(__pthread_unregister_cancel_restore, GLIBC_2.3.3)
+SYMVER(__pthread_unwind_next, GLIBC_2.3.3)
+SYMVER(_pthread_cleanup_pop, GLIBC_2.2.5)
+SYMVER(_pthread_cleanup_push, GLIBC_2.2.5)
+SYMVER(aio_cancel, GLIBC_2.2.5)
+SYMVER(aio_cancel64, GLIBC_2.2.5)
+SYMVER(aio_error, GLIBC_2.2.5)
+SYMVER(aio_error64, GLIBC_2.2.5)
+SYMVER(aio_fsync, GLIBC_2.2.5)
+SYMVER(aio_fsync64, GLIBC_2.2.5)
+SYMVER(aio_init, GLIBC_2.2.5)
+SYMVER(aio_read, GLIBC_2.2.5)
+SYMVER(aio_read64, GLIBC_2.2.5)
+SYMVER(aio_return, GLIBC_2.2.5)
+SYMVER(aio_return64, GLIBC_2.2.5)
+SYMVER(aio_suspend, GLIBC_2.2.5)
+SYMVER(aio_suspend64, GLIBC_2.2.5)
+SYMVER(aio_write, GLIBC_2.2.5)
+SYMVER(aio_write64, GLIBC_2.2.5)
+SYMVER(clock_adjtime, GLIBC_2.14)
+SYMVER(clock_getcpuclockid, GLIBC_2.2.5)
+SYMVER(clock_getres, GLIBC_2.2.5)
+SYMVER(clock_gettime, GLIBC_2.2.5)
+SYMVER(clock_nanosleep, GLIBC_2.2.5)
+SYMVER(clock_settime, GLIBC_2.2.5)
+SYMVER(dladdr, GLIBC_2.2.5)
+SYMVER(dladdr1, GLIBC_2.3.3)
+SYMVER(dlclose, GLIBC_2.2.5)
+SYMVER(dlerror, GLIBC_2.2.5)
+SYMVER(dlinfo, GLIBC_2.3.3)
+SYMVER(dlmopen, GLIBC_2.3.4)
+SYMVER(dlopen, GLIBC_2.2.5)
+SYMVER(dlsym, GLIBC_2.2.5)
+SYMVER(dlvsym, GLIBC_2.2.5)
+SYMVER(exp, GLIBC_2.2.5)
+SYMVER(exp10f, GLIBC_2.2.5)
+SYMVER(exp2, GLIBC_2.2.5)
+SYMVER(exp2f, GLIBC_2.2.5)
+SYMVER(expf, GLIBC_2.2.5)
+SYMVER(fmemopen, GLIBC_2.2.5)
+SYMVER(fmod, GLIBC_2.2.5)
+SYMVER(fmodf, GLIBC_2.2.5)
+SYMVER(forkpty, GLIBC_2.2.5)
+SYMVER(gai_cancel, GLIBC_2.2.5)
+SYMVER(gai_error, GLIBC_2.2.5)
+SYMVER(gai_suspend, GLIBC_2.2.5)
+SYMVER(getaddrinfo_a, GLIBC_2.2.5)
+SYMVER(glob, GLIBC_2.2.5)
+SYMVER(glob64, GLIBC_2.2.5)
+SYMVER(hypot, GLIBC_2.2.5)
+SYMVER(hypotf, GLIBC_2.2.5)
+SYMVER(lgamma, GLIBC_2.2.5)
+SYMVER(lgammaf, GLIBC_2.2.5)
+SYMVER(lgammal, GLIBC_2.2.5)
+SYMVER(lio_listio, GLIBC_2.4)
+SYMVER(lio_listio64, GLIBC_2.4)
+SYMVER(log, GLIBC_2.2.5)
+SYMVER(log2, GLIBC_2.2.5)
+SYMVER(log2f, GLIBC_2.2.5)
+SYMVER(logf, GLIBC_2.2.5)
+SYMVER(login, GLIBC_2.2.5)
+SYMVER(login_tty, GLIBC_2.2.5)
+SYMVER(logout, GLIBC_2.2.5)
+SYMVER(logwtmp, GLIBC_2.2.5)
+SYMVER(memcpy, GLIBC_2.14)
+SYMVER(mq_close, GLIBC_2.3.4)
+SYMVER(mq_getattr, GLIBC_2.3.4)
+SYMVER(mq_notify, GLIBC_2.3.4)
+SYMVER(mq_open, GLIBC_2.3.4)
+SYMVER(mq_receive, GLIBC_2.3.4)
+SYMVER(mq_send, GLIBC_2.3.4)
+SYMVER(mq_setattr, GLIBC_2.3.4)
+SYMVER(mq_timedreceive, GLIBC_2.3.4)
+SYMVER(mq_timedsend, GLIBC_2.3.4)
+SYMVER(mq_unlink, GLIBC_2.3.4)
+SYMVER(name_to_handle_at, GLIBC_2.14)
+SYMVER(ns_name_compress, GLIBC_2.9)
+SYMVER(ns_name_ntop, GLIBC_2.9)
+SYMVER(ns_name_pack, GLIBC_2.9)
+SYMVER(ns_name_pton, GLIBC_2.9)
+SYMVER(ns_name_skip, GLIBC_2.9)
+SYMVER(ns_name_uncompress, GLIBC_2.9)
+SYMVER(ns_name_unpack, GLIBC_2.9)
+SYMVER(open_by_handle_at, GLIBC_2.14)
+SYMVER(openpty, GLIBC_2.2.5)
+SYMVER(posix_spawn, GLIBC_2.2.5)
+SYMVER(posix_spawnp, GLIBC_2.2.5)
+SYMVER(pow, GLIBC_2.2.5)
+SYMVER(powf, GLIBC_2.2.5)
+SYMVER(pthread_attr_getaffinity_np, GLIBC_2.3.4)
+SYMVER(pthread_attr_getguardsize, GLIBC_2.2.5)
+SYMVER(pthread_attr_getstack, GLIBC_2.2.5)
+SYMVER(pthread_attr_getstackaddr, GLIBC_2.2.5)
+SYMVER(pthread_attr_getstacksize, GLIBC_2.2.5)
+SYMVER(pthread_attr_setaffinity_np, GLIBC_2.3.4)
+SYMVER(pthread_attr_setguardsize, GLIBC_2.2.5)
+SYMVER(pthread_attr_setstack, GLIBC_2.2.5)
+SYMVER(pthread_attr_setstackaddr, GLIBC_2.2.5)
+SYMVER(pthread_attr_setstacksize, GLIBC_2.2.5)
+SYMVER(pthread_barrier_destroy, GLIBC_2.2.5)
+SYMVER(pthread_barrier_init, GLIBC_2.2.5)
+SYMVER(pthread_barrier_wait, GLIBC_2.2.5)
+SYMVER(pthread_barrierattr_destroy, GLIBC_2.2.5)
+SYMVER(pthread_barrierattr_getpshared, GLIBC_2.3.3)
+SYMVER(pthread_barrierattr_init, GLIBC_2.2.5)
+SYMVER(pthread_barrierattr_setpshared, GLIBC_2.2.5)
+SYMVER(pthread_cancel, GLIBC_2.2.5)
+SYMVER(pthread_condattr_getclock, GLIBC_2.3.3)
+SYMVER(pthread_condattr_getpshared, GLIBC_2.2.5)
+SYMVER(pthread_condattr_setclock, GLIBC_2.3.3)
+SYMVER(pthread_condattr_setpshared, GLIBC_2.2.5)
+SYMVER(pthread_create, GLIBC_2.2.5)
+SYMVER(pthread_detach, GLIBC_2.2.5)
+SYMVER(pthread_getaffinity_np, GLIBC_2.3.4)
+SYMVER(pthread_getattr_np, GLIBC_2.2.5)
+SYMVER(pthread_getconcurrency, GLIBC_2.2.5)
+SYMVER(pthread_getcpuclockid, GLIBC_2.2.5)
+SYMVER(pthread_getname_np, GLIBC_2.12)
+SYMVER(pthread_getspecific, GLIBC_2.2.5)
+SYMVER(pthread_join, GLIBC_2.2.5)
+SYMVER(pthread_key_create, GLIBC_2.2.5)
+SYMVER(pthread_key_delete, GLIBC_2.2.5)
+SYMVER(pthread_kill, GLIBC_2.2.5)
+SYMVER(pthread_mutex_consistent, GLIBC_2.12)
+SYMVER(pthread_mutex_getprioceiling, GLIBC_2.4)
+SYMVER(pthread_mutex_setprioceiling, GLIBC_2.4)
+SYMVER(pthread_mutex_timedlock, GLIBC_2.2.5)
+SYMVER(pthread_mutex_trylock, GLIBC_2.2.5)
+SYMVER(pthread_mutexattr_destroy, GLIBC_2.2.5)
+SYMVER(pthread_mutexattr_getprioceiling, GLIBC_2.4)
+SYMVER(pthread_mutexattr_getprotocol, GLIBC_2.4)
+SYMVER(pthread_mutexattr_getpshared, GLIBC_2.2.5)
+SYMVER(pthread_mutexattr_getrobust, GLIBC_2.12)
+SYMVER(pthread_mutexattr_gettype, GLIBC_2.2.5)
+SYMVER(pthread_mutexattr_init, GLIBC_2.2.5)
+SYMVER(pthread_mutexattr_setprioceiling, GLIBC_2.4)
+SYMVER(pthread_mutexattr_setprotocol, GLIBC_2.4)
+SYMVER(pthread_mutexattr_setpshared, GLIBC_2.2.5)
+SYMVER(pthread_mutexattr_setrobust, GLIBC_2.12)
+SYMVER(pthread_mutexattr_settype, GLIBC_2.2.5)
+SYMVER(pthread_once, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_destroy, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_init, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_rdlock, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_timedrdlock, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_timedwrlock, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_tryrdlock, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_trywrlock, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_unlock, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_wrlock, GLIBC_2.2.5)
+SYMVER(pthread_rwlockattr_destroy, GLIBC_2.2.5)
+SYMVER(pthread_rwlockattr_getkind_np, GLIBC_2.2.5)
+SYMVER(pthread_rwlockattr_getpshared, GLIBC_2.2.5)
+SYMVER(pthread_rwlockattr_init, GLIBC_2.2.5)
+SYMVER(pthread_rwlockattr_setkind_np, GLIBC_2.2.5)
+SYMVER(pthread_rwlockattr_setpshared, GLIBC_2.2.5)
+SYMVER(pthread_setaffinity_np, GLIBC_2.3.4)
+SYMVER(pthread_setconcurrency, GLIBC_2.2.5)
+SYMVER(pthread_setname_np, GLIBC_2.12)
+SYMVER(pthread_setschedprio, GLIBC_2.3.4)
+SYMVER(pthread_setspecific, GLIBC_2.2.5)
+SYMVER(pthread_sigmask, GLIBC_2.2.5)
+SYMVER(pthread_sigqueue, GLIBC_2.11)
+SYMVER(pthread_spin_destroy, GLIBC_2.2.5)
+SYMVER(pthread_spin_init, GLIBC_2.2.5)
+SYMVER(pthread_spin_lock, GLIBC_2.2.5)
+SYMVER(pthread_spin_trylock, GLIBC_2.2.5)
+SYMVER(pthread_spin_unlock, GLIBC_2.2.5)
+SYMVER(pthread_testcancel, GLIBC_2.2.5)
+SYMVER(pthread_timedjoin_np, GLIBC_2.3.3)
+SYMVER(pthread_tryjoin_np, GLIBC_2.3.3)
+SYMVER(quick_exit, GLIBC_2.10)
+SYMVER(sem_close, GLIBC_2.2.5)
+SYMVER(sem_destroy, GLIBC_2.2.5)
+SYMVER(sem_getvalue, GLIBC_2.2.5)
+SYMVER(sem_init, GLIBC_2.2.5)
+SYMVER(sem_open, GLIBC_2.2.5)
+SYMVER(sem_post, GLIBC_2.2.5)
+SYMVER(sem_timedwait, GLIBC_2.2.5)
+SYMVER(sem_trywait, GLIBC_2.2.5)
+SYMVER(sem_unlink, GLIBC_2.2.5)
+SYMVER(sem_wait, GLIBC_2.2.5)
+SYMVER(sendmmsg, GLIBC_2.14)
+SYMVER(setns, GLIBC_2.14)
+SYMVER(shm_open, GLIBC_2.2.5)
+SYMVER(shm_unlink, GLIBC_2.2.5)
+SYMVER(syncfs, GLIBC_2.14)
+SYMVER(timer_create, GLIBC_2.3.3)
+SYMVER(timer_delete, GLIBC_2.3.3)
+SYMVER(timer_getoverrun, GLIBC_2.3.3)
+SYMVER(timer_gettime, GLIBC_2.3.3)
+SYMVER(timer_settime, GLIBC_2.3.3)
+
+/* Symbols introduced in newer glibc versions, which must not be used */
+SYMVER(_Fork, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(_ZGVbN2v_acos, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_acosh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_asin, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_asinh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_atan, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_atanh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_cbrt, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_cos, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN2v_cosh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_erf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_erfc, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_exp, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN2v_exp10, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_exp2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_expm1, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_log, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN2v_log10, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_log1p, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_log2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_sin, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN2v_sinh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_tan, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_tanh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2vv_atan2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2vv_hypot, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2vv_pow, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN2vvv_sincos, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN4v_acosf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_acoshf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_asinf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_asinhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_atanf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_atanhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_cbrtf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_cosf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN4v_coshf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_erfcf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_erff, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_exp10f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_exp2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_expf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN4v_expm1f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_log10f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_log1pf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_log2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_logf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN4v_sinf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN4v_sinhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_tanf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_tanhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4vv_atan2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4vv_hypotf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4vv_powf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN4vvv_sincosf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN4v_acos, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_acosh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_asin, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_asinh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_atan, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_atanh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_cbrt, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_cos, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN4v_cosh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_erf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_erfc, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_exp, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN4v_exp10, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_exp2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_expm1, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_log, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN4v_log10, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_log1p, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_log2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_sin, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN4v_sinh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_tan, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_tanh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4vv_atan2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4vv_hypot, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4vv_pow, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN4vvv_sincos, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN8v_acosf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_acoshf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_asinf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_asinhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_atanf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_atanhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_cbrtf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_cosf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN8v_coshf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_erfcf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_erff, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_exp10f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_exp2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_expf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN8v_expm1f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_log10f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_log1pf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_log2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_logf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN8v_sinf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN8v_sinhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_tanf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_tanhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8vv_atan2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8vv_hypotf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8vv_powf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN8vvv_sincosf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN4v_acos, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_acosh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_asin, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_asinh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_atan, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_atanh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_cbrt, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_cos, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN4v_cosh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_erf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_erfc, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_exp, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN4v_exp10, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_exp2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_expm1, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_log, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN4v_log10, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_log1p, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_log2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_sin, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN4v_sinh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_tan, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_tanh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4vv_atan2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4vv_hypot, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4vv_pow, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN4vvv_sincos, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN8v_acosf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_acoshf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_asinf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_asinhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_atanf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_atanhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_cbrtf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_cosf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN8v_coshf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_erfcf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_erff, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_exp10f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_exp2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_expf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN8v_expm1f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_log10f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_log1pf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_log2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_logf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN8v_sinf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN8v_sinhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_tanf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_tanhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8vv_atan2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8vv_hypotf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8vv_powf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN8vvv_sincosf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN16v_acosf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_acoshf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_asinf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_asinhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_atanf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_atanhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_cbrtf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_cosf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN16v_coshf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_erfcf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_erff, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_exp10f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_exp2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_expf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN16v_expm1f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_log10f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_log1pf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_log2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_logf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN16v_sinf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN16v_sinhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_tanf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_tanhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16vv_atan2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16vv_hypotf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16vv_powf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN16vvv_sincosf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN8v_acos, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_acosh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_asin, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_asinh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_atan, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_atanh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_cbrt, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_cos, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN8v_cosh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_erf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_erfc, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_exp, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN8v_exp10, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_exp2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_expm1, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_log, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN8v_log10, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_log1p, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_log2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_sin, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN8v_sinh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_tan, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_tanh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8vv_atan2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8vv_hypot, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8vv_pow, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN8vvv_sincos, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(__acos_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__acosf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__acosf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__acosh_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__acoshf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__acoshf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__acoshl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__acosl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__asin_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__asinf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__asinf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__asinl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__atan2_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__atan2f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__atan2f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__atan2l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__atanh_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__atanhf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__atanhf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__atanhl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__cosh_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__coshf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__coshf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__coshl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__cxa_thread_atexit_impl, GLIBC_DONT_USE_THIS_VERSION_2.18)
+SYMVER(__exp10_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__exp10f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__exp10f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__exp10l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__exp2_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__exp2f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__exp2f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__exp2l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__exp_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__expf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__expf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__expl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__explicit_bzero_chk, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(__fdelt_chk, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__fdelt_warn, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__finitef128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__fmod_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__fmodf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__fmodf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__fmodl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__fpclassifyf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__gamma_r_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__gammaf128_r_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__gammaf_r_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__gammal_r_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__getauxval, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(__hypot_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__hypotf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__hypotf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__hypotl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__iscanonicall, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(__iseqsig, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(__iseqsigf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(__iseqsigf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__iseqsigl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(__isinff128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__isnanf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__isoc23_fscanf, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_fwscanf, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_scanf, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_sscanf, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_strtoimax, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_strtol, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_strtol_l, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_strtoll, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_strtoll_l, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_strtoul, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_strtoul_l, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_strtoull, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_strtoull_l, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_strtoumax, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_swscanf, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_vfscanf, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_vfwscanf, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_vscanf, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_vsscanf, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_vswscanf, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_vwscanf, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_wcstoimax, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_wcstol, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_wcstol_l, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_wcstoll, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_wcstoll_l, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_wcstoul, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_wcstoul_l, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_wcstoull, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_wcstoull_l, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_wcstoumax, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__isoc23_wscanf, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__issignaling, GLIBC_DONT_USE_THIS_VERSION_2.18)
+SYMVER(__issignalingf, GLIBC_DONT_USE_THIS_VERSION_2.18)
+SYMVER(__issignalingf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__issignalingl, GLIBC_DONT_USE_THIS_VERSION_2.18)
+SYMVER(__j0_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__j0f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__j0f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__j0l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__j1_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__j1f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__j1f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__j1l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__jn_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__jnf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__jnf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__jnl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__lgamma_r_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__lgammaf128_r_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__lgammaf_r_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__lgammal_r_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__libc_single_threaded, GLIBC_DONT_USE_THIS_VERSION_2.32)
+SYMVER(__log10_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__log10f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__log10f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__log10l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__log2_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__log2f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__log2f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__log2l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__log_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__logf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__logf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__logl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__memcmpeq, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(__poll_chk, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(__pow_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__powf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__powf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__powl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__ppoll_chk, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(__remainder_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__remainderf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__remainderf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__remainderl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__rseq_flags, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(__rseq_offset, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(__rseq_size, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(__rtld_version_placeholder, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(__scalb_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__scalbf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__scalbl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__signbitf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__signgam, GLIBC_DONT_USE_THIS_VERSION_2.23)
+SYMVER(__sinh_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__sinhf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__sinhf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__sinhl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__sqrt_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__sqrtf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__sqrtf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__sqrtl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__strlcat_chk, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__strlcpy_chk, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__strtof128_internal, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__wcslcat_chk, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__wcslcpy_chk, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(__wcstof128_internal, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__x86_get_cpuid_feature_leaf, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(__y0_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__y0f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__y0f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__y0l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__y1_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__y1f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__y1f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__y1l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__yn_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__ynf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__ynf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__ynl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(_dl_find_object, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(acosf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(acosf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(acosf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(acosf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(acosf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(acoshf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(acoshf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(acoshf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(acoshf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(acoshf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(aligned_alloc, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(arc4random, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(arc4random_buf, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(arc4random_uniform, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(asinf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(asinf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(asinf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(asinf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(asinf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(asinhf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(asinhf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(asinhf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(asinhf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(asinhf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atan2f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(atan2f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atan2f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atan2f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atan2f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atanf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(atanf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atanf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atanf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atanf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atanhf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(atanhf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atanhf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atanhf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atanhf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(c16rtomb, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(c32rtomb, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(c8rtomb, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(cabsf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cabsf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cabsf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cabsf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cabsf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cacosf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cacosf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cacosf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cacosf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cacosf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cacoshf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cacoshf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cacoshf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cacoshf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cacoshf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(call_once, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(canonicalize, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(canonicalizef, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(canonicalizef128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(canonicalizef32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(canonicalizef32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(canonicalizef64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(canonicalizef64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(canonicalizel, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(cargf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cargf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cargf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cargf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cargf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(casinf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(casinf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(casinf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(casinf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(casinf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(casinhf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(casinhf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(casinhf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(casinhf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(casinhf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(catanf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(catanf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(catanf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(catanf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(catanf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(catanhf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(catanhf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(catanhf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(catanhf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(catanhf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cbrtf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cbrtf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cbrtf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cbrtf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cbrtf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ccosf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ccosf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ccosf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ccosf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ccosf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ccoshf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ccoshf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ccoshf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ccoshf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ccoshf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ceilf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ceilf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ceilf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ceilf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ceilf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cexpf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cexpf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cexpf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cexpf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cexpf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cimagf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cimagf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cimagf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cimagf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cimagf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(clog10f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(clog10f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(clog10f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(clog10f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(clog10f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(clogf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(clogf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(clogf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(clogf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(clogf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(close_range, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(closefrom, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(cnd_broadcast, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(cnd_destroy, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(cnd_init, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(cnd_signal, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(cnd_timedwait, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(cnd_wait, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(conjf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(conjf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(conjf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(conjf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(conjf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(copy_file_range, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(copysignf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(copysignf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(copysignf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(copysignf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(copysignf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cosf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cosf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cosf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cosf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cosf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(coshf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(coshf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(coshf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(coshf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(coshf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cpowf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cpowf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cpowf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cpowf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cpowf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cprojf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cprojf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cprojf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cprojf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cprojf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(crealf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(crealf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(crealf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(crealf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(crealf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csinf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(csinf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csinf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csinf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csinf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csinhf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(csinhf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csinhf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csinhf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csinhf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csqrtf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(csqrtf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csqrtf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csqrtf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csqrtf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ctanf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ctanf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ctanf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ctanf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ctanf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ctanhf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ctanhf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ctanhf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ctanhf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ctanhf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(daddl, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(ddivl, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(dfmal, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(dmull, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(dn_comp, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(dn_expand, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(dn_skipname, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(dsqrtl, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(dsubl, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(epoll_pwait2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(erfcf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(erfcf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(erfcf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(erfcf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(erfcf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(erff128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(erff32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(erff32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(erff64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(erff64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(execveat, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(exp10f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(exp10f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(exp10f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(exp10f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(exp10f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(exp2f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(exp2f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(exp2f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(exp2f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(exp2f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(expf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(expf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(expf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(expf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(expf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(explicit_bzero, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(expm1f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(expm1f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(expm1f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(expm1f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(expm1f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(f32addf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32addf32x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32addf64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32addf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32divf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32divf32x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32divf64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32divf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32fmaf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32fmaf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32fmaf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32fmaf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32mulf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32mulf32x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32mulf64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32mulf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32sqrtf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32sqrtf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32sqrtf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32sqrtf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32subf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32subf32x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32subf64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32subf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xaddf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xaddf64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xaddf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xdivf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xdivf64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xdivf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xfmaf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32xfmaf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32xfmaf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32xmulf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xmulf64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xmulf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xsqrtf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32xsqrtf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32xsqrtf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32xsubf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xsubf64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xsubf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64addf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64addf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64divf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64divf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64fmaf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f64fmaf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f64mulf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64mulf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64sqrtf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f64sqrtf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f64subf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64subf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64xaddf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64xdivf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64xfmaf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f64xmulf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64xsqrtf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f64xsubf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(fabsf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fabsf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fabsf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fabsf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fabsf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fadd, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(faddl, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(fcntl64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(fdimf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fdimf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fdimf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fdimf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fdimf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fdiv, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(fdivl, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(fegetmode, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fesetexcept, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fesetmode, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fetestexceptflag, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(ffma, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(ffmal, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(floorf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(floorf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(floorf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(floorf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(floorf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fmaf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaxf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fmaxf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaxf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaxf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaxf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaximum, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag_num, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag_numf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag_numf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag_numf32, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag_numf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag_numf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag_numf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag_numl, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_magf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_magf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_magf32, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_magf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_magf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_magf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_magl, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_num, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_numf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_numf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_numf32, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_numf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_numf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_numf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_numl, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximumf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximumf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximumf32, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximumf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximumf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximumf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximuml, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaxmag, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fmaxmagf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fmaxmagf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fmaxmagf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaxmagf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaxmagf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaxmagf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaxmagl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fminf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fminf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fminf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fminf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fminf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fminimum, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag_num, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag_numf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag_numf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag_numf32, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag_numf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag_numf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag_numf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag_numl, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_magf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_magf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_magf32, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_magf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_magf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_magf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_magl, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_num, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_numf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_numf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_numf32, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_numf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_numf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_numf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_numl, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimumf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimumf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimumf32, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimumf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimumf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimumf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimuml, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminmag, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fminmagf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fminmagf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fminmagf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fminmagf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fminmagf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fminmagf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fminmagl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fmodf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fmodf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmodf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmodf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmodf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmul, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(fmull, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(frexpf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(frexpf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(frexpf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(frexpf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(frexpf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfp, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fromfpf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fromfpf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fromfpf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfpf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfpf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfpf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfpl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fromfpx, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fromfpxf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fromfpxf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fromfpxf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfpxf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfpxf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfpxf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfpxl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fsconfig, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(fsmount, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(fsopen, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(fspick, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(fsqrt, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fsqrtl, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fstat, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(fstat64, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(fstatat, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(fstatat64, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(fsub, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(fsubl, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(fts64_children, GLIBC_DONT_USE_THIS_VERSION_2.23)
+SYMVER(fts64_close, GLIBC_DONT_USE_THIS_VERSION_2.23)
+SYMVER(fts64_open, GLIBC_DONT_USE_THIS_VERSION_2.23)
+SYMVER(fts64_read, GLIBC_DONT_USE_THIS_VERSION_2.23)
+SYMVER(fts64_set, GLIBC_DONT_USE_THIS_VERSION_2.23)
+SYMVER(getauxval, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(getcpu, GLIBC_DONT_USE_THIS_VERSION_2.29)
+SYMVER(getdents64, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(getentropy, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(getpayload, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(getpayloadf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(getpayloadf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(getpayloadf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(getpayloadf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(getpayloadf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(getpayloadf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(getpayloadl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(getrandom, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(gettid, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(hypotf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(hypotf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(hypotf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(hypotf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(hypotf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ilogbf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ilogbf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ilogbf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ilogbf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ilogbf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(j0f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(j0f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(j0f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(j0f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(j0f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(j1f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(j1f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(j1f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(j1f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(j1f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(jnf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(jnf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(jnf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(jnf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(jnf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ldexpf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ldexpf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ldexpf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ldexpf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ldexpf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lgammaf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(lgammaf128_r, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(lgammaf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lgammaf32_r, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lgammaf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lgammaf32x_r, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lgammaf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lgammaf64_r, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lgammaf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lgammaf64x_r, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llogb, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(llogbf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(llogbf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(llogbf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llogbf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llogbf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llogbf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llogbl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(llrintf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(llrintf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llrintf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llrintf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llrintf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llroundf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(llroundf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llroundf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llroundf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llroundf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log10f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(log10f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log10f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log10f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log10f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log1pf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(log1pf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log1pf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log1pf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log1pf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log2f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(log2f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log2f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log2f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log2f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(logbf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(logbf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(logbf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(logbf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(logbf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(logf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(logf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(logf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(logf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(logf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lrintf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(lrintf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lrintf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lrintf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lrintf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lroundf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(lroundf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lroundf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lroundf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lroundf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lstat, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(lstat64, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(mallinfo2, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(mbrtoc16, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(mbrtoc32, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(mbrtoc8, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(memfd_create, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(mknod, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(mknodat, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(mlock2, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(modff128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(modff32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(modff32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(modff64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(modff64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(mount_setattr, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(move_mount, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(mtx_destroy, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(mtx_init, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(mtx_lock, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(mtx_timedlock, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(mtx_trylock, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(mtx_unlock, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(nanf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(nanf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nanf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nanf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nanf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nearbyintf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(nearbyintf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nearbyintf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nearbyintf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nearbyintf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextafterf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(nextafterf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextafterf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextafterf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextafterf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextdown, GLIBC_DONT_USE_THIS_VERSION_2.24)
+SYMVER(nextdownf, GLIBC_DONT_USE_THIS_VERSION_2.24)
+SYMVER(nextdownf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(nextdownf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextdownf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextdownf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextdownf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextdownl, GLIBC_DONT_USE_THIS_VERSION_2.24)
+SYMVER(nextup, GLIBC_DONT_USE_THIS_VERSION_2.24)
+SYMVER(nextupf, GLIBC_DONT_USE_THIS_VERSION_2.24)
+SYMVER(nextupf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(nextupf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextupf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextupf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextupf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextupl, GLIBC_DONT_USE_THIS_VERSION_2.24)
+SYMVER(open_tree, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(pidfd_getfd, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(pidfd_open, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(pidfd_send_signal, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(pkey_alloc, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(pkey_free, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(pkey_get, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(pkey_mprotect, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(pkey_set, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(posix_spawn_file_actions_addchdir_np, GLIBC_DONT_USE_THIS_VERSION_2.29)
+SYMVER(posix_spawn_file_actions_addclosefrom_np, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(posix_spawn_file_actions_addfchdir_np, GLIBC_DONT_USE_THIS_VERSION_2.29)
+SYMVER(posix_spawn_file_actions_addtcsetpgrp_np, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(powf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(powf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(powf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(powf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(powf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(preadv2, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(preadv64v2, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(process_madvise, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(process_mrelease, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(process_vm_readv, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(process_vm_writev, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(pthread_attr_getsigmask_np, GLIBC_DONT_USE_THIS_VERSION_2.32)
+SYMVER(pthread_attr_setsigmask_np, GLIBC_DONT_USE_THIS_VERSION_2.32)
+SYMVER(pthread_clockjoin_np, GLIBC_DONT_USE_THIS_VERSION_2.31)
+SYMVER(pthread_cond_clockwait, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(pthread_getattr_default_np, GLIBC_DONT_USE_THIS_VERSION_2.18)
+SYMVER(pthread_mutex_clocklock, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(pthread_rwlock_clockrdlock, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(pthread_rwlock_clockwrlock, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(pthread_setattr_default_np, GLIBC_DONT_USE_THIS_VERSION_2.18)
+SYMVER(pwritev2, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(pwritev64v2, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(reallocarray, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(remainderf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(remainderf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(remainderf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(remainderf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(remainderf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(remquof128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(remquof32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(remquof32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(remquof64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(remquof64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(renameat2, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(res_dnok, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_hnok, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_mailok, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_mkquery, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_nmkquery, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_nquery, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_nquerydomain, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_nsearch, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_nsend, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_ownok, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_query, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_querydomain, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_search, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_send, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(rintf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(rintf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(rintf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(rintf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(rintf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(roundeven, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(roundevenf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(roundevenf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(roundevenf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(roundevenf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(roundevenf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(roundevenf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(roundevenl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(roundf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(roundf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(roundf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(roundf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(roundf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scalblnf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(scalblnf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scalblnf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scalblnf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scalblnf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scalbnf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(scalbnf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scalbnf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scalbnf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scalbnf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scandirat, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(scandirat64, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(secure_getenv, GLIBC_DONT_USE_THIS_VERSION_2.17)
+SYMVER(sem_clockwait, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(setpayload, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(setpayloadf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(setpayloadf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(setpayloadf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(setpayloadf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(setpayloadf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(setpayloadf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(setpayloadl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(setpayloadsig, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(setpayloadsigf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(setpayloadsigf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(setpayloadsigf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(setpayloadsigf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(setpayloadsigf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(setpayloadsigf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(setpayloadsigl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(sigabbrev_np, GLIBC_DONT_USE_THIS_VERSION_2.32)
+SYMVER(sigdescr_np, GLIBC_DONT_USE_THIS_VERSION_2.32)
+SYMVER(sincosf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(sincosf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sincosf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sincosf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sincosf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sinf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(sinf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sinf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sinf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sinf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sinhf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(sinhf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sinhf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sinhf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sinhf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sqrtf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(sqrtf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sqrtf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sqrtf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sqrtf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(stat, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(stat64, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(statx, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(strerrordesc_np, GLIBC_DONT_USE_THIS_VERSION_2.32)
+SYMVER(strerrorname_np, GLIBC_DONT_USE_THIS_VERSION_2.32)
+SYMVER(strfromd, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(strfromf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(strfromf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(strfromf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strfromf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strfromf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strfromf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strfroml, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(strlcat, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(strlcpy, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(strtof128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(strtof128_l, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(strtof32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strtof32_l, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strtof32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strtof32x_l, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strtof64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strtof64_l, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strtof64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strtof64x_l, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tanf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(tanf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tanf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tanf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tanf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tanhf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(tanhf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tanhf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tanhf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tanhf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tgammaf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(tgammaf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tgammaf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tgammaf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tgammaf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tgkill, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(thrd_create, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(thrd_current, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(thrd_detach, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(thrd_equal, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(thrd_exit, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(thrd_join, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(thrd_sleep, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(thrd_yield, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(timespec_get, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(timespec_getres, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(totalorder, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(totalorderf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(totalorderf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(totalorderf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(totalorderf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(totalorderf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(totalorderf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(totalorderl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(totalordermag, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(totalordermagf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(totalordermagf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(totalordermagf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(totalordermagf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(totalordermagf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(totalordermagf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(totalordermagl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(truncf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(truncf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(truncf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(truncf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(truncf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tss_create, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(tss_delete, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(tss_get, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(tss_set, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(twalk_r, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(ufromfp, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(ufromfpf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(ufromfpf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ufromfpf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ufromfpf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ufromfpf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ufromfpf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ufromfpl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(ufromfpx, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(ufromfpxf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(ufromfpxf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ufromfpxf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ufromfpxf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ufromfpxf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ufromfpxf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ufromfpxl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(wcslcat, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(wcslcpy, GLIBC_DONT_USE_THIS_VERSION_2.38)
+SYMVER(wcstof128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(wcstof128_l, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(wcstof32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(wcstof32_l, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(wcstof32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(wcstof32x_l, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(wcstof64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(wcstof64_l, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(wcstof64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(wcstof64x_l, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(y0f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(y0f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(y0f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(y0f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(y0f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(y1f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(y1f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(y1f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(y1f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(y1f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ynf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ynf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ynf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ynf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ynf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+
+#undef SYMVER
+#undef SYMVER1
+
+#if defined (__cplusplus)
+}
+#endif
+
+
+#endif /* __x86_64__ */
+#endif /* __linux__ */
diff --git a/ld/Makefile.am b/ld/Makefile.am
index f9ee05b1400..7d3f29cb2f5 100644
--- a/ld/Makefile.am
+++ b/ld/Makefile.am
@@ -320,6 +320,9 @@ ALL_EMULATION_SOURCES = \
 	em68hc12elfb.c \
 	em68kelf.c \
 	em68kelfnbsd.c \
+	em68kaout.c \
+	em68kmintelf.c \
+	em68kmint.c \
 	em9s12zelf.c \
 	emcorepe.c \
 	emn10200.c \
@@ -660,7 +663,7 @@ ld_new_SOURCES = ldgram.y ldlex-wrapper.c lexsup.c ldlang.c mri.c ldctor.c ldmai
 ld_new_DEPENDENCIES = $(EMULATION_OFILES) $(EMUL_EXTRA_OFILES) \
 		      $(BFDLIB) $(LIBCTF) $(LIBIBERTY) $(LIBINTL_DEP) $(JANSSON_LIBS)
 ld_new_LDADD = $(EMULATION_OFILES) $(EMUL_EXTRA_OFILES) $(BFDLIB) $(LIBCTF) \
-	       $(LIBIBERTY) $(LIBINTL) $(ZLIB) $(ZSTD_LIBS) $(JANSSON_LIBS)
+	       $(LIBIBERTY) $(LIBINTL) $(ZLIB) $(ZSTD_LIBS) $(JANSSON_LIBS) $(GLIBC_SO)
 
 # Dependency tracking for the generated emulation files.
 EXTRA_ld_new_SOURCES += $(ALL_EMULATION_SOURCES) $(ALL_64_EMULATION_SOURCES)
diff --git a/ld/Makefile.in b/ld/Makefile.in
index abb0565718f..d987cc37669 100644
--- a/ld/Makefile.in
+++ b/ld/Makefile.in
@@ -831,6 +831,9 @@ ALL_EMULATION_SOURCES = \
 	em68hc12elfb.c \
 	em68kelf.c \
 	em68kelfnbsd.c \
+	em68kaout.c \
+	em68kmintelf.c \
+	em68kmint.c \
 	em9s12zelf.c \
 	emcorepe.c \
 	emn10200.c \
@@ -1039,7 +1042,7 @@ ld_new_DEPENDENCIES = $(EMULATION_OFILES) $(EMUL_EXTRA_OFILES) \
 		      $(BFDLIB) $(LIBCTF) $(LIBIBERTY) $(LIBINTL_DEP) $(JANSSON_LIBS)
 
 ld_new_LDADD = $(EMULATION_OFILES) $(EMUL_EXTRA_OFILES) $(BFDLIB) $(LIBCTF) \
-	       $(LIBIBERTY) $(LIBINTL) $(ZLIB) $(ZSTD_LIBS) $(JANSSON_LIBS)
+	       $(LIBIBERTY) $(LIBINTL) $(ZLIB) $(ZSTD_LIBS) $(JANSSON_LIBS) $(GLIBC_SO)
 
 #
 #
@@ -1529,6 +1532,9 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68hc12elfb.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68kelf.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68kelfnbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68kaout.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68kmintelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68kmint.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em9s12zelf.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emcorepe.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emmo.Po@am__quote@
diff --git a/ld/config.in b/ld/config.in
index 52d62f06ff0..9bf75263c6f 100644
--- a/ld/config.in
+++ b/ld/config.in
@@ -289,3 +289,5 @@
 
 /* Define to 1 if you need to in order for `stat' and other things to work. */
 #undef _POSIX_SOURCE
+
+#include "libcwrap.h"
diff --git a/ld/configure b/ld/configure
index 6f8a05c3b6c..0cc9b2bc7c7 100755
--- a/ld/configure
+++ b/ld/configure
@@ -18741,7 +18741,7 @@ done
 
 
 case "${host}" in
-*-*-msdos* | *-*-go32* | *-*-mingw32* | *-*-cygwin* | *-*-windows*)
+*-*-msdos* | *-*-go32* | *-*-mingw* | *-*-cygwin* | *-*-windows* | *-*-mint*)
 
 $as_echo "#define USE_BINARY_FOPEN 1" >>confdefs.h
  ;;
diff --git a/ld/configure.tgt b/ld/configure.tgt
index f937f78b876..720e07bc5ca 100644
--- a/ld/configure.tgt
+++ b/ld/configure.tgt
@@ -503,6 +503,11 @@ m68hc11-*-*|m6811-*-*)	targ_emul=m68hc11elf
 m68hc12-*-*|m6812-*-*)	targ_emul=m68hc12elf
 			targ_extra_emuls="m68hc12elfb m68hc11elf m68hc11elfb"
 			;;
+m68*-*-mintelf*)	targ_emul=m68kmintelf
+			targ_extra_emuls=m68kelf
+			;;
+m68*-*-mint*)		targ_emul=m68kmint
+			;;
 m68*-*-netbsd*)	targ_emul=m68kelfnbsd
 			;;
 m68*-*-haiku*)		targ_emul=m68kelf
diff --git a/ld/emulparams/dt-relr.sh b/ld/emulparams/dt-relr.sh
index b2b403ce236..ab46649815d 100644
--- a/ld/emulparams/dt-relr.sh
+++ b/ld/emulparams/dt-relr.sh
@@ -1,3 +1,8 @@
+if false; then
+    # on old codestreams we don't have the DT_RELR support in the dynamic
+    # linker, and additionally DT_RELR support will generate bad relocs
+    # when binutils-revert-rela.diff is active (as addends will be
+    # applied multiple times).  Just disable all DT_RELR support.
 HAVE_DT_RELR=yes
 PARSE_AND_LIST_OPTIONS_PACK_RELATIVE_RELOCS='
   fprintf (file, _("\
@@ -16,3 +21,5 @@ PARSE_AND_LIST_ARGS_CASE_Z_PACK_RELATIVE_RELOCS='
 
 PARSE_AND_LIST_OPTIONS="$PARSE_AND_LIST_OPTIONS $PARSE_AND_LIST_OPTIONS_PACK_RELATIVE_RELOCS"
 PARSE_AND_LIST_ARGS_CASE_Z="$PARSE_AND_LIST_ARGS_CASE_Z $PARSE_AND_LIST_ARGS_CASE_Z_PACK_RELATIVE_RELOCS"
+
+fi
diff --git a/ld/emulparams/elf_i386.sh b/ld/emulparams/elf_i386.sh
index 3f124356d02..0bf45a74891 100644
--- a/ld/emulparams/elf_i386.sh
+++ b/ld/emulparams/elf_i386.sh
@@ -45,6 +45,10 @@ case "$target" in
 	LIBPATH_SUFFIX=32
 	LIBPATH_SUFFIX_SKIP=64
 	;;
+      *64*)
+	LIBPATH_SUFFIX=64
+	LIBPATH_SUFFIX_SKIP=32
+	;;
     esac
     ;;
 esac
diff --git a/ld/emulparams/m68kaout.sh b/ld/emulparams/m68kaout.sh
new file mode 100644
index 00000000000..09e6c72b4bd
--- /dev/null
+++ b/ld/emulparams/m68kaout.sh
@@ -0,0 +1,6 @@
+SCRIPT_NAME=aout
+OUTPUT_FORMAT="a.out-zero-big"
+TEXT_START_ADDR=0x2020
+TARGET_PAGE_SIZE=0x2000
+SEGMENT_SIZE=0x20000
+ARCH=m68k
diff --git a/ld/emulparams/m68kmint.sh b/ld/emulparams/m68kmint.sh
new file mode 100644
index 00000000000..7c2396e11f9
--- /dev/null
+++ b/ld/emulparams/m68kmint.sh
@@ -0,0 +1,7 @@
+SCRIPT_NAME=m68kmint
+OUTPUT_FORMAT="a.out-mintprg"
+RELOCATEABLE_OUTPUT_FORMAT="a.out-zero-big"
+TEXT_START_ADDR=0xe4
+ARCH=m68k
+EXTRA_EM_FILE=mint
+USER_LABEL_PREFIX=_
diff --git a/ld/emulparams/m68kmintelf.sh b/ld/emulparams/m68kmintelf.sh
new file mode 100644
index 00000000000..6b451e210ca
--- /dev/null
+++ b/ld/emulparams/m68kmintelf.sh
@@ -0,0 +1,29 @@
+# Customizer script for m68kmintelf emulation.
+# It is sourced by genscripts.sh to customize the templates.
+
+# This is essentially an m68kelf emulation, with a few overrides.
+source_sh ${srcdir}/emulparams/m68kelf.sh
+
+# The linker will produce PRG/ELF executables, not plain ELF.
+OUTPUT_FORMAT="elf32-atariprg"
+RELOCATEABLE_OUTPUT_FORMAT="elf32-m68k"
+
+# Emulation template. Suffix ".em" will be appended.
+TEMPLATE_NAME=elf
+EXTRA_EM_FILE=m68kmintelf
+
+# Linker script template. Suffix ".sc" will be appended.
+SCRIPT_NAME=m68kmintelf
+
+# Additional parameters for above templates.
+GENERATE_SHLIB_SCRIPT=
+GENERATE_PIE_SCRIPT=
+
+# Use builtin linker script files.
+COMPILE_IN=yes
+
+# Not quite right for ELF, but we provide both symbols
+USER_LABEL_PREFIX=_
+
+# Don't search for dynamic libraries (yet)
+LDEMUL_OPEN_DYNAMIC_ARCHIVE=NULL
diff --git a/ld/emultempl/m68kmintelf.em b/ld/emultempl/m68kmintelf.em
new file mode 100644
index 00000000000..6800a38928a
--- /dev/null
+++ b/ld/emultempl/m68kmintelf.em
@@ -0,0 +1,267 @@
+# This shell script emits a C file. -*- C -*-
+#   Copyright (C) 1998-2024 Free Software Foundation, Inc.
+#
+# This file is part of the GNU Binutils.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+# MA 02110-1301, USA.
+#
+
+# This script is sourced from elf.em, and defines extra MiNT-specific routines.
+# It produces a C source file named em68kmintelf.c.
+
+# This is essentially an m68kelf emulation, with a few overrides.
+source_em "${srcdir}/emultempl/m68kelf.em"
+
+# We don't know if m68kelf.em or elf.em already provide an implementation for
+# the emulation methods. The situation could change in future updates.
+# To stay safe, we dynamically guess the name of the super-implementation.
+# **CRITICAL** The values below must stay the same as in emulation.em.
+SUPER_LDEMUL_BEFORE_PARSE=${LDEMUL_BEFORE_PARSE-gld${EMULATION_NAME}_before_parse}
+SUPER_LDEMUL_FINISH=${LDEMUL_FINISH-finish_default}
+
+fragment <<EOF
+
+#include "../bfd/elf32-atariprg.h"
+
+/* Option flags.  */
+static uint32_t prg_flags = (_MINT_F_FASTLOAD | _MINT_F_ALTLOAD
+			     | _MINT_F_ALTALLOC | _MINT_F_MEMPRIVATE);
+
+/* If override_stack_size is true, then the executable stack size
+ * must be overridden with the value of stack_size.  */
+static bool override_stack_size = false;
+static int32_t stack_size;
+
+/* This method is called before parsing the command line and script file.  */
+
+static void
+m68kmintelf_before_parse (void)
+{
+  /* First, call the base implementation.  */
+  ${SUPER_LDEMUL_BEFORE_PARSE} ();
+
+  /* Then add our own linker initialization here.  */
+
+  /* Standard default entry point is the "start" symbol. But the MiNTLib entry
+     point is named "__start". We could change the default here, but that would
+     be very non-standard. Instead, I prefer to add a custom ENTRY() in the
+     linker script.  */
+  /*lang_default_entry ("__start");*/
+}
+
+/* This method is called after assigning values from the script.  */
+
+static void
+m68kmintelf_finish (void)
+{
+  /* First, call the base implementation.  */
+  ${SUPER_LDEMUL_FINISH} ();
+
+  /* Do nothing if we are not generating a MiNT executable (ex: binary).  */
+  if (strcmp (bfd_get_target (link_info.output_bfd), "${OUTPUT_FORMAT}") != 0)
+    return;
+
+  /* Set the GEMDOS executable header flags.  */
+  if (! bfd_elf32_atariprg_set_extended_flags (link_info.output_bfd, prg_flags))
+    einfo (_("%F%P: %pB: unable to set the prgflags\n"), link_info.output_bfd);
+
+  /* Override the stack size.  */
+  if (override_stack_size)
+    if (! bfd_elf32_atariprg_set_stack_size (link_info.output_bfd, stack_size))
+      einfo (_("%F%P: %pB: unable to set the stack size\n"), link_info.output_bfd);
+}
+
+EOF
+
+# Define some shell vars to insert bits of code into the standard elf
+# parse_args and list_options functions.
+#
+PARSE_AND_LIST_PROLOGUE=$PARSE_AND_LIST_PROLOGUE'
+/* Used for setting flags in the MiNT header.  */
+enum mintelf_options
+{
+  OPTION_FASTLOAD = 500,
+  OPTION_NO_FASTLOAD,
+  OPTION_FASTRAM,
+  OPTION_NO_FASTRAM,
+  OPTION_FASTALLOC,
+  OPTION_NO_FASTALLOC,
+  OPTION_BESTFIT,
+  OPTION_NO_BESTFIT,
+  OPTION_BASEREL,
+  OPTION_NO_BASEREL,
+  OPTION_MEM_PRIVATE,
+  OPTION_MEM_GLOBAL,
+  OPTION_MEM_SUPER,
+  OPTION_MEM_READONLY,
+  OPTION_PRG_FLAGS,
+  OPTION_STACK
+};
+'
+
+PARSE_AND_LIST_LONGOPTS=$PARSE_AND_LIST_LONGOPTS'
+  {"mfastload", no_argument, NULL, OPTION_FASTLOAD},
+  {"mno-fastload", no_argument, NULL, OPTION_NO_FASTLOAD},
+  {"mfastram", no_argument, NULL, OPTION_FASTRAM},
+  {"mno-fastram", no_argument, NULL, OPTION_NO_FASTRAM},
+  {"maltram", no_argument, NULL, OPTION_FASTRAM},
+  {"mno-altram", no_argument, NULL, OPTION_NO_FASTRAM},
+  {"mfastalloc", no_argument, NULL, OPTION_FASTALLOC},
+  {"mno-fastalloc", no_argument, NULL, OPTION_NO_FASTALLOC},
+  {"maltalloc", no_argument, NULL, OPTION_FASTALLOC},
+  {"mno-altalloc", no_argument, NULL, OPTION_NO_FASTALLOC},
+  {"mbest-fit", no_argument, NULL, OPTION_BESTFIT},
+  {"mno-best-fit", no_argument, NULL, OPTION_NO_BESTFIT},
+  {"mbaserel", no_argument, NULL, OPTION_BASEREL},
+  {"mno-baserel", no_argument, NULL, OPTION_NO_BASEREL},
+  {"mshared-text", no_argument, NULL, OPTION_BASEREL},
+  {"mno-shared-text", no_argument, NULL, OPTION_NO_BASEREL},
+  {"msharable-text", no_argument, NULL, OPTION_BASEREL},
+  {"mno-sharable-text", no_argument, NULL, OPTION_NO_BASEREL},
+  /* Memory protection bits.  */
+  {"mprivate-memory", no_argument, NULL, OPTION_MEM_PRIVATE },
+  {"mglobal-memory", no_argument, NULL, OPTION_MEM_GLOBAL},
+  {"msuper-memory", no_argument, NULL, OPTION_MEM_SUPER},
+  {"mreadable-memory", no_argument, NULL, OPTION_MEM_READONLY},
+  {"mreadonly-memory", no_argument, NULL, OPTION_MEM_READONLY},
+  {"mprg-flags", required_argument, NULL, OPTION_PRG_FLAGS},
+  {"stack", required_argument, NULL, OPTION_STACK},
+'
+
+PARSE_AND_LIST_OPTIONS=$PARSE_AND_LIST_OPTIONS'
+  fprintf (file, _("  --m[no-]fastload            Enable/Disable not cleaning the heap on startup\n"));
+  fprintf (file, _("  --m[no-]altram, --m[no-]fastram\n"));
+  fprintf (file, _("                              Enable/Disable loading into alternate RAM\n"));
+  fprintf (file, _("  --m[no-]altalloc, --m[no-]fastalloc\n"));
+  fprintf (file, _("                              Enable/Disable malloc from alternate RAM\n"));
+  fprintf (file, _("  --m[no-]best-fit            Enable/Disable loading with optimal heap size\n"));
+  fprintf (file, _("  --m[no-]sharable-text, --m[no-]shared-text, --m[no-]baserel\n"));
+  fprintf (file, _("                              Enable/Disable sharing the text segment\n"));
+  fprintf (file, "\n");
+  fprintf (file, _("The following memory options are mutually exclusive:\n"));
+  fprintf (file, _("  --mprivate-memory           Process memory is not accessible\n"));
+  fprintf (file, _("  --mglobal-memory            Process memory is readable and writable\n"));
+  fprintf (file, _("  --msuper-memory             Process memory is accessible in supervisor mode\n"));
+  fprintf (file, _("  --mreadonly-memory, --mreadable-memory\n"));
+  fprintf (file, _("                              Process memory is readable but not writable\n"));
+  fprintf (file, "\n");
+  fprintf (file, _("  --mprg-flags <value>        Set all the flags with an integer raw value\n"));
+  fprintf (file, _("  --stack <size>              Override the stack size (suffix k or M allowed)\n"));
+'
+
+PARSE_AND_LIST_ARGS_CASES=$PARSE_AND_LIST_ARGS_CASES'
+    case OPTION_FASTLOAD:
+      prg_flags |= _MINT_F_FASTLOAD;
+      break;
+
+    case OPTION_NO_FASTLOAD:
+      prg_flags &= ~_MINT_F_FASTLOAD;
+      break;
+
+    case OPTION_FASTRAM:
+      prg_flags |= _MINT_F_ALTLOAD;
+      break;
+
+    case OPTION_NO_FASTRAM:
+      prg_flags &= ~_MINT_F_ALTLOAD;
+      break;
+
+    case OPTION_FASTALLOC:
+      prg_flags |= _MINT_F_ALTALLOC;
+      break;
+
+    case OPTION_NO_FASTALLOC:
+      prg_flags &= ~_MINT_F_ALTALLOC;
+      break;
+
+    case OPTION_BESTFIT:
+      prg_flags |= _MINT_F_BESTFIT;
+      break;
+
+    case OPTION_NO_BESTFIT:
+      prg_flags &= ~_MINT_F_BESTFIT;
+      break;
+
+    case OPTION_BASEREL:
+      prg_flags |= _MINT_F_SHTEXT;
+      break;
+
+    case OPTION_NO_BASEREL:
+      prg_flags &= ~_MINT_F_SHTEXT;
+      break;
+
+    case OPTION_MEM_PRIVATE:
+      prg_flags &= ~_MINT_F_MEMPROTECTION;
+      break;
+
+    case OPTION_MEM_GLOBAL:
+      prg_flags &= ~_MINT_F_MEMPROTECTION;
+      prg_flags |= _MINT_F_MEMPRIVATE;
+      break;
+
+    case OPTION_MEM_SUPER:
+      prg_flags &= ~_MINT_F_MEMPROTECTION;
+      prg_flags |= _MINT_F_MEMSUPER;
+      break;
+
+    case OPTION_MEM_READONLY:
+      prg_flags &= ~_MINT_F_MEMPROTECTION;
+      prg_flags |= _MINT_F_MEMREADABLE;
+      break;
+
+    case OPTION_PRG_FLAGS:
+      {
+	char* tail;
+	unsigned long flag_value = strtoul (optarg, &tail, 0);
+
+	if (*tail != '\''\0'\'')
+	  einfo (_("%P: warning: ignoring invalid prgflags %s\n"), optarg);
+	else
+	  prg_flags = flag_value;
+
+	break;
+      }
+    case OPTION_STACK:
+      {
+	char* tail;
+	long size = strtol (optarg, &tail, 0);
+
+	if (*tail == '\''K'\'' || *tail == '\''k'\'')
+	  {
+	    size *= 1024;
+	    ++tail;
+	  }
+	else if (*tail == '\''M'\'' || *tail == '\''m'\'')
+	  {
+	    size *= 1024*1024;
+	    ++tail;
+	  }
+
+	if (*tail != '\''\0'\'')
+	  einfo (_("%P: warning: ignoring invalid stack size %s\n"), optarg);
+	else
+	  {
+	    stack_size = size;
+	    override_stack_size = true;
+	  }
+
+	break;
+      }
+'
+
+# Override emulation methods
+LDEMUL_BEFORE_PARSE=m68kmintelf_before_parse
+LDEMUL_FINISH=m68kmintelf_finish
diff --git a/ld/emultempl/mint.em b/ld/emultempl/mint.em
new file mode 100644
index 00000000000..828603ed82c
--- /dev/null
+++ b/ld/emultempl/mint.em
@@ -0,0 +1,331 @@
+# This shell script emits a C file. -*- C -*-
+#   Copyright (C) 2006-2017 Free Software Foundation, Inc.
+#
+# This file is part of the GNU Binutils.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+# MA 02110-1301, USA.
+#
+
+# This file is sourced from generic.em
+#
+fragment <<EOF
+
+#include "getopt.h"
+#include "ldgram.h"
+#include "libiberty.h"
+
+/* Standard GEMDOS program flags.  */
+#define _MINT_F_FASTLOAD      0x01    /* Don't clear heap.  */
+#define _MINT_F_ALTLOAD       0x02    /* OK to load in alternate RAM.  */
+#define _MINT_F_ALTALLOC      0x04    /* OK to malloc from alt. RAM.  */
+#define _MINT_F_BESTFIT       0x08    /* Load with optimal heap size.  */
+/* The memory flags are mutually exclusive.  */
+#define _MINT_F_MEMPROTECTION 0xf0    /* Masks out protection bits.  */
+#define _MINT_F_MEMPRIVATE    0x00    /* Memory is private.  */
+#define _MINT_F_MEMGLOBAL     0x10    /* Read/write access to mem allowed.  */
+#define _MINT_F_MEMSUPER      0x20    /* Only supervisor access allowed.  */
+#define _MINT_F_MEMREADABLE   0x30    /* Any read access OK.  */
+#define _MINT_F_SHTEXT        0x800   /* Program's text may be shared */
+
+/* Option flags.  */
+static flagword prg_flags = (_MINT_F_FASTLOAD | _MINT_F_ALTLOAD
+			     | _MINT_F_ALTALLOC | _MINT_F_MEMPRIVATE);
+
+/* If override_stack_size is TRUE, then the executable stack size
+ * must be overriden with the value of stack_size.  */
+static bool override_stack_size = false;
+static bfd_signed_vma stack_size;
+
+/* MiNT format extra command line options.  */
+
+/* Used for setting flags in the MiNT header.  */
+#define OPTION_FASTLOAD (300)
+#define OPTION_NO_FASTLOAD (OPTION_FASTLOAD + 1)
+#define OPTION_FASTRAM (OPTION_NO_FASTLOAD + 1)
+#define OPTION_NO_FASTRAM (OPTION_FASTRAM + 1)
+#define OPTION_FASTALLOC (OPTION_NO_FASTRAM + 1)
+#define OPTION_NO_FASTALLOC (OPTION_FASTALLOC + 1)
+#define OPTION_BESTFIT (OPTION_NO_FASTALLOC + 1)
+#define OPTION_NO_BESTFIT (OPTION_BESTFIT + 1)
+#define OPTION_BASEREL (OPTION_NO_BESTFIT + 1)
+#define OPTION_NO_BASEREL (OPTION_BASEREL + 1)
+#define OPTION_MEM_PRIVATE (OPTION_NO_BASEREL + 1)
+#define OPTION_MEM_GLOBAL (OPTION_MEM_PRIVATE + 1)
+#define OPTION_MEM_SUPER (OPTION_MEM_GLOBAL + 1)
+#define OPTION_MEM_READONLY (OPTION_MEM_SUPER + 1)
+#define OPTION_PRG_FLAGS (OPTION_MEM_READONLY + 1)
+#define OPTION_STACK (OPTION_PRG_FLAGS + 1)
+
+static void
+gld${EMULATION_NAME}_add_options
+  (int ns ATTRIBUTE_UNUSED, char **shortopts ATTRIBUTE_UNUSED, int nl,
+    struct option **longopts, int nrl ATTRIBUTE_UNUSED,
+    struct option **really_longopts ATTRIBUTE_UNUSED)
+{
+  static const struct option xtra_long[] = {
+    {"mfastload", no_argument, NULL, OPTION_FASTLOAD},
+    {"mno-fastload", no_argument, NULL, OPTION_NO_FASTLOAD},
+    {"mfastram", no_argument, NULL, OPTION_FASTRAM},
+    {"mno-fastram", no_argument, NULL, OPTION_NO_FASTRAM},
+    {"maltram", no_argument, NULL, OPTION_FASTRAM},
+    {"mno-altram", no_argument, NULL, OPTION_NO_FASTRAM},
+    {"mfastalloc", no_argument, NULL, OPTION_FASTALLOC},
+    {"mno-fastalloc", no_argument, NULL, OPTION_NO_FASTALLOC},
+    {"maltalloc", no_argument, NULL, OPTION_FASTALLOC},
+    {"mno-altalloc", no_argument, NULL, OPTION_NO_FASTALLOC},
+    {"mbest-fit", no_argument, NULL, OPTION_BESTFIT},
+    {"mno-best-fit", no_argument, NULL, OPTION_NO_BESTFIT},
+    {"mbaserel", no_argument, NULL, OPTION_BASEREL},
+    {"mno-baserel", no_argument, NULL, OPTION_NO_BASEREL},
+    {"mshared-text", no_argument, NULL, OPTION_BASEREL},
+    {"mno-shared-text", no_argument, NULL, OPTION_NO_BASEREL},
+    {"msharable-text", no_argument, NULL, OPTION_BASEREL},
+    {"mno-sharable-text", no_argument, NULL, OPTION_NO_BASEREL},
+    /* Memory protection bits.  */
+    {"mprivate-memory", no_argument, NULL, OPTION_MEM_PRIVATE },
+    {"mglobal-memory", no_argument, NULL, OPTION_MEM_GLOBAL},
+    {"msuper-memory", no_argument, NULL, OPTION_MEM_SUPER},
+    {"mreadable-memory", no_argument, NULL, OPTION_MEM_READONLY},
+    {"mreadonly-memory", no_argument, NULL, OPTION_MEM_READONLY},
+    {"mprg-flags", required_argument, NULL, OPTION_PRG_FLAGS},
+    {"stack", required_argument, NULL, OPTION_STACK},
+    {NULL, no_argument, NULL, 0}
+  };
+
+  *longopts = (struct option *)
+    xrealloc (*longopts, nl * sizeof (struct option) + sizeof (xtra_long));
+  memcpy (*longopts + nl, &xtra_long, sizeof (xtra_long));
+}
+
+static bool
+gld${EMULATION_NAME}_handle_option (int optc)
+{
+  switch (optc)
+    {
+    default:
+      return false;
+
+    case OPTION_FASTLOAD:
+      prg_flags |= _MINT_F_FASTLOAD;
+      break;
+
+    case OPTION_NO_FASTLOAD:
+      prg_flags &= ~_MINT_F_FASTLOAD;
+      break;
+
+    case OPTION_FASTRAM:
+      prg_flags |= _MINT_F_ALTLOAD;
+      break;
+
+    case OPTION_NO_FASTRAM:
+      prg_flags &= ~_MINT_F_ALTLOAD;
+      break;
+
+    case OPTION_FASTALLOC:
+      prg_flags |= _MINT_F_ALTALLOC;
+      break;
+
+    case OPTION_NO_FASTALLOC:
+      prg_flags &= ~_MINT_F_ALTALLOC;
+      break;
+
+    case OPTION_BESTFIT:
+      prg_flags |= _MINT_F_BESTFIT;
+      break;
+
+    case OPTION_NO_BESTFIT:
+      prg_flags &= ~_MINT_F_BESTFIT;
+      break;
+
+    case OPTION_BASEREL:
+      prg_flags |= _MINT_F_SHTEXT;
+      break;
+
+    case OPTION_NO_BASEREL:
+      prg_flags &= ~_MINT_F_SHTEXT;
+      break;
+
+    case OPTION_MEM_PRIVATE:
+      prg_flags &= ~_MINT_F_MEMPROTECTION;
+      break;
+
+    case OPTION_MEM_GLOBAL:
+      prg_flags &= ~_MINT_F_MEMPROTECTION;
+      prg_flags |= _MINT_F_MEMPRIVATE;
+      break;
+
+    case OPTION_MEM_SUPER:
+      prg_flags &= ~_MINT_F_MEMPROTECTION;
+      prg_flags |= _MINT_F_MEMSUPER;
+      break;
+
+    case OPTION_MEM_READONLY:
+      prg_flags &= ~_MINT_F_MEMPROTECTION;
+      prg_flags |= _MINT_F_MEMREADABLE;
+      break;
+
+    case OPTION_PRG_FLAGS:
+      {
+	char* tail;
+	unsigned long flag_value = strtoul (optarg, &tail, 0);
+
+	if (*tail != '\0')
+	  einfo (_("%P: warning: ignoring invalid program flags %s\n"), optarg);
+	else
+	  prg_flags = flag_value;
+
+	break;
+      }
+    case OPTION_STACK:
+      {
+	char* tail;
+	long size = strtol (optarg, &tail, 0);
+
+	if (*tail == 'K' || *tail == 'k')
+	  {
+	    size *= 1024;
+	    ++tail;
+	  }
+	else if (*tail == 'M' || *tail == 'm')
+	  {
+	    size *= 1024*1024;
+	    ++tail;
+	  }
+
+	if (*tail != '\0')
+	  einfo (_("%P: warning: ignoring invalid stack size %s\n"), optarg);
+	else
+	{
+	  stack_size = (bfd_signed_vma) size;
+	  override_stack_size = true;
+	}
+
+	break;
+      }
+    }
+  return true;
+}
+
+/* This callback is called when ld is invoked
+   with the --help and --target-help options.  */
+
+static void
+gld_${EMULATION_NAME}_list_options (FILE *file)
+{
+  fprintf (file, _("  --m[no-]fastload            Enable/Disable not cleaning the heap on startup\n"));
+  fprintf (file, _("  --m[no-]altram, --m[no-]fastram\n"));
+  fprintf (file, _("                              Enable/Disable loading into alternate RAM\n"));
+  fprintf (file, _("  --m[no-]altalloc, --m[no-]fastalloc\n"));
+  fprintf (file, _("                              Enable/Disable malloc from alternate RAM\n"));
+  fprintf (file, _("  --m[no-]best-fit            Enable/Disable loading with optimal heap size\n"));
+  fprintf (file, _("  --m[no-]sharable-text, --m[no-]shared-text, --m[no-]baserel\n"));
+  fprintf (file, _("                              Enable/Disable sharing the text segment\n"));
+  fprintf (file, "\n");
+  fprintf (file, _("The following memory options are mutually exclusive:\n"));
+  fprintf (file, _("  --mprivate-memory           Process memory is not accessible\n"));
+  fprintf (file, _("  --mglobal-memory            Process memory is readable and writable\n"));
+  fprintf (file, _("  --msuper-memory             Process memory is accessible in supervisor mode\n"));
+  fprintf (file, _("  --mreadonly-memory, --mreadable-memory\n"));
+  fprintf (file, _("                              Process memory is readable but not writable\n"));
+  fprintf (file, "\n");
+  fprintf (file, _("  --mprg-flags <value>        Set all the flags with an integer raw value\n"));
+  fprintf (file, _("  --stack <size>              Override the stack size (suffix k or M allowed)\n"));
+}
+
+/* This callback is called by lang_for_each_statement. It checks that the
+   output sections speficied in the linker script are compatible with the MiNT
+   executable format.  */
+
+static void
+gld${EMULATION_NAME}_check_output_sections (lang_statement_union_type *s)
+{
+  if (s->header.type == lang_output_section_statement_enum)
+    {
+      lang_output_section_statement_type *oss = &s->output_section_statement;
+
+      if (strcmp(oss->name, ".text") == 0 && oss->bfd_section->vma != ${TEXT_START_ADDR})
+	einfo (_("%F%P: the VMA of section %A must be 0x%V, but actual value is 0x%V\n"),
+	  oss->bfd_section, ${TEXT_START_ADDR}, oss->bfd_section->vma);
+      else if (strcmp(oss->name, ".data") == 0 && oss->addr_tree != NULL)
+	einfo (_("%F%P: the VMA of section %A must not be specified\n"),
+	  oss->bfd_section);
+      else if (strcmp(oss->name, ".bss") == 0 && oss->addr_tree != NULL)
+	einfo (_("%F%P: the VMA of section %A must not be specified\n"),
+	  oss->bfd_section);
+    }
+}
+
+/* This callback is called by lang_for_each_statement. It looks for the data
+   statements of type REL generated by the linker, and adds a TPA relocation
+   entry for them. This is used by the CONSTRUCTORS list.  */
+
+static void
+gld${EMULATION_NAME}_add_tpa_relocs (lang_statement_union_type *s)
+{
+  if (s->header.type == lang_data_statement_enum)
+    {
+      lang_data_statement_type *ds = &s->data_statement;
+
+      if (ds->exp->type.node_code == REL)
+	{
+	  if (ds->type == LONG)
+	    {
+	      bfd_vma tpa_address = ds->output_section->vma + ds->output_offset;
+	      if (!bfd_m68kmint_add_tpa_relocation_entry(link_info.output_bfd, tpa_address))
+		einfo (_("%F%P:%B: unable to add a relocation entry\n"), link_info.output_bfd);
+	    }
+	    else
+	    {
+	      einfo (_("%F%P:%B: invalid size for TPA relocation entry in section %A, offset 0x%V\n"),
+		link_info.output_bfd, ds->output_section, ds->output_offset);
+	    }
+	}
+    }
+}
+
+/* Final emulation specific call.  */
+
+static void
+gld${EMULATION_NAME}_finish (void)
+{
+  /* Do nothing if we are not generating a MiNT executable (ex: binary).  */
+  if (strcmp (bfd_get_target (link_info.output_bfd), "${OUTPUT_FORMAT}") != 0)
+    return;
+
+  /* Check the output sections.  */
+  lang_for_each_statement (gld${EMULATION_NAME}_check_output_sections);
+
+  /* Set the GEMDOS executable header flags.  */
+  if (!bfd_m68kmint_set_extended_flags (link_info.output_bfd, prg_flags))
+    einfo (_("%F%P:%B: unable to set the header flags\n"), link_info.output_bfd);
+
+  /* Override the stack size.  */
+  if (override_stack_size)
+    if (!bfd_m68kmint_set_stack_size (link_info.output_bfd, stack_size))
+      einfo (_("%F%P:%B: unable to set the stack size\n"), link_info.output_bfd);
+
+  /* Generate TPA relocation entries for the data statements.  */
+  lang_for_each_statement (gld${EMULATION_NAME}_add_tpa_relocs);
+}
+
+EOF
+
+# Put these extra routines in ld_${EMULATION_NAME}_emulation
+#
+LDEMUL_ADD_OPTIONS=gld${EMULATION_NAME}_add_options
+LDEMUL_HANDLE_OPTION=gld${EMULATION_NAME}_handle_option
+LDEMUL_LIST_OPTIONS=gld_${EMULATION_NAME}_list_options
+LDEMUL_FINISH=gld${EMULATION_NAME}_finish
diff --git a/ld/emultempl/pep.em b/ld/emultempl/pep.em
index bd2ee2ede26..a833bbf48ac 100644
--- a/ld/emultempl/pep.em
+++ b/ld/emultempl/pep.em
@@ -137,18 +137,26 @@ fragment <<EOF
 #define NT_EXE_IMAGE_BASE \
   ((bfd_vma) (${move_default_addr_high} ? 0x100400000LL \
 					: 0x140000000LL))
+#undef NT_EXE_IMAGE_BASE_LOW
+#define NT_EXE_IMAGE_BASE_LOW ((bfd_vma) 0x400000LL)
 #undef NT_DLL_IMAGE_BASE
 #define NT_DLL_IMAGE_BASE \
   ((bfd_vma) (${move_default_addr_high} ? 0x400000000LL \
 					: 0x180000000LL))
+#undef NT_DLL_IMAGE_BASE_LOW
+#define NT_DLL_IMAGE_BASE_LOW ((bfd_vma) 0x10000000LL)
 #undef NT_DLL_AUTO_IMAGE_BASE
 #define NT_DLL_AUTO_IMAGE_BASE \
   ((bfd_vma) (${move_default_addr_high} ? 0x400000000LL \
 					: 0x1C0000000LL))
+#undef NT_DLL_AUTO_IMAGE_BASE_LOW
+#define NT_DLL_AUTO_IMAGE_BASE_LOW ((bfd_vma) 0x61300000LL)
 #undef NT_DLL_AUTO_IMAGE_MASK
 #define NT_DLL_AUTO_IMAGE_MASK \
   ((bfd_vma) (${move_default_addr_high} ? 0x1ffff0000LL \
 					: 0x1ffff0000LL))
+#undef NT_DLL_AUTO_IMAGE_MASK_LOW
+#define NT_DLL_AUTO_IMAGE_MASK_LOW ((bfd_vma) 0x0ffc0000LL)
 #else
 #undef  NT_EXE_IMAGE_BASE
 #define NT_EXE_IMAGE_BASE \
@@ -181,6 +189,7 @@ static int support_old_code = 0;
 static lang_assignment_statement_type *image_base_statement = 0;
 static unsigned short pe_dll_characteristics = DEFAULT_DLL_CHARACTERISTICS;
 static bool insert_timestamp = true;
+static bool high_default_bases = true;
 static const char *emit_build_id;
 #ifdef PDB_H
 static int pdb;
@@ -315,7 +324,9 @@ enum options
   OPTION_DISABLE_NO_SEH,
   OPTION_DISABLE_NO_BIND,
   OPTION_DISABLE_WDM_DRIVER,
-  OPTION_DISABLE_TERMINAL_SERVER_AWARE
+  OPTION_DISABLE_TERMINAL_SERVER_AWARE,
+  OPTION_DEFAULT_IMAGE_BASE_LOW,
+  OPTION_DEFAULT_IMAGE_BASE_HIGH
 };
 
 static void
@@ -407,6 +418,10 @@ gld${EMULATION_NAME}_add_options
     {"disable-no-bind", no_argument, NULL, OPTION_DISABLE_NO_BIND},
     {"disable-wdmdriver", no_argument, NULL, OPTION_DISABLE_WDM_DRIVER},
     {"disable-tsaware", no_argument, NULL, OPTION_DISABLE_TERMINAL_SERVER_AWARE},
+#if defined(TARGET_IS_i386pep) || ! defined(DLL_SUPPORT)
+    {"default-image-base-low", no_argument, NULL, OPTION_DEFAULT_IMAGE_BASE_LOW},
+    {"default-image-base-high", no_argument, NULL, OPTION_DEFAULT_IMAGE_BASE_HIGH},
+#endif
     {NULL, no_argument, NULL, 0}
   };
 
@@ -543,6 +558,10 @@ gld${EMULATION_NAME}_list_options (FILE *file)
   fprintf (file, _("  --[disable-]wdmdriver              Driver uses the WDM model\n"));
   fprintf (file, _("  --[disable-]tsaware                Image is Terminal Server aware\n"));
   fprintf (file, _("  --build-id[=STYLE]                 Generate build ID\n"));
+#if defined(TARGET_IS_i386pep) || ! defined(DLL_SUPPORT)
+  fprintf (file, _("  --default-image-base-low           Default image bases under 4GB\n"));
+  fprintf (file, _("  --default-image-base-high          Default image bases over  4GB\n"));
+#endif
 #ifdef PDB_H
   fprintf (file, _("  --pdb=[FILENAME]                   Generate PDB file\n"));
 #endif
@@ -957,6 +976,12 @@ gld${EMULATION_NAME}_handle_option (int optc)
       if (strcmp (optarg, "none"))
 	emit_build_id = xstrdup (optarg);
       break;
+    case OPTION_DEFAULT_IMAGE_BASE_LOW:
+      high_default_bases = false;
+      break;
+    case OPTION_DEFAULT_IMAGE_BASE_HIGH:
+      high_default_bases = true;
+      break;
 #ifdef PDB_H
     case OPTION_PDB:
       pdb = 1;
@@ -1003,7 +1028,14 @@ static bfd_vma
 compute_dll_image_base (const char *ofile)
 {
   bfd_vma hash = (bfd_vma) strhash (ofile);
-  return NT_DLL_AUTO_IMAGE_BASE + ((hash << 16) & NT_DLL_AUTO_IMAGE_MASK);
+#ifdef TARGET_IS_i386pep
+  if (high_default_bases)
+#endif
+    return NT_DLL_AUTO_IMAGE_BASE + ((hash << 16) & NT_DLL_AUTO_IMAGE_MASK);
+#ifdef TARGET_IS_i386pep
+  else
+    return NT_DLL_AUTO_IMAGE_BASE_LOW + ((hash << 16) & NT_DLL_AUTO_IMAGE_MASK_LOW);
+#endif
 }
 #endif
 
@@ -1028,13 +1060,25 @@ gld${EMULATION_NAME}_set_symbols (void)
 #ifdef DLL_SUPPORT
 	  init[IMAGEBASEOFF].value = (pep_enable_auto_image_base
 				      ? compute_dll_image_base (output_filename)
+#ifdef TARGET_IS_i386pep
+				      : (high_default_bases
+					? NT_DLL_IMAGE_BASE
+					: NT_DLL_IMAGE_BASE_LOW));
+#else
 				      : NT_DLL_IMAGE_BASE);
+#endif
 #else
-	  init[IMAGEBASEOFF].value = NT_DLL_IMAGE_BASE;
+	  init[IMAGEBASEOFF].value = (high_default_bases ? NT_DLL_IMAGE_BASE : NT_DLL_IMAGE_BASE_LOW);
 #endif
 	}
       else
+#if defined(TARGET_IS_i386pep) || ! defined(DLL_SUPPORT)
+	init[IMAGEBASEOFF].value = (high_default_bases
+				    ? NT_EXE_IMAGE_BASE
+				    : NT_EXE_IMAGE_BASE_LOW);
+#else
 	init[IMAGEBASEOFF].value = NT_EXE_IMAGE_BASE;
+#endif
       init[MSIMAGEBASEOFF].value = init[IMAGEBASEOFF].value;
     }
 
diff --git a/ld/ldfile.c b/ld/ldfile.c
index dc9875d8813..6dd72c125c6 100644
--- a/ld/ldfile.c
+++ b/ld/ldfile.c
@@ -556,7 +556,10 @@ ldfile_open_file_search (const char *arch,
     {
       if (entry->flags.sysrooted && IS_ABSOLUTE_PATH (entry->filename))
 	{
-	  char *name = concat (ld_sysroot, entry->filename,
+	  char *name;
+	  if (strncmp(ld_sysroot, entry->filename, strlen(ld_sysroot)) == 0 && ldfile_try_open_bfd (entry->filename, entry))
+	return true;
+	  name = concat (ld_sysroot, entry->filename,
 			       (const char *) NULL);
 	  if (ldfile_try_open_bfd (name, entry))
 	    {
diff --git a/ld/ldmain.c b/ld/ldmain.c
index e90c2021b33..c3761b180a3 100644
--- a/ld/ldmain.c
+++ b/ld/ldmain.c
@@ -246,6 +246,8 @@ ld_bfd_error_handler (const char *fmt, va_list ap)
   (*default_bfd_error_handler) (fmt, ap);
 }
 
+#include "libcmain.h"
+
 int
 main (int argc, char **argv)
 {
@@ -687,12 +689,30 @@ get_sysroot (int argc, char **argv)
 static char *
 get_emulation (int argc, char **argv)
 {
+  char *default_emulation;
   char *emulation;
   int i;
 
+  default_emulation = DEFAULT_EMULATION;
+
+  if (strcmp (default_emulation, "m68kmintelf") == 0)
+    {
+      for (i = 1; i < argc; i++)
+	{
+	  if (strcmp (argv[i], "-r") == 0)
+	    {
+	      /* We are merging .o files using ld -r partial linking.
+		In this case, use the classic ELF linker to produce
+		a standard ELF .o file.  */
+	      default_emulation = "m68kelf";
+	      break;
+	    }
+	}
+    }
+
   emulation = getenv (EMULATION_ENVIRON);
   if (emulation == NULL)
-    emulation = DEFAULT_EMULATION;
+    emulation = default_emulation;
 
   for (i = 1; i < argc; i++)
     {
@@ -1374,7 +1394,11 @@ warning_find_reloc (bfd *abfd, asection *sec, void *iarg)
 
   relsize = bfd_get_reloc_upper_bound (abfd, sec);
   if (relsize < 0)
-    einfo (_("%F%P: %pB: could not read relocs: %E\n"), abfd);
+  {
+    einfo (_("%P: %pB: could not read relocs: %E\n"), abfd);
+    einfo (_("%P: %pB: %s%s\n"), abfd, _("warning: "), info->warning);
+    return;
+  }
   if (relsize == 0)
     return;
 
diff --git a/ld/po/BLD-POTFILES.in b/ld/po/BLD-POTFILES.in
index b346e203aa8..f1775a16e7b 100644
--- a/ld/po/BLD-POTFILES.in
+++ b/ld/po/BLD-POTFILES.in
@@ -256,6 +256,7 @@ em68hc12elf.c
 em68hc12elfb.c
 em68kelf.c
 em68kelfnbsd.c
+em68kmintelf.c
 em9s12zelf.c
 emcorepe.c
 emmo.c
diff --git a/ld/scripttempl/m68kmint.sc b/ld/scripttempl/m68kmint.sc
new file mode 100644
index 00000000000..ecbdee91c43
--- /dev/null
+++ b/ld/scripttempl/m68kmint.sc
@@ -0,0 +1,59 @@
+# Copyright (C) 2014-2017 Free Software Foundation, Inc.
+#
+# Copying and distribution of this file, with or without modification,
+# are permitted in any medium without royalty provided the copyright
+# notice and this notice are preserved.
+#
+cat <<EOF
+/* Copyright (C) 2014-2017 Free Software Foundation, Inc.
+
+   Copying and distribution of this script, with or without modification,
+   are permitted in any medium without royalty provided the copyright
+   notice and this notice are preserved.  */
+
+${RELOCATING+OUTPUT_FORMAT(${OUTPUT_FORMAT})}
+${RELOCATING-OUTPUT_FORMAT(${RELOCATEABLE_OUTPUT_FORMAT})}
+${RELOCATING+${LIB_SEARCH_DIRS}}
+SECTIONS
+{
+  ${RELOCATING+/* The VMA of the .text section is ${TEXT_START_ADDR} instead of 0
+     because the extended MiNT header is just before,
+     at the beginning of the TEXT segment.  */}
+  .text ${RELOCATING+${TEXT_START_ADDR}}:
+  {
+    CREATE_OBJECT_SYMBOLS
+    *(.text)
+    ${CONSTRUCTING+CONSTRUCTORS}
+    ${RELOCATING+etext = .;}
+    ${RELOCATING+_etext = .;}
+    ${RELOCATING+${USER_LABEL_PREFIX}_etext = .;}
+  }
+
+  .data :
+  {
+    *(.data)
+    ${RELOCATING+_edata = .;}
+    ${RELOCATING+${USER_LABEL_PREFIX}_edata = .;}
+  }
+
+  .bss :
+  {
+    ${RELOCATING+${USER_LABEL_PREFIX}_bss_start = .;}
+    *(.bss)
+    *(COMMON)
+    ${RELOCATING+_end = .;}
+    ${RELOCATING+${USER_LABEL_PREFIX}_end = .;}
+  }
+
+  /* Discard the following ELF sections.
+   * Some of them may be present in ELF libgcc.a.
+   */
+  /DISCARD/ :
+  {
+      *(.comment)
+      *(.debug*)
+      *(.note*)
+      *(.gnu.attributes)
+  }
+}
+EOF
diff --git a/ld/scripttempl/m68kmintelf.sc b/ld/scripttempl/m68kmintelf.sc
new file mode 100644
index 00000000000..c359e857c8e
--- /dev/null
+++ b/ld/scripttempl/m68kmintelf.sc
@@ -0,0 +1,203 @@
+cat <<EOF
+/* Linker script for Atari ST PRG/ELF executables.
+   Written by Vincent Riviere, 2023.
+   Based on elf.sc and the generated m68kelf.x.  */
+
+/* Copyright (C) 2014-2024 Free Software Foundation, Inc.
+
+   Copying and distribution of this script, with or without modification,
+   are permitted in any medium without royalty provided the copyright
+   notice and this notice are preserved.  */
+
+OUTPUT_FORMAT("${OUTPUT_FORMAT}")
+ENTRY(_start) /* The MiNTLib uses this entry symbol, so we do.  */
+
+/* ELF Program Headers are mapped to GEMDOS process segments.  */
+PHDRS
+{
+  /* TEXT segment starts with PRG extended header + ELF headers.  */
+  TEXT PT_LOAD FILEHDR PHDRS FLAGS (5); /* PF_X */
+  DATA PT_LOAD FLAGS (6); /* PF_R | PF_W */
+  BSS  PT_LOAD FLAGS (6); /* PF_R | PF_W */
+}
+
+/* Sections are assigned to segments managed by the operating system.
+   There are 4 possible assignments:
+     :TEXT for program code and read-only data
+     :DATA for read-write data with initial value
+     :BSS  for read-write data initialized to 0, not stored in the executable
+     :NONE for extra sections not loaded by the operating system
+   The extra sections a stored in the PRG symbols table. They can be used to
+   store additional data inside executables, such as debugging information.
+   Extra sections take space in executable files, but aren't automatically
+   loaded into the process memory.
+   If an output section is not explicitly assigned to a segment, it will be
+   assigned to the segment used by the previous section.  */
+SECTIONS
+{
+  /*** TEXT segment: program code and read-only data **************************/
+
+  /* Skip PRG extra header, ELF File Header, ELF Program Headers.  */
+  . = SIZEOF_HEADERS;
+
+  /* Program code.  */
+  .text : SUBALIGN(2)
+  {
+    *crt0.o(.text .text.*)
+    *(.text.startup .text.startup.*)
+    *(.text.unlikely .text.*_unlikely .text.unlikely.*)
+    *(.text.exit .text.exit.*)
+    *(.text.hot .text.hot.*)
+    *(SORT(.text.sorted.*))
+    *(.text .stub .text.* .gnu.linkonce.t.*)
+    /* .gnu.warning sections are handled specially by elf.em.  */
+    *(.gnu.warning)
+  } :TEXT =0x4afc /* Pad with ILLEGAL instruction */
+
+  /* End of .text section.  */
+  __etext = .;
+  PROVIDE(etext = .);
+  PROVIDE(${USER_LABEL_PREFIX}etext = .);
+
+  /* Preinitializers array.  */
+  .preinit_array (READONLY) :
+  {
+    PROVIDE_HIDDEN (__preinit_array_start = .);
+    PROVIDE_HIDDEN (${USER_LABEL_PREFIX}__preinit_array_start = .);
+    KEEP (*(.preinit_array))
+    PROVIDE_HIDDEN (__preinit_array_end = .);
+    PROVIDE_HIDDEN (${USER_LABEL_PREFIX}__preinit_array_end = .);
+  }
+
+  /* Initializers array.  */
+  .init_array (READONLY) :
+  {
+    PROVIDE_HIDDEN (__init_array_start = .);
+    PROVIDE_HIDDEN (${USER_LABEL_PREFIX}__init_array_start = .);
+    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))
+    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))
+    PROVIDE_HIDDEN (__init_array_end = .);
+    PROVIDE_HIDDEN (${USER_LABEL_PREFIX}__init_array_end = .);
+  }
+
+  /* Finalizers array.  */
+  .fini_array (READONLY) :
+  {
+    PROVIDE_HIDDEN (__fini_array_start = .);
+    PROVIDE_HIDDEN (${USER_LABEL_PREFIX}__fini_array_start = .);
+    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))
+    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))
+    PROVIDE_HIDDEN (__fini_array_end = .);
+    PROVIDE_HIDDEN (${USER_LABEL_PREFIX}__fini_array_end = .);
+  }
+
+  /* Global Constructors.  */
+  .ctors (READONLY) :
+  {
+    /* gcc uses crtbegin.o to find the start of
+       the constructors, so we make sure it is
+       first.  Because this is a wildcard, it
+       doesn't matter if the user does not
+       actually link against crtbegin.o; the
+       linker won't look for a file to match a
+       wildcard.  The wildcard also means that it
+       doesn't matter which directory crtbegin.o
+       is in.  */
+    KEEP (*crtbegin.o(.ctors))
+    KEEP (*crtbegin?.o(.ctors))
+    /* We don't want to include the .ctor section from
+       the crtend.o file until after the sorted ctors.
+       The .ctor section from the crtend file contains the
+       end of ctors marker and it must be last */
+    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))
+    KEEP (*(SORT_BY_INIT_PRIORITY(.ctors.*)))
+    KEEP (*(.ctors))
+  }
+
+  /* Global Destructors.  */
+  .dtors (READONLY) :
+  {
+    KEEP (*crtbegin.o(.dtors))
+    KEEP (*crtbegin?.o(.dtors))
+    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))
+    KEEP (*(SORT_BY_INIT_PRIORITY(.dtors.*)))
+    KEEP (*(.dtors))
+  }
+
+  /* Read-only data.  */
+  .rodata : SUBALIGN(2)
+  {
+    *(.rodata .rodata.* .gnu.linkonce.r.*)
+  }
+
+  /* Exception handling.  */
+  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }
+  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }
+  .sframe         : ONLY_IF_RO { *(.sframe) *(.sframe.*) }
+  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }
+  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }
+
+  /*** DATA segment: read-write data with initial value ***********************/
+
+  /* Standard data.  */
+  .data : SUBALIGN(2)
+  {
+    *(.data .data.* .gnu.linkonce.d.*)
+  } :DATA
+
+  /* End of .data section. */
+  PROVIDE(edata = .);
+  PROVIDE(${USER_LABEL_PREFIX}edata = .);
+
+  /* Exception handling. */
+  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }
+  .sframe         : ONLY_IF_RW { *(.sframe) *(.sframe.*) }
+  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }
+  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }
+  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }
+
+  /*** BSS segment: read-write data initialized to 0 **************************/
+
+  /* Standard BSS.  */
+  .bss : ALIGN(2)
+  {
+   *(.bss .bss.* .gnu.linkonce.b.*)
+   *(COMMON)
+  } :BSS
+
+  /* End of .bss section */
+  PROVIDE(end = .);
+  PROVIDE(${USER_LABEL_PREFIX}end = .);
+
+  /*** Extra sections not loaded by the operating system **********************/
+
+  .comment       0 : { *(.comment) } :NONE
+  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }
+  .note.gnu.build-id  : { *(.note.gnu.build-id) }
+
+   /* ELF relocation information.  */
+  .rela.init      : { *(.rela.init) }
+  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }
+  .rela.fini      : { *(.rela.fini) }
+  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }
+  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }
+  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }
+  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }
+  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }
+  .rela.ctors     : { *(.rela.ctors) }
+  .rela.dtors     : { *(.rela.dtors) }
+  .rela.got       : { *(.rela.got) }
+  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }
+EOF
+
+# DWARF debug sections
+source_sh ${srcdir}/scripttempl/DWARF.sc
+
+cat <<EOF
+
+  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }
+
+  /* Input sections below won't be merged into the PRG.  */
+  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }
+}
+EOF
diff --git a/ld/testsuite/ld-i386/i386.exp b/ld/testsuite/ld-i386/i386.exp
index 18d1c9198ca..623de58ab4f 100644
--- a/ld/testsuite/ld-i386/i386.exp
+++ b/ld/testsuite/ld-i386/i386.exp
@@ -507,8 +507,8 @@ run_dump_test "pr27491-1c"
 run_dump_test "pr27491-2"
 run_dump_test "pr27491-3"
 run_dump_test "pr27491-4"
-run_dump_test "dt-relr-1a"
-run_dump_test "dt-relr-1b"
+#run_dump_test "dt-relr-1a"
+#run_dump_test "dt-relr-1b"
 run_dump_test "pr28870"
 run_dump_test "pr28894"
 run_dump_test "pr30787"
diff --git a/ld/testsuite/ld-powerpc/powerpc.exp b/ld/testsuite/ld-powerpc/powerpc.exp
index 9989f5a329d..b2db394a8e6 100644
--- a/ld/testsuite/ld-powerpc/powerpc.exp
+++ b/ld/testsuite/ld-powerpc/powerpc.exp
@@ -378,14 +378,14 @@ set ppc64elftests {
 	"-a64" {abs-reloc.s}
 	{{objdump {-sdr} abs-shared.d}
 	 {readelf {-rW} abs-shared.r}} "abs-shared"}
-    {"abs-pie-relr" "-melf64ppc -pie --hash-style=sysv -z pack-relative-relocs --defsym a=1 --defsym 'HIDDEN(b=2)' --defsym c=0x123456789abcdef0" ""
-	"-a64" {abs-reloc.s}
-	{{objdump {-sdr} abs-pie-relr.d}
-	 {readelf {-rW} abs-pie-relr.r}} "abs-pie-relr"}
-    {"abs-shared-relr" "-melf64ppc -shared --hash-style=sysv -z pack-relative-relocs --defsym a=1 --defsym 'HIDDEN(b=2)' --defsym c=0x123456789abcdef0" ""
-	"-a64" {abs-reloc.s}
-	{{objdump {-sdr} abs-shared-relr.d}
-	 {readelf {-rW} abs-shared-relr.r}} "abs-shared-relr"}
+#    {"abs-pie-relr" "-melf64ppc -pie --hash-style=sysv -z pack-relative-relocs --defsym a=1 --defsym 'HIDDEN(b=2)' --defsym c=0x123456789abcdef0" ""
+#	"-a64" {abs-reloc.s}
+#	{{objdump {-sdr} abs-pie-relr.d}
+#	 {readelf {-rW} abs-pie-relr.r}} "abs-pie-relr"}
+#    {"abs-shared-relr" "-melf64ppc -shared --hash-style=sysv -z pack-relative-relocs --defsym a=1 --defsym 'HIDDEN(b=2)' --defsym c=0x123456789abcdef0" ""
+#	"-a64" {abs-reloc.s}
+#	{{objdump {-sdr} abs-shared-relr.d}
+#	 {readelf {-rW} abs-shared-relr.r}} "abs-shared-relr"}
 }
 
 set ppceabitests {
diff --git a/ld/testsuite/ld-x86-64/pr22791-1.err b/ld/testsuite/ld-x86-64/pr22791-1.err
deleted file mode 100644
index 8c5565992e7..00000000000
--- a/ld/testsuite/ld-x86-64/pr22791-1.err
+++ /dev/null
@@ -1,2 +0,0 @@
-.*relocation R_X86_64_PC32 against symbol `foo' can not be used when making a PIE object; recompile with -fPIE
-#...
diff --git a/ld/testsuite/ld-x86-64/pr22791-1a.c b/ld/testsuite/ld-x86-64/pr22791-1a.c
deleted file mode 100644
index cd0130cacdf..00000000000
--- a/ld/testsuite/ld-x86-64/pr22791-1a.c
+++ /dev/null
@@ -1,4 +0,0 @@
-void
-foo (void)
-{
-}
diff --git a/ld/testsuite/ld-x86-64/pr22791-1b.s b/ld/testsuite/ld-x86-64/pr22791-1b.s
deleted file mode 100644
index 4bd75570253..00000000000
--- a/ld/testsuite/ld-x86-64/pr22791-1b.s
+++ /dev/null
@@ -1,7 +0,0 @@
-	.text
-	.globl	main
-	.type	main, @function
-main:
-	movl	foo(%rip), %eax
-	.size	main, .-main
-	.section	.note.GNU-stack
diff --git a/ld/testsuite/ld-x86-64/pr22791-2.rd b/ld/testsuite/ld-x86-64/pr22791-2.rd
deleted file mode 100644
index 70deb30d84d..00000000000
--- a/ld/testsuite/ld-x86-64/pr22791-2.rd
+++ /dev/null
@@ -1,6 +0,0 @@
-#failif
-#...
-.*\(TEXTREL\).*
-#...
-[0-9a-f ]+R_X86_64_NONE.*
-#...
diff --git a/ld/testsuite/ld-x86-64/pr22791-2a.s b/ld/testsuite/ld-x86-64/pr22791-2a.s
deleted file mode 100644
index 0a855024d74..00000000000
--- a/ld/testsuite/ld-x86-64/pr22791-2a.s
+++ /dev/null
@@ -1,8 +0,0 @@
-	.text
-	.p2align 4,,15
-	.globl	foo
-	.type	foo, @function
-foo:
-	jmp	bar
-	.size	foo, .-foo
-	.section	.note.GNU-stack,"",@progbits
diff --git a/ld/testsuite/ld-x86-64/pr22791-2b.c b/ld/testsuite/ld-x86-64/pr22791-2b.c
deleted file mode 100644
index 79ef27c0857..00000000000
--- a/ld/testsuite/ld-x86-64/pr22791-2b.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <stdio.h>
-
-void
-bar (void)
-{
-  puts ("PASS");
-}
diff --git a/ld/testsuite/ld-x86-64/pr22791-2c.s b/ld/testsuite/ld-x86-64/pr22791-2c.s
deleted file mode 100644
index 1460d1b8288..00000000000
--- a/ld/testsuite/ld-x86-64/pr22791-2c.s
+++ /dev/null
@@ -1,12 +0,0 @@
-	.text
-	.p2align 4,,15
-	.globl	main
-	.type	main, @function
-main:
-	subq	$8, %rsp
-	call	foo
-	xorl	%eax, %eax
-	addq	$8, %rsp
-	ret
-	.size	main, .-main
-	.section	.note.GNU-stack,"",@progbits
diff --git a/ld/testsuite/ld-x86-64/pr22842b.S b/ld/testsuite/ld-x86-64/pr22842b.S
index f0659cd901e..b9dd81345b7 100644
--- a/ld/testsuite/ld-x86-64/pr22842b.S
+++ b/ld/testsuite/ld-x86-64/pr22842b.S
@@ -7,7 +7,7 @@ main:
         leaq    bar(%rip), %rdi
 	addq	%rax, %rdi
 
-	callq	foo
+	callq	foo@PLT
 	xorl	%eax, %eax
 	popq	%rcx
 	retq
diff --git a/ld/testsuite/ld-x86-64/rela.d b/ld/testsuite/ld-x86-64/rela.d
deleted file mode 100644
index 20bb7e35232..00000000000
--- a/ld/testsuite/ld-x86-64/rela.d
+++ /dev/null
@@ -1,10 +0,0 @@
-#name: x86-64 rela relocs w/ non-zero relocated fields
-#as: --64
-#source: ${srcdir}/../../../gas/testsuite/gas/i386/rela.s
-#ld: -melf_x86_64
-#objdump: -sj .data
-
-.*: +file format .*
-
-Contents of section .data:
- *[0-9a-f]*0 .8 ?.. ?.. ?.. 00 ?00 ?00 ?00 .0 ?.. ?.. ?.. 44 ?44 ?44 ?44 .*
diff --git a/ld/testsuite/ld-x86-64/x86-64.exp b/ld/testsuite/ld-x86-64/x86-64.exp
index e370f393a7a..68c29169ae1 100644
--- a/ld/testsuite/ld-x86-64/x86-64.exp
+++ b/ld/testsuite/ld-x86-64/x86-64.exp
@@ -291,7 +291,6 @@ run_dump_test "apic"
 run_dump_test "pcrel8"
 run_dump_test "pcrel16"
 run_dump_test "pcrel16-2"
-run_dump_test "rela"
 run_dump_test "tlsgd2"
 run_dump_test "tlsgd3"
 run_dump_test "tlsgd12"
@@ -506,10 +505,10 @@ run_dump_test "pr27491-1c"
 run_dump_test "pr27491-2"
 run_dump_test "pr27491-3"
 run_dump_test "pr27491-4"
-run_dump_test "dt-relr-1a"
-run_dump_test "dt-relr-1a-x32"
-run_dump_test "dt-relr-1b"
-run_dump_test "dt-relr-1b-x32"
+#run_dump_test "dt-relr-1a"
+#run_dump_test "dt-relr-1a-x32"
+#run_dump_test "dt-relr-1b"
+#run_dump_test "dt-relr-1b-x32"
 run_dump_test "pr30787"
 run_dump_test "pr31047"
 run_dump_test "pr31047-x32"
@@ -1234,44 +1233,6 @@ if { [isnative] && [check_compiler_available] } {
 	     {readelf -lW pr22393-3b.rd}} \
 	    "pr22393-3-static" \
 	] \
-	[list \
-	    "Build pr22791-1.so" \
-	    "-shared" \
-	    "-fPIC -Wa,-mx86-used-note=yes" \
-	    { pr22791-1a.c } \
-	    {} \
-	    "pr22791-1.so" \
-	] \
-	[list \
-	    "Build pr22791-1" \
-	    "-pie -Wl,--no-as-needed,-z,notext tmpdir/pr22791-1.so" \
-	    "$NOPIE_CFLAGS -Wa,-mx86-used-note=yes" \
-	    { pr22791-1b.s } \
-	    {{error_output "pr22791-1.err"}} \
-	    "pr22791-1" \
-	] \
-	[list \
-	    "Build pr22791-2a.o" \
-	    "" \
-	    "$NOPIE_CFLAGS -Wa,-mx86-used-note=yes" \
-	    { pr22791-2a.s } \
-	] \
-	[list \
-	    "Build pr22791-2.so" \
-	    "-shared tmpdir/pr22791-2a.o" \
-	    "-fPIC -Wa,-mx86-used-note=yes" \
-	    { pr22791-2b.c } \
-	    {{readelf -drW pr22791-2.rd}} \
-	    "pr22791-2.so" \
-	] \
-	[list \
-	    "Build pr22791-2" \
-	    "-pie -Wl,--no-as-needed tmpdir/pr22791-2.so" \
-	    "$NOPIE_CFLAGS -Wa,-mx86-used-note=yes" \
-	    { pr22791-2c.s } \
-	    {{readelf -drW pr22791-2.rd}} \
-	    "pr22791-2" \
-	] \
 	[list \
 	    "Build pr22842.so" \
 	    "-shared" \
@@ -1761,15 +1722,6 @@ if { [isnative] && [check_compiler_available] } {
 	    "pr22393-3-static" \
 	    "pass.out" \
 	] \
-	[list \
-	    "Run pr22791-2" \
-	    "-pie -Wl,--no-as-needed tmpdir/pr22791-2.so" \
-	    "-Wa,-mx86-used-note=yes" \
-	    { pr22791-2c.s } \
-	    "pr22791-2" \
-	    "pass.out" \
-	    "$NOPIE_CFLAGS" \
-	] \
 	[list \
 	    "Run pr22842" \
 	    "-pie -Wl,--no-as-needed tmpdir/pr22842.so" \
diff --git a/libctf/Makefile.am b/libctf/Makefile.am
index fb1a306c888..f6c17e90e86 100644
--- a/libctf/Makefile.am
+++ b/libctf/Makefile.am
@@ -58,7 +58,7 @@ libctf_nobfd_la_CPPFLAGS = $(AM_CPPFLAGS) -DNOBFD=1
 libctf_nobfd_la_SOURCES = ctf-archive.c ctf-dump.c ctf-create.c ctf-decl.c ctf-error.c \
 			  ctf-hash.c ctf-labels.c ctf-dedup.c ctf-link.c ctf-lookup.c \
 			  ctf-open.c ctf-serialize.c ctf-sha1.c ctf-string.c ctf-subr.c \
-			  ctf-types.c ctf-util.c
+			  ctf-types.c ctf-util.c stat64.c
 if NEED_CTF_QSORT_R
 libctf_nobfd_la_SOURCES += ctf-qsort_r.c
 endif
diff --git a/libctf/Makefile.in b/libctf/Makefile.in
index 1cdf105a323..9d46739c400 100644
--- a/libctf/Makefile.in
+++ b/libctf/Makefile.in
@@ -211,7 +211,7 @@ am_libctf_nobfd_la_OBJECTS = libctf_nobfd_la-ctf-archive.lo \
 	libctf_nobfd_la-ctf-lookup.lo libctf_nobfd_la-ctf-open.lo \
 	libctf_nobfd_la-ctf-serialize.lo libctf_nobfd_la-ctf-sha1.lo \
 	libctf_nobfd_la-ctf-string.lo libctf_nobfd_la-ctf-subr.lo \
-	libctf_nobfd_la-ctf-types.lo libctf_nobfd_la-ctf-util.lo \
+	libctf_nobfd_la-ctf-types.lo libctf_nobfd_la-ctf-util.lo libctf_nobfd_la-stat64.lo \
 	$(am__objects_1)
 libctf_nobfd_la_OBJECTS = $(am_libctf_nobfd_la_OBJECTS)
 AM_V_lt = $(am__v_lt_@AM_V@)
@@ -240,7 +240,7 @@ am__objects_3 = libctf_la-ctf-archive.lo libctf_la-ctf-dump.lo \
 	libctf_la-ctf-open.lo libctf_la-ctf-serialize.lo \
 	libctf_la-ctf-sha1.lo libctf_la-ctf-string.lo \
 	libctf_la-ctf-subr.lo libctf_la-ctf-types.lo \
-	libctf_la-ctf-util.lo $(am__objects_2)
+	libctf_la-ctf-util.lo libctf_la-stat64.lo $(am__objects_2)
 am_libctf_la_OBJECTS = $(am__objects_3) libctf_la-ctf-open-bfd.lo
 libctf_la_OBJECTS = $(am_libctf_la_OBJECTS)
 libctf_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
@@ -933,6 +933,13 @@ libctf_nobfd_la-ctf-util.lo: ctf-util.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libctf_nobfd_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libctf_nobfd_la-ctf-util.lo `test -f 'ctf-util.c' || echo '$(srcdir)/'`ctf-util.c
 
+libctf_nobfd_la-stat64.lo: stat64.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libctf_nobfd_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libctf_nobfd_la-stat64.lo -MD -MP -MF $(DEPDIR)/libctf_nobfd_la-stat64.Tpo -c -o libctf_nobfd_la-stat64.lo `test -f 'stat64.c' || echo '$(srcdir)/'`stat64.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libctf_nobfd_la-stat64.Tpo $(DEPDIR)/libctf_nobfd_la-stat64.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='stat64.c' object='libctf_nobfd_la-stat64.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libctf_nobfd_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libctf_nobfd_la-stat64.lo `test -f 'stat64.c' || echo '$(srcdir)/'`stat64.c
+
 libctf_nobfd_la-ctf-qsort_r.lo: ctf-qsort_r.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libctf_nobfd_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libctf_nobfd_la-ctf-qsort_r.lo -MD -MP -MF $(DEPDIR)/libctf_nobfd_la-ctf-qsort_r.Tpo -c -o libctf_nobfd_la-ctf-qsort_r.lo `test -f 'ctf-qsort_r.c' || echo '$(srcdir)/'`ctf-qsort_r.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libctf_nobfd_la-ctf-qsort_r.Tpo $(DEPDIR)/libctf_nobfd_la-ctf-qsort_r.Plo
@@ -1059,6 +1066,13 @@ libctf_la-ctf-util.lo: ctf-util.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libctf_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libctf_la-ctf-util.lo `test -f 'ctf-util.c' || echo '$(srcdir)/'`ctf-util.c
 
+libctf_la-stat64.lo: stat64.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libctf_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libctf_la-stat64.lo -MD -MP -MF $(DEPDIR)/libctf_la-stat64.Tpo -c -o libctf_la-stat64.lo `test -f 'stat64.c' || echo '$(srcdir)/'`stat64.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libctf_la-stat64.Tpo $(DEPDIR)/libctf_la-stat64.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='stat64.c' object='libctf_la-stat64.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libctf_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libctf_la-stat64.lo `test -f 'stat64.c' || echo '$(srcdir)/'`stat64.c
+
 libctf_la-ctf-qsort_r.lo: ctf-qsort_r.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libctf_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libctf_la-ctf-qsort_r.lo -MD -MP -MF $(DEPDIR)/libctf_la-ctf-qsort_r.Tpo -c -o libctf_la-ctf-qsort_r.lo `test -f 'ctf-qsort_r.c' || echo '$(srcdir)/'`ctf-qsort_r.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libctf_la-ctf-qsort_r.Tpo $(DEPDIR)/libctf_la-ctf-qsort_r.Plo
diff --git a/libctf/config.h.in b/libctf/config.h.in
index 794779eab5a..828e49a2ed1 100644
--- a/libctf/config.h.in
+++ b/libctf/config.h.in
@@ -200,3 +200,5 @@
 
 /* Define to 1 if you need to in order for `stat' and other things to work. */
 #undef _POSIX_SOURCE
+
+#include "libcwrap.h"
diff --git a/libctf/stat64.c b/libctf/stat64.c
new file mode 100644
index 00000000000..80f847de20e
--- /dev/null
+++ b/libctf/stat64.c
@@ -0,0 +1 @@
+#include "../bfd/stat64.c"
diff --git a/libiberty/config.in b/libiberty/config.in
index 1b1f2b09a8a..a5b4b0d0820 100644
--- a/libiberty/config.in
+++ b/libiberty/config.in
@@ -587,3 +587,5 @@
 
 /* Define as `fork' if `vfork' does not work. */
 #undef vfork
+
+#include "libcwrap.h"
diff --git a/libiberty/configure b/libiberty/configure
index 5c69fee56c1..02111b96b29 100755
--- a/libiberty/configure
+++ b/libiberty/configure
@@ -5380,6 +5380,10 @@ case "${host}" in
     sh*-*-netbsd*)
 	PICFLAG=-fpic
 	;;
+    m68k-*-mint*)
+	# PIC is not supported
+	PICFLAG=
+	;;
     # Default to -fPIC unless specified otherwise.
     *)
 	PICFLAG=-fPIC
diff --git a/libiberty/dyn-string.c b/libiberty/dyn-string.c
index ecd8c069984..1c3d2f64c3a 100644
--- a/libiberty/dyn-string.c
+++ b/libiberty/dyn-string.c
@@ -254,7 +254,7 @@ dyn_string_insert (dyn_string_t dest, int pos, dyn_string_t src)
   for (i = dest->length; i >= pos; --i)
     dest->s[i + src->length] = dest->s[i];
   /* Splice in the new stuff.  */
-  strncpy (dest->s + pos, src->s, src->length);
+  memcpy (dest->s + pos, src->s, src->length);
   /* Compute the new length.  */
   dest->length += src->length;
   return 1;
diff --git a/libiberty/hex.c b/libiberty/hex.c
index 5de5f9d5600..8cefc213e71 100644
--- a/libiberty/hex.c
+++ b/libiberty/hex.c
@@ -24,7 +24,7 @@ Boston, MA 02110-1301, USA.  */
 #include "libiberty.h"
 #include "safe-ctype.h" /* for HOST_CHARSET_ASCII */
 
-#if EOF != -1
+#if !(EOF == -1)	/* gcc 2.95.3 has bug in '!=' operator for negative constants */
  #error "hex.c requires EOF == -1"
 #endif
 
diff --git a/libiberty/safe-ctype.c b/libiberty/safe-ctype.c
index 0f44e9465b2..ef65d55b635 100644
--- a/libiberty/safe-ctype.c
+++ b/libiberty/safe-ctype.c
@@ -118,7 +118,7 @@ sets of characters:
 #include <safe-ctype.h>
 #include <stdio.h>  /* for EOF */
 
-#if EOF != -1
+#if !(EOF == -1)	/* gcc 2.95.3 has bug in '!=' operator for negative constants */
  #error "<safe-ctype.h> requires EOF == -1"
 #endif
 
diff --git a/libiberty/unlink-if-ordinary.c b/libiberty/unlink-if-ordinary.c
index 0816ceb88b3..29304e226b2 100644
--- a/libiberty/unlink-if-ordinary.c
+++ b/libiberty/unlink-if-ordinary.c
@@ -64,6 +64,12 @@ unlink_if_ordinary (const char *name)
 {
   struct stat st;
 
+/* MS-Windows 'stat' function (and in turn, S_ISREG)
+   reports the null device as a regular file.  */
+#ifdef _WIN32
+  if (stricmp (name, "nul") == 0)
+    return 1;
+#endif
   if (lstat (name, &st) == 0
       && (S_ISREG (st.st_mode) || S_ISLNK (st.st_mode)))
     return unlink (name);
diff --git a/opcodes/config.in b/opcodes/config.in
index 409998f51e2..f4f16e07a5c 100644
--- a/opcodes/config.in
+++ b/opcodes/config.in
@@ -138,3 +138,5 @@
 
 /* Define to 1 if you need to in order for `stat' and other things to work. */
 #undef _POSIX_SOURCE
+
+#include "libcwrap.h"
diff --git a/opcodes/m68k-opc.c b/opcodes/m68k-opc.c
index 37345bab2b3..f3b466558cd 100644
--- a/opcodes/m68k-opc.c
+++ b/opcodes/m68k-opc.c
@@ -955,12 +955,12 @@ const struct m68k_opcode m68k_opcodes[] =
 
 {"fmovemx", 4,	two(0xF000, 0xF800), two(0xF1C0, 0xFF8F), "IiDk&s", mfloat },
 {"fmovemx", 4,	two(0xF020, 0xE800), two(0xF1F8, 0xFF8F), "IiDk-s", mfloat },
-{"fmovemx", 4,	two(0xF000, 0xD800), two(0xF1C0, 0xFF8F), "Ii&sDk", mfloat },
+{"fmovemx", 4,	two(0xF000, 0xD800), two(0xF1C0, 0xFF8F), "Ii!sDk", mfloat },
 {"fmovemx", 4,	two(0xF018, 0xD800), two(0xF1F8, 0xFF8F), "Ii+sDk", mfloat },
 {"fmovemx", 4,	two(0xF000, 0xF000), two(0xF1C0, 0xFF00), "Idl3&s", mfloat },
 {"fmovemx", 4,	two(0xF000, 0xF000), two(0xF1C0, 0xFF00), "Id#3&s", mfloat },
-{"fmovemx", 4,	two(0xF000, 0xD000), two(0xF1C0, 0xFF00), "Id&sl3", mfloat },
-{"fmovemx", 4,	two(0xF000, 0xD000), two(0xF1C0, 0xFF00), "Id&s#3", mfloat },
+{"fmovemx", 4,	two(0xF000, 0xD000), two(0xF1C0, 0xFF00), "Id!sl3", mfloat },
+{"fmovemx", 4,	two(0xF000, 0xD000), two(0xF1C0, 0xFF00), "Id!s#3", mfloat },
 {"fmovemx", 4,	two(0xF020, 0xE000), two(0xF1F8, 0xFF00), "IdL3-s", mfloat },
 {"fmovemx", 4,	two(0xF020, 0xE000), two(0xF1F8, 0xFF00), "Id#3-s", mfloat },
 {"fmovemx", 4,	two(0xF018, 0xD000), two(0xF1F8, 0xFF00), "Id+sl3", mfloat },
@@ -978,18 +978,18 @@ const struct m68k_opcode m68k_opcodes[] =
 {"fmovem", 4,	two(0xF000, 0xF000), two(0xF1C0, 0xFF00), "Iil3ys", cfloat },
 {"fmovem", 4,	two(0xF000, 0xF000), two(0xF1C0, 0xFF00), "Ii#3ys", cfloat },
 
-{"fmovem", 4,	two(0xF020, 0xE000), two(0xF1F8, 0xFF00), "IdL3-s", mfloat },
-{"fmovem", 4,	two(0xF000, 0xF000), two(0xF1C0, 0xFF00), "Idl3&s", mfloat },
-{"fmovem", 4,	two(0xF018, 0xD000), two(0xF1F8, 0xFF00), "Id+sl3", mfloat },
-{"fmovem", 4,	two(0xF000, 0xD000), two(0xF1C0, 0xFF00), "Id&sl3", mfloat },
-{"fmovem", 4,	two(0xF020, 0xE000), two(0xF1F8, 0xFF00), "Id#3-s", mfloat },
-{"fmovem", 4,	two(0xF020, 0xE800), two(0xF1F8, 0xFF8F), "IiDk-s", mfloat },
-{"fmovem", 4,	two(0xF000, 0xF000), two(0xF1C0, 0xFF00), "Id#3&s", mfloat },
-{"fmovem", 4,	two(0xF000, 0xF800), two(0xF1C0, 0xFF8F), "IiDk&s", mfloat },
-{"fmovem", 4,	two(0xF018, 0xD000), two(0xF1F8, 0xFF00), "Id+s#3", mfloat },
-{"fmovem", 4,	two(0xF018, 0xD800), two(0xF1F8, 0xFF8F), "Ii+sDk", mfloat },
-{"fmovem", 4,	two(0xF000, 0xD000), two(0xF1C0, 0xFF00), "Id&s#3", mfloat },
-{"fmovem", 4,	two(0xF000, 0xD800), two(0xF1C0, 0xFF8F), "Ii&sDk", mfloat },
+{"fmovem", 4,	two(0xF020, 0xE000), two(0xF1F8, 0xFF00), "IdL3-s", mfloat }, /* fmovem <list>,-(An) */
+{"fmovem", 4,	two(0xF000, 0xF000), two(0xF1C0, 0xFF00), "Idl3&s", mfloat }, /* fmovem <list>,<ea> */
+{"fmovem", 4,	two(0xF018, 0xD000), two(0xF1F8, 0xFF00), "Id+sl3", mfloat }, /* fmovem (An)+,<list> */
+{"fmovem", 4,	two(0xF000, 0xD000), two(0xF1C0, 0xFF00), "Id!sl3", mfloat }, /* fmovem <ea>,<list> */
+{"fmovem", 4,	two(0xF020, 0xE000), two(0xF1F8, 0xFF00), "Id#3-s", mfloat }, /* fmovem #regs,-(An) */
+{"fmovem", 4,	two(0xF020, 0xE800), two(0xF1F8, 0xFF8F), "IiDk-s", mfloat }, /* fmovem Dn,-(An) */
+{"fmovem", 4,	two(0xF000, 0xF000), two(0xF1C0, 0xFF00), "Id#3&s", mfloat }, /* fmovem #regs,<ea> */
+{"fmovem", 4,	two(0xF000, 0xF800), two(0xF1C0, 0xFF8F), "IiDk&s", mfloat }, /* fmovem Dn,<ea> */
+{"fmovem", 4,	two(0xF018, 0xD000), two(0xF1F8, 0xFF00), "Id+s#3", mfloat }, /* fmovem (An)+,#regs */
+{"fmovem", 4,	two(0xF018, 0xD800), two(0xF1F8, 0xFF8F), "Ii+sDk", mfloat }, /* fmovem (An)+,Dn */
+{"fmovem", 4,	two(0xF000, 0xD000), two(0xF1C0, 0xFF00), "Id!s#3", mfloat }, /* fmovem <ea>,#regs */
+{"fmovem", 4,	two(0xF000, 0xD800), two(0xF1C0, 0xFF8F), "Ii!sDk", mfloat }, /* fmovem <ea>,Dn */
 {"fmovem", 4,	two(0xF000, 0xA000), two(0xF1C0, 0xE3FF), "Iis8%s", mfloat },
 {"fmovem", 4,	two(0xF000, 0x8000), two(0xF1C0, 0xE3FF), "Ii*ss8", mfloat },
 {"fmovem", 4,	two(0xF000, 0xA000), two(0xF1C0, 0xE3FF), "IiL8~s", mfloat },
