diff --git a/Makefile.in b/Makefile.in
index b1ed67d3d4f..09744119e07 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -13247,14 +13247,14 @@ configure-gmp: stage_current
 maybe-configure-gmp: configure-gmp
 configure-gmp: 
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	test ! -f $(HOST_SUBDIR)/gmp/Makefile || exit 0; \
 	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp; \
 	$(HOST_EXPORTS)  \
 	echo Configuring in $(HOST_SUBDIR)/gmp; \
 	cd "$(HOST_SUBDIR)/gmp" || exit 1; \
 	case $(srcdir) in \
-	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  /* | [A-Za-z]:[\\/]*) topdir=$$s ;; \
 	  *) topdir=`echo $(HOST_SUBDIR)/gmp/ | \
 		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
 	esac; \
@@ -13277,7 +13277,7 @@ configure-stage1-gmp:
 	@[ $(current_stage) = stage1 ] || $(MAKE) stage1-start
 	@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGE1_TFLAGS)"; \
 	test ! -f $(HOST_SUBDIR)/gmp/Makefile || exit 0; \
 	$(HOST_EXPORTS) \
@@ -13288,7 +13288,7 @@ configure-stage1-gmp:
 	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp; \
 	cd $(HOST_SUBDIR)/gmp || exit 1; \
 	case $(srcdir) in \
-	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  /* | [A-Za-z]:[\\/]*) topdir=$$s ;; \
 	  *) topdir=`echo $(HOST_SUBDIR)/gmp/ | \
 		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
 	esac; \
@@ -13310,7 +13310,7 @@ configure-stage2-gmp:
 	@[ $(current_stage) = stage2 ] || $(MAKE) stage2-start
 	@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGE2_TFLAGS)"; \
 	test ! -f $(HOST_SUBDIR)/gmp/Makefile || exit 0; \
 	$(HOST_EXPORTS) \
@@ -13322,7 +13322,7 @@ configure-stage2-gmp:
 	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp; \
 	cd $(HOST_SUBDIR)/gmp || exit 1; \
 	case $(srcdir) in \
-	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  /* | [A-Za-z]:[\\/]*) topdir=$$s ;; \
 	  *) topdir=`echo $(HOST_SUBDIR)/gmp/ | \
 		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
 	esac; \
@@ -13344,7 +13344,7 @@ configure-stage3-gmp:
 	@[ $(current_stage) = stage3 ] || $(MAKE) stage3-start
 	@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGE3_TFLAGS)"; \
 	test ! -f $(HOST_SUBDIR)/gmp/Makefile || exit 0; \
 	$(HOST_EXPORTS) \
@@ -13356,7 +13356,7 @@ configure-stage3-gmp:
 	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp; \
 	cd $(HOST_SUBDIR)/gmp || exit 1; \
 	case $(srcdir) in \
-	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  /* | [A-Za-z]:[\\/]*) topdir=$$s ;; \
 	  *) topdir=`echo $(HOST_SUBDIR)/gmp/ | \
 		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
 	esac; \
@@ -13378,7 +13378,7 @@ configure-stage4-gmp:
 	@[ $(current_stage) = stage4 ] || $(MAKE) stage4-start
 	@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGE4_TFLAGS)"; \
 	test ! -f $(HOST_SUBDIR)/gmp/Makefile || exit 0; \
 	$(HOST_EXPORTS) \
@@ -13390,7 +13390,7 @@ configure-stage4-gmp:
 	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp; \
 	cd $(HOST_SUBDIR)/gmp || exit 1; \
 	case $(srcdir) in \
-	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  /* | [A-Za-z]:[\\/]*) topdir=$$s ;; \
 	  *) topdir=`echo $(HOST_SUBDIR)/gmp/ | \
 		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
 	esac; \
@@ -13412,7 +13412,7 @@ configure-stageprofile-gmp:
 	@[ $(current_stage) = stageprofile ] || $(MAKE) stageprofile-start
 	@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGEprofile_TFLAGS)"; \
 	test ! -f $(HOST_SUBDIR)/gmp/Makefile || exit 0; \
 	$(HOST_EXPORTS) \
@@ -13424,7 +13424,7 @@ configure-stageprofile-gmp:
 	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp; \
 	cd $(HOST_SUBDIR)/gmp || exit 1; \
 	case $(srcdir) in \
-	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  /* | [A-Za-z]:[\\/]*) topdir=$$s ;; \
 	  *) topdir=`echo $(HOST_SUBDIR)/gmp/ | \
 		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
 	esac; \
@@ -13446,7 +13446,7 @@ configure-stagetrain-gmp:
 	@[ $(current_stage) = stagetrain ] || $(MAKE) stagetrain-start
 	@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGEtrain_TFLAGS)"; \
 	test ! -f $(HOST_SUBDIR)/gmp/Makefile || exit 0; \
 	$(HOST_EXPORTS) \
@@ -13458,7 +13458,7 @@ configure-stagetrain-gmp:
 	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp; \
 	cd $(HOST_SUBDIR)/gmp || exit 1; \
 	case $(srcdir) in \
-	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  /* | [A-Za-z]:[\\/]*) topdir=$$s ;; \
 	  *) topdir=`echo $(HOST_SUBDIR)/gmp/ | \
 		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
 	esac; \
@@ -13480,7 +13480,7 @@ configure-stagefeedback-gmp:
 	@[ $(current_stage) = stagefeedback ] || $(MAKE) stagefeedback-start
 	@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGEfeedback_TFLAGS)"; \
 	test ! -f $(HOST_SUBDIR)/gmp/Makefile || exit 0; \
 	$(HOST_EXPORTS) \
@@ -13492,7 +13492,7 @@ configure-stagefeedback-gmp:
 	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp; \
 	cd $(HOST_SUBDIR)/gmp || exit 1; \
 	case $(srcdir) in \
-	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  /* | [A-Za-z]:[\\/]*) topdir=$$s ;; \
 	  *) topdir=`echo $(HOST_SUBDIR)/gmp/ | \
 		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
 	esac; \
@@ -13514,7 +13514,7 @@ configure-stageautoprofile-gmp:
 	@[ $(current_stage) = stageautoprofile ] || $(MAKE) stageautoprofile-start
 	@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGEautoprofile_TFLAGS)"; \
 	test ! -f $(HOST_SUBDIR)/gmp/Makefile || exit 0; \
 	$(HOST_EXPORTS) \
@@ -13526,7 +13526,7 @@ configure-stageautoprofile-gmp:
 	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp; \
 	cd $(HOST_SUBDIR)/gmp || exit 1; \
 	case $(srcdir) in \
-	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  /* | [A-Za-z]:[\\/]*) topdir=$$s ;; \
 	  *) topdir=`echo $(HOST_SUBDIR)/gmp/ | \
 		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
 	esac; \
@@ -13548,7 +13548,7 @@ configure-stageautofeedback-gmp:
 	@[ $(current_stage) = stageautofeedback ] || $(MAKE) stageautofeedback-start
 	@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGEautofeedback_TFLAGS)"; \
 	test ! -f $(HOST_SUBDIR)/gmp/Makefile || exit 0; \
 	$(HOST_EXPORTS) \
@@ -13560,7 +13560,7 @@ configure-stageautofeedback-gmp:
 	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp; \
 	cd $(HOST_SUBDIR)/gmp || exit 1; \
 	case $(srcdir) in \
-	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  /* | [A-Za-z]:[\\/]*) topdir=$$s ;; \
 	  *) topdir=`echo $(HOST_SUBDIR)/gmp/ | \
 		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
 	esac; \
@@ -13588,7 +13588,7 @@ TARGET-gmp=all
 maybe-all-gmp: all-gmp
 all-gmp: configure-gmp
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	$(HOST_EXPORTS)  \
 	(cd $(HOST_SUBDIR)/gmp && \
 	  $(MAKE) $(BASE_FLAGS_TO_PASS) $(EXTRA_HOST_FLAGS) $(STAGE1_FLAGS_TO_PASS) AM_CFLAGS="-DNO_ASM" \
@@ -13608,7 +13608,7 @@ TARGET-stage1-gmp = $(TARGET-gmp)
 all-stage1-gmp: configure-stage1-gmp
 	@[ $(current_stage) = stage1 ] || $(MAKE) stage1-start
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGE1_TFLAGS)"; \
 	$(HOST_EXPORTS)  \
 	cd $(HOST_SUBDIR)/gmp && \
@@ -13652,7 +13652,7 @@ TARGET-stage2-gmp = $(TARGET-gmp)
 all-stage2-gmp: configure-stage2-gmp
 	@[ $(current_stage) = stage2 ] || $(MAKE) stage2-start
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGE2_TFLAGS)"; \
 	$(HOST_EXPORTS) \
 	$(POSTSTAGE1_HOST_EXPORTS)  \
@@ -13695,7 +13695,7 @@ TARGET-stage3-gmp = $(TARGET-gmp)
 all-stage3-gmp: configure-stage3-gmp
 	@[ $(current_stage) = stage3 ] || $(MAKE) stage3-start
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGE3_TFLAGS)"; \
 	$(HOST_EXPORTS) \
 	$(POSTSTAGE1_HOST_EXPORTS)  \
@@ -13738,7 +13738,7 @@ TARGET-stage4-gmp = $(TARGET-gmp)
 all-stage4-gmp: configure-stage4-gmp
 	@[ $(current_stage) = stage4 ] || $(MAKE) stage4-start
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGE4_TFLAGS)"; \
 	$(HOST_EXPORTS) \
 	$(POSTSTAGE1_HOST_EXPORTS)  \
@@ -13781,7 +13781,7 @@ TARGET-stageprofile-gmp = $(TARGET-gmp)
 all-stageprofile-gmp: configure-stageprofile-gmp
 	@[ $(current_stage) = stageprofile ] || $(MAKE) stageprofile-start
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGEprofile_TFLAGS)"; \
 	$(HOST_EXPORTS) \
 	$(POSTSTAGE1_HOST_EXPORTS)  \
@@ -13824,7 +13824,7 @@ TARGET-stagetrain-gmp = $(TARGET-gmp)
 all-stagetrain-gmp: configure-stagetrain-gmp
 	@[ $(current_stage) = stagetrain ] || $(MAKE) stagetrain-start
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGEtrain_TFLAGS)"; \
 	$(HOST_EXPORTS) \
 	$(POSTSTAGE1_HOST_EXPORTS)  \
@@ -13867,7 +13867,7 @@ TARGET-stagefeedback-gmp = $(TARGET-gmp)
 all-stagefeedback-gmp: configure-stagefeedback-gmp
 	@[ $(current_stage) = stagefeedback ] || $(MAKE) stagefeedback-start
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGEfeedback_TFLAGS)"; \
 	$(HOST_EXPORTS) \
 	$(POSTSTAGE1_HOST_EXPORTS)  \
@@ -13910,7 +13910,7 @@ TARGET-stageautoprofile-gmp = $(TARGET-gmp)
 all-stageautoprofile-gmp: configure-stageautoprofile-gmp
 	@[ $(current_stage) = stageautoprofile ] || $(MAKE) stageautoprofile-start
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGEautoprofile_TFLAGS)"; \
 	$(HOST_EXPORTS) \
 	$(POSTSTAGE1_HOST_EXPORTS)  \
@@ -13953,7 +13953,7 @@ TARGET-stageautofeedback-gmp = $(TARGET-gmp)
 all-stageautofeedback-gmp: configure-stageautofeedback-gmp
 	@[ $(current_stage) = stageautofeedback ] || $(MAKE) stageautofeedback-start
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGEautofeedback_TFLAGS)"; \
 	$(HOST_EXPORTS) \
 	$(POSTSTAGE1_HOST_EXPORTS)  \
@@ -13996,7 +13996,7 @@ maybe-check-gmp: check-gmp
 check-gmp:
 	@: $(MAKE); $(unstage)
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	$(HOST_EXPORTS) $(EXTRA_HOST_EXPORTS) \
 	(cd $(HOST_SUBDIR)/gmp && \
 	  $(MAKE) $(FLAGS_TO_PASS) AM_CFLAGS="-DNO_ASM" $(EXTRA_BOOTSTRAP_FLAGS) check)
@@ -14032,7 +14032,7 @@ info-gmp: \
     configure-gmp 
 	@[ -f ./gmp/Makefile ] || exit 0; \
 	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	$(HOST_EXPORTS) \
 	for flag in $(EXTRA_HOST_FLAGS) AM_CFLAGS="-DNO_ASM"; do \
 	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
@@ -14057,7 +14057,7 @@ dvi-gmp: \
     configure-gmp 
 	@[ -f ./gmp/Makefile ] || exit 0; \
 	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	$(HOST_EXPORTS) \
 	for flag in $(EXTRA_HOST_FLAGS) AM_CFLAGS="-DNO_ASM"; do \
 	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
@@ -14082,7 +14082,7 @@ pdf-gmp: \
     configure-gmp 
 	@[ -f ./gmp/Makefile ] || exit 0; \
 	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	$(HOST_EXPORTS) \
 	for flag in $(EXTRA_HOST_FLAGS) AM_CFLAGS="-DNO_ASM"; do \
 	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
@@ -14107,7 +14107,7 @@ html-gmp: \
     configure-gmp 
 	@[ -f ./gmp/Makefile ] || exit 0; \
 	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	$(HOST_EXPORTS) \
 	for flag in $(EXTRA_HOST_FLAGS) AM_CFLAGS="-DNO_ASM"; do \
 	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
@@ -14132,7 +14132,7 @@ TAGS-gmp: \
     configure-gmp 
 	@[ -f ./gmp/Makefile ] || exit 0; \
 	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	$(HOST_EXPORTS) \
 	for flag in $(EXTRA_HOST_FLAGS) AM_CFLAGS="-DNO_ASM"; do \
 	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
@@ -14158,7 +14158,7 @@ install-info-gmp: \
     info-gmp 
 	@[ -f ./gmp/Makefile ] || exit 0; \
 	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	$(HOST_EXPORTS) \
 	for flag in $(EXTRA_HOST_FLAGS) AM_CFLAGS="-DNO_ASM"; do \
 	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
@@ -14210,7 +14210,7 @@ install-pdf-gmp: \
     pdf-gmp 
 	@[ -f ./gmp/Makefile ] || exit 0; \
 	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	$(HOST_EXPORTS) \
 	for flag in $(EXTRA_HOST_FLAGS) AM_CFLAGS="-DNO_ASM"; do \
 	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
@@ -14236,7 +14236,7 @@ install-html-gmp: \
     html-gmp 
 	@[ -f ./gmp/Makefile ] || exit 0; \
 	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	$(HOST_EXPORTS) \
 	for flag in $(EXTRA_HOST_FLAGS) AM_CFLAGS="-DNO_ASM"; do \
 	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
@@ -14261,7 +14261,7 @@ installcheck-gmp: \
     configure-gmp 
 	@[ -f ./gmp/Makefile ] || exit 0; \
 	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	$(HOST_EXPORTS) \
 	for flag in $(EXTRA_HOST_FLAGS) AM_CFLAGS="-DNO_ASM"; do \
 	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
diff --git a/c++tools/server.cc b/c++tools/server.cc
index 339a88746cc..4477b4eafc9 100644
--- a/c++tools/server.cc
+++ b/c++tools/server.cc
@@ -879,6 +879,8 @@ static int maybe_parse_socket (std::string &option, module_resolver *r)
   return fd;
 }
 
+#include "libcmain.h"
+
 int
 main (int argc, char *argv[])
 {
diff --git a/config-ml.in b/config-ml.in
index 7934a1ddf4b..79c3ac1262f 100644
--- a/config-ml.in
+++ b/config-ml.in
@@ -346,6 +346,36 @@ m68*-*-*)
 	    esac
 	  done
 	fi
+	case "${host}" in
+	  *-*-mint*)
+            # mshort variants are only generated for libgcc
+            # mfastcall variants are only generated for libgcc & libstdc++
+	    case "${srcdir}" in
+	      */libgcc ) : ;;
+	      */libstdc++-v3)
+	        old_multidirs="${multidirs}"
+	        multidirs=""
+	        for x in ${old_multidirs}; do
+		  case "$x" in
+		    *mshort* ) : ;;
+		    *) multidirs="${multidirs} ${x}" ;;
+		  esac
+		done
+		;;
+	      *)
+	        old_multidirs="${multidirs}"
+	        multidirs=""
+	        for x in ${old_multidirs}; do
+		  case "$x" in
+		    *mshort* ) : ;;
+		    *mfastcall* ) : ;;
+		    *) multidirs="${multidirs} ${x}" ;;
+		  esac
+		done
+		;;
+	    esac
+	    ;;
+	esac
 	;;
 mips*-*-*)
 	if [ x$enable_single_float = xno ]
diff --git a/config.guess b/config.guess
index 1972fda8eb0..106b1c4917d 100755
--- a/config.guess
+++ b/config.guess
@@ -466,22 +466,22 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
     # MiNT.  But MiNT is downward compatible to TOS, so this should
     # be no problem.
     atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
-	echo m68k-atari-mint"$UNAME_RELEASE"
+	echo m68k-atari-mint
 	exit ;;
     atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
-	echo m68k-atari-mint"$UNAME_RELEASE"
+	echo m68k-atari-mint
 	exit ;;
     *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
-	echo m68k-atari-mint"$UNAME_RELEASE"
+	echo m68k-atari-mint
 	exit ;;
     milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
-	echo m68k-milan-mint"$UNAME_RELEASE"
+	echo m68k-milan-mint
 	exit ;;
     hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
-	echo m68k-hades-mint"$UNAME_RELEASE"
+	echo m68k-hades-mint
 	exit ;;
     *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
-	echo m68k-unknown-mint"$UNAME_RELEASE"
+	echo m68k-unknown-mint
 	exit ;;
     m68k:machten:*:*)
 	echo m68k-apple-machten"$UNAME_RELEASE"
diff --git a/config.sub b/config.sub
index 38f3d037a78..3f5612c6f8f 100755
--- a/config.sub
+++ b/config.sub
@@ -1395,6 +1395,12 @@ case $os in
 	psos*)
 		os=psos
 		;;
+	mintelf)
+		os=mintelf
+		;;
+	mint | mint[0-9]*)
+		os=mint
+		;;
 	qnx*)
 		os=qnx
 		;;
@@ -1486,6 +1492,9 @@ case $os in
 	ose*)
 		os=ose
 		;;
+	*mintelf)
+		os=mintelf
+		;;
 	*mint | mint[0-9]* | *MiNT | MiNT[0-9]*)
 		os=mint
 		;;
diff --git a/config/lib-ld.m4 b/config/lib-ld.m4
index 73cf9571b57..b749946efc0 100644
--- a/config/lib-ld.m4
+++ b/config/lib-ld.m4
@@ -49,7 +49,7 @@ if test "$GCC" = yes; then
   # Check if gcc -print-prog-name=ld gives a path.
   AC_MSG_CHECKING([for ld used by GCC])
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
diff --git a/config/lthostflags.m4 b/config/lthostflags.m4
index bc0f59ee79e..253e7aa6b06 100644
--- a/config/lthostflags.m4
+++ b/config/lthostflags.m4
@@ -13,7 +13,7 @@ AC_DEFUN([ACX_LT_HOST_FLAGS], [
 AC_REQUIRE([AC_CANONICAL_SYSTEM])
 
 case $host in
-  *-cygwin* | *-mingw*)
+  *-cygwin* | *-mingw* | *-msys*)
     # 'host' will be top-level target in the case of a target lib,
     # we must compare to with_cross_host to decide if this is a native
     # or cross-compiler and select where to install dlls appropriately.
diff --git a/config/mmap.m4 b/config/mmap.m4
index fba0d9d3657..5342ed8ab2c 100644
--- a/config/mmap.m4
+++ b/config/mmap.m4
@@ -42,7 +42,7 @@ else
    # Systems known to be in this category are Windows (all variants),
    # VMS, and Darwin.
    case "$host_os" in
-     *vms* | cygwin* | pe | mingw* | darwin* | ultrix* | hpux10* | hpux11.00)
+     *vms* | cygwin* | pe | mingw* | msys* | darwin* | ultrix* | hpux10* | hpux11.00)
         gcc_cv_func_mmap_dev_zero=no ;;
      *)
         gcc_cv_func_mmap_dev_zero=yes;;
@@ -74,7 +74,7 @@ else
    # above for use of /dev/zero.
    # Systems known to be in this category are Windows, VMS, and SCO Unix.
    case "$host_os" in
-     *vms* | cygwin* | pe | mingw* | sco* | udk* )
+     *vms* | cygwin* | pe | mingw* | msys* | sco* | udk* )
         gcc_cv_func_mmap_anon=no ;;
      *)
         gcc_cv_func_mmap_anon=yes;;
diff --git a/config/picflag.m4 b/config/picflag.m4
index 3f3ac744c96..b5e263265ed 100644
--- a/config/picflag.m4
+++ b/config/picflag.m4
@@ -25,7 +25,9 @@ case "${$2}" in
 	;;
     i[[34567]]86-*-cygwin* | x86_64-*-cygwin*)
 	;;
-    i[[34567]]86-*-mingw* | x86_64-*-mingw*)
+    i[[34567]]86-*-mingw* | x86_64-*-mingw* | x86_64-*-msys*)
+	;;
+    *-*-mint*)
 	;;
     i[[34567]]86-*-interix[[3-9]]*)
 	# Interix 3.x gcc -fpic/-fPIC options generate broken code.
diff --git a/configure b/configure
index ebc44416b6c..17daa12ce76 100755
--- a/configure
+++ b/configure
@@ -3301,6 +3301,9 @@ if test x$enable_libgomp = x ; then
 	;;
     nvptx*-*-* | amdgcn*-*-*)
 	;;
+    *-*-mint*)
+        # Enable libmudflap by default in MiNT.
+	;;
     *)
 	noconfigdirs="$noconfigdirs target-libgomp"
 	;;
@@ -3780,6 +3783,9 @@ case "${target}" in
   m68hc11-*-*|m6811-*-*|m68hc12-*-*|m6812-*-*)
     libgloss_dir=m68hc11
     ;;
+  m68k-*-mint*)
+    noconfigdirs="$noconfigdirs target-libiberty"
+    ;;
   m68*-*-* | fido-*-*)
     libgloss_dir=m68k
     ;;
@@ -9006,9 +9012,9 @@ fi
 if test "x$with_gmp$with_gmp_include$with_gmp_lib" = x && test -d ${srcdir}/gmp; then
   gmplibs='-L$$r/$(HOST_SUBDIR)/gmp/'"$lt_cv_objdir $gmplibs"
   gmpinc='-I$$r/$(HOST_SUBDIR)/gmp -I$$s/gmp '"$gmpinc"
-  extra_mpfr_configure_flags='--with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-gmp-lib=$$r/$(HOST_SUBDIR)/gmp/'"$lt_cv_objdir"
-  extra_mpc_gmp_configure_flags='--with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-gmp-lib=$$r/$(HOST_SUBDIR)/gmp/'"$lt_cv_objdir"
-  extra_isl_gmp_configure_flags='--with-gmp-builddir=$$r/$(HOST_SUBDIR)/gmp'
+  extra_mpfr_configure_flags='--with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-gmp-lib=$$r/$(HOST_SUBDIR)/gmp/'"$lt_cv_objdir --disable-shared"
+  extra_mpc_gmp_configure_flags='--with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-gmp-lib=$$r/$(HOST_SUBDIR)/gmp/'"$lt_cv_objdir --disable-shared"
+  extra_isl_gmp_configure_flags='--with-gmp-builddir=$$r/$(HOST_SUBDIR)/gmp --disable-shared'
   # Do not test the gmp version.  Assume that it is sufficient, since
   # it is in the source tree, and the library has not been built yet
   # but it would be included on the link line in the version check below
@@ -11578,7 +11584,7 @@ case "$target" in
   x86_64-*mingw* | *-w64-mingw*)
   # MinGW-w64 does not use newlib, nor does it use winsup. It may,
   # however, use a symlink named 'mingw' in ${prefix} .
-    FLAGS_FOR_TARGET=$FLAGS_FOR_TARGET' -L${prefix}/${target}/lib -L${prefix}/mingw/lib -isystem ${prefix}/${target}/include -isystem ${prefix}/mingw/include'
+    FLAGS_FOR_TARGET=$FLAGS_FOR_TARGET' -L${prefix}/${target}/lib -L${prefix}/lib -isystem ${prefix}/${target}/include -isystem ${prefix}/include'
     ;;
   *-mingw*)
   # MinGW can't be handled as Cygwin above since it does not use newlib.
diff --git a/configure.ac b/configure.ac
index 730db3c1402..dd36c3c4882 100644
--- a/configure.ac
+++ b/configure.ac
@@ -539,6 +539,9 @@ if test x$enable_libgomp = x ; then
 	;;
     nvptx*-*-* | amdgcn*-*-*)
 	;;
+    *-*-mint*)
+        # Enable libmudflap by default in MiNT.
+	;;
     *)
 	noconfigdirs="$noconfigdirs target-libgomp"
 	;;
@@ -997,6 +1000,9 @@ case "${target}" in
   m68hc11-*-*|m6811-*-*|m68hc12-*-*|m6812-*-*)
     libgloss_dir=m68hc11
     ;;
+  m68k-*-mint*)
+    noconfigdirs="$noconfigdirs target-libiberty"
+    ;;
   m68*-*-* | fido-*-*)
     libgloss_dir=m68k
     ;;
@@ -1756,9 +1762,9 @@ fi
 if test "x$with_gmp$with_gmp_include$with_gmp_lib" = x && test -d ${srcdir}/gmp; then
   gmplibs='-L$$r/$(HOST_SUBDIR)/gmp/'"$lt_cv_objdir $gmplibs"
   gmpinc='-I$$r/$(HOST_SUBDIR)/gmp -I$$s/gmp '"$gmpinc"
-  extra_mpfr_configure_flags='--with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-gmp-lib=$$r/$(HOST_SUBDIR)/gmp/'"$lt_cv_objdir"
-  extra_mpc_gmp_configure_flags='--with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-gmp-lib=$$r/$(HOST_SUBDIR)/gmp/'"$lt_cv_objdir"
-  extra_isl_gmp_configure_flags='--with-gmp-builddir=$$r/$(HOST_SUBDIR)/gmp'
+  extra_mpfr_configure_flags='--with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-gmp-lib=$$r/$(HOST_SUBDIR)/gmp/'"$lt_cv_objdir --disable-shared"
+  extra_mpc_gmp_configure_flags='--with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-gmp-lib=$$r/$(HOST_SUBDIR)/gmp/'"$lt_cv_objdir --disable-shared"
+  extra_isl_gmp_configure_flags='--with-gmp-builddir=$$r/$(HOST_SUBDIR)/gmp --disable-shared'
   # Do not test the gmp version.  Assume that it is sufficient, since
   # it is in the source tree, and the library has not been built yet
   # but it would be included on the link line in the version check below
@@ -3805,7 +3811,7 @@ case "$target" in
   x86_64-*mingw* | *-w64-mingw*)
   # MinGW-w64 does not use newlib, nor does it use winsup. It may,
   # however, use a symlink named 'mingw' in ${prefix} .
-    FLAGS_FOR_TARGET=$FLAGS_FOR_TARGET' -L${prefix}/${target}/lib -L${prefix}/mingw/lib -isystem ${prefix}/${target}/include -isystem ${prefix}/mingw/include'
+    FLAGS_FOR_TARGET=$FLAGS_FOR_TARGET' -L${prefix}/${target}/lib -L${prefix}/lib -isystem ${prefix}/${target}/include -isystem ${prefix}/include'
     ;;
   *-mingw*)
   # MinGW can't be handled as Cygwin above since it does not use newlib.
diff --git a/fixincludes/configure b/fixincludes/configure
index 662c94dc112..789a8bfccfa 100755
--- a/fixincludes/configure
+++ b/fixincludes/configure
@@ -4819,7 +4819,8 @@ else
   case $host in
 	i?86-*-msdosdjgpp* | \
 	i?86-*-mingw32* | \
-	x86_64-*-mingw32* | \
+	x86_64-*-mingw* | \
+	*-*-msys* | \
 	*-*-beos* | \
         *-*-*vms*)
 		TARGET=twoprocess
@@ -5370,7 +5371,7 @@ else
    # Systems known to be in this category are Windows (all variants),
    # VMS, and Darwin.
    case "$host_os" in
-     *vms* | cygwin* | pe | mingw* | darwin* | ultrix* | hpux10* | hpux11.00)
+     *vms* | cygwin* | pe | mingw* | msys* | darwin* | ultrix* | hpux10* | hpux11.00)
         gcc_cv_func_mmap_dev_zero=no ;;
      *)
         gcc_cv_func_mmap_dev_zero=yes;;
@@ -5427,7 +5428,7 @@ else
    # above for use of /dev/zero.
    # Systems known to be in this category are Windows, VMS, and SCO Unix.
    case "$host_os" in
-     *vms* | cygwin* | pe | mingw* | sco* | udk* )
+     *vms* | cygwin* | pe | mingw* | msys* | sco* | udk* )
         gcc_cv_func_mmap_anon=no ;;
      *)
         gcc_cv_func_mmap_anon=yes;;
diff --git a/fixincludes/configure.ac b/fixincludes/configure.ac
index 4e78511d20f..352cb22856f 100644
--- a/fixincludes/configure.ac
+++ b/fixincludes/configure.ac
@@ -51,7 +51,8 @@ fi],
 [case $host in
 	i?86-*-msdosdjgpp* | \
 	i?86-*-mingw32* | \
-	x86_64-*-mingw32* | \
+	x86_64-*-mingw* | \
+	*-*-msys* | \
 	*-*-beos* | \
         *-*-*vms*)
 		TARGET=twoprocess
diff --git a/fixincludes/mkfixinc.sh b/fixincludes/mkfixinc.sh
index 7112f4dcd64..7bb14a52400 100755
--- a/fixincludes/mkfixinc.sh
+++ b/fixincludes/mkfixinc.sh
@@ -12,7 +12,8 @@ target=fixinc.sh
 # Check for special fix rules for particular targets
 case $machine in
     i?86-*-cygwin* | \
-    *-mingw32* | \
+    i?86-*-mingw32* | \
+    x86_64-*-mingw* | \
     powerpc-*-eabisim* | \
     powerpc-*-eabi*    | \
     powerpc-*-rtems*   | \
diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index 55b4cd7dbed..82ecb5862f9 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -493,7 +493,7 @@ T_STDINT_GCC_H = $(srcdir)/ginclude/stdint-gcc.h
 # The GCC to use for compiling crt*.o.
 # Usually the one we just built.
 # Don't use this as a dependency--use $(GCC_PASSES).
-GCC_FOR_TARGET = $(STAGE_CC_WRAPPER) ./xgcc -B./ -B$(build_tooldir)/bin/ -isystem $(build_tooldir)/include -isystem $(build_tooldir)/sys-include -L$(objdir)/../ld $(TFLAGS)
+GCC_FOR_TARGET = $(STAGE_CC_WRAPPER) ./xgcc -B./ -B$(mingw_build_tooldir)/bin/ -isystem $(mingw_build_tooldir)/include -isystem $(mingw_build_tooldir)/sys-include -L$(objdir)/../ld $(TFLAGS)
 
 # The GCC to use when running selftests
 GCC_FOR_SELFTESTS = LC_ALL=C GCC_COLORS= $(GCC_FOR_TARGET)
@@ -753,6 +753,10 @@ man7ext = .7
 objext = .o
 exeext = @host_exeext@
 build_exeext = @build_exeext@
+EVAL_MINGW := case `uname -s` in MINGW*) echo yes;; *) echo no;; esac
+MINGW := $(shell $(EVAL_MINGW))
+mingw_srcdir = $(shell if test "${MINGW}" = yes; then cmd //c echo ${srcdir}; else echo ${srcdir}; fi)
+mingw_build_tooldir = $(shell if test "${MINGW}" = yes; then cmd //c echo ${build_tooldir}; else echo ${build_tooldir}; fi)
 
 # Directory in which to put man pages.
 mandir = @mandir@
@@ -969,7 +973,7 @@ REVISION_s  := "\"\""
 endif
 
 # Shorthand variables for dependency lists.
-DUMPFILE_H = $(srcdir)/../libcpp/include/line-map.h dumpfile.h
+DUMPFILE_H = $(mingw_srcdir)/../libcpp/include/line-map.h dumpfile.h
 VEC_H = vec.h statistics.h $(GGC_H)
 HASH_TABLE_H = $(HASHTAB_H) hash-table.h $(GGC_H)
 EXCEPT_H = except.h $(HASHTAB_H)
@@ -1039,24 +1043,24 @@ GCC_H = gcc.h version.h $(DIAGNOSTIC_CORE_H)
 GGC_H = ggc.h gtype-desc.h statistics.h
 TIMEVAR_H = timevar.h timevar.def
 INSN_ATTR_H = insn-attr.h insn-attr-common.h $(INSN_ADDR_H)
-INSN_ADDR_H = $(srcdir)/insn-addr.h
+INSN_ADDR_H = $(mingw_srcdir)/insn-addr.h
 C_COMMON_H = c-family/c-common.h c-family/c-common.def $(TREE_H) \
 	$(SPLAY_TREE_H) $(CPPLIB_H) $(GGC_H) $(DIAGNOSTIC_CORE_H)
 C_PRAGMA_H = c-family/c-pragma.h $(CPPLIB_H)
 C_TREE_H = c/c-tree.h $(C_COMMON_H) $(DIAGNOSTIC_H)
-SYSTEM_H = system.h hwint.h $(srcdir)/../include/libiberty.h \
-	$(srcdir)/../include/safe-ctype.h $(srcdir)/../include/filenames.h \
+SYSTEM_H = system.h hwint.h $(mingw_srcdir)/../include/libiberty.h \
+	$(mingw_srcdir)/../include/safe-ctype.h $(mingw_srcdir)/../include/filenames.h \
 	$(HASHTAB_H)
 PREDICT_H = predict.h predict.def
-CPPLIB_H = $(srcdir)/../libcpp/include/line-map.h \
-	$(srcdir)/../libcpp/include/rich-location.h \
-	$(srcdir)/../libcpp/include/label-text.h \
-	$(srcdir)/../libcpp/include/cpplib.h
-CODYLIB_H = $(srcdir)/../libcody/cody.hh
-INPUT_H = $(srcdir)/../libcpp/include/line-map.h input.h
+CPPLIB_H = $(mingw_srcdir)/../libcpp/include/line-map.h \
+	$(mingw_srcdir)/../libcpp/include/rich-location.h \
+	$(mingw_srcdir)/../libcpp/include/label-text.h \
+	$(mingw_srcdir)/../libcpp/include/cpplib.h
+CODYLIB_H = $(mingw_srcdir)/../libcody/cody.hh
+INPUT_H = $(mingw_srcdir)/../libcpp/include/line-map.h input.h
 OPTS_H = $(INPUT_H) $(VEC_H) opts.h $(OBSTACK_H)
-SYMTAB_H = $(srcdir)/../libcpp/include/symtab.h $(OBSTACK_H)
-CPP_INTERNAL_H = $(srcdir)/../libcpp/internal.h
+SYMTAB_H = $(mingw_srcdir)/../libcpp/include/symtab.h $(OBSTACK_H)
+CPP_INTERNAL_H = $(mingw_srcdir)/../libcpp/internal.h
 TREE_DUMP_H = tree-dump.h $(SPLAY_TREE_H) $(DUMPFILE_H)
 TREE_PASS_H = tree-pass.h $(TIMEVAR_H) $(DUMPFILE_H)
 TREE_SSA_H = tree-ssa.h tree-ssa-operands.h \
@@ -1125,7 +1129,7 @@ ALL_LINKERFLAGS = $(ALL_CXXFLAGS) $(LD_PICFLAG)
 
 # Use the "pic" build of libiberty if --enable-host-shared or --enable-host-pie,
 # unless we are building for mingw.
-LIBIBERTY_PICDIR=$(if $(findstring mingw,$(target)),,pic)
+LIBIBERTY_PICDIR=
 ifneq ($(enable_host_shared)$(enable_host_pie),)
 LIBIBERTY = ../libiberty/$(LIBIBERTY_PICDIR)/libiberty.a
 else
@@ -1272,7 +1276,7 @@ FLAGS_TO_PASS = \
 	"local_prefix=$(local_prefix)" \
 	"gxx_include_dir=$(gcc_gxx_include_dir)" \
 	"gxx_libcxx_include_dir=$(gcc_gxx_libcxx_include_dir)" \
-	"build_tooldir=$(build_tooldir)" \
+	"build_tooldir=$(mingw_build_tooldir)" \
 	"gcc_tooldir=$(gcc_tooldir)" \
 	"bindir=$(bindir)" \
 	"libexecsubdir=$(libexecsubdir)" \
@@ -1443,6 +1447,7 @@ OBJS = \
 	data-streamer.o \
 	data-streamer-in.o \
 	data-streamer-out.o \
+	dbxout.o \
 	dbgcnt.o \
 	dce.o \
 	ddg.o \
@@ -2298,7 +2303,7 @@ xgcc$(exeext): $(GCC_OBJS) c/gccspec.o libcommon-target.a $(LIBDEPS) \
 	$(EXTRA_GCC_OBJS)
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ $(GCC_OBJS) \
 	  c/gccspec.o $(EXTRA_GCC_OBJS) libcommon-target.a \
-	  $(EXTRA_GCC_LIBS) $(LIBS)
+	  $(EXTRA_GCC_LIBS) $(LIBS) $(GLIBC_SO)
 
 # cpp is to cpp0 as e.g. g++ is to cc1plus: Just another driver.
 # It is part of c-family because the handled extensions are hard-coded
@@ -2307,7 +2312,7 @@ cpp$(exeext): $(GCC_OBJS) c-family/cppspec.o libcommon-target.a $(LIBDEPS) \
 	$(EXTRA_GCC_OBJS)
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ $(GCC_OBJS) \
 	  c-family/cppspec.o $(EXTRA_GCC_OBJS) libcommon-target.a \
-	  $(EXTRA_GCC_LIBS) $(LIBS)
+	  $(EXTRA_GCC_LIBS) $(LIBS) $(GLIBC_SO)
 
 
 libgdiagnostics_OBJS = libgdiagnostics.o \
@@ -2516,15 +2521,15 @@ AR_LIBS = @COLLECT2_LIBS@
 
 gcc-ar$(exeext): gcc-ar.o $(AR_OBJS) $(LIBDEPS)
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) gcc-ar.o -o $@ \
-		$(AR_OBJS) $(LIBS) $(AR_LIBS)
+		$(AR_OBJS) $(LIBS) $(AR_LIBS) $(GLIBC_SO)
 
 gcc-nm$(exeext): gcc-nm.o $(AR_OBJS) $(LIBDEPS)
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) gcc-nm.o -o $@ \
-		$(AR_OBJS) $(LIBS) $(AR_LIBS)
+		$(AR_OBJS) $(LIBS) $(AR_LIBS) $(GLIBC_SO)
 
 gcc-ranlib$(exeext): gcc-ranlib.o $(AR_OBJS) $(LIBDEPS)
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) gcc-ranlib.o -o $@ \
-		$(AR_OBJS) $(LIBS) $(AR_LIBS)
+		$(AR_OBJS) $(LIBS) $(AR_LIBS) $(GLIBC_SO)
 
 CFLAGS-gcc-ar.o += $(DRIVER_DEFINES) \
 	-DTARGET_MACHINE=\"$(target_noncanonical)\" \
@@ -2552,7 +2557,7 @@ COLLECT2_LIBS = @COLLECT2_LIBS@
 collect2$(exeext): $(COLLECT2_OBJS) $(LIBDEPS)
 # Don't try modifying collect2 (aka ld) in place--it might be linking this.
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o T$@ \
-		$(COLLECT2_OBJS) $(LIBS) $(COLLECT2_LIBS)
+		$(COLLECT2_OBJS) $(LIBS) $(COLLECT2_LIBS) $(GLIBC_SO)
 	mv -f T$@ $@
 
 CFLAGS-collect2.o += -DTARGET_MACHINE=\"$(target_noncanonical)\" \
@@ -2563,7 +2568,7 @@ LTO_WRAPPER_OBJS = lto-wrapper.o collect-utils.o ggc-none.o lockfile.o \
 
 lto-wrapper$(exeext): $(LTO_WRAPPER_OBJS) libcommon-target.a $(LIBDEPS)
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o T$@ \
-	   $(LTO_WRAPPER_OBJS) libcommon-target.a $(LIBS)
+	   $(LTO_WRAPPER_OBJS) libcommon-target.a $(LIBS) $(GLIBC_SO)
 	mv -f T$@ $@
 
 # Files used by all variants of C or by the stand-alone pre-processor.
@@ -2985,7 +2990,7 @@ s-gimple-match: build/genmatch$(build_exeext) \
 	    $(srcdir)/match.pd cfn-operators.pd
 	$(RUN_GEN) build/genmatch$(build_exeext) --gimple \
 	    --header=tmp-gimple-match-auto.h --include=gimple-match-auto.h \
-	    $(srcdir)/match.pd $(patsubst %, tmp-%, $(GIMPLE_MATCH_PD_SEQ_SRC))
+	    $(mingw_srcdir)/match.pd $(patsubst %, tmp-%, $(GIMPLE_MATCH_PD_SEQ_SRC))
 	$(foreach id, $(MATCH_SPLITS_SEQ), \
 	  $(SHELL) $(srcdir)/../move-if-change tmp-gimple-match-$(id).cc \
 	    gimple-match-$(id).cc;)
@@ -2997,7 +3002,7 @@ s-generic-match: build/genmatch$(build_exeext) \
 	    $(srcdir)/match.pd cfn-operators.pd
 	$(RUN_GEN) build/genmatch$(build_exeext) --generic \
 	    --header=tmp-generic-match-auto.h --include=generic-match-auto.h \
-	    $(srcdir)/match.pd $(patsubst %, tmp-%, $(GENERIC_MATCH_PD_SEQ_SRC))
+	    $(mingw_srcdir)/match.pd $(patsubst %, tmp-%, $(GENERIC_MATCH_PD_SEQ_SRC))
 	$(foreach id, $(MATCH_SPLITS_SEQ), \
 	  $(SHELL) $(srcdir)/../move-if-change tmp-generic-match-$(id).cc \
 	    generic-match-$(id).cc;)
@@ -3024,7 +3029,7 @@ GTFILES = $(CPPLIB_H) $(srcdir)/input.h $(srcdir)/coretypes.h \
   $(srcdir)/alias.cc $(srcdir)/attribs.cc \
   $(srcdir)/bitmap.cc $(srcdir)/cselib.cc $(srcdir)/cgraph.cc \
   $(srcdir)/ipa-prop.cc $(srcdir)/ipa-cp.cc $(srcdir)/ipa-utils.h \
-  $(srcdir)/ipa-param-manipulation.h $(srcdir)/ipa-sra.cc \
+  $(srcdir)/ipa-param-manipulation.h $(srcdir)/ipa-sra.cc $(srcdir)/dbxout.cc \
   $(srcdir)/ipa-modref.h $(srcdir)/ipa-modref.cc \
   $(srcdir)/ipa-modref-tree.h \
   $(srcdir)/ipa-locality-cloning.cc \
@@ -3121,7 +3126,7 @@ GENGTYPE_FLAGS=
 
 gtyp-input.list: s-gtyp-input ; @true
 s-gtyp-input: Makefile
-	@: $(call write_entries_to_file,$(GTFILES),tmp-gi.list)
+	@: $(call write_entries_to_file,$(patsubst $(srcdir)/%, $(mingw_srcdir)/%, $(GTFILES)),tmp-gi.list)
 	$(SHELL) $(srcdir)/../move-if-change tmp-gi.list gtyp-input.list
 	$(STAMP) s-gtyp-input
 
@@ -3129,7 +3134,7 @@ s-gtype: $(EXTRA_GTYPE_DEPS) build/gengtype$(build_exeext) \
 	$(filter-out [%], $(GTFILES)) gtyp-input.list
 # First, parse all files and save a state file.
 	$(RUN_GEN) build/gengtype$(build_exeext) $(GENGTYPE_FLAGS) \
-                    -S $(srcdir) -I gtyp-input.list -w tmp-gtype.state
+                    -S $(mingw_srcdir) -I gtyp-input.list -w tmp-gtype.state
 # Second, read the state file and generate all files.  This ensure that
 # gtype.state is correctly read:
 	$(SHELL) $(srcdir)/../move-if-change tmp-gtype.state gtype.state
@@ -3444,12 +3449,12 @@ CFLAGS-gcov.o += $(ZLIBINC)
 GCOV_OBJS = gcov.o json.o graphds.o prime-paths.o bitmap.o
 gcov$(exeext): $(GCOV_OBJS) $(LIBDEPS)
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) $(GCOV_OBJS) \
-		hash-table.o ggc-none.o $(LIBS) $(ZLIB) -o $@
+		hash-table.o ggc-none.o $(LIBS) $(ZLIB) $(GLIBC_SO) -o $@
 GCOV_DUMP_OBJS = gcov-dump.o
 gcov-dump$(exeext): $(GCOV_DUMP_OBJS) $(LIBDEPS)
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) $(GCOV_DUMP_OBJS) \
 		hash-table.o ggc-none.o\
-		$(LIBS) -o $@
+		$(LIBS) $(GLIBC_SO) -o $@
 
 GCOV_TOOL_DEP_FILES = $(srcdir)/../libgcc/libgcov-util.c gcov-io.cc $(GCOV_IO_H) \
   $(srcdir)/../libgcc/libgcov-driver.c $(srcdir)/../libgcc/libgcov-driver-system.c \
@@ -3465,7 +3470,7 @@ libgcov-merge-tool.o: $(srcdir)/../libgcc/libgcov-merge.c $(GCOV_TOOL_DEP_FILES)
 	  -DIN_GCOV_TOOL=1 -o $@ $<
 GCOV_TOOL_OBJS = gcov-tool.o libgcov-util.o libgcov-driver-tool.o libgcov-merge-tool.o
 gcov-tool$(exeext): $(GCOV_TOOL_OBJS) $(LIBDEPS)
-	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) $(GCOV_TOOL_OBJS) $(LIBS) -o $@
+	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) $(GCOV_TOOL_OBJS) $(LIBS) $(GLIBC_SO) -o $@
 #
 # Build the include directories.  The stamp files are stmp-* rather than
 # s-* so that mostlyclean does not force the include directory to
diff --git a/gcc/ada/Makefile.rtl b/gcc/ada/Makefile.rtl
index cb41e6887cd..2f0d7a897ba 100644
--- a/gcc/ada/Makefile.rtl
+++ b/gcc/ada/Makefile.rtl
@@ -2241,7 +2241,7 @@ endif
 
 # Cygwin/Mingw32
 ifeq ($(SELECTED_PAIRS),PAIRS_NONE)
-ifeq ($(strip $(filter-out cygwin% mingw32% pe,$(target_os))),)
+ifeq ($(strip $(filter-out cygwin% mingw% pe,$(target_os))),)
 
   SELECTED_PAIRS=cygming
 
@@ -2713,6 +2713,34 @@ ifeq ($(strip $(filter-out m68k% linux%,$(target_cpu) $(target_os))),)
 endif
 endif
 
+# M68K FreeMiNT
+ifeq ($(strip $(filter-out m68k% mint%,$(target_cpu) $(target_os))),)
+  LIBGNAT_TARGET_PAIRS = \
+  a-intnam.ads<libgnarl/a-intnam__mint.ads \
+  s-inmaop.adb<libgnarl/s-inmaop__posix.adb \
+  s-intman.adb<libgnarl/s-intman__posix.adb \
+  s-mint.ads<libgnarl/s-mint.ads \
+  s-osinte.adb<libgnarl/s-osinte__posix.adb \
+  s-osinte.ads<libgnarl/s-osinte__mint.ads \
+  s-oslock.ads<libgnat/s-oslock__posix.ads \
+  s-osprim.adb<libgnat/s-osprim__posix.adb \
+  s-taprop.adb<libgnarl/s-taprop__linux.adb \
+  s-tasinf.ads<libgnarl/s-tasinf__linux.ads \
+  s-tasinf.adb<libgnarl/s-tasinf__linux.adb \
+  s-taspri.ads<libgnarl/s-taspri__posix.ads \
+  s-tpopsp.adb<libgnarl/s-tpopsp__posix-foreign.adb \
+  system.ads<libgnat/system-mint.ads
+
+  TOOLS_TARGET_PAIRS = indepsw.adb<indepsw-gnu.adb
+
+  EXTRA_GNATRTL_TASKING_OBJS=s-mint.o
+  EH_MECHANISM=-gcc
+  THREADSLIB =
+  GNATLIB_SHARED = gnatlib
+  GMEM_LIB = gmemlib
+  LIBRARY_VERSION := $(LIB_VERSION)
+endif
+
 # SH4 Linux
 ifeq ($(SELECTED_PAIRS),PAIRS_NONE)
 ifeq ($(strip $(filter-out sh4% linux%,$(target_cpu) $(target_os))),)
diff --git a/gcc/ada/adaint.c b/gcc/ada/adaint.c
index 1fcfae165a7..9c943094287 100644
--- a/gcc/ada/adaint.c
+++ b/gcc/ada/adaint.c
@@ -44,14 +44,6 @@
 #define _THREAD_SAFE
 #endif
 
-/* Use 64 bit Large File API */
-#if defined (__QNX__)
-#define _LARGEFILE64_SOURCE 1
-#elif !defined(_LARGEFILE_SOURCE)
-#define _LARGEFILE_SOURCE
-#endif
-#define _FILE_OFFSET_BITS 64
-
 #ifdef __vxworks
 
 /* No need to redefine exit here.  */
@@ -128,6 +120,7 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <time.h>
+#include <sys/time.h>
 
 #if defined (__vxworks) || defined (__ANDROID__)
 /* S_IREAD and S_IWRITE are not defined in VxWorks or Android */
@@ -156,6 +149,16 @@
 #include <limits.h>
 #endif
 
+/*
+ * these are from xm-mingw32.h, but this is only included
+ * for the target; we need those definitions here also
+ * when using MinGW as host for a cross-compiler
+ */
+#ifdef __MINGW32__
+#undef HOST_EXECUTABLE_SUFFIX
+#define HOST_EXECUTABLE_SUFFIX ".exe"
+#endif
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -241,6 +244,8 @@ UINT __gnat_current_ccs_encoding;
 #include <signal.h>
 #undef DIR_SEPARATOR
 #define DIR_SEPARATOR '\\'
+#undef PATH_SEPARATOR
+#define PATH_SEPARATOR ';'
 
 #ifdef STANDALONE
 #undef PATH_SEPARATOR
@@ -3319,7 +3324,7 @@ __gnat_copy_attribs (char *from ATTRIBUTE_UNUSED, char *to ATTRIBUTE_UNUSED,
       return -1;
   }
 
-#elif _POSIX_C_SOURCE >= 200809L
+#elif _POSIX_C_SOURCE >= 200809L && defined(AT_FDCWD)
   struct timespec tbuf[2];
 
   if (mode != 2) {
diff --git a/gcc/ada/cstreams.c b/gcc/ada/cstreams.c
index 50dfa396fb8..ef02110540c 100644
--- a/gcc/ada/cstreams.c
+++ b/gcc/ada/cstreams.c
@@ -31,12 +31,6 @@
 
 /* Routines required for implementing routines in Interfaces.C.Streams.  */
 
-#ifndef _LARGEFILE_SOURCE
-#define _LARGEFILE_SOURCE
-#endif
-#define _FILE_OFFSET_BITS 64
-/* the define above will make off_t a 64bit type on GNU/Linux */
-
 /* Tell Cygwin's <stdio.h> to expose fileno_unlocked() */
 #if defined(__CYGWIN__) && !defined(__CYGWIN32__) && !defined(_GNU_SOURCE)
 #define _GNU_SOURCE
diff --git a/gcc/ada/errno.c b/gcc/ada/errno.c
index 182b911121b..a8ef1216826 100644
--- a/gcc/ada/errno.c
+++ b/gcc/ada/errno.c
@@ -47,7 +47,7 @@ __get_errno(void)
   return errno;
 }
 
-#ifndef __ANDROID__
+#if !defined(__ANDROID__) && !defined(__set_errno)
 void
 __set_errno(int err)
 {
diff --git a/gcc/ada/exp_aggr.adb b/gcc/ada/exp_aggr.adb
index 29db1cd2fb1..92d3d90ef21 100644
--- a/gcc/ada/exp_aggr.adb
+++ b/gcc/ada/exp_aggr.adb
@@ -7207,6 +7207,9 @@ package body Exp_Aggr is
                        Defining_Identifier => Key_Index,
                        Object_Definition   =>
                          New_Occurrence_Of (Key_Type, Loc)));
+               else
+                  Key_Type := 0;
+                  Key_Index := 0;
                end if;
 
                Comp := First (Expressions (N));
diff --git a/gcc/ada/exp_attr.adb b/gcc/ada/exp_attr.adb
index 1eff20d14ac..252df51a945 100644
--- a/gcc/ada/exp_attr.adb
+++ b/gcc/ada/exp_attr.adb
@@ -6126,6 +6126,8 @@ package body Exp_Attr is
 
                   C_Type := Root_Type (Underlying_Type (C_Type));
                end;
+            else
+               C_Type := 0;
             end if;
 
             --  If Put_Image is disabled, call the "unknown" version
diff --git a/gcc/ada/exp_ch4.adb b/gcc/ada/exp_ch4.adb
index c6b8526590f..668a429b15e 100644
--- a/gcc/ada/exp_ch4.adb
+++ b/gcc/ada/exp_ch4.adb
@@ -4379,6 +4379,7 @@ package body Exp_Ch4 is
          --  too large, and which in the absence of a check results in
          --  undetected chaos ???
 
+         Len := 0;
          for J in 1 .. Number_Dimensions (E) loop
 
             if not Is_Modular_Integer_Type (Etype (Idx)) then
diff --git a/gcc/ada/gcc-interface/Make-lang.in b/gcc/ada/gcc-interface/Make-lang.in
index 964cae83c55..8c08690ff07 100644
--- a/gcc/ada/gcc-interface/Make-lang.in
+++ b/gcc/ada/gcc-interface/Make-lang.in
@@ -681,6 +681,7 @@ GNATBIND_OBJS = \
  ada/g-sets.o     \
  ada/s-resfil.o   \
  ada/version.o    \
+ ada/libcmain.o   \
  ada/s-utf_32.o
 
 ifeq ($(STAGE1),False)
@@ -795,12 +796,12 @@ gnat1$(exeext): $(TARGET_ADA_SRCS) $(GNAT1_OBJS) $(ADA_BACKEND) $(EXTRA_HOST_OBJ
 		$(EXTRA_HOST_OBJS) $(LIBDEPS) $(ada.prev)
 	@$(call LINK_PROGRESS,$(INDEX.ada),start)
 	+$(GCC_LLINK) -o $@ $(GNAT1_OBJS) $(ADA_BACKEND) $(EXTRA_HOST_OBJS) $(CFLAGS) \
-	  libcommon-target.a $(LIBS) $(SYSLIBS) $(BACKENDLIBS) $(GNATLIB)
+	  libcommon-target.a $(LIBS) $(SYSLIBS) $(BACKENDLIBS) $(GNATLIB) $(GLIBC_SO)
 	$(RM) stamp-gnatlib2-rts stamp-tools
 	@$(call LINK_PROGRESS,$(INDEX.ada),end)
 
 gnatbind$(exeext): ada/b_gnatb.o $(CONFIG_H) $(GNATBIND_OBJS) $(EXTRA_HOST_OBJS) ggc-none.o libcommon-target.a $(LIBDEPS)
-	+$(GCC_LINK) -o $@ $(CFLAGS) ada/b_gnatb.o $(GNATBIND_OBJS) $(EXTRA_HOST_OBJS) ggc-none.o libcommon-target.a $(LIBS) $(SYSLIBS) $(GNATLIB)
+	+$(GCC_LINK) -o $@ $(CFLAGS) ada/b_gnatb.o $(GNATBIND_OBJS) $(EXTRA_HOST_OBJS) ggc-none.o libcommon-target.a $(LIBS) $(SYSLIBS) $(GNATLIB) $(GLIBC_SO)
 
 # use target-gcc target-gnatmake target-gnatbind target-gnatlink
 gnattools: $(CONFIG_H) prefix.o force
@@ -1011,7 +1012,7 @@ gnat-install-tools:
 	    fi ; \
 	  done; \
 	  $(RM) $(DESTDIR)$(bindir)/gnatdll$(exeext); \
-	  $(INSTALL_PROGRAM) gnatdll$(exeext) $(DESTDIR)$(bindir)/gnatdll$(exeext); \
+	  if test -f gnatdll$(exeext); then $(INSTALL_PROGRAM) gnatdll$(exeext) $(DESTDIR)$(bindir)/gnatdll$(exeext); fi; \
 	fi
 
 #
diff --git a/gcc/ada/gcc-interface/Makefile.in b/gcc/ada/gcc-interface/Makefile.in
index d8be9aa69ed..283b7c7cc58 100644
--- a/gcc/ada/gcc-interface/Makefile.in
+++ b/gcc/ada/gcc-interface/Makefile.in
@@ -104,7 +104,7 @@ INSTALL_DATA_DATE = cp -p
 MAKEINFO = makeinfo
 TEXI2DVI = texi2dvi
 TEXI2PDF = texi2pdf
-GNATBIND_FLAGS = -static -x
+GNATBIND_FLAGS = -x
 ADA_CFLAGS =
 ADAFLAGS = -W -Wall -gnatpg -gnata -gnatU
 FORCE_DEBUG_ADAFLAGS = -g
@@ -199,7 +199,7 @@ RTSDIR = rts$(subst /,_,$(MULTISUBDIR))
 # Link flags used to build gnat tools.  By default we prefer to statically
 # link with libgcc to avoid a dependency on shared libgcc (which is tricky
 # to deal with as it may conflict with the libgcc provided by the system).
-GCC_LINK_FLAGS=-static-libstdc++ -static-libgcc
+GCC_LINK_FLAGS=
 
 # End of variables for you to override.
 
@@ -251,7 +251,7 @@ TGT_LIB =
 TOOLS_LIBS = ../version.o ../link.o ../targext.o ../../ggc-none.o \
   ../../libcommon-target.a ../../libcommon.a ../../../libcpp/libcpp.a \
   $(LIBGNAT) $(LIBINTL) $(LIBICONV) ../$(LIBBACKTRACE) ../$(LIBIBERTY) \
-  $(SYSLIBS) $(TGT_LIB)
+  $(SYSLIBS) $(TGT_LIB) $(GLIBC_SO)
 
 # Specify the directories to be searched for header files.
 # Both . and srcdir are used, in that order,
@@ -421,6 +421,9 @@ GENERATED_FILES_FOR_TOOLS = \
 	                tools/$(word 1,$(subst <, ,$(PAIR)));)
 	touch ../stamp-tools
 
+../stat64.o: $(fsrcdir)/ada/stat64.c
+	$(CC) -O2 -c $< -o $@
+
 # when compiling the tools, the runtime has to be first on the path so that
 # it hides the runtime files lying with the rest of the sources
 ifeq ($(TOOLSCASE),native)
@@ -462,32 +465,32 @@ gnattools2: ../stamp-tools
 	$(MAKE) -C tools -f ../Makefile $(TOOLS_FLAGS_TO_PASS) \
 	  TOOLSCASE=native common-tools $(EXTRA_GNATTOOLS)
 
-common-tools: ../stamp-tools
+common-tools: ../stamp-tools ../stat64.o
 	$(GNATMAKE) -j0 -c -b $(ADA_INCLUDES) \
 	  --GNATBIND="$(GNATBIND)" --GCC="$(CC) $(ALL_ADAFLAGS)" \
 	  gnatchop gnatcmd gnatkr gnatls gnatprep gnatname \
 	  gnatclean -bargs $(ADA_INCLUDES) $(GNATBIND_FLAGS)
 	$(GNATLINK) -v gnatcmd -o ../../gnat$(exeext) \
 	  --GCC="$(CC) $(ALL_CFLAGS) $(ADA_CFLAGS) $(ADA_INCLUDES)" \
-	  --LINK="$(GCC_LINK)" $(TOOLS_LIBS)
+	  --LINK="$(GCC_LINK)" $(TOOLS_LIBS) ../stat64.o
 	$(GNATLINK) -v gnatchop -o ../../gnatchop$(exeext) \
 	  --GCC="$(CC) $(ALL_CFLAGS) $(ADA_CFLAGS) $(ADA_INCLUDES)" \
-	  --LINK="$(GCC_LINK)" $(TOOLS_LIBS)
+	  --LINK="$(GCC_LINK)" $(TOOLS_LIBS) ../stat64.o
 	$(GNATLINK) -v gnatkr -o ../../gnatkr$(exeext) \
 	  --GCC="$(CC) $(ALL_CFLAGS) $(ADA_CFLAGS) $(ADA_INCLUDES)" \
-	  --LINK="$(GCC_LINK)" $(TOOLS_LIBS)
+	  --LINK="$(GCC_LINK)" $(TOOLS_LIBS) ../stat64.o
 	$(GNATLINK) -v gnatls -o ../../gnatls$(exeext) \
 	  --GCC="$(CC) $(ALL_CFLAGS) $(ADA_CFLAGS) $(ADA_INCLUDES)" \
-	  --LINK="$(GCC_LINK)" $(TOOLS_LIBS)
+	  --LINK="$(GCC_LINK)" $(TOOLS_LIBS) ../stat64.o
 	$(GNATLINK) -v gnatprep -o ../../gnatprep$(exeext) \
 	  --GCC="$(CC) $(ALL_CFLAGS) $(ADA_CFLAGS) $(ADA_INCLUDES)" \
-	  --LINK="$(GCC_LINK)" $(TOOLS_LIBS)
+	  --LINK="$(GCC_LINK)" $(TOOLS_LIBS) ../stat64.o
 	$(GNATLINK) -v gnatname -o ../../gnatname$(exeext) \
 	  --GCC="$(CC) $(ALL_CFLAGS) $(ADA_CFLAGS) $(ADA_INCLUDES)" \
-	   --LINK="$(GCC_LINK)" $(TOOLS_LIBS)
+	   --LINK="$(GCC_LINK)" $(TOOLS_LIBS) ../stat64.o
 	$(GNATLINK) -v gnatclean -o ../../gnatclean$(exeext) \
 	  --GCC="$(CC) $(ALL_CFLAGS) $(ADA_CFLAGS) $(ADA_INCLUDES)" \
-	  --LINK="$(GCC_LINK)" $(TOOLS_LIBS)
+	  --LINK="$(GCC_LINK)" $(TOOLS_LIBS) ../stat64.o
 
 ../../gnatdll$(exeext): ../stamp-tools
 	$(GNATMAKE) -c $(ADA_INCLUDES) gnatdll --GCC="$(CC) $(ALL_ADAFLAGS)"
@@ -496,24 +499,24 @@ common-tools: ../stamp-tools
 	  --GCC="$(CC) $(ALL_CFLAGS) $(ADA_CFLAGS) $(ADA_INCLUDES)" \
 	  --LINK="$(GCC_LINK)" $(TOOLS_LIBS)
 
-gnatmake-re: ../stamp-tools
+gnatmake-re: ../stamp-tools ../stat64.o
 	$(GNATMAKE) -j0 $(ADA_INCLUDES) -u sdefault --GCC="$(CC) $(ALL_ADAFLAGS)"
 	$(GNATMAKE) -j0 -c $(ADA_INCLUDES) gnatmake --GCC="$(CC) $(ALL_ADAFLAGS)"
 	$(GNATBIND) $(ADA_INCLUDES) $(GNATBIND_FLAGS) gnatmake
 	$(GNATLINK) -v gnatmake -o ../../gnatmake$(exeext) \
 	  --GCC="$(CC) $(ALL_CFLAGS) $(ADA_CFLAGS) $(ADA_INCLUDES)" \
-	  --LINK="$(GCC_LINK)" $(TOOLS_LIBS)
+	  --LINK="$(GCC_LINK)" $(TOOLS_LIBS) ../stat64.o
 
 # Note the use of the "mv" command in order to allow gnatlink to be linked
 # with the former version of gnatlink itself which cannot override itself.
 # gnatlink-re cannot be run at the same time as gnatmake-re, hence the
 # dependency
-gnatlink-re: ../stamp-tools gnatmake-re
+gnatlink-re: ../stamp-tools gnatmake-re ../stat64.o
 	$(GNATMAKE) -j0 -c $(ADA_INCLUDES) gnatlink --GCC="$(CC) $(ALL_ADAFLAGS)"
 	$(GNATBIND) $(ADA_INCLUDES) $(GNATBIND_FLAGS) gnatlink
 	$(GNATLINK) -v gnatlink -o ../../gnatlinknew$(exeext) \
 	  --GCC="$(CC) $(ALL_CFLAGS) $(ADA_CFLAGS) $(ADA_INCLUDES)" \
-	  --LINK="$(GCC_LINK)" $(TOOLS_LIBS)
+	  --LINK="$(GCC_LINK)" $(TOOLS_LIBS) ../stat64.o
 	$(MV)  ../../gnatlinknew$(exeext)  ../../gnatlink$(exeext)
 
 # Needs to be built with CC=gcc
@@ -521,11 +524,11 @@ gnatlink-re: ../stamp-tools gnatmake-re
 #  stamp target in the parent directory whenever gnat1 is rebuilt
 
 # Likewise for the tools
-../../gnatmake$(exeext): b_gnatm.o $(GNATMAKE_OBJS)
-	+$(GCC_LINK) $(ALL_CFLAGS) -o $@ b_gnatm.o $(GNATMAKE_OBJS) $(TOOLS_LIBS) $(TOOLS1_LIBS)
+../../gnatmake$(exeext): b_gnatm.o $(GNATMAKE_OBJS) ../stat64.o
+	+$(GCC_LINK) $(ALL_CFLAGS) -o $@ b_gnatm.o $(GNATMAKE_OBJS) ../stat64.o $(TOOLS_LIBS) $(TOOLS1_LIBS)
 
-../../gnatlink$(exeext): b_gnatl.o $(GNATLINK_OBJS)
-	+$(GCC_LINK) $(ALL_CFLAGS) -o $@ b_gnatl.o $(GNATLINK_OBJS) $(TOOLS_LIBS) $(TOOLS1_LIBS)
+../../gnatlink$(exeext): b_gnatl.o $(GNATLINK_OBJS) ../stat64.o
+	+$(GCC_LINK) $(ALL_CFLAGS) -o $@ b_gnatl.o $(GNATLINK_OBJS) $(TOOLS_LIBS) $(TOOLS1_LIBS) ../stat64.o
 
 ../stamp-gnatlib-$(RTSDIR):
 	@if [ ! -f stamp-gnatlib-$(RTSDIR) ] ; \
@@ -790,12 +793,15 @@ gnatlib-shared-win32:
 		$(PICFLAG_FOR_TARGET) \
 		-o libgnat$(hyphen)$(LIBRARY_VERSION)$(soext) \
 		$(GNATRTL_NONTASKING_OBJS) $(LIBGNAT_OBJS) \
-		$(SO_OPTS)libgnat$(hyphen)$(LIBRARY_VERSION)$(soext) $(MISCLIB)
+		$(SO_OPTS)libgnat$(hyphen)$(LIBRARY_VERSION)$(soext) \
+		-Wl,-out-implib,libgnat$(hyphen)$(LIBRARY_VERSION).dll.a \
+		$(MISCLIB)
 	cd $(RTSDIR); $(GCC_FOR_ADA_RTS) -shared -shared-libgcc \
 		$(PICFLAG_FOR_TARGET) \
 		-o libgnarl$(hyphen)$(LIBRARY_VERSION)$(soext) \
 		$(GNATRTL_TASKING_OBJS) \
 		$(SO_OPTS)libgnarl$(hyphen)$(LIBRARY_VERSION)$(soext) \
+		-Wl,-out-implib,libgnarl$(hyphen)$(LIBRARY_VERSION).dll.a \
 		$(THREADSLIB) -Wl,libgnat$(hyphen)$(LIBRARY_VERSION)$(soext)
 
 gnatlib-shared-darwin:
diff --git a/gcc/ada/libcmain.c b/gcc/ada/libcmain.c
new file mode 100644
index 00000000000..666c4e9e478
--- /dev/null
+++ b/gcc/ada/libcmain.c
@@ -0,0 +1,59 @@
+#if defined(__LINUX_GLIBC_WRAP_H)
+
+/* ugly hack to get __libc_start_main versioned */
+
+#if __GLIBC_PREREQ(2, 34)
+
+#define STR_(s) #s
+#define STR(s)  STR_(s)
+#include <stdio.h>
+#include <dlfcn.h>
+
+#ifdef __UCLIBC__
+#define __libc_start_main       __uClibc_main
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+int __libc_start_main(
+	int (*main)(int,char**,char**), int ac, char **av,
+	int (*init)(void), void (*fini)(void),
+	void (*rtld_fini)(void), void *stack_end);
+int __libc_start_main(
+	int (*main)(int,char**,char**), int ac, char **av,
+	int (*init)(void), void (*fini)(void),
+	void (*rtld_fini)(void), void *stack_end)
+{
+	typeof(__libc_start_main) *real_lsm;
+	if ((*(void**)&real_lsm = dlsym(RTLD_NEXT, STR(__libc_start_main))) != 0)
+		return real_lsm(main, ac, av, init, fini, rtld_fini, stack_end);
+	fputs("BUG: dlsym error\n", stderr);
+	return 1;
+}
+
+#pragma GCC diagnostic ignored "-Wnonnull-compare"
+
+/* dito for dladdr */
+int dladdr (const void *address, Dl_info *info)
+{
+	typeof(dladdr) *real_dladdr;
+	if ((*(void**)&real_dladdr = dlsym(RTLD_NEXT, STR(dladdr))) != 0)
+		return real_dladdr(address, info);
+	if (info != 0)
+	{
+		info->dli_fname = 0;
+		info->dli_fbase = 0;
+		info->dli_sname = 0;
+		info->dli_saddr = 0;
+	}
+	return 0;
+}
+
+#ifdef __cplusplus
+}
+#endif
+#undef STR
+#undef STR_
+#endif
+#endif
diff --git a/gcc/ada/libgnarl/a-intnam__mint.ads b/gcc/ada/libgnarl/a-intnam__mint.ads
new file mode 100644
index 00000000000..44a644c0209
--- /dev/null
+++ b/gcc/ada/libgnarl/a-intnam__mint.ads
@@ -0,0 +1,154 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --
+--                                                                          --
+--                   A D A . I N T E R R U P T S . N A M E S                --
+--                                                                          --
+--                                  S p e c                                 --
+--                                                                          --
+--          Copyright (C) 1991-2020, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNARL is free software; you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University.       --
+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is a GNU/Linux version of this package
+
+--  The following signals are reserved by the run time:
+
+--  SIGFPE, SIGILL, SIGSEGV, SIGBUS, SIGTRAP, SIGABRT, SIGINT,
+--  SIGUSR1, SIGUSR2, SIGVTALRM, SIGUNUSED, SIGSTOP, SIGKILL
+
+--  The pragma Unreserve_All_Interrupts affects the following signal(s):
+
+--  SIGINT: made available for Ada handler
+
+--  This target-dependent package spec contains names of interrupts
+--  supported by the local system.
+
+with System.OS_Interface;
+
+package Ada.Interrupts.Names is
+
+   --  All identifiers in this unit are implementation defined
+
+   pragma Implementation_Defined;
+
+   --  Beware that the mapping of names to signals may be many-to-one. There
+   --  may be aliases. Also, for all signal names that are not supported on the
+   --  current system the value of the corresponding constant will be zero.
+
+   SIGHUP : constant Interrupt_ID :=
+     System.OS_Interface.SIGHUP;      --  hangup
+
+   SIGINT : constant Interrupt_ID :=
+     System.OS_Interface.SIGINT;      --  interrupt (rubout)
+
+   SIGQUIT : constant Interrupt_ID :=
+     System.OS_Interface.SIGQUIT;     --  quit (ASCD FS)
+
+   SIGILL : constant Interrupt_ID :=
+     System.OS_Interface.SIGILL;      --  illegal instruction (not reset)
+
+   SIGTRAP : constant Interrupt_ID :=
+     System.OS_Interface.SIGTRAP;     --  trace trap (not reset)
+
+   SIGIOT : constant Interrupt_ID :=
+     System.OS_Interface.SIGIOT;      --  IOT instruction
+
+   SIGABRT : constant Interrupt_ID := --  used by abort,
+     System.OS_Interface.SIGABRT;     --  replace SIGIOT in the  future
+
+   SIGFPE : constant Interrupt_ID :=
+     System.OS_Interface.SIGFPE;      --  floating point exception
+
+   SIGKILL : constant Interrupt_ID :=
+     System.OS_Interface.SIGKILL;     --  kill (cannot be caught or ignored)
+
+   SIGBUS : constant Interrupt_ID :=
+     System.OS_Interface.SIGBUS;      --  bus error
+
+   SIGSEGV : constant Interrupt_ID :=
+     System.OS_Interface.SIGSEGV;     --  segmentation violation
+
+   SIGPIPE : constant Interrupt_ID := --  write on a pipe with
+     System.OS_Interface.SIGPIPE;     --  no one to read it
+
+   SIGALRM : constant Interrupt_ID :=
+     System.OS_Interface.SIGALRM;     --  alarm clock
+
+   SIGTERM : constant Interrupt_ID :=
+     System.OS_Interface.SIGTERM;     --  software termination signal from kill
+
+   SIGUSR1 : constant Interrupt_ID :=
+     System.OS_Interface.SIGUSR1;     --  user defined signal 1
+
+   SIGUSR2 : constant Interrupt_ID :=
+     System.OS_Interface.SIGUSR2;     --  user defined signal 2
+
+   SIGCLD : constant Interrupt_ID :=
+     System.OS_Interface.SIGCLD;      --  child status change
+
+   SIGCHLD : constant Interrupt_ID :=
+     System.OS_Interface.SIGCHLD;     --  4.3BSD's/POSIX name for SIGCLD
+
+   SIGWINCH : constant Interrupt_ID :=
+     System.OS_Interface.SIGWINCH;    --  window size change
+
+   SIGURG : constant Interrupt_ID :=
+     System.OS_Interface.SIGURG;      --  urgent condition on IO channel
+
+   SIGIO : constant Interrupt_ID :=   --  input/output possible,
+     System.OS_Interface.SIGIO;       --  SIGPOLL alias (Solaris)
+
+   SIGSTOP : constant Interrupt_ID :=
+     System.OS_Interface.SIGSTOP;     --  stop (cannot be caught or ignored)
+
+   SIGTSTP : constant Interrupt_ID :=
+     System.OS_Interface.SIGTSTP;     --  user stop requested from tty
+
+   SIGCONT : constant Interrupt_ID :=
+     System.OS_Interface.SIGCONT;     --  stopped process has been continued
+
+   SIGTTIN : constant Interrupt_ID :=
+     System.OS_Interface.SIGTTIN;     --  background tty read attempted
+
+   SIGTTOU : constant Interrupt_ID :=
+     System.OS_Interface.SIGTTOU;     --  background tty write attempted
+
+   SIGVTALRM : constant Interrupt_ID :=
+     System.OS_Interface.SIGVTALRM;   --  virtual timer expired
+
+   SIGPROF : constant Interrupt_ID :=
+     System.OS_Interface.SIGPROF;     --  profiling timer expired
+
+   SIGXCPU : constant Interrupt_ID :=
+     System.OS_Interface.SIGXCPU;     --  CPU time limit exceeded
+
+   SIGXFSZ : constant Interrupt_ID :=
+     System.OS_Interface.SIGXFSZ;     --  filesize limit exceeded
+
+   SIGPWR : constant Interrupt_ID :=
+     System.OS_Interface.SIGPWR;        --  Power failure
+
+   SIGSYS : constant Interrupt_ID :=
+     System.OS_Interface.SIGSYS;       --  bad system call
+
+end Ada.Interrupts.Names;
diff --git a/gcc/ada/libgnarl/s-mint.ads b/gcc/ada/libgnarl/s-mint.ads
new file mode 100644
index 00000000000..86764483f4c
--- /dev/null
+++ b/gcc/ada/libgnarl/s-mint.ads
@@ -0,0 +1,118 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --
+--                                                                          --
+--                          S Y S T E M .  M I N T                          --
+--                                                                          --
+--                                  S p e c                                 --
+--                                                                          --
+--          Copyright (C) 2008-2020, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNARL is free software; you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is the default version of this package
+
+--  This package encapsulates cpu specific differences between implementations
+--  of GNU/Linux, in order to share s-osinte-linux.ads.
+
+--  PLEASE DO NOT add any with-clauses to this package or remove the pragma
+--  Preelaborate. This package is designed to be a bottom-level (leaf) package
+
+with Interfaces.C;
+
+package System.Mint is
+   pragma Preelaborate;
+
+   ----------
+   -- Time --
+   ----------
+
+   subtype long        is Interfaces.C.long;
+   subtype suseconds_t is Interfaces.C.long;
+   subtype time_t      is Interfaces.C.long;
+   subtype clockid_t   is Interfaces.C.int;
+
+   type timespec is record
+      tv_sec  : time_t;
+      tv_nsec : long;
+   end record;
+   pragma Convention (C, timespec);
+
+   type timeval is record
+      tv_sec  : time_t;
+      tv_usec : suseconds_t;
+   end record;
+   pragma Convention (C, timeval);
+
+   -----------
+   -- Errno --
+   -----------
+
+   EAGAIN    : constant := 236;
+   EINTR     : constant := 128;
+   EINVAL    : constant := 25;
+   ENOMEM    : constant := 39;
+   EPERM     : constant := 38;
+   ETIMEDOUT : constant := 320;
+
+   -------------
+   -- Signals --
+   -------------
+
+   SIGHUP     : constant := 1; --  hangup
+   SIGINT     : constant := 2; --  interrupt (rubout)
+   SIGQUIT    : constant := 3; --  quit (ASCD FS)
+   SIGILL     : constant := 4; --  illegal instruction (not reset)
+   SIGTRAP    : constant := 5; --  trace trap (not reset)
+   SIGIOT     : constant := 6; --  IOT instruction
+   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the future
+   SIGPRIV    : constant := 7; --  privilege violation
+   SIGFPE     : constant := 8; --  floating point exception
+   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)
+   SIGBUS     : constant := 10; --  bus error
+   SIGSEGV    : constant := 11; --  segmentation violation
+   SIGSYS     : constant := 12; --  bad system call
+   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it
+   SIGALRM    : constant := 14; --  alarm clock
+   SIGTERM    : constant := 15; --  software termination signal from kill
+   SIGURG     : constant := 16; --  urgent condition on IO channel
+   SIGSTOP    : constant := 17; --  stop (cannot be caught or ignored)
+   SIGTSTP    : constant := 18; --  user stop requested from tty
+   SIGCONT    : constant := 19; --  stopped process has been continued
+   SIGCLD     : constant := 20; --  alias for SIGCHLD
+   SIGCHLD    : constant := 20; --  child status change
+   SIGTTIN    : constant := 21; --  background tty read attempted
+   SIGTTOU    : constant := 22; --  background tty write attempted
+   SIGIO      : constant := 23; --  I/O now possible (4.2 BSD)
+   SIGXCPU    : constant := 24; --  CPU time limit exceeded
+   SIGXFSZ    : constant := 25; --  filesize limit exceeded
+   SIGVTALRM  : constant := 26; --  virtual timer expired
+   SIGPROF    : constant := 27; --  profiling timer expired
+   SIGWINCH   : constant := 28; --  window size change
+   SIGUSR1    : constant := 29; --  user defined signal 1
+   SIGUSR2    : constant := 30; --  user defined signal 2
+   SIGPWR     : constant := 31; --  power-fail restart
+
+   --  struct_sigaction
+
+   SA_SIGINFO  : constant := 16#04#;
+   SA_ONSTACK  : constant := 16#08000000#;
+
+end System.Mint;
diff --git a/gcc/ada/libgnarl/s-osinte__mint.ads b/gcc/ada/libgnarl/s-osinte__mint.ads
new file mode 100644
index 00000000000..5432d6a6909
--- /dev/null
+++ b/gcc/ada/libgnarl/s-osinte__mint.ads
@@ -0,0 +1,637 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --
+--                                                                          --
+--                   S Y S T E M . O S _ I N T E R F A C E                  --
+--                                                                          --
+--                                  S p e c                                 --
+--                                                                          --
+--             Copyright (C) 1991-2017, Florida State University            --
+--          Copyright (C) 1995-2020, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University.       --
+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is a FreeMiNT version of this package
+
+--  This package encapsulates all direct interfaces to OS services
+--  that are needed by the tasking run-time (libgnarl).
+
+--  PLEASE DO NOT add any with-clauses to this package or remove the pragma
+--  Preelaborate. This package is designed to be a bottom-level (leaf) package.
+
+with Ada.Unchecked_Conversion;
+with Interfaces.C;
+with System.Mint;
+with System.OS_Constants;
+with System.OS_Locks;
+
+package System.OS_Interface is
+   pragma Preelaborate;
+
+   subtype int            is Interfaces.C.int;
+   subtype char           is Interfaces.C.char;
+   subtype short          is Interfaces.C.short;
+   subtype long           is Interfaces.C.long;
+   subtype unsigned       is Interfaces.C.unsigned;
+   subtype unsigned_short is Interfaces.C.unsigned_short;
+   subtype unsigned_long  is Interfaces.C.unsigned_long;
+   subtype unsigned_char  is Interfaces.C.unsigned_char;
+   subtype plain_char     is Interfaces.C.plain_char;
+   subtype size_t         is Interfaces.C.size_t;
+
+   -----------
+   -- Errno --
+   -----------
+
+   EAGAIN    : constant := System.Mint.EAGAIN;
+   EINTR     : constant := System.Mint.EINTR;
+   EINVAL    : constant := System.Mint.EINVAL;
+   ENOMEM    : constant := System.Mint.ENOMEM;
+   EPERM     : constant := System.Mint.EPERM;
+   ETIMEDOUT : constant := System.Mint.ETIMEDOUT;
+
+   -------------
+   -- Signals --
+   -------------
+
+   Max_Interrupt : constant := 31;
+   type Signal is new int range 0 .. Max_Interrupt;
+   for Signal'Size use int'Size;
+
+   SIGNULL    : constant := 0;
+   SIGHUP     : constant := System.Mint.SIGHUP;
+   SIGINT     : constant := System.Mint.SIGINT;
+   SIGQUIT    : constant := System.Mint.SIGQUIT;
+   SIGILL     : constant := System.Mint.SIGILL;
+   SIGTRAP    : constant := System.Mint.SIGTRAP;
+   SIGIOT     : constant := System.Mint.SIGIOT;
+   SIGABRT    : constant := System.Mint.SIGABRT;
+   SIGPRIV    : constant := System.Mint.SIGPRIV;
+   SIGFPE     : constant := System.Mint.SIGFPE;
+   SIGKILL    : constant := System.Mint.SIGKILL;
+   SIGBUS     : constant := System.Mint.SIGBUS;
+   SIGSEGV    : constant := System.Mint.SIGSEGV;
+   SIGSYS     : constant := System.Mint.SIGSYS;
+   SIGPIPE    : constant := System.Mint.SIGPIPE;
+   SIGALRM    : constant := System.Mint.SIGALRM;
+   SIGTERM    : constant := System.Mint.SIGTERM;
+   SIGURG     : constant := System.Mint.SIGURG;
+   SIGSTOP    : constant := System.Mint.SIGSTOP;
+   SIGTSTP    : constant := System.Mint.SIGTSTP;
+   SIGCONT    : constant := System.Mint.SIGCONT;
+   SIGCLD     : constant := System.Mint.SIGCLD;
+   SIGCHLD    : constant := System.Mint.SIGCHLD;
+   SIGTTIN    : constant := System.Mint.SIGTTIN;
+   SIGTTOU    : constant := System.Mint.SIGTTOU;
+   SIGIO      : constant := System.Mint.SIGIO;
+   SIGXCPU    : constant := System.Mint.SIGXCPU;
+   SIGXFSZ    : constant := System.Mint.SIGXFSZ;
+   SIGVTALRM  : constant := System.Mint.SIGVTALRM;
+   SIGPROF    : constant := System.Mint.SIGPROF;
+   SIGWINCH   : constant := System.Mint.SIGWINCH;
+   SIGUSR1    : constant := System.Mint.SIGUSR1;
+   SIGUSR2    : constant := System.Mint.SIGUSR2;
+   SIGPWR     : constant := System.Mint.SIGPWR;
+
+   SIGADAABORT : constant := SIGABRT;
+   --  Change this to use another signal for task abort. SIGTERM might be a
+   --  good one.
+
+   type Signal_Set is array (Natural range <>) of Signal;
+
+   Unmasked : constant Signal_Set := (
+      SIGTRAP,
+      --  To enable debugging on multithreaded applications, mark SIGTRAP to
+      --  be kept unmasked.
+
+      SIGBUS,
+
+      SIGTTIN, SIGTTOU, SIGTSTP,
+      --  Keep these three signals unmasked so that background processes and IO
+      --  behaves as normal "C" applications
+
+      SIGPROF,
+      --  To avoid confusing the profiler
+
+      SIGKILL, SIGSTOP
+      --  These two signals actually can't be masked (POSIX won't allow it)
+      );
+
+   Reserved : constant Signal_Set := (SIGNULL, SIGNULL);
+
+   type sigset_t is private;
+
+   function sigaddset (set : access sigset_t; sig : Signal) return int;
+   pragma Import (C, sigaddset, "sigaddset");
+
+   function sigdelset (set : access sigset_t; sig : Signal) return int;
+   pragma Import (C, sigdelset, "sigdelset");
+
+   function sigfillset (set : access sigset_t) return int;
+   pragma Import (C, sigfillset, "sigfillset");
+
+   function sigismember (set : access sigset_t; sig : Signal) return int;
+   pragma Import (C, sigismember, "sigismember");
+
+   function sigemptyset (set : access sigset_t) return int;
+   pragma Import (C, sigemptyset, "sigemptyset");
+
+   type union_type_3 is new String (1 .. 116);
+   type siginfo_t is record
+      si_signo : int;
+      si_code  : int;
+      si_errno : int;
+      X_data   : union_type_3;
+   end record;
+   pragma Convention (C, siginfo_t);
+
+   type struct_sigaction is record
+      sa_handler  : System.Address;
+      sa_mask     : sigset_t;
+      sa_flags    : int;
+      sa_restorer : System.Address;
+   end record;
+   pragma Convention (C, struct_sigaction);
+
+   type struct_sigaction_ptr is access all struct_sigaction;
+
+   SA_SIGINFO : constant := System.Mint.SA_SIGINFO;
+   SA_ONSTACK : constant := System.Mint.SA_ONSTACK;
+
+   SIG_BLOCK   : constant := 0;
+   SIG_UNBLOCK : constant := 1;
+   SIG_SETMASK : constant := 2;
+
+   SIG_DFL : constant := 0;
+   SIG_IGN : constant := 1;
+
+   function sigaction
+     (sig  : Signal;
+      act  : struct_sigaction_ptr;
+      oact : struct_sigaction_ptr) return int;
+   pragma Import (C, sigaction, "sigaction");
+
+   ----------
+   -- Time --
+   ----------
+
+   subtype time_t    is System.Mint.time_t;
+   subtype timespec  is System.Mint.timespec;
+   subtype timeval   is System.Mint.timeval;
+   subtype clockid_t is System.Mint.clockid_t;
+
+   function clock_gettime
+     (clock_id : clockid_t; tp : access timespec) return int;
+   pragma Import (C, clock_gettime, "clock_gettime");
+
+   function clock_getres
+     (clock_id : clockid_t;
+      res      : access timespec) return int;
+   pragma Import (C, clock_getres, "clock_getres");
+
+   function To_Duration (TS : timespec) return Duration;
+   pragma Inline (To_Duration);
+
+   function To_Timespec (D : Duration) return timespec;
+   pragma Inline (To_Timespec);
+
+   function sysconf (name : int) return long;
+   pragma Import (C, sysconf);
+
+   SC_CLK_TCK          : constant := 5;
+   SC_NPROCESSORS_ONLN : constant := 3015;
+
+   -------------------------
+   -- Priority Scheduling --
+   -------------------------
+
+   SCHED_OTHER : constant := 0;
+   SCHED_FIFO  : constant := 1;
+   SCHED_RR    : constant := 2;
+
+   function To_Target_Priority
+     (Prio : System.Any_Priority) return Interfaces.C.int;
+   --  Maps System.Any_Priority to a POSIX priority
+
+   -------------
+   -- Process --
+   -------------
+
+   type pid_t is private;
+
+   function kill (pid : pid_t; sig : Signal) return int;
+   pragma Import (C, kill, "kill");
+
+   function getpid return pid_t;
+   pragma Import (C, getpid, "getpid");
+
+   PR_SET_NAME : constant := 15;
+   PR_GET_NAME : constant := 16;
+
+   function prctl
+     (option : int;
+      arg    : unsigned_long) return int;
+   pragma Import (C_Variadic_1, prctl, "prctl");
+
+   -------------
+   -- Threads --
+   -------------
+
+   type Thread_Body is access
+     function (arg : System.Address) return System.Address;
+   pragma Convention (C, Thread_Body);
+
+   function Thread_Body_Access is new
+     Ada.Unchecked_Conversion (System.Address, Thread_Body);
+
+   type pthread_t is new unsigned_long;
+   subtype Thread_Id is pthread_t;
+
+   function To_pthread_t is
+     new Ada.Unchecked_Conversion (unsigned_long, pthread_t);
+
+   subtype pthread_mutex_t   is System.OS_Locks.pthread_mutex_t;
+   type pthread_rwlock_t     is limited private;
+   type pthread_cond_t       is limited private;
+   type pthread_attr_t       is limited private;
+   type pthread_mutexattr_t  is limited private;
+   type pthread_rwlockattr_t is limited private;
+   type pthread_condattr_t   is limited private;
+   type pthread_key_t        is private;
+
+   PTHREAD_CREATE_DETACHED : constant := 1;
+
+   -----------
+   -- Stack --
+   -----------
+
+   subtype char_array is Interfaces.C.char_array;
+
+   type stack_t is record
+      ss_sp    : System.Address;
+      ss_flags : int;
+      ss_size  : size_t;
+   end record;
+   pragma Convention (C, stack_t);
+
+   function sigaltstack
+     (ss  : not null access stack_t;
+      oss : access stack_t) return int;
+   pragma Import (C, sigaltstack, "sigaltstack");
+
+   Alternate_Stack_Size : constant := 32 * 1024;
+   --  This must be in keeping with init.c:__gnat_alternate_stack
+
+   Alternate_Stack : aliased char_array (1 .. Alternate_Stack_Size);
+   pragma Import (C, Alternate_Stack, "__gnat_alternate_stack");
+   --  The alternate signal stack for stack overflows
+
+   function Get_Stack_Base (thread : pthread_t) return Address;
+   pragma Inline (Get_Stack_Base);
+   --  This is a dummy procedure to share some GNULLI files
+
+   ---------------------------------------
+   -- Nonstandard Thread Initialization --
+   ---------------------------------------
+
+   procedure pthread_init;
+   pragma Inline (pthread_init);
+   --  This is a dummy procedure to share some GNULLI files
+
+   -------------------------
+   -- POSIX.1c  Section 3 --
+   -------------------------
+
+   function sigwait (set : access sigset_t; sig : access Signal) return int;
+   pragma Import (C, sigwait, "sigwait");
+
+   function pthread_kill (thread : pthread_t; sig : Signal) return int;
+   pragma Import (C, pthread_kill, "pthread_kill");
+
+   function pthread_sigmask
+     (how  : int;
+      set  : access sigset_t;
+      oset : access sigset_t) return int;
+   pragma Import (C, pthread_sigmask, "pthread_sigmask");
+
+   --------------------------
+   -- POSIX.1c  Section 11 --
+   --------------------------
+
+   function pthread_mutexattr_init
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_init, "pthread_mutexattr_init");
+
+   function pthread_mutexattr_destroy
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_destroy, "pthread_mutexattr_destroy");
+
+   function pthread_mutex_init
+     (mutex : access pthread_mutex_t;
+      attr  : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutex_init, "pthread_mutex_init");
+
+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_destroy, "pthread_mutex_destroy");
+
+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_lock, "pthread_mutex_lock");
+
+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_unlock, "pthread_mutex_unlock");
+
+   function pthread_rwlockattr_init
+     (attr : access pthread_rwlockattr_t) return int;
+   pragma Import (C, pthread_rwlockattr_init, "pthread_rwlockattr_init");
+
+   function pthread_rwlockattr_destroy
+     (attr : access pthread_rwlockattr_t) return int;
+   pragma Import (C, pthread_rwlockattr_destroy, "pthread_rwlockattr_destroy");
+
+   PTHREAD_RWLOCK_PREFER_READER_NP              : constant := 0;
+   PTHREAD_RWLOCK_PREFER_WRITER_NP              : constant := 1;
+   PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP : constant := 2;
+
+   function pthread_rwlockattr_setkind_np
+     (attr : access pthread_rwlockattr_t;
+      pref : int) return int;
+   pragma Import
+     (C, pthread_rwlockattr_setkind_np, "pthread_rwlockattr_setkind_np");
+
+   function pthread_rwlock_init
+     (mutex : access pthread_rwlock_t;
+      attr  : access pthread_rwlockattr_t) return int;
+   pragma Import (C, pthread_rwlock_init, "pthread_rwlock_init");
+
+   function pthread_rwlock_destroy
+     (mutex : access pthread_rwlock_t) return int;
+   pragma Import (C, pthread_rwlock_destroy, "pthread_rwlock_destroy");
+
+   function pthread_rwlock_rdlock (mutex : access pthread_rwlock_t) return int;
+   pragma Import (C, pthread_rwlock_rdlock, "pthread_rwlock_rdlock");
+
+   function pthread_rwlock_wrlock (mutex : access pthread_rwlock_t) return int;
+   pragma Import (C, pthread_rwlock_wrlock, "pthread_rwlock_wrlock");
+
+   function pthread_rwlock_unlock (mutex : access pthread_rwlock_t) return int;
+   pragma Import (C, pthread_rwlock_unlock, "pthread_rwlock_unlock");
+
+   function pthread_condattr_init
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_init, "pthread_condattr_init");
+
+   function pthread_condattr_destroy
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_destroy, "pthread_condattr_destroy");
+
+   function pthread_cond_init
+     (cond : access pthread_cond_t;
+      attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_cond_init, "pthread_cond_init");
+
+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_destroy, "pthread_cond_destroy");
+
+   function pthread_cond_signal (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_signal, "pthread_cond_signal");
+
+   function pthread_cond_wait
+     (cond  : access pthread_cond_t;
+      mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_cond_wait, "pthread_cond_wait");
+
+   function pthread_cond_timedwait
+     (cond    : access pthread_cond_t;
+      mutex   : access pthread_mutex_t;
+      abstime : access timespec) return int;
+   pragma Import (C, pthread_cond_timedwait, "pthread_cond_timedwait");
+
+   --------------------------
+   -- POSIX.1c  Section 13 --
+   --------------------------
+
+   PTHREAD_PRIO_NONE    : constant := 0;
+   PTHREAD_PRIO_INHERIT : constant := 1;
+   PTHREAD_PRIO_PROTECT : constant := 2;
+
+   function pthread_mutexattr_setprotocol
+     (attr     : access pthread_mutexattr_t;
+      protocol : int) return int;
+   pragma Import (C, pthread_mutexattr_setprotocol);
+
+   function pthread_mutexattr_setprioceiling
+     (attr        : access pthread_mutexattr_t;
+      prioceiling : int) return int;
+   pragma Import (C, pthread_mutexattr_setprioceiling);
+
+   type struct_sched_param is record
+      sched_priority : int;  --  scheduling priority
+   end record;
+   pragma Convention (C, struct_sched_param);
+
+   function pthread_setschedparam
+     (thread : pthread_t;
+      policy : int;
+      param  : access struct_sched_param) return int;
+   pragma Import (C, pthread_setschedparam, "pthread_setschedparam");
+
+   function pthread_attr_setschedpolicy
+     (attr   : access pthread_attr_t;
+      policy : int) return int;
+   pragma Import
+     (C, pthread_attr_setschedpolicy, "pthread_attr_setschedpolicy");
+
+   function sched_yield return int;
+   pragma Import (C, sched_yield, "sched_yield");
+
+   ---------------------------
+   -- P1003.1c - Section 16 --
+   ---------------------------
+
+   function pthread_attr_init
+     (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_init, "pthread_attr_init");
+
+   function pthread_attr_destroy
+     (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_destroy, "pthread_attr_destroy");
+
+   function pthread_attr_setdetachstate
+     (attr        : access pthread_attr_t;
+      detachstate : int) return int;
+   pragma Import
+     (C, pthread_attr_setdetachstate, "pthread_attr_setdetachstate");
+
+   function pthread_attr_setstacksize
+     (attr      : access pthread_attr_t;
+      stacksize : size_t) return int;
+   pragma Import (C, pthread_attr_setstacksize, "pthread_attr_setstacksize");
+
+   function pthread_create
+     (thread        : access pthread_t;
+      attributes    : access pthread_attr_t;
+      start_routine : Thread_Body;
+      arg           : System.Address) return int;
+   pragma Import (C, pthread_create, "pthread_create");
+
+   procedure pthread_exit (status : System.Address);
+   pragma Import (C, pthread_exit, "pthread_exit");
+
+   function pthread_self return pthread_t;
+   pragma Import (C, pthread_self, "pthread_self");
+
+   function lwp_self return System.Address;
+   pragma Import (C, lwp_self, "__gnat_lwp_self");
+
+   --------------------------
+   -- POSIX.1c  Section 17 --
+   --------------------------
+
+   function pthread_setspecific
+     (key   : pthread_key_t;
+      value : System.Address) return int;
+   pragma Import (C, pthread_setspecific, "pthread_setspecific");
+
+   function pthread_getspecific (key : pthread_key_t) return System.Address;
+   pragma Import (C, pthread_getspecific, "pthread_getspecific");
+
+   type destructor_pointer is access procedure (arg : System.Address);
+   pragma Convention (C, destructor_pointer);
+
+   function pthread_key_create
+     (key        : access pthread_key_t;
+      destructor : destructor_pointer) return int;
+   pragma Import (C, pthread_key_create, "pthread_key_create");
+
+   ----------------
+   -- Extensions --
+   ----------------
+
+   CPU_SETSIZE : constant := 1_024;
+   --  Size of the cpu_set_t mask on most linux systems (SUSE 11 uses 4_096).
+   --  This is kept for backward compatibility (System.Task_Info uses it), but
+   --  the run-time library does no longer rely on static masks, using
+   --  dynamically allocated masks instead.
+
+   type bit_field is array (1 .. CPU_SETSIZE) of Boolean;
+   for bit_field'Size use CPU_SETSIZE;
+   pragma Pack (bit_field);
+   pragma Convention (C, bit_field);
+
+   type cpu_set_t is record
+      bits : bit_field;
+   end record;
+   pragma Convention (C, cpu_set_t);
+
+   type cpu_set_t_ptr is access all cpu_set_t;
+   --  In the run-time library we use this pointer because the size of type
+   --  cpu_set_t varies depending on the glibc version. Hence, objects of type
+   --  cpu_set_t are allocated dynamically using the number of processors
+   --  available in the target machine (value obtained at execution time).
+
+   function CPU_ALLOC (count : size_t) return cpu_set_t_ptr;
+   pragma Import (C, CPU_ALLOC, "__gnat_cpu_alloc");
+   --  Wrapper around the CPU_ALLOC C macro
+
+   function CPU_ALLOC_SIZE (count : size_t) return size_t;
+   pragma Import (C, CPU_ALLOC_SIZE, "__gnat_cpu_alloc_size");
+   --  Wrapper around the CPU_ALLOC_SIZE C macro
+
+   procedure CPU_FREE (cpuset : cpu_set_t_ptr);
+   pragma Import (C, CPU_FREE, "__gnat_cpu_free");
+   --  Wrapper around the CPU_FREE C macro
+
+   procedure CPU_ZERO (count : size_t; cpuset : cpu_set_t_ptr);
+   pragma Import (C, CPU_ZERO, "__gnat_cpu_zero");
+   --  Wrapper around the CPU_ZERO_S C macro
+
+   procedure CPU_SET (cpu : int; count : size_t; cpuset : cpu_set_t_ptr);
+   pragma Import (C, CPU_SET, "__gnat_cpu_set");
+   --  Wrapper around the CPU_SET_S C macro
+
+   function pthread_setaffinity_np
+     (thread     : pthread_t;
+      cpusetsize : size_t;
+      cpuset     : cpu_set_t_ptr) return int;
+   pragma Import (C, pthread_setaffinity_np, "pthread_setaffinity_np");
+   pragma Weak_External (pthread_setaffinity_np);
+   --  Use a weak symbol because this function may be available or not,
+   --  depending on the version of the system.
+
+   function pthread_attr_setaffinity_np
+     (attr       : access pthread_attr_t;
+      cpusetsize : size_t;
+      cpuset     : cpu_set_t_ptr) return int;
+   pragma Import (C, pthread_attr_setaffinity_np,
+                    "pthread_attr_setaffinity_np");
+   pragma Weak_External (pthread_attr_setaffinity_np);
+   --  Use a weak symbol because this function may be available or not,
+   --  depending on the version of the system.
+
+private
+
+   type sigset_t is
+     array (0 .. OS_Constants.SIZEOF_sigset - 1) of unsigned_char;
+   pragma Convention (C, sigset_t);
+   for sigset_t'Alignment use Interfaces.C.unsigned_long'Alignment;
+
+   type pid_t is new int;
+
+   type pthread_attr_t is record
+      Data : char_array (1 .. OS_Constants.PTHREAD_ATTR_SIZE);
+   end record;
+   pragma Convention (C, pthread_attr_t);
+   for pthread_attr_t'Alignment use Interfaces.C.unsigned_long'Alignment;
+
+   type pthread_condattr_t is record
+      Data : char_array (1 .. OS_Constants.PTHREAD_CONDATTR_SIZE);
+   end record;
+   pragma Convention (C, pthread_condattr_t);
+   for pthread_condattr_t'Alignment use Interfaces.C.int'Alignment;
+
+   type pthread_mutexattr_t is record
+      Data : char_array (1 .. OS_Constants.PTHREAD_MUTEXATTR_SIZE);
+   end record;
+   pragma Convention (C, pthread_mutexattr_t);
+   for pthread_mutexattr_t'Alignment use Interfaces.C.int'Alignment;
+
+   type pthread_rwlockattr_t is record
+      Data : char_array (1 .. OS_Constants.PTHREAD_RWLOCKATTR_SIZE);
+   end record;
+   pragma Convention (C, pthread_rwlockattr_t);
+   for pthread_rwlockattr_t'Alignment use Interfaces.C.unsigned_long'Alignment;
+
+   type pthread_rwlock_t is record
+      Data : char_array (1 .. OS_Constants.PTHREAD_RWLOCK_SIZE);
+   end record;
+   pragma Convention (C, pthread_rwlock_t);
+   for pthread_rwlock_t'Alignment use Interfaces.C.unsigned_long'Alignment;
+
+   type pthread_cond_t is record
+      Data : char_array (1 .. OS_Constants.PTHREAD_COND_SIZE);
+   end record;
+   pragma Convention (C, pthread_cond_t);
+   for pthread_cond_t'Alignment use Interfaces.Unsigned_64'Alignment;
+
+   type pthread_key_t is new unsigned;
+
+end System.OS_Interface;
diff --git a/gcc/ada/libgnat/a-calend.adb b/gcc/ada/libgnat/a-calend.adb
index 4f89a401a9c..eac70865544 100644
--- a/gcc/ada/libgnat/a-calend.adb
+++ b/gcc/ada/libgnat/a-calend.adb
@@ -1137,8 +1137,12 @@ is
       ------------------
 
       function To_Unix_Time (Ada_Time : Time) return Long_Integer is
+         pragma Unreferenced (Ada_Time);
       begin
-         return Long_Integer (To_Unix_Time_64 (Ada_Time));
+         --  crashes in extract_constrain_insn, at recog.cc:2783
+         --  expanding subdi3?
+         --  return Long_Integer (To_Unix_Time_64 (Ada_Time));
+         return 0;
       end To_Unix_Time;
 
       ---------------------
diff --git a/gcc/ada/libgnat/g-sechas.ads b/gcc/ada/libgnat/g-sechas.ads
index 78b42b79656..8711cbbe7e7 100644
--- a/gcc/ada/libgnat/g-sechas.ads
+++ b/gcc/ada/libgnat/g-sechas.ads
@@ -45,7 +45,7 @@ with System;
 package GNAT.Secure_Hashes is
 
    type Buffer_Type is new Stream_Element_Array;
-   for Buffer_Type'Alignment use 8;
+   --  for Buffer_Type'Alignment use 8;
    --  Secure hash functions use a string buffer that is also accessed as an
    --  array of words, which may require up to 64 bit alignment.
 
diff --git a/gcc/ada/libgnat/g-socket.adb b/gcc/ada/libgnat/g-socket.adb
index 5042dacc166..3f9e4194b8f 100644
--- a/gcc/ada/libgnat/g-socket.adb
+++ b/gcc/ada/libgnat/g-socket.adb
@@ -2879,6 +2879,7 @@ package body GNAT.Sockets is
          --  Check for possible Duration overflow when Tv_Sec field is 64 bit
          --  integer.
 
+         pragma Warnings (Off);
          if Val.Tv_Sec > time_t (Max_D)
              or else
            (Val.Tv_Sec = time_t (Max_D)
diff --git a/gcc/ada/libgnat/g-sothco.ads b/gcc/ada/libgnat/g-sothco.ads
index cdf0a16ef08..15040f39cb8 100644
--- a/gcc/ada/libgnat/g-sothco.ads
+++ b/gcc/ada/libgnat/g-sothco.ads
@@ -214,7 +214,7 @@ package GNAT.Sockets.Thin_Common is
 
    type Hostent is new
      System.Storage_Elements.Storage_Array (1 .. SOSC.SIZEOF_struct_hostent);
-   for Hostent'Alignment use 8;
+   --  for Hostent'Alignment use 8;
    --  Host entry. This is an opaque type used only via the following
    --  accessor functions, because 'struct hostent' has different layouts on
    --  different platforms.
@@ -244,7 +244,7 @@ package GNAT.Sockets.Thin_Common is
 
    type Servent is new
      System.Storage_Elements.Storage_Array (1 .. SOSC.SIZEOF_struct_servent);
-   for Servent'Alignment use 8;
+   --  for Servent'Alignment use 8;
    --  Service entry. This is an opaque type used only via the following
    --  accessor functions, because 'struct servent' has different layouts on
    --  different platforms.
diff --git a/gcc/ada/libgnat/i-cexten.ads b/gcc/ada/libgnat/i-cexten.ads
index a6a6c27292a..62064fb76a7 100644
--- a/gcc/ada/libgnat/i-cexten.ads
+++ b/gcc/ada/libgnat/i-cexten.ads
@@ -72,7 +72,7 @@ package Interfaces.C.Extensions is
    --  typedef int signed_128 __attribute__ ((mode (TI)));
 
    pragma Convention (C_Pass_By_Copy, Signed_128);
-   for Signed_128'Alignment use unsigned_long_long'Alignment * 2;
+   --  for Signed_128'Alignment use unsigned_long_long'Alignment * 2;
 
    type Float_128 is record
       low, high : unsigned_long_long;
@@ -81,7 +81,7 @@ package Interfaces.C.Extensions is
    --  typedef float float_128 __attribute__ ((mode (TF)));
 
    pragma Convention (C_Pass_By_Copy, Float_128);
-   for Float_128'Alignment use unsigned_long_long'Alignment * 2;
+   --  for Float_128'Alignment use unsigned_long_long'Alignment * 2;
 
    type CFloat_128 is record
       re, im : Float_128;
diff --git a/gcc/ada/libgnat/s-bitfie.ads b/gcc/ada/libgnat/s-bitfie.ads
index dabbe5371af..b4574b34b96 100644
--- a/gcc/ada/libgnat/s-bitfie.ads
+++ b/gcc/ada/libgnat/s-bitfie.ads
@@ -43,9 +43,9 @@ package System.Bitfields is
    Val_Bits  : constant := Long_Long_Integer'Size / 2;
    Val_Bytes : constant := Val_Bits / System.Storage_Unit;
 
-   type Val_2 is mod 2**(Val_Bits * 2) with Alignment => Val_Bytes;
+   type Val_2 is mod 2**(Val_Bits * 2) with Alignment => 2;
    pragma Provide_Shift_Operators (Val_2);
-   type Val is mod 2**Val_Bits with Alignment => Val_Bytes;
+   type Val is mod 2**Val_Bits with Alignment => 2;
 
    --  Enabling checks on the instantiation of System.Bitfield_Utils.G makes a
    --  latent visibility bug appear on strict alignment platforms related to
diff --git a/gcc/ada/libgnat/s-bituti.ads b/gcc/ada/libgnat/s-bituti.ads
index 8b7729ed4b2..2b77ac0d064 100644
--- a/gcc/ada/libgnat/s-bituti.ads
+++ b/gcc/ada/libgnat/s-bituti.ads
@@ -85,7 +85,7 @@ package System.Bitfield_Utils is
       --  Assert that both are aligned the same, to the size in bytes of Val
       --  (not Val_2).
 
-      pragma Assert (Val'Alignment = Val'Size / Storage_Unit);
+      pragma Assert (Val'Alignment = 2);
       pragma Assert (Val_2'Alignment = Val'Alignment);
 
       type Val_Array is array (Positive range <>) of Val;
diff --git a/gcc/ada/libgnat/s-secsta.ads b/gcc/ada/libgnat/s-secsta.ads
index c8f9f903023..e2549077918 100644
--- a/gcc/ada/libgnat/s-secsta.ads
+++ b/gcc/ada/libgnat/s-secsta.ads
@@ -262,7 +262,7 @@ private
    --  Index into the memory storage of a single chunk
 
    type Chunk_Memory is array (Memory_Size range <>) of SSE.Storage_Element;
-   for Chunk_Memory'Alignment use Standard'Maximum_Alignment;
+   --  for Chunk_Memory'Alignment use Standard'Maximum_Alignment;
    --  The memory storage of a single chunk
 
    --------------
diff --git a/gcc/ada/libgnat/s-stposu.adb b/gcc/ada/libgnat/s-stposu.adb
index a77ddb77467..33bddd5008f 100644
--- a/gcc/ada/libgnat/s-stposu.adb
+++ b/gcc/ada/libgnat/s-stposu.adb
@@ -207,6 +207,7 @@ package body System.Storage_Pools.Subpools is
       else
          N_Size      := Storage_Size;
          N_Alignment := Alignment;
+         Header_And_Padding := 0;
       end if;
 
       --  Step 3: Allocation of object
diff --git a/gcc/ada/libgnat/system-mint.ads b/gcc/ada/libgnat/system-mint.ads
new file mode 100644
index 00000000000..eb28e76edf0
--- /dev/null
+++ b/gcc/ada/libgnat/system-mint.ads
@@ -0,0 +1,147 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                        GNAT RUN-TIME COMPONENTS                          --
+--                                                                          --
+--                               S Y S T E M                                --
+--                                                                          --
+--                                 S p e c                                  --
+--                         (freemint/m68k Version)                          --
+--                                                                          --
+--          Copyright (C) 2014-2020, Free Software Foundation, Inc.         --
+--                                                                          --
+-- This specification is derived from the Ada Reference Manual for use with --
+-- GNAT. The copyright notice above, and the license provisions that follow --
+-- apply solely to the  contents of the part following the private keyword. --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+package System is
+   pragma Pure;
+   --  Note that we take advantage of the implementation permission to make
+   --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada
+   --  2005, this is Pure in any case (AI-362).
+
+   pragma No_Elaboration_Code_All;
+   --  Allow the use of that restriction in units that WITH this unit
+
+   type Name is (SYSTEM_NAME_GNAT);
+   System_Name : constant Name := SYSTEM_NAME_GNAT;
+
+   --  System-Dependent Named Numbers
+
+   Min_Int             : constant := -2 ** (Standard'Max_Integer_Size - 1);
+   Max_Int             : constant :=  2 ** (Standard'Max_Integer_Size - 1) - 1;
+
+   Max_Binary_Modulus    : constant := 2 ** Standard'Max_Integer_Size;
+   Max_Nonbinary_Modulus : constant := 2 ** Integer'Size - 1;
+
+   Max_Base_Digits       : constant := Long_Long_Float'Digits;
+   Max_Digits            : constant := Long_Long_Float'Digits;
+
+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;
+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);
+
+   Tick                  : constant := 0.05;
+
+   --  Storage-related Declarations
+
+   type Address is private;
+   pragma Preelaborable_Initialization (Address);
+   Null_Address : constant Address;
+
+   Storage_Unit : constant := 8;
+   Word_Size    : constant := 32;
+   Memory_Size  : constant := 2 ** 32;
+
+   --  Address comparison
+
+   function "<"  (Left, Right : Address) return Boolean;
+   function "<=" (Left, Right : Address) return Boolean;
+   function ">"  (Left, Right : Address) return Boolean;
+   function ">=" (Left, Right : Address) return Boolean;
+   function "="  (Left, Right : Address) return Boolean;
+
+   pragma Import (Intrinsic, "<");
+   pragma Import (Intrinsic, "<=");
+   pragma Import (Intrinsic, ">");
+   pragma Import (Intrinsic, ">=");
+   pragma Import (Intrinsic, "=");
+
+   --  Other System-Dependent Declarations
+
+   type Bit_Order is (High_Order_First, Low_Order_First);
+   Default_Bit_Order : constant Bit_Order := High_Order_First;
+   pragma Warnings (Off, Default_Bit_Order); -- kill constant condition warning
+
+   --  Priority-related Declarations (RM D.1)
+
+   Max_Priority           : constant Positive := 30;
+   Max_Interrupt_Priority : constant Positive := 31;
+
+   subtype Any_Priority       is Integer      range  0 .. 31;
+   subtype Priority           is Any_Priority range  0 .. 30;
+   subtype Interrupt_Priority is Any_Priority range 31 .. 31;
+
+   Default_Priority : constant Priority := 15;
+
+private
+
+   type Address is mod Memory_Size;
+   for Address'Size use Standard'Address_Size;
+
+   Null_Address : constant Address := 0;
+
+   --------------------------------------
+   -- System Implementation Parameters --
+   --------------------------------------
+
+   --  These parameters provide information about the target that is used
+   --  by the compiler. They are in the private part of System, where they
+   --  can be accessed using the special circuitry in the Targparm unit
+   --  whose source should be consulted for more detailed descriptions
+   --  of the individual switch values.
+
+   Backend_Divide_Checks     : constant Boolean := False;
+   Backend_Overflow_Checks   : constant Boolean := True;
+   Command_Line_Args         : constant Boolean := True;
+   Configurable_Run_Time     : constant Boolean := False;
+   Denorm                    : constant Boolean := True;
+   Duration_32_Bits          : constant Boolean := False;
+   Exit_Status_Supported     : constant Boolean := True;
+   Machine_Overflows         : constant Boolean := False;
+   Machine_Rounds            : constant Boolean := True;
+   Preallocated_Stacks       : constant Boolean := False;
+   Signed_Zeros              : constant Boolean := True;
+   Stack_Check_Default       : constant Boolean := False;
+   Stack_Check_Probes        : constant Boolean := False;
+   Stack_Check_Limits        : constant Boolean := False;
+   Support_Aggregates        : constant Boolean := True;
+   Support_Atomic_Primitives : constant Boolean := True;
+   Support_Composite_Assign  : constant Boolean := True;
+   Support_Composite_Compare : constant Boolean := True;
+   Support_Long_Shifts       : constant Boolean := True;
+   Always_Compatible_Rep     : constant Boolean := False;
+   Suppress_Standard_Library : constant Boolean := False;
+   Use_Ada_Main_Program_Name : constant Boolean := False;
+   ZCX_By_Default            : constant Boolean := True;
+
+end System;
diff --git a/gcc/ada/output.adb b/gcc/ada/output.adb
index 2702b3ffb1f..bd8d861d69b 100644
--- a/gcc/ada/output.adb
+++ b/gcc/ada/output.adb
@@ -26,7 +26,7 @@
 package body Output is
 
    Buffer : String (1 .. Buffer_Max + 1) := (others => '*');
-   for Buffer'Alignment use 4;
+   for Buffer'Alignment use Integer'Alignment;
    --  Buffer used to build output line. We do line buffering because it is
    --  needed for the support of the debug-generated-code option (-gnatD). Note
    --  any attempt to write more output to a line than can fit in the buffer
diff --git a/gcc/ada/par-ch6.adb b/gcc/ada/par-ch6.adb
index 55591fdc033..dbbc1a0b128 100644
--- a/gcc/ada/par-ch6.adb
+++ b/gcc/ada/par-ch6.adb
@@ -1398,6 +1398,7 @@ package body Ch6 is
 
    begin
       Specification_List := New_List;
+      Specification_Node := 0;
       Specification_Loop : loop
          begin
             if Token = Tok_Pragma then
diff --git a/gcc/ada/s-oscons-tmplt.c b/gcc/ada/s-oscons-tmplt.c
index 97537ef5e94..cd6a5bf2fb9 100644
--- a/gcc/ada/s-oscons-tmplt.c
+++ b/gcc/ada/s-oscons-tmplt.c
@@ -86,7 +86,7 @@ pragma Style_Checks ("N");
  ** a number of non-POSIX but useful/required features.
  **/
 
-#if defined (__linux__) || defined (__ANDROID__) || defined (__GNU__)
+#if defined (__linux__) || defined (__ANDROID__) || defined (__GNU__) || defined(__MINT__)
 
 /* Define _XOPEN_SOURCE to get IOV_MAX */
 # if !defined (_XOPEN_SOURCE)
@@ -160,7 +160,7 @@ pragma Style_Checks ("N");
 #endif
 
 #if defined (__linux__) || defined (__ANDROID__) || defined (__QNX__) \
-  || defined (__rtems__) || defined (__GNU__)
+  || defined (__rtems__) || defined (__GNU__) || defined(__MINT__)
 # include <pthread.h>
 # include <signal.h>
 #endif
@@ -1210,12 +1210,12 @@ CND(NI_NUMERICSERV, "Numeric form of the service")
 CND(NI_NUMERICHOST, "Numeric form of the hostname")
 
 #ifndef NI_MAXHOST
-# define NI_MAXHOST -1
+# define NI_MAXHOST 1025
 #endif
 CND(NI_MAXHOST, "Maximum size of hostname")
 
 #ifndef NI_MAXSERV
-# define NI_MAXSERV -1
+# define NI_MAXSERV 32
 #endif
 CND(NI_MAXSERV, "Maximum size of service name")
 
@@ -1465,7 +1465,7 @@ CND(MSG_EOR, "Send end of record")
 CND(MSG_WAITALL, "Wait for full reception")
 
 #ifndef MSG_NOSIGNAL
-# define MSG_NOSIGNAL -1
+# define MSG_NOSIGNAL 0
 #endif
 CND(MSG_NOSIGNAL, "No SIGPIPE on send")
 
@@ -1938,7 +1938,7 @@ CST(Poll_Linkname, "")
 
 #endif /* HAVE_SOCKETS */
 
-#if defined (__linux__) || defined (__ANDROID__) || defined (__QNX__) || defined (__GNU__)
+#if defined (__linux__) || defined (__ANDROID__) || defined (__QNX__) || defined (__GNU__) || defined(__MINT__)
 #define SIZEOF_sigset (sizeof (sigset_t))
 CND(SIZEOF_sigset, "sigset")
 #endif
@@ -1999,7 +1999,7 @@ CNS(CLOCK_RT_Ada, "")
 
 #if defined (__APPLE__) || defined (__ANDROID__) || defined (DUMMY) \
   || defined (__FreeBSD__) || defined (__linux__) \
-  || defined (__QNX__) || defined (__rtems__) || defined (__GNU__)
+  || defined (__QNX__) || defined (__rtems__) || defined (__GNU__) || defined(__MINT__)
 
 /*
 
diff --git a/gcc/ada/scng.adb b/gcc/ada/scng.adb
index a4304f8e7b2..2fc7dac1342 100644
--- a/gcc/ada/scng.adb
+++ b/gcc/ada/scng.adb
@@ -1085,6 +1085,7 @@ package body Scng is
          --  literal circuit.
 
          String_Start := Scan_Ptr;
+         Code := 0;
 
          --  Continuation of interpolated string literal
 
diff --git a/gcc/ada/sem_ch12.adb b/gcc/ada/sem_ch12.adb
index e00f5140588..d318229b093 100644
--- a/gcc/ada/sem_ch12.adb
+++ b/gcc/ada/sem_ch12.adb
@@ -12191,6 +12191,7 @@ package body Sem_Ch12 is
          return Decl_Node;
 
       else
+         Nam := 0;
          pragma Assert (False);
       end if;
 
diff --git a/gcc/ada/sem_disp.adb b/gcc/ada/sem_disp.adb
index 4881d6f2f8b..b780e1087e6 100644
--- a/gcc/ada/sem_disp.adb
+++ b/gcc/ada/sem_disp.adb
@@ -651,6 +651,7 @@ package body Sem_Disp is
                Wrapper_Found : Boolean := False;
 
             begin
+               Prim := 0;
                Prim_Elmt := First_Elmt (Primitive_Operations (Typ));
                while Present (Prim_Elmt) loop
                   Prim := Node (Prim_Elmt);
diff --git a/gcc/ada/sem_res.adb b/gcc/ada/sem_res.adb
index 0df6c27c30d..6f434c9e757 100644
--- a/gcc/ada/sem_res.adb
+++ b/gcc/ada/sem_res.adb
@@ -11424,6 +11424,7 @@ package body Sem_Res is
          --  of the correct name and type.
 
          Found := False;
+         It1.Typ := 0;
          Get_First_Interp (P, I, It);
 
          Search : while Present (It.Typ) loop
diff --git a/gcc/ada/sinput.ads b/gcc/ada/sinput.ads
index 0a9602fd7e2..5c461a6f27d 100644
--- a/gcc/ada/sinput.ads
+++ b/gcc/ada/sinput.ads
@@ -940,7 +940,7 @@ private
    end record;
    Dope_Rec_Size : constant := 2 * Source_Ptr'Base'Size;
    for Dope_Rec'Size use Dope_Rec_Size;
-   for Dope_Rec'Alignment use Dope_Rec_Size / 8;
+   for Dope_Rec'Alignment use Source_Ptr'Base'Alignment;
    type Dope_Ptr is access all Dope_Rec;
 
    procedure Set_Dope
diff --git a/gcc/ada/stat64.c b/gcc/ada/stat64.c
new file mode 100644
index 00000000000..415a09b912c
--- /dev/null
+++ b/gcc/ada/stat64.c
@@ -0,0 +1,66 @@
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+#define _FILE_OFFSET_BITS 64
+#include <sys/stat.h>
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+#ifdef __linux__
+
+#if __GLIBC_PREREQ(2, 33)
+
+#include <stdarg.h>
+#include <fcntl.h>
+
+/*
+ * those are referenced by the hosts libgnat.a
+ */
+
+extern int __xstat64(int __ver, const char *__filename,
+      struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
+extern int __lxstat64(int __ver, const char *__filename,
+       struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
+extern int __fxstat64(int __ver, int __fildes, struct stat64 *__stat_buf)
+     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
+
+__attribute__((__nothrow__))
+int stat64(const char *__path, struct stat64 *__statbuf)
+{
+	return __xstat64(1, __path, __statbuf);
+}
+
+__attribute__((__nothrow__))
+int lstat64 (const char *__path, struct stat64 *__statbuf)
+{
+	return __lxstat64(1, __path, __statbuf);
+}
+
+__attribute__((__nothrow__))
+int fstat64(int __fd, struct stat64 *__statbuf)
+{
+	return __fxstat64(1, __fd, __statbuf);
+}
+
+#undef fcntl
+int fcntl64(int fd, int cmd, ...)
+{
+  va_list ap;
+  void *arg;
+
+  va_start (ap, cmd);
+  arg = va_arg (ap, void *);
+  va_end (ap);
+
+  return fcntl(fd, cmd, arg);
+}
+
+#endif /* __GLIBC_PREREQ */
+
+#endif /* __linux__ */
+
+#if defined (__cplusplus)
+}
+#endif
diff --git a/gcc/ada/sysdep.c b/gcc/ada/sysdep.c
index 04ca270f085..00a53512295 100644
--- a/gcc/ada/sysdep.c
+++ b/gcc/ada/sysdep.c
@@ -847,7 +847,7 @@ __gnat_localtime_tzoff (const OS_Time *timer ATTRIBUTE_UNUSED,
 
 #elif defined (__APPLE__) || defined (__FreeBSD__) || defined (__linux__) \
   || defined (__GLIBC__) || defined (__DragonFly__) || defined (__OpenBSD__) \
-  || defined (__DJGPP__) || defined (__QNX__)
+  || defined (__DJGPP__) || defined (__QNX__) || defined(__MINT__)
 {
   localtime_r (&time, &tp);
   *off = tp.tm_gmtoff;
diff --git a/gcc/ada/terminals.c b/gcc/ada/terminals.c
index 89f887556c0..e8a2655706b 100644
--- a/gcc/ada/terminals.c
+++ b/gcc/ada/terminals.c
@@ -34,7 +34,7 @@
 /* First all unsupported platforms. Add stubs for exported routines. */
 
 #if defined (VMS) || defined (__vxworks) || defined (__Lynx__) \
-  || defined (__ANDROID__) || defined (__PikeOS__) || defined(__DJGPP__)
+  || defined (__ANDROID__) || defined (__PikeOS__) || defined(__DJGPP__) || defined(__MINT__)
 
 void *
 __gnat_new_tty (void)
@@ -108,7 +108,7 @@ __gnat_tty_supported (void)
 }
 
 int
-__gnat_tty_waitpid (void *desc ATTRIBUTE_UNUSED, int blocking)
+__gnat_tty_waitpid (void *desc ATTRIBUTE_UNUSED, int blocking ATTRIBUTE_UNUSED)
 {
   return 1;
 }
diff --git a/gcc/c-family/c-common.cc b/gcc/c-family/c-common.cc
index 65478c3c37a..e858e43716e 100644
--- a/gcc/c-family/c-common.cc
+++ b/gcc/c-family/c-common.cc
@@ -5673,9 +5673,14 @@ check_user_alignment (const_tree align, bool objfile, bool warn_zero)
       unsigned maxalign = MAX_OFILE_ALIGNMENT / BITS_PER_UNIT;
       if (!tree_fits_uhwi_p (align) || tree_to_uhwi (align) > maxalign)
 	{
+#if 0
 	  error ("requested alignment %qE exceeds object file maximum %u",
 		 align, maxalign);
 	  return -1;
+#else
+	  warning (OPT_Wattributes, "requested alignment %qE exceeds object file maximum %u",
+		 align, maxalign);
+#endif
 	}
     }
 
diff --git a/gcc/c/Make-lang.in b/gcc/c/Make-lang.in
index 2517b64439f..f37f975cc84 100644
--- a/gcc/c/Make-lang.in
+++ b/gcc/c/Make-lang.in
@@ -85,7 +85,7 @@ cc1-checksum.cc : build/genchecksum$(build_exeext) checksum-options \
 cc1$(exeext): $(C_OBJS) cc1-checksum.o $(BACKEND) $(LIBDEPS)
 	@$(call LINK_PROGRESS,$(INDEX.c),start)
 	+$(LLINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ $(C_OBJS) \
-	  cc1-checksum.o $(BACKEND) $(LIBS) $(BACKENDLIBS)
+	  cc1-checksum.o $(BACKEND) $(LIBS) $(BACKENDLIBS) $(GLIBC_SO)
 	@$(call LINK_PROGRESS,$(INDEX.c),end)
 
 components_in_prev = "bfd opcodes binutils fixincludes gas gcc gmp mpfr mpc isl gold intl ld libbacktrace libcpp libcody libdecnumber libiberty libiberty-linker-plugin libiconv zlib lto-plugin libctf libsframe"
diff --git a/gcc/c/c-decl.cc b/gcc/c/c-decl.cc
index 5032ba13779..115e8e4947b 100644
--- a/gcc/c/c-decl.cc
+++ b/gcc/c/c-decl.cc
@@ -11601,9 +11601,12 @@ check_for_loop_decls (location_t loc, bool turn_off_iso_c99_error)
 	}
       return NULL_TREE;
     }
-  else
-    pedwarn_c90 (loc, OPT_Wpedantic, "ISO C90 does not support %<for%> loop "
-		 "initial declarations");
+  if (warn_c90_c99_compat > 0)
+  {
+	warning_at (loc, OPT_Wc90_c99_compat,
+	   "ISO C90 does not support %<for%> loop "
+		"initial declarations");
+  }
 
   /* C99 subclause 6.8.5 paragraph 3:
 
diff --git a/gcc/cobol/Make-lang.in b/gcc/cobol/Make-lang.in
index 0e2a773d4df..2730d470eec 100644
--- a/gcc/cobol/Make-lang.in
+++ b/gcc/cobol/Make-lang.in
@@ -265,7 +265,7 @@ cobol.srcextra: cobol/parse.cc cobol/cdf.cc cobol/scan.cc
 cobol1$(exeext): $(cobol1_OBJS) $(BACKEND) $(LIBDEPS) attribs.o $(cobol.prev)
 	@$(call LINK_PROGRESS,$(INDEX.cobol),start)
 	+$(LLINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) attribs.o -o $@	\
-	      $(cobol1_OBJS) $(BACKEND) $(LIBS) $(BACKENDLIBS)
+	      $(cobol1_OBJS) $(BACKEND) $(LIBS) $(BACKENDLIBS) $(GLIBC_SO)
 	@$(call LINK_PROGRESS,$(INDEX.cobol),end)
 
 cobol.all.cross: gcobol-cross$(exeext)
diff --git a/gcc/collect2.cc b/gcc/collect2.cc
index 268ac378b9c..d1574315e25 100644
--- a/gcc/collect2.cc
+++ b/gcc/collect2.cc
@@ -158,6 +158,16 @@ int do_collecting = 0;
 #define DO_COLLECT_EXPORT_LIST 0
 #endif
 
+/*
+ * these are from xm-mingw32.h, but this is only included
+ * for the target; we need those definitions here also
+ * when using MinGW as host for a cross-compiler
+ */
+#ifdef __MINGW32__
+#undef HOST_EXECUTABLE_SUFFIX
+#define HOST_EXECUTABLE_SUFFIX ".exe"
+#endif
+
 /* Nonzero if we should suppress the automatic demangling of identifiers
    in linker error messages.  Set from COLLECT_NO_DEMANGLE.  */
 int no_demangle;
@@ -766,6 +776,8 @@ do_link (char **ld_argv, const char *atsuffix)
 
 /* Main program.  */
 
+#include "libcmain.h"
+
 int
 main (int argc, char **argv)
 {
diff --git a/gcc/common.opt b/gcc/common.opt
index e3fa0dacec4..9cbbe8f57ea 100644
--- a/gcc/common.opt
+++ b/gcc/common.opt
@@ -122,6 +122,12 @@ uint32_t write_symbols = NO_DEBUG
 Variable
 enum debug_info_levels debug_info_level = DINFO_LEVEL_NONE
 
+; Nonzero means use GNU-only extensions in the generated symbolic
+; debugging information.  Currently, this only has an effect when
+; write_symbols is set to DBX_DEBUG or XCOFF_DEBUG.
+Variable
+bool use_gnu_debug_info_extensions
+
 ; Level of CTF debugging information we are producing.  See flag-types.h
 ; for the definitions of the different possible levels.
 Variable
@@ -3644,7 +3650,7 @@ Common Driver JoinedOrMissing RejectNegative
 Generate debug information in default version of DWARF format.
 
 gdwarf-
-Common Driver Joined UInteger Var(dwarf_version) Init(DWARF_VERSION_DEFAULT) RejectNegative
+Common Driver Joined UInteger Var(dwarf_version) Init(DWARF_VERSION_DEFAULT) RejectNegative Negative(gstabs)
 Generate debug information in DWARF v2 (or later) format.
 
 gdwarf32
@@ -3692,12 +3698,12 @@ Common Driver Var(dwarf_split_debug_info) Init(0)
 Generate debug information in separate .dwo files.
 
 gstabs
-Common Driver WarnRemoved
-Does nothing.  Preserved for backward compatibility.
+Common Driver JoinedOrMissing Negative(gstabs+)
+Generate debug information in STABS format.
 
 gstabs+
-Common Driver WarnRemoved
-Does nothing.  Preserved for backward compatibility.
+Common Driver JoinedOrMissing Negative(gvms)
+Generate debug information in extended STABS format.
 
 gstatement-frontiers
 Common Driver Var(debug_nonbind_markers_p) PerFunction
diff --git a/gcc/common/config/m68k/m68k-common.cc b/gcc/common/config/m68k/m68k-common.cc
index dacdbd372c6..a2e88e3205b 100644
--- a/gcc/common/config/m68k/m68k-common.cc
+++ b/gcc/common/config/m68k/m68k-common.cc
@@ -75,4 +75,26 @@ m68k_handle_option (struct gcc_options *opts,
 #undef TARGET_HANDLE_OPTION
 #define TARGET_HANDLE_OPTION m68k_handle_option
 
+/* Implement TARGET_EXCEPT_UNWIND_INFO.  */
+
+static enum unwind_info_type
+m68k_except_unwind_info (struct gcc_options *opts ATTRIBUTE_UNUSED)
+{
+#ifdef USING_ELFOS_H
+  /* Honor the --enable-sjlj-exceptions configure switch.  */
+#ifdef CONFIG_SJLJ_EXCEPTIONS
+  if (CONFIG_SJLJ_EXCEPTIONS)
+    return UI_SJLJ;
+#endif
+
+  if (DWARF2_UNWIND_INFO)
+    return UI_DWARF2;
+#endif
+
+  return UI_SJLJ;
+}
+
+#undef TARGET_EXCEPT_UNWIND_INFO
+#define TARGET_EXCEPT_UNWIND_INFO m68k_except_unwind_info
+
 struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;
diff --git a/gcc/config.gcc b/gcc/config.gcc
index 087aaa7be37..64e52b949f2 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -2286,7 +2286,10 @@ i[34567]86-*-mingw* | x86_64-*-mingw*)
 			tmake_file="${tmake_file} i386/t-mingw-w32"
 			;;
 	esac
-        native_system_header_dir=/mingw/include
+	# Don't ignore values passed in to configure via --native-system-header-dir
+	if test x$native_system_header_dir = x ; then
+		native_system_header_dir=/mingw/include
+	fi
 	target_gtfiles="$target_gtfiles \$(srcdir)/config/mingw/winnt.cc"
 	target_gtfiles="$target_gtfiles \$(srcdir)/config/mingw/winnt-dll.cc"
 	extra_options="${extra_options} mingw/cygming.opt mingw/mingw.opt"
@@ -2461,6 +2464,31 @@ m68k-*-linux*)			# Motorola m68k's running GNU/Linux
 	tm_defines="${tm_defines} MOTOROLA=1"
 	tmake_file="${tmake_file} m68k/t-floatlib m68k/t-linux m68k/t-mlibs"
 	;;
+m68k-*-mintelf*)
+	default_m68k_cpu=68000
+	default_cf_cpu=5475
+	tm_file="${tm_file} dbxelf.h elfos.h m68k/mint.h m68k/mint-stdint.h"
+	tm_d_file="${tm_d_file} dbxelf.h elfos.h m68k/mint.h m68k/mint-stdint.h"
+	tm_defines="${tm_defines} MOTOROLA=1"
+	tmake_file="m68k/t-floatlib m68k/t-mint"
+	xm_file=m68k/xm-mint.h
+	gas=yes
+	gnu_ld=yes
+	if test x${disable_initfini_array} != xyes; then
+		gcc_cv_initfini_array=yes
+	fi
+	;;
+m68k-*-mint*)
+	default_m68k_cpu=68000
+	default_cf_cpu=5475
+	tm_file="${tm_file} m68k/mint.h m68k/mint-stdint.h"
+	tm_d_file="${tm_d_file} m68k/mint.h m68k/mint-stdint.h"
+	tm_defines="${tm_defines} MOTOROLA=1"
+	tmake_file="m68k/t-floatlib m68k/t-mint"
+	xm_file=m68k/xm-mint.h
+	gas=yes
+	gnu_ld=yes
+	;;
 m68k-*-rtems*)
 	default_m68k_cpu=68020
 	default_cf_cpu=5206
diff --git a/gcc/config.host b/gcc/config.host
index 4c1a5e9910c..853567891d1 100644
--- a/gcc/config.host
+++ b/gcc/config.host
@@ -230,7 +230,7 @@ case ${host} in
     host_exeext=.exe
     host_lto_plugin_soname=cyglto_plugin.dll
     ;;
-  i[34567]86-*-mingw32* | x86_64-*-mingw*)
+  i[34567]86-*-mingw32* | x86_64-*-mingw* | i[34567]86-*-msys* | x86_64-*-msys*)
     host_xm_file=i386/xm-mingw32.h
     host_xmake_file="${host_xmake_file} ${host_xmake_mingw} i386/x-mingw32"
     host_extra_gcc_objs="${host_extra_gcc_objs} ${host_extra_gcc_objs_mingw} driver-mingw32.o"
diff --git a/gcc/config.in b/gcc/config.in
index a79c51adb2b..d58bc77ba2c 100644
--- a/gcc/config.in
+++ b/gcc/config.in
@@ -477,6 +477,12 @@
 #endif
 
 
+/* Define if your assembler supports the --gstabs option. */
+#ifndef USED_FOR_TARGET
+#undef HAVE_AS_GSTABS_DEBUG_FLAG
+#endif
+
+
 /* Define if your assembler supports the Sun syntax for cmov. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_AS_IX86_CMOV_SUN_SYNTAX
@@ -800,6 +806,12 @@
 #endif
 
 
+/* Define if your assembler supports .stabs. */
+#ifndef USED_FOR_TARGET
+#undef HAVE_AS_STABS_DIRECTIVE
+#endif
+
+
 /* Define if your assembler and linker support thread-local storage. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_AS_TLS
diff --git a/gcc/config/dbxelf.h b/gcc/config/dbxelf.h
new file mode 100644
index 00000000000..4b90e95bc74
--- /dev/null
+++ b/gcc/config/dbxelf.h
@@ -0,0 +1,68 @@
+/* Definitions needed when using stabs embedded in ELF sections.
+   Copyright (C) 1999-2022 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+/* This file may be included by any ELF target which wishes to
+   support -gstabs generating stabs in sections, as produced by gas
+   and understood by gdb.  */
+
+#ifndef GCC_DBX_ELF_H
+#define GCC_DBX_ELF_H
+
+/* Output DBX (stabs) debugging information if doing -gstabs.  */
+
+#define DBX_DEBUGGING_INFO 1
+
+/* Make LBRAC and RBRAC addresses relative to the start of the
+   function.  The native Solaris stabs debugging format works this
+   way, gdb expects it, and it reduces the number of relocation
+   entries...  */
+
+#define DBX_BLOCKS_FUNCTION_RELATIVE 1
+
+/* ... but, to make this work, functions must appear prior to line info.  */
+
+#define DBX_FUNCTION_FIRST
+
+/* When generating stabs debugging, use N_BINCL entries.  */
+
+#define DBX_USE_BINCL
+
+/* There is no limit to the length of stabs strings.  */
+
+#ifndef DBX_CONTIN_LENGTH
+#define DBX_CONTIN_LENGTH 0
+#endif
+
+/* Like block addresses, stabs line numbers are relative to the
+   current function.  */
+
+#define DBX_LINES_FUNCTION_RELATIVE 1
+
+/* Generate a blank trailing N_SO to mark the end of the .o file, since
+   we can't depend upon the linker to mark .o file boundaries with
+   embedded stabs.  */
+
+#define DBX_OUTPUT_NULL_N_SO_AT_MAIN_SOURCE_FILE_END
+
+#endif /* ! GCC_DBX_ELF_H */
diff --git a/gcc/config/elfos.h b/gcc/config/elfos.h
index afef22721a5..6170af6a9c4 100644
--- a/gcc/config/elfos.h
+++ b/gcc/config/elfos.h
@@ -206,7 +206,13 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #define ASCII_DATA_ASM_OP	"\t.ascii\t"
 
 /* Support a read-only data section.  */
-#define READONLY_DATA_SECTION_ASM_OP	"\t.section\t.rodata"
+#ifndef READONLY_DATA_SECTION_ASM_OP
+#define READONLY_DATA_SECTION_ASM_OP	"\t.section\t" ELF_DEFAULT_RODATA_SECTION
+#endif
+#define ELF_SECTION_FORMAT		"\t.section %s"
+#define ELF_DEFAULT_TEXT_SECTION	".text"
+#define ELF_DEFAULT_DATA_SECTION	".data"
+#define ELF_DEFAULT_RODATA_SECTION	".rodata"
 
 /* On svr4, we *do* have support for the .init and .fini sections, and we
    can put stuff in there to be executed before and after `main'.  We let
diff --git a/gcc/config/i386/xm-mingw32.h b/gcc/config/i386/xm-mingw32.h
index 7b795e53c2b..a02bf3a92f4 100644
--- a/gcc/config/i386/xm-mingw32.h
+++ b/gcc/config/i386/xm-mingw32.h
@@ -25,9 +25,10 @@ along with GCC; see the file COPYING3.  If not see
 
 /* This is the name of the null device on windows.  */
 #define HOST_BIT_BUCKET "nul"
+#define HOST_BIT_BUCKET2 "/dev/null"
 
 /*  The st_ino field of struct stat is always 0.  */
-#define HOST_LACKS_INODE_NUMBERS
+#define HOST_LACKS_INODE_NUMBERS 1
 
 #ifdef __MINGW32__
 #undef __USE_MINGW_ANSI_STDIO
@@ -37,3 +38,20 @@ along with GCC; see the file COPYING3.  If not see
    "long long" values.  Instead, we use "I64".  */
 #define HOST_LONG_LONG_FORMAT "I64"
 #endif
+
+#ifndef STANDARD_STARTFILE_PREFIX_1
+#ifdef __MINGW64__
+#define STANDARD_STARTFILE_PREFIX_1 "C:/msys64/mingw64/x86_64-w64-mingw64/lib/"
+#else
+#define STANDARD_STARTFILE_PREFIX_1 "C:/msys64/mingw32/i686-w64-mingw32/lib/"
+#endif
+#endif
+
+/* For native mingw-version we need to take care that NATIVE_SYSTEM_HEADER_DIR
+   macro contains POSIX-style path.  See bug 52947.  */
+#undef NATIVE_SYSTEM_HEADER_DIR
+#ifdef __MINGW64__
+#define NATIVE_SYSTEM_HEADER_DIR "C:/msys64/mingw64/x86_64-w64-mingw64/include"
+#else
+#define NATIVE_SYSTEM_HEADER_DIR "C:/msys64/mingw32/i686-w64-mingw32/include"
+#endif
diff --git a/gcc/config/i386/xmmintrin.h b/gcc/config/i386/xmmintrin.h
index 16f407daaf6..041d1732cba 100644
--- a/gcc/config/i386/xmmintrin.h
+++ b/gcc/config/i386/xmmintrin.h
@@ -67,6 +67,10 @@ _mm_prefetch (const void *__P, enum _mm_hint __I)
 #define __DISABLE_SSE__
 #endif /* __SSE__ */
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 /* The Intel API is flexible enough that we must allow aliasing with other
    vector types, and their scalar components.  */
 typedef float __m128 __attribute__ ((__vector_size__ (16), __may_alias__));
@@ -1360,6 +1364,10 @@ do {									\
   (row3) = __builtin_ia32_movhlps (__t3, __t2);				\
 } while (0)
 
+#ifdef __cplusplus
+}
+#endif
+
 /* For backward source compatibility.  */
 # include <emmintrin.h>
 
diff --git a/gcc/config/m68k/linux.h b/gcc/config/m68k/linux.h
index 0cf5e136f7a..73ab57f69c3 100644
--- a/gcc/config/m68k/linux.h
+++ b/gcc/config/m68k/linux.h
@@ -146,6 +146,10 @@ along with GCC; see the file COPYING3.  If not see
     fprintf (FILE, "\tjbsr _mcount\n");					\
 }
 
+/* Do not break .stabs pseudos into continuations.  */
+
+#define DBX_CONTIN_LENGTH 0
+
 /* 1 if N is a possible register number for a function value.  For
    m68k/SVR4 allow d0, a0, or fp0 as return registers, for integral,
    pointer, or floating types, respectively.  Reject fp0 if not using
@@ -170,7 +174,7 @@ along with GCC; see the file COPYING3.  If not see
 
 #undef FUNCTION_VALUE
 #define FUNCTION_VALUE(VALTYPE, FUNC)					\
-  m68k_function_value (VALTYPE, FUNC)
+  m68k_function_value (VALTYPE, FUNC, true)
 
 /* Define how to find the value returned by a library function
    assuming the value has mode MODE.
@@ -222,8 +226,6 @@ along with GCC; see the file COPYING3.  If not see
      : "%d0", "%d2", "%d3");						\
 }
 
-#define TARGET_ASM_FILE_END file_end_indicate_exec_stack
-
 #undef DEBUGGER_REGNO
 #define DEBUGGER_REGNO(REGNO) (REGNO)
 
@@ -241,4 +243,4 @@ along with GCC; see the file COPYING3.  If not see
 
 /* Install the __sync libcalls.  */
 #undef TARGET_INIT_LIBFUNCS
-#define TARGET_INIT_LIBFUNCS  m68k_init_sync_libfuncs
+#define TARGET_INIT_LIBFUNCS  m68k_init_libfuncs
diff --git a/gcc/config/m68k/m68k-protos.h b/gcc/config/m68k/m68k-protos.h
index 9cba3be80a1..5c32924a58f 100644
--- a/gcc/config/m68k/m68k-protos.h
+++ b/gcc/config/m68k/m68k-protos.h
@@ -79,7 +79,7 @@ extern rtx m68k_legitimize_tls_address (rtx);
 extern bool m68k_tls_reference_p (rtx, bool);
 extern int valid_dbcc_comparison_p_2 (rtx, machine_mode);
 extern rtx m68k_libcall_value (machine_mode);
-extern rtx m68k_function_value (const_tree, const_tree);
+extern rtx m68k_function_value (const_tree, const_tree, bool);
 extern int emit_move_sequence (rtx *, machine_mode, rtx);
 extern bool m68k_movem_pattern_p (rtx, rtx, HOST_WIDE_INT, bool);
 extern const char *m68k_output_movem (rtx *, rtx, HOST_WIDE_INT, bool);
@@ -115,3 +115,13 @@ extern rtx m68k_legitimize_call_address (rtx);
 extern rtx m68k_legitimize_sibcall_address (rtx);
 extern int m68k_hard_regno_rename_ok(unsigned int, unsigned int);
 extern poly_int64 m68k_push_rounding (poly_int64);
+
+#ifdef RTX_CODE
+#ifdef TREE_CODE
+void m68k_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, int);
+#endif
+#endif
+void m68k_order_regs_for_local_alloc(void);
+void m68k_call_abi_override (const_tree);
+enum calling_abi m68k_function_type_abi (const_tree);
+enum calling_abi m68k_cfun_abi (void);
diff --git a/gcc/config/m68k/m68k.cc b/gcc/config/m68k/m68k.cc
index d8fa6e00de1..874566b411c 100644
--- a/gcc/config/m68k/m68k.cc
+++ b/gcc/config/m68k/m68k.cc
@@ -67,6 +67,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "builtins.h"
 #include "rtl-iter.h"
 #include "toplev.h"
+#include "dbxout.h"
 
 /* This file should be included last.  */
 #include "target-def.h"
@@ -83,6 +84,11 @@ enum reg_class regno_reg_class[] =
 };
 
 
+/* Name of text, data, and rodata sections used in varasm.c.  */
+const char *m68k_text_section;
+const char *m68k_data_section;
+const char *m68k_rodata_section;
+
 /* The minimum number of integer registers that we want to save with the
    movem instruction.  Using two movel instructions instead of a single
    moveml is about 15% faster for the 68020 and 68030 at no expense in
@@ -157,6 +163,7 @@ static void m68k_sched_dfa_post_advance_cycle (void);
 static int m68k_sched_first_cycle_multipass_dfa_lookahead (void);
 
 static bool m68k_can_eliminate (const int, const int);
+static void m68k_set_current_function (tree);
 static void m68k_conditional_register_usage (void);
 static bool m68k_legitimate_address_p (machine_mode, rtx, bool,
 				       code_helper = ERROR_MARK);
@@ -170,6 +177,8 @@ static rtx m68k_struct_value_rtx (tree, int);
 static tree m68k_handle_fndecl_attribute (tree *node, tree name,
 					  tree args, int flags,
 					  bool *no_add_attrs);
+static tree m68k_handle_type_attribute (tree *, tree, tree, int, bool *);
+static int m68k_comp_type_attributes (const_tree, const_tree);
 static void m68k_compute_frame_layout (void);
 static bool m68k_save_reg (unsigned int regno, bool interrupt_handler);
 static bool m68k_ok_for_sibcall_p (tree, tree);
@@ -183,12 +192,10 @@ static void m68k_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;
 static void m68k_trampoline_init (rtx, tree, rtx);
 static poly_int64 m68k_return_pops_args (tree, tree, poly_int64);
 static rtx m68k_delegitimize_address (rtx);
-static void m68k_function_arg_advance (cumulative_args_t,
-				       const function_arg_info &);
-static rtx m68k_function_arg (cumulative_args_t, const function_arg_info &);
+static void m68k_maybe_switch_abi (void);
 static bool m68k_cannot_force_const_mem (machine_mode mode, rtx x);
 static bool m68k_output_addr_const_extra (FILE *, rtx);
-static void m68k_init_sync_libfuncs (void) ATTRIBUTE_UNUSED;
+static void m68k_init_libfuncs (void) ATTRIBUTE_UNUSED;
 static enum flt_eval_method
 m68k_excess_precision (enum excess_precision_type);
 static unsigned int m68k_hard_regno_nregs (unsigned int, machine_mode);
@@ -200,6 +207,7 @@ static void m68k_asm_final_postscan_insn (FILE *, rtx_insn *insn, rtx [], int);
 static HARD_REG_SET m68k_zero_call_used_regs (HARD_REG_SET);
 static machine_mode m68k_c_mode_for_floating_type (enum tree_index);
 static bool m68k_use_lra_p (void);
+static void m68k_file_end (void);
 
 /* Initialize the GCC target structure.  */
 
@@ -234,10 +242,12 @@ static bool m68k_use_lra_p (void);
 #undef TARGET_ASM_OUTPUT_MI_THUNK
 #define TARGET_ASM_OUTPUT_MI_THUNK m68k_output_mi_thunk
 #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK
-#define TARGET_ASM_CAN_OUTPUT_MI_THUNK hook_bool_const_tree_hwi_hwi_const_tree_true
+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK m68k_can_output_mi_thunk
 
 #undef TARGET_ASM_FILE_START_APP_OFF
 #define TARGET_ASM_FILE_START_APP_OFF true
+#undef TARGET_ASM_FILE_END
+#define TARGET_ASM_FILE_END m68k_file_end
 
 #undef TARGET_LEGITIMIZE_ADDRESS
 #define TARGET_LEGITIMIZE_ADDRESS m68k_legitimize_address
@@ -316,6 +326,12 @@ static bool m68k_use_lra_p (void);
 #undef TARGET_CAN_ELIMINATE
 #define TARGET_CAN_ELIMINATE m68k_can_eliminate
 
+#undef TARGET_SET_CURRENT_FUNCTION
+#define TARGET_SET_CURRENT_FUNCTION m68k_set_current_function
+
+#undef TARGET_EXPAND_TO_RTL_HOOK
+#define TARGET_EXPAND_TO_RTL_HOOK m68k_maybe_switch_abi
+
 #undef TARGET_CONDITIONAL_REGISTER_USAGE
 #define TARGET_CONDITIONAL_REGISTER_USAGE m68k_conditional_register_usage
 
@@ -370,6 +386,9 @@ static bool m68k_use_lra_p (void);
 #undef TARGET_C_MODE_FOR_FLOATING_TYPE
 #define TARGET_C_MODE_FOR_FLOATING_TYPE m68k_c_mode_for_floating_type
 
+#undef TARGET_STATIC_CHAIN
+#define TARGET_STATIC_CHAIN m68k_static_chain
+
 TARGET_GNU_ATTRIBUTES (m68k_attribute_table,
 {
   /* { name, min_len, max_len, decl_req, type_req, fn_type_req,
@@ -379,13 +398,24 @@ TARGET_GNU_ATTRIBUTES (m68k_attribute_table,
   { "interrupt_handler", 0, 0, true,  false, false, false,
     m68k_handle_fndecl_attribute, NULL },
   { "interrupt_thread", 0, 0, true,  false, false, false,
-    m68k_handle_fndecl_attribute, NULL }
+    m68k_handle_fndecl_attribute, NULL },
+
+ /* cdecl attribute specifies to pass arguments on the stack */
+  { "cdecl",             0, 0, false, true,  true,  true, m68k_handle_type_attribute, NULL },
+  /* Regparm attribute specifies how many integer arguments are to be
+     passed in registers.  */
+  { "regparm",           0, 1, false, true,  true,  true, m68k_handle_type_attribute, NULL },
+  /* Fastcall attribute says callee is responsible for popping arguments
+   if they are not variable.  */
+  { "fastcall",          0, 0, false, true,  true,  true, m68k_handle_type_attribute, NULL },
 });
 
+#undef TARGET_COMP_TYPE_ATTRIBUTES
+#define TARGET_COMP_TYPE_ATTRIBUTES m68k_comp_type_attributes
+
 #undef TARGET_DOCUMENTATION_NAME
 #define TARGET_DOCUMENTATION_NAME "m68k"
 
-struct gcc_target targetm = TARGET_INITIALIZER;
 
 /* Base flags for 68k ISAs.  */
 #define FL_FOR_isa_00    FL_ISA_68000
@@ -494,6 +524,9 @@ unsigned int m68k_cpu_flags;
 /* The set of FL_* flags that apply to the processor to be tuned for.  */
 unsigned int m68k_tune_flags;
 
+/* The abi used by target.  */
+enum calling_abi m68k_abi;
+
 /* Asm templates for calling or jumping to an arbitrary symbolic address,
    or NULL if such calls or jumps are not supported.  The address is held
    in operand 0.  */
@@ -504,10 +537,27 @@ const char *m68k_symbolic_jump;
 enum M68K_SYMBOLIC_CALL m68k_symbolic_call_var;
 
 
-/* Implement TARGET_OPTION_OVERRIDE.  */
+/* Clear stack slot assignments remembered from previous functions.
+   This is called from INIT_EXPANDERS once before RTL is emitted for each
+   function.  */
+
+static struct machine_function *
+m68k_init_machine_status (void)
+{
+  struct machine_function *machine;
+
+  machine = ggc_cleared_alloc<machine_function> ();
+  machine->call_abi = m68k_abi;
+
+  return machine;
+}
+
+/* Override various settings based on options.  If MAIN_ARGS_P, the
+   options are from the command line, otherwise they are from
+   attributes.  */
 
 static void
-m68k_option_override (void)
+m68k_option_override_internal (bool main_args_p)
 {
   const struct m68k_target_selection *entry;
   unsigned long target_mask;
@@ -553,6 +603,8 @@ m68k_option_override (void)
 
   m68k_cpu_flags = entry->flags;
 
+  m68k_abi = TARGET_FASTCALL ? FASTCALL_ABI : STD_ABI;
+
   /* Use the architecture setting to derive default values for
      certain flags.  */
   target_mask = 0;
@@ -670,6 +722,27 @@ m68k_option_override (void)
       gcc_unreachable ();
     }
 
+  /* Set the pseudo-ops for the various standard sections.  */
+#ifdef ELF_SECTION_FORMAT
+  {
+  char *tmp;
+  const char *name;
+  name = m68k_text_string ? m68k_text_string : M68K_DEFAULT_TEXT_SECTION;
+  m68k_text_section = tmp = XNEWVEC (char, strlen (name) + sizeof (ELF_SECTION_FORMAT) + 1);
+  sprintf (tmp, ELF_SECTION_FORMAT, name);
+  name = m68k_data_string ? m68k_data_string : M68K_DEFAULT_DATA_SECTION;
+  m68k_data_section = tmp = XNEWVEC (char, strlen (name) + sizeof (ELF_SECTION_FORMAT) + 1);
+  sprintf (tmp, ELF_SECTION_FORMAT, name);
+  name = m68k_rodata_string ? m68k_rodata_string : M68K_DEFAULT_RODATA_SECTION;
+  m68k_rodata_section = tmp = XNEWVEC (char, strlen (name) + sizeof (ELF_SECTION_FORMAT) + 1);
+  sprintf (tmp, ELF_SECTION_FORMAT, name);
+  }
+#else
+  m68k_text_section = "\t" M68K_DEFAULT_TEXT_SECTION;
+  m68k_data_section = "\t" M68K_DEFAULT_DATA_SECTION;
+  m68k_rodata_section = m68k_text_section;
+#endif
+
 #ifndef ASM_OUTPUT_ALIGN_WITH_NOP
   parse_alignment_opts ();
   int label_alignment = align_labels.levels[0].get_value ();
@@ -724,8 +797,38 @@ m68k_option_override (void)
       else
 	m68k_sched_mac = MAC_NO;
     }
+
+  init_machine_status = m68k_init_machine_status;
+
+  /* Save the initial options in case the user does function specific options */
+  if (main_args_p)
+    target_option_default_node = target_option_current_node
+      = build_target_option_node (&global_options, &global_options_set);
+
+  /*
+   * disable -fcombine-stack-adjustments for coldfire/mshort combination,
+   * which generates wrong CFI offsets.
+   * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=88160
+   */
+  if (PREFERRED_STACK_BOUNDARY > 16 && INT_TYPE_SIZE <= 16 && (write_symbols & DWARF2_DEBUG))
+    flag_combine_stack_adjustments = 0;
+
+  /*
+   * disable -ffold-mem-offsets. This generates incorrect code.
+   * Introduced by commit 04c9cf5c786b94fbe3f6f21f06cae73a7575ff7a
+   */
+  flag_fold_mem_offsets = 0;
+}
+
+/* Implement the TARGET_OPTION_OVERRIDE hook.  */
+
+static void
+m68k_option_override (void)
+{
+  m68k_option_override_internal (true);
 }
 
+
 /* Implement TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE.  */
 
 static void
@@ -822,6 +925,283 @@ m68k_handle_fndecl_attribute (tree *node, tree name,
   return NULL_TREE;
 }
 
+/* Handle a "regparm" or "cdecl" attribute;
+   arguments as in struct attribute_spec.handler.  */
+
+static void
+m68k_validate_mutually_exclusive_attribute (const char *attr1, const char *attr2, tree *node, tree name ATTRIBUTE_UNUSED)
+{
+  if (lookup_attribute (attr2, TYPE_ATTRIBUTES(*node)))
+    error ("%s and %s attributes are mutually exclusive", attr1, attr2);
+}
+
+static tree
+m68k_handle_type_attribute (tree *node, tree name, tree args ATTRIBUTE_UNUSED,
+			    int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)
+{
+  if (TREE_CODE (*node) == FUNCTION_TYPE ||
+      TREE_CODE (*node) == METHOD_TYPE ||
+      TREE_CODE (*node) == FIELD_DECL ||
+      TREE_CODE (*node) == TYPE_DECL)
+    {
+      if (is_attribute_p ("cdecl", name))
+	{
+	  m68k_validate_mutually_exclusive_attribute ("cdecl", "fastcall", node, name);
+	  m68k_validate_mutually_exclusive_attribute ("cdecl", "regparm", node, name);
+	}
+      else if (is_attribute_p ("fastcall", name))
+	{
+	  m68k_validate_mutually_exclusive_attribute ("fastcall", "cdecl", node, name);
+	  m68k_validate_mutually_exclusive_attribute ("fastcall", "regparm", node, name);
+	}
+      else if (is_attribute_p ("regparm", name))
+	{
+	  m68k_validate_mutually_exclusive_attribute ("regparm", "cdecl", node, name);
+	  m68k_validate_mutually_exclusive_attribute ("regparm", "fastcall", node, name);
+	}
+    }
+  else
+    {
+      warning (OPT_Wattributes, "%qE attribute only applies to functions",
+	       name);
+      *no_add_attrs = true;
+    }
+
+  return NULL_TREE;
+}
+
+/* Return zero if the attributes on TYPE1 and TYPE2 are incompatible,
+   one if they are compatible, and two if they are nearly compatible
+   (which causes a warning to be generated). */
+
+static int
+m68k_comp_exclusive_type_attributes(const char *name1, const char *name2, const_tree type1, const_tree type2)
+{
+	return (!! lookup_attribute (name1, TYPE_ATTRIBUTES (type1)) !=
+	    !! lookup_attribute (name1, TYPE_ATTRIBUTES (type2))
+	 || !! lookup_attribute (name2, TYPE_ATTRIBUTES (type1)) !=
+	    !! lookup_attribute (name2, TYPE_ATTRIBUTES (type2)));
+}
+
+static int
+m68k_comp_type_attributes (const_tree type1, const_tree type2)
+{
+  /* Functions or methods are incompatible if they specify mutually
+     exclusive ways of passing arguments.  */
+  if (TREE_CODE (type1) == FUNCTION_TYPE || TREE_CODE (type1) == METHOD_TYPE)
+    {
+      tree arg1, arg2;
+      if (m68k_comp_exclusive_type_attributes ("cdecl", "regparm", type1, type2)
+	   || m68k_comp_exclusive_type_attributes ("cdecl", "fastcall", type1, type2)
+	   || m68k_comp_exclusive_type_attributes ("regparm", "fastcall", type1, type2))
+	return 0; /* 'regparm' and 'cdecl' are mutually exclusive.  */
+
+      arg1 = lookup_attribute ("regparm", TYPE_ATTRIBUTES (type1));
+      arg2 = lookup_attribute ("regparm", TYPE_ATTRIBUTES (type2));
+      if (arg1 && arg2)
+	{
+	  int num1 = 0, num2 = 0;
+	  if (TREE_VALUE (arg1) && TREE_CODE (TREE_VALUE (arg1)) == TREE_LIST)
+	    {
+	      tree numofregs = TREE_VALUE (TREE_VALUE (arg1));
+	      if (numofregs)
+		num1 = TREE_INT_CST_LOW (numofregs);
+	    }
+	  if (TREE_VALUE (arg2) && TREE_CODE (TREE_VALUE (arg2)) == TREE_LIST)
+	    {
+	      tree numofregs = TREE_VALUE (TREE_VALUE (arg2));
+	      if (numofregs)
+		num2 = TREE_INT_CST_LOW (numofregs);
+	    }
+	  if (num1 != num2)
+	    return 0; /* Different numbers, or no number in one type.  */
+	}
+    }
+  return 1;
+}
+
+
+/* Implementation of call abi switching target hook. Specific to FNDECL
+   the specific call register sets are set.  See also
+   ix86_conditional_register_usage for more details.  */
+void
+m68k_call_abi_override (const_tree fndecl)
+{
+  if (fndecl == NULL_TREE)
+    cfun->machine->call_abi = m68k_abi;
+  else
+    cfun->machine->call_abi = m68k_function_type_abi (TREE_TYPE (fndecl));
+}
+
+static enum calling_abi
+m68k_function_abi (const_tree fndecl)
+{
+  if (! fndecl)
+    return m68k_abi;
+  return m68k_function_type_abi (TREE_TYPE (fndecl));
+}
+
+/* Returns value STD_ABI, FASTCALL_ABI dependent on cfun, specifying the
+   call abi used.  */
+enum calling_abi
+m68k_cfun_abi (void)
+{
+  if (! cfun)
+    return m68k_abi;
+  return cfun->machine->call_abi;
+}
+
+/* Returns value STD_ABI, FASTCALL_ABI dependent on fntype, specifying the
+   call abi used.  */
+enum calling_abi
+m68k_function_type_abi (const_tree fntype)
+{
+  if (fntype != NULL)
+    {
+      enum calling_abi abi = m68k_abi;
+      if (abi == STD_ABI)
+	{
+	  if (lookup_attribute ("fastcall", TYPE_ATTRIBUTES (fntype)))
+	    abi = FASTCALL_ABI;
+	}
+      else if (lookup_attribute ("cdecl", TYPE_ATTRIBUTES (fntype)))
+	abi = STD_ABI;
+      return abi;
+    }
+  return m68k_abi;
+}
+
+/* STD and FASTCALL ABI have different set of call used registers.  Avoid expensive
+   re-initialization of init_regs each time we switch function context since
+   this is needed only during RTL expansion.  */
+static void
+m68k_maybe_switch_abi (void)
+{
+  if (call_used_regs[D2_REG] == (cfun->machine->call_abi == STD_ABI))
+    reinit_regs ();
+}
+
+/* Initialize a variable CUM of type CUMULATIVE_ARGS
+   for a call to a function whose data type is FNTYPE.
+   For a library call, FNTYPE is 0.  */
+
+void
+m68k_init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */
+		      tree fntype,	/* tree ptr for function decl */
+		      rtx libname,	/* SYMBOL_REF of library name or 0 */
+		      tree fndecl,
+		      int caller ATTRIBUTE_UNUSED)
+{
+  cum->last_arg_reg = -1;
+  cum->last_arg_len = 0;
+  CLEAR_HARD_REG_SET(cum->regs_already_used);
+
+  if (libname)
+    {
+      cum->call_abi = m68k_abi;
+    }
+  else if (fndecl)
+    {
+      cum->call_abi = m68k_function_abi (fndecl);
+    }
+  else
+    {
+      cum->call_abi = m68k_function_type_abi (fntype);
+    }
+
+#if ! defined (PCC_STATIC_STRUCT_RETURN) && defined (M68K_STRUCT_VALUE_REGNUM)
+  /* If return value is a structure, and we pass the buffer address in a
+     register, we can't use this register for our own purposes.
+     FIXME: Something similar would be useful for static chain.  */
+  if (fntype && aggregate_value_p (TREE_TYPE (fntype), fntype))
+    SET_HARD_REG_BIT(cum->regs_already_used, M68K_STRUCT_VALUE_REGNUM);
+#endif
+}
+
+/* Define where to put the arguments to a function.
+   Value is zero to push the argument on the stack,
+   or a hard register in which to store the argument.
+
+   MODE is the argument's machine mode.
+   TYPE is the data type of the argument (as a tree).
+    This is null for libcalls where that information may
+    not be available.
+   CUM is a variable of type CUMULATIVE_ARGS which gives info about
+    the preceding args and about the function being called.  */
+
+static rtx m68k_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)
+{
+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
+
+  if (cum->call_abi == FASTCALL_ABI)
+    {
+      int regbegin = -1, regend, len;
+      machine_mode mode = arg.mode;
+
+      /* FIXME: The last condition below is a workaround for a bug.  */
+      if (!TARGET_68881 && FLOAT_MODE_P (mode) && GET_MODE_UNIT_SIZE (mode) <= 4 &&
+	  (GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT || mode == SCmode))
+	{
+	    regbegin = D0_REG; /* Dx */
+	    regend = regbegin + M68K_FASTCALL_DATA_PARM;
+	    len = (GET_MODE_SIZE (mode) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;
+	}
+      else if (TARGET_68881 && FLOAT_MODE_P (mode) &&
+	  GET_MODE_UNIT_SIZE (mode) <= 12 &&
+	  (GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT || mode == SCmode))
+	{
+	  regbegin = FP0_REG; /* FPx */
+	  regend = regbegin + M68K_FASTCALL_DATA_PARM;
+	  len = GET_MODE_NUNITS (mode);
+	}
+      /* FIXME: Two last conditions below are workarounds for bugs.  */
+      else if (INTEGRAL_MODE_P (mode) && mode != CQImode && mode != CHImode)
+	{
+	  len = (GET_MODE_SIZE (mode) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;
+	  if (len == 1)
+	    {
+	      const_tree type = arg.type;
+	      if (type && POINTER_TYPE_P (type))  /* THIS */
+		{
+		  regbegin = A0_REG; /* Ax */
+		  regend = regbegin + M68K_FASTCALL_ADDR_PARM;
+		}
+	      else
+		{
+		  regbegin = D0_REG; /* Dx */
+		  regend = regbegin + M68K_FASTCALL_DATA_PARM;
+		}
+	    }
+	}
+
+      if (regbegin != -1)
+	{
+	  int reg;
+	  for (reg = regbegin; reg < regend; reg++)
+	    {
+	      if (!TEST_HARD_REG_BIT(cum->regs_already_used, reg) &&
+		  (reg + len <= regend))
+		{
+		  cum->last_arg_reg = reg;
+		  cum->last_arg_len = len;
+		  break;
+		}
+	     }
+	 }
+
+      if (!arg.named)
+	SET_HARD_REG_SET(cum->regs_already_used);
+
+      if (cum->last_arg_reg != -1)
+	{
+	  return gen_rtx_REG (mode, cum->last_arg_reg);
+	}
+    }
+  return NULL_RTX;
+}
+
+
+
 static void
 m68k_compute_frame_layout (void)
 {
@@ -1032,6 +1412,40 @@ m68k_set_frame_related (rtx_insn *insn)
       RTX_FRAME_RELATED_P (XVECEXP (body, 0, i)) = 1;
 }
 
+#define IS_INTERRUPT(func_kind) (func_kind != m68k_fk_normal_function)
+
+int m68k_emit_stack_check(void)
+{
+  if (flag_stack_check == FULL_BUILTIN_STACK_CHECK &&
+        !IS_INTERRUPT(m68k_get_function_kind (current_function_decl)) &&
+        !DECL_NO_LIMIT_STACK(current_function_decl))
+  {
+        rtx_code_label *lab1;
+        rtx limit_mem;
+        rtx jump;
+
+        static rtx stack_limit_symbol;
+        static rtx stack_overflow_rtx;
+
+        if (stack_limit_symbol == 0)
+                stack_limit_symbol = gen_rtx_SYMBOL_REF (Pmode, "_StkLim");
+        if (stack_overflow_rtx == 0)
+                stack_overflow_rtx = gen_rtx_SYMBOL_REF (Pmode, "_StkOver");
+        lab1 = gen_label_rtx ();
+        limit_mem = gen_rtx_MEM (Pmode, stack_limit_symbol);
+        emit_cmp_and_jump_insns (limit_mem, stack_pointer_rtx, LTU, 0,
+                           Pmode, 1, lab1);
+        JUMP_LABEL (get_last_insn ()) = lab1;
+        jump = gen_rtx_SET(pc_rtx, stack_overflow_rtx);
+        emit_insn(jump);
+        emit_barrier ();
+        emit_label(lab1);
+        return true;
+  }
+  return false;
+}
+
+
 /* Emit RTL for the "prologue" define_expand.  */
 
 void
@@ -1048,7 +1462,7 @@ m68k_expand_prologue (void)
 
   /* If the stack limit is a symbol, we can check it here,
      before actually allocating the space.  */
-  if (crtl->limit_stack
+  if (crtl->limit_stack && !IS_INTERRUPT(m68k_get_function_kind (current_function_decl))
       && GET_CODE (stack_limit_rtx) == SYMBOL_REF)
     {
       limit = plus_constant (Pmode, stack_limit_rtx, current_frame.size + 4);
@@ -1138,9 +1552,14 @@ m68k_expand_prologue (void)
 	}
     }
 
+#ifdef STACK_CHECK_ATARI
+  if (m68k_emit_stack_check())
+  {
+  } else
+#endif
   /* If the stack limit is not a symbol, check it here.
      This has the disadvantage that it may be too late...  */
-  if (crtl->limit_stack)
+  if (crtl->limit_stack && !IS_INTERRUPT(m68k_get_function_kind (current_function_decl)))
     {
       if (REG_P (stack_limit_rtx))
         emit_insn (gen_ctrapsi4 (gen_rtx_LTU (VOIDmode, stack_pointer_rtx,
@@ -1403,12 +1822,25 @@ static bool
 m68k_ok_for_sibcall_p (tree decl, tree exp)
 {
   enum m68k_function_kind kind;
+  tree type;
 
   /* We cannot use sibcalls for nested functions because we use the
      static chain register for indirect calls.  */
   if (CALL_EXPR_STATIC_CHAIN (exp))
     return false;
 
+  if (decl)
+    {
+      type = TREE_TYPE (decl);
+    }
+  else
+    {
+      /* We're looking at the CALL_EXPR, we need the type of the function.  */
+      type = CALL_EXPR_FN (exp);		/* pointer expression */
+      type = TREE_TYPE (type);			/* pointer type */
+      type = TREE_TYPE (type);			/* function type */
+    }
+
   if (!VOID_TYPE_P (TREE_TYPE (DECL_RESULT (cfun->decl))))
     {
       /* Check that the return value locations are the same.  For
@@ -1429,6 +1861,18 @@ m68k_ok_for_sibcall_p (tree decl, tree exp)
 	return false;
     }
 
+  /* The FASTCALL ABI has more call-clobbered registers;
+      disallow sibcalls from STD to FASTCALL.  */
+  if (cfun->machine->call_abi == STD_ABI
+      && m68k_function_type_abi (type) == FASTCALL_ABI)
+      return false;
+
+  /* FIXME: currently does not work at all for FASTCALL, because the
+     A2 register for the call will be restored in the epilogue
+     before being used */
+  if (cfun->machine->call_abi == FASTCALL_ABI || m68k_function_type_abi (type) != cfun->machine->call_abi)
+      return false;
+
   kind = m68k_get_function_kind (current_function_decl);
   if (kind == m68k_fk_normal_function)
     /* We can always sibcall from a normal function, because it's
@@ -1443,21 +1887,19 @@ m68k_ok_for_sibcall_p (tree decl, tree exp)
   return false;
 }
 
-/* On the m68k all args are always pushed.  */
-
-static rtx
-m68k_function_arg (cumulative_args_t, const function_arg_info &)
-{
-  return NULL_RTX;
-}
-
 static void
 m68k_function_arg_advance (cumulative_args_t cum_v,
-			   const function_arg_info &arg)
+			   const function_arg_info &)
 {
   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
 
-  *cum += (arg.promoted_size_in_bytes () + 3) & ~3;
+  if (cum->last_arg_reg != -1)
+    {
+      int count;
+      for (count = 0; count < cum->last_arg_len; count++)
+	SET_HARD_REG_BIT(cum->regs_already_used, cum->last_arg_reg + count);
+      cum->last_arg_reg = -1;
+    }
 }
 
 /* Convert X to a legitimate function call memory reference and return the
@@ -1481,10 +1923,58 @@ m68k_legitimize_sibcall_address (rtx x)
   if (sibcall_operand (XEXP (x, 0), VOIDmode))
     return x;
 
+  if (m68k_abi == FASTCALL_ABI)
+  {
+    static bool issued_error;
+    if (!issued_error)
+      {
+	issued_error = true;
+	error ("m68k_legitimize_sibcall_address not supported with -mfastcall");
+      }
+  }
   emit_move_insn (gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM), XEXP (x, 0));
   return replace_equiv_address (x, gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM));
 }
 
+/* Return an rtx for the static chain for FNDECL.  If INCOMING_P is true,
+       then it should be for the callee; otherwise for the caller.  */
+static rtx
+m68k_static_chain (const_tree fndecl_or_type, bool incoming_p)
+{
+  const_tree fntype, fndecl;
+
+  if (DECL_P (fndecl_or_type) && !DECL_STATIC_CHAIN (fndecl_or_type))
+    return NULL;
+
+  if (incoming_p)
+    {
+    }
+
+  if (TREE_CODE (fndecl_or_type) == FUNCTION_DECL)
+   {
+      fntype = TREE_TYPE (fndecl_or_type);
+      fndecl = fndecl_or_type;
+   }
+ else
+   {
+     fntype = fndecl_or_type;
+     fndecl = NULL;
+   }
+
+  if (m68k_function_type_abi(fntype) == FASTCALL_ABI)
+  {
+    static bool issued_error;
+    if (!issued_error)
+      {
+	issued_error = true;
+	error ("nested functions not supported with -mfastcall in %qD", fndecl);
+      }
+    return gen_rtx_MEM (Pmode, stack_pointer_rtx);
+  }
+  
+  return gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);
+}
+
 /* Convert X to a legitimate address and return it if successful.  Otherwise
    return X.
 
@@ -4220,6 +4710,135 @@ m68k_movem_pattern_p (rtx pattern, rtx automod_base,
    AUTOMOD_OFFSET is the total adjustment, otherwise it is 0.  STORE_P
    is true if this is a store instruction.  */
 
+static void
+reglist(char *buf, int regmask)
+{
+  int regnum;
+  int liststart;
+  int lastreg;
+  int status;
+
+  if (regmask == 0)
+    {
+      strcpy(buf, "#0");
+      return;
+    }
+#define oad(reg) \
+  *buf++ = '%'; \
+  *buf++ = REGISTER_PREFIX[0]; \
+  *buf++ = reg >= 8 ? 'a' : 'd'; \
+  *buf++ = '0' + (reg & 7)
+
+  liststart = status = 0;
+  lastreg = 20;
+  for (regnum = 0; regnum < 16; regnum++)
+    {
+      if ((1 << regnum) & regmask)
+	{
+	  if (regnum == (lastreg + 1) && regnum != 8)
+	    {
+	      if (liststart != 0)
+		*buf++ = '-';
+	      liststart = 0;
+	      status = 1;
+	      lastreg = regnum;
+	    }
+	  else
+	    {
+	      if (status != 0)
+		{
+		  oad(lastreg);
+		  status = 0;
+		  liststart = 1;
+		}
+	      if (liststart != 0)
+		*buf++ = '/';
+	      oad(regnum);
+	      lastreg = regnum;
+	      liststart = 1;
+	    }
+	}
+    }
+  if (status != 0)
+    {
+      oad(lastreg);
+    }
+  *buf = '\0';
+#undef oad
+}
+
+static void
+freglist(char *buf, int regmask)
+{
+  int regnum;
+  int liststart;
+  int lastreg;
+  int status;
+
+  if (regmask == 0)
+    {
+      strcpy(buf, "#0");
+      return;
+    }
+#define ofpreg(reg) \
+  *buf++ = '%'; \
+  *buf++ = REGISTER_PREFIX[0]; \
+  *buf++ = 'f'; \
+  *buf++ = 'p'; \
+  *buf++ = '0' + reg
+
+  liststart = status = 0;
+  lastreg = 20;
+  for (regnum = 0; regnum < 8; regnum++)
+    {
+      if ((1 << regnum) & regmask)
+	{
+	  if (regnum == (lastreg + 1) && regnum != 8)
+	    {
+	      if (liststart != 0)
+		*buf++ = '-';
+	      liststart = 0;
+	      status = 1;
+	      lastreg = regnum;
+	    }
+	  else
+	    {
+	      if (status != 0)
+		{
+		  ofpreg(lastreg);
+		  status = 0;
+		  liststart = 1;
+		}
+	      if (liststart != 0)
+		*buf++ = '/';
+	      ofpreg(regnum);
+	      lastreg = regnum;
+	      liststart = 1;
+	    }
+	}
+    }
+  if (status != 0)
+    {
+      ofpreg(lastreg);
+    }
+  *buf = '\0';
+#undef ofpreg
+}
+
+static int
+revbits(int mask, int n)
+{
+  int i;
+  int newmask;
+
+  for (newmask = 0, i = n; i > 0; i--)
+    {
+      newmask = (newmask << 1) | (mask & 1);
+      mask >>= 1;
+    }
+  return newmask;
+}
+
 const char *
 m68k_output_movem (rtx *operands, rtx pattern,
 		   HOST_WIDE_INT automod_offset, bool store_p)
@@ -4268,17 +4887,41 @@ m68k_output_movem (rtx *operands, rtx pattern,
   operands[1] = GEN_INT (mask);
   if (FP_REGNO_P (REGNO (XEXP (XVECEXP (pattern, 0, first), store_p))))
     {
+      char buf[8 * 6 + 1];
+
+      if (automod_offset >= 0)
+	 mask = revbits(mask, 8);
       if (store_p)
-	return "fmovem %1,%a0";
+	{
+	  strcpy(buf, "fmovem ");
+	  freglist(buf + 7, mask);
+	  strcat(buf, ",%a0");
+	}
       else
-	return "fmovem %a0,%1";
+	{
+	  strcpy(buf, "fmovem %a0,");
+	  freglist(buf + 11, mask);
+	}
+      return xstrdup(buf);
     }
   else
     {
+      char buf[16 * 5 + 1];
+
+      if (automod_offset < 0)
+	 mask = revbits(mask, 16);
       if (store_p)
-	return "movem%.l %1,%a0";
+	{
+	  strcpy(buf, "movem%.l ");
+	  reglist(buf + 9, mask);
+	  strcat(buf, ",%a0");
+	}
       else
-	return "movem%.l %a0,%1";
+	{
+	  strcpy(buf, "movem%.l %a0,");
+	  reglist(buf + 13, mask);
+	}
+      return xstrdup(buf);
     }
 }
 
@@ -5611,7 +6254,7 @@ output_call (rtx x)
   if (symbolic_operand (x, VOIDmode))
     return m68k_symbolic_call;
   else
-    return "jsr %a0";
+    return "jsr %a0"; /* note: will be replaced by STATIC_CHAIN_REGNUM in m68k_legitimize_sibcall_address */
 }
 
 /* Likewise sibling calls.  */
@@ -5622,9 +6265,53 @@ output_sibcall (rtx x)
   if (symbolic_operand (x, VOIDmode))
     return m68k_symbolic_jump;
   else
-    return "jmp %a0";
+    return "jmp %a0"; /* note: will be replaced by STATIC_CHAIN_REGNUM in m68k_legitimize_sibcall_address */
+}
+
+/* Determine whether m68k_output_mi_thunk can succeed.  */
+
+static bool
+m68k_can_output_mi_thunk (const_tree, HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,
+			 const_tree function)
+{
+  /* without fastcall we can handle anything.  */
+  if (m68k_function_abi(function) != FASTCALL_ABI)
+    return true;
+
+  return true;
+}
+
+static void
+emit_push_reg (unsigned regno)
+{
+  rtx mem, reg;
+
+  mem = gen_rtx_PRE_DEC (Pmode, stack_pointer_rtx);
+  mem = gen_frame_mem (SImode, mem);
+  reg = gen_rtx_REG (Pmode, regno);
+
+  emit_insn (gen_movsi (mem, reg));
 }
 
+static void
+emit_pop_reg (unsigned regno)
+{
+  rtx mem, reg;
+
+  mem = gen_rtx_POST_INC (Pmode, stack_pointer_rtx);
+  mem = gen_frame_mem (Pmode, mem);
+  reg = gen_rtx_REG (SImode, regno);
+
+  emit_move_insn (reg, mem);
+}
+
+
+/* Output the assembler code for a thunk function.  THUNK_DECL is the
+   declaration for the thunk function itself, FUNCTION is the decl for
+   the target function.  DELTA is an immediate constant offset to be
+   added to THIS.  If VCALL_OFFSET is nonzero, the word at
+   *(*this + vcall_offset) should be added to THIS.  */
+
 static void
 m68k_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,
 		      HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,
@@ -5632,38 +6319,63 @@ m68k_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,
 {
   const char *fnname = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (thunk));
   rtx this_slot, offset, addr, mem, tmp;
+  int tmp_regno;
+  int preserve_a2 = 0;
   rtx_insn *insn;
 
-  /* Avoid clobbering the struct value reg by using the
-     static chain reg as a temporary.  */
-  tmp = gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);
-
   /* Pretend to be a post-reload pass while generating rtl.  */
   reload_completed = 1;
 
-  /* The "this" pointer is stored at 4(%sp).  */
-  this_slot = gen_rtx_MEM (Pmode, plus_constant (Pmode,
+  if (m68k_function_abi(function) == FASTCALL_ABI)
+    {
+      tmp_regno = A2_REG;
+      tmp = gen_rtx_REG (Pmode, tmp_regno);
+      /* The "this" pointer is stored in %a0.  */
+      this_slot = gen_rtx_REG (Pmode, A0_REG);
+    }
+  else
+    {
+      /* Avoid clobbering the M68K_STRUCT_VALUE_REGNUM by using the
+	 STATIC_CHAIN_REGNUM as a temporary.  */
+      tmp_regno = STATIC_CHAIN_REGNUM;
+      tmp = gen_rtx_REG (Pmode, tmp_regno);
+      /* The "this" pointer is stored at 4(%sp).  */
+      this_slot = gen_rtx_MEM (Pmode, plus_constant (Pmode,
 						 stack_pointer_rtx, 4));
+    }
 
   /* Add DELTA to THIS.  */
   if (delta != 0)
     {
       /* Make the offset a legitimate operand for memory addition.  */
       offset = GEN_INT (delta);
-      if ((delta < -8 || delta > 8)
-	  && (TARGET_COLDFIRE || USE_MOVQ (delta)))
+      if (m68k_function_abi(function) != FASTCALL_ABI)
 	{
-	  emit_move_insn (gen_rtx_REG (Pmode, D0_REG), offset);
-	  offset = gen_rtx_REG (Pmode, D0_REG);
-	}
-      emit_insn (gen_add3_insn (copy_rtx (this_slot),
+	  if ((delta < -8 || delta > 8)
+		  && (TARGET_COLDFIRE || USE_MOVQ (delta)))
+	    {
+	       int offset_regno = D0_REG;
+	       emit_move_insn (gen_rtx_REG (Pmode, offset_regno), offset);
+	       offset = gen_rtx_REG (Pmode, offset_regno);
+	    }
+	  emit_insn (gen_add3_insn (copy_rtx (this_slot),
 				copy_rtx (this_slot), offset));
+	}
+      else
+	{
+	  emit_insn(gen_addsi3(this_slot, this_slot, offset));
+	}
     }
 
   /* If needed, add *(*THIS + VCALL_OFFSET) to THIS.  */
   if (vcall_offset != 0)
     {
       /* Set the static chain register to *THIS.  */
+      if (tmp_regno == A2_REG)
+      {
+	emit_push_reg(A2_REG);
+	preserve_a2 = 1;
+      }
       emit_move_insn (tmp, this_slot);
       emit_move_insn (tmp, gen_rtx_MEM (Pmode, tmp));
 
@@ -5675,12 +6387,22 @@ m68k_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,
 	  addr = tmp;
 	}
 
-      /* Load the offset into %d0 and add it to THIS.  */
-      emit_move_insn (gen_rtx_REG (Pmode, D0_REG),
+      if (m68k_function_abi(function) != FASTCALL_ABI)
+	{
+	  /* Load the offset into %d0 and add it to THIS.  */
+	  int offset_regno = D0_REG;
+	  emit_move_insn (gen_rtx_REG (Pmode, offset_regno),
 		      gen_rtx_MEM (Pmode, addr));
-      emit_insn (gen_add3_insn (copy_rtx (this_slot),
+	  emit_insn (gen_add3_insn (copy_rtx (this_slot),
 				copy_rtx (this_slot),
-				gen_rtx_REG (Pmode, D0_REG)));
+				gen_rtx_REG (Pmode, offset_regno)));
+	}
+      else
+	{
+	  emit_insn (gen_add3_insn (copy_rtx (this_slot),
+				copy_rtx (this_slot),
+				gen_rtx_MEM (Pmode, addr)));
+	}
     }
 
   /* Jump to the target function.  Use a sibcall if direct jumps are
@@ -5695,12 +6417,14 @@ m68k_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,
 	  /* Use the static chain register as a temporary (call-clobbered)
 	     GOT pointer for this function.  We can use the static chain
 	     register because it isn't live on entry to the thunk.  */
-	  SET_REGNO (pic_offset_table_rtx, STATIC_CHAIN_REGNUM);
+	  SET_REGNO (pic_offset_table_rtx, M68K_STRUCT_VALUE_REGNUM == A0_REG ? A1_REG : A0_REG);
 	  emit_insn (gen_load_got (pic_offset_table_rtx));
 	}
       legitimize_pic_address (XEXP (mem, 0), Pmode, tmp);
       mem = replace_equiv_address (mem, tmp);
     }
+  if (preserve_a2)
+    emit_pop_reg(A2_REG);
   insn = emit_call_insn (gen_sibcall (mem, const0_rtx));
   SIBLING_CALL_P (insn) = 1;
 
@@ -5891,11 +6615,22 @@ m68k_libcall_value (machine_mode mode)
    NOTE: Due to differences in ABIs, don't call this function directly,
    use FUNCTION_VALUE instead.  */
 rtx
-m68k_function_value (const_tree valtype, const_tree func ATTRIBUTE_UNUSED)
+m68k_function_value (const_tree valtype, const_tree func, bool regs)
 {
-  machine_mode mode;
+  enum machine_mode mode = TYPE_MODE (valtype);
+  const_tree fn, fntype;
+  bool func_fastcall;
+
+  fn = NULL_TREE;
+  if (func && DECL_P (func))
+    fn = func;
+  fntype = fn ? TREE_TYPE (fn) : func;
+
+  func_fastcall = m68k_function_type_abi(fntype) == FASTCALL_ABI;
+
+  if (! regs && !func_fastcall)
+    return gen_rtx_REG (mode, D0_REG);
 
-  mode = TYPE_MODE (valtype);
   switch (mode) {
   case E_SFmode:
   case E_DFmode:
@@ -5908,7 +6643,7 @@ m68k_function_value (const_tree valtype, const_tree func ATTRIBUTE_UNUSED)
   }
 
   /* If the function returns a pointer, push that into %a0.  */
-  if (func && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (func))))
+  if (regs && fntype && POINTER_TYPE_P (TREE_TYPE (fntype)) && !func_fastcall)
     /* For compatibility with the large body of existing code which
        does not always properly declare external functions returning
        pointer types, the m68k/SVR4 convention is to copy the value
@@ -7108,6 +7843,66 @@ m68k_return_pops_args (tree fundecl, tree funtype, poly_int64 size)
 	  ? (HOST_WIDE_INT) size : 0);
 }
 
+/* Remember the last target of m68k_set_current_function.  */
+static GTY(()) tree m68k_previous_fndecl;
+
+/* Establish appropriate back-end context for processing the function
+   FNDECL.  The argument might be NULL to indicate processing at top
+   level, outside of any function scope.  */
+static void
+m68k_set_current_function (tree fndecl)
+{
+  /* Only change the context if the function changes.  This hook is called
+     several times in the course of compiling a function, and we don't want to
+     slow things down too much or call target_reinit when it isn't safe.  */
+  if (fndecl && fndecl != m68k_previous_fndecl)
+    {
+      tree old_tree = (m68k_previous_fndecl
+		       ? DECL_FUNCTION_SPECIFIC_TARGET (m68k_previous_fndecl)
+		       : NULL_TREE);
+
+      tree new_tree = (fndecl
+		       ? DECL_FUNCTION_SPECIFIC_TARGET (fndecl)
+		       : NULL_TREE);
+
+      m68k_previous_fndecl = fndecl;
+      if (old_tree == new_tree)
+	;
+
+      else if (new_tree)
+	{
+	  cl_target_option_restore (&global_options, &global_options_set,
+				    TREE_TARGET_OPTION (new_tree));
+	  target_reinit ();
+	}
+
+      else if (old_tree)
+	{
+	  struct cl_target_option *def
+	    = TREE_TARGET_OPTION (target_option_current_node);
+
+	  cl_target_option_restore (&global_options, &global_options_set, def);
+	  target_reinit ();
+	}
+    }
+}
+
+void
+m68k_order_regs_for_local_alloc (void)
+{
+  int i;
+  int pos = 0;
+  for (i = 0; i < 16; i ++)
+    if (call_used_regs [i] && !fixed_regs[i])
+      reg_alloc_order[pos++] = i;
+  for (i = 0; i < 16; i ++)
+    if (!(call_used_regs [i] && !fixed_regs[i]))
+      reg_alloc_order[pos++] = i;
+  reg_alloc_order[pos++] = 24;
+  for (i = 16; i < 24; i++)
+    reg_alloc_order[pos++] = i;
+}
+
 /* Make sure everything's fine if we *don't* have a given processor.
    This assumes that putting a register in fixed_regs will keep the
    compiler's mitts completely off it.  We don't bother to zero it out
@@ -7118,6 +7913,21 @@ m68k_conditional_register_usage (void)
 {
   int i;
   HARD_REG_SET x;
+
+  int num_of_dregs = (TARGET_FASTCALL) ? M68K_FASTCALL_USED_DATA_REGS : M68K_STD_USED_REGS;
+  int num_of_aregs = (TARGET_FASTCALL) ? M68K_FASTCALL_USED_ADDR_REGS : M68K_STD_USED_REGS;
+  for (i = 0; i < 8; i++)
+    {
+      call_used_regs[i] = (i < num_of_dregs) | fixed_regs[i];
+      call_used_regs[i + 8] = (i < num_of_aregs) | fixed_regs[i + 8];
+      call_used_regs[i + 16] = (i < num_of_dregs) | fixed_regs[i + 16];
+    }
+  if (flag_pic)
+    fixed_regs[PIC_REG] = 1;
+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
+    {
+       call_used_regs[i] |= fixed_regs[i];
+    }
   if (!TARGET_HARD_FLOAT)
     {
       x = reg_class_contents[FP_REGS];
@@ -7125,12 +7935,10 @@ m68k_conditional_register_usage (void)
         if (TEST_HARD_REG_BIT (x, i))
 	  fixed_regs[i] = call_used_regs[i] = 1;
     }
-  if (flag_pic)
-    fixed_regs[PIC_REG] = call_used_regs[PIC_REG] = 1;
 }
 
 static void
-m68k_init_sync_libfuncs (void)
+m68k_init_libfuncs (void)
 {
   init_sync_libfuncs (UNITS_PER_WORD);
 }
@@ -7269,4 +8077,35 @@ m68k_use_lra_p ()
   return m68k_lra_p;
 }
 
+/* Do not emit .note.GNU-stack by default.  */
+#undef NEED_INDICATE_EXEC_STACK
+#ifdef USING_ELFOS_H
+#define NEED_INDICATE_EXEC_STACK	1
+#else
+#define NEED_INDICATE_EXEC_STACK	0
+#endif
+
+static void
+m68k_file_end (void)
+{
+#if defined(HAVE_AS_GNU_ATTRIBUTE)
+#if 0
+  /* Emit .gnu_attribute directive for Tag_GNU_M68K_ABI_FP.  */
+  int fp_abi = TARGET_68881 ? (FUNCTION_VALUE_REGNO_P(FP0_REG) ? 1 : 2) : 0;
+  fprintf (asm_out_file, "\t.gnu_attribute 4,%d\n", fp_abi);
+#endif
+#endif
+#ifdef USING_ELFOS_H
+  /* Emit .gnu_attribute directive for Tag_GNU_M68K_ABI.  */
+  int abi = 1 + (TARGET_SHORT ? 2 : 0) + (TARGET_FASTCALL ? 4 : 0);
+  fprintf (asm_out_file, "\t.gnu_attribute 8,%d\n", abi);
+#endif
+
+  if (NEED_INDICATE_EXEC_STACK)
+    /* Add .note.GNU-stack.  */
+    file_end_indicate_exec_stack ();
+}
+
+struct gcc_target targetm = TARGET_INITIALIZER;
+
 #include "gt-m68k.h"
diff --git a/gcc/config/m68k/m68k.h b/gcc/config/m68k/m68k.h
index 05e6ca70629..4be98a94068 100644
--- a/gcc/config/m68k/m68k.h
+++ b/gcc/config/m68k/m68k.h
@@ -26,6 +26,19 @@ along with GCC; see the file COPYING3.  If not see
 # define MOTOROLA 0  /* Use the MIT assembly syntax.  */
 #endif
 
+/* Available call abi.  */
+enum calling_abi
+{
+  STD_ABI = 0,
+  FASTCALL_ABI = 1
+};
+
+/* The abi used by target.  */
+extern enum calling_abi m68k_abi;
+
+/* The default abi used by target.  */
+#define DEFAULT_ABI STD_ABI
+
 /* Handle --with-cpu default option from configure script.  */
 #define OPTION_DEFAULT_SPECS						\
   { "cpu",   "%{!m68020-40:%{!m68020-60:\
@@ -37,8 +50,8 @@ along with GCC; see the file COPYING3.  If not see
 
 #define ASM_CPU_SPEC "\
 %{m68851}%{mno-68851} %{m68881}%{mno-68881} %{msoft-float:-mno-float} \
-%{m68020-40:-m68040}%{m68020-60:-m68040}\
-%{mcpu=*:-mcpu=%*}%{march=*:-march=%*}\
+%{m68020-40:-m68040} %{m68020-60:-m68040} \
+%{mcpu=*:-mcpu=%*} %{march=*:-march=%*}\
 "
 #define ASM_PCREL_SPEC "%{" FPIE_OR_FPIC_SPEC ":--pcrel} \
  %{mpcrel:%{" NO_FPIE_AND_FPIC_SPEC ":--pcrel}} \
@@ -131,7 +144,15 @@ along with GCC; see the file COPYING3.  If not see
 	}								\
 									\
       if (TARGET_68881)							\
-	builtin_define ("__HAVE_68881__");				\
+	{								\
+	  builtin_define ("__HAVE_68881__");				\
+	  builtin_define ("__M68881__"); /* Non-standard */		\
+	}								\
+									\
+      if (TARGET_FASTCALL)					      \
+	{							       \
+	  builtin_define ("__FASTCALL__"); /* Non-standard */		\
+	}							       \
 									\
       if (TARGET_COLDFIRE)						\
 	{								\
@@ -406,7 +427,7 @@ along with GCC; see the file COPYING3.  If not see
  */
 #define ARG_POINTER_REGNUM 24
 
-#define STATIC_CHAIN_REGNUM A0_REG
+#define STATIC_CHAIN_REGNUM (M68K_STRUCT_VALUE_REGNUM == A0_REG ? A1_REG : A0_REG)
 #define M68K_STATIC_CHAIN_REG_NAME REGISTER_PREFIX "a0"
 
 /* Register in which address to store a structure value
@@ -455,7 +476,7 @@ extern enum reg_class regno_reg_class[];
 /* On the m68k, this is the size of MODE in words,
    except in the FP regs, where a single reg is always enough.  */
 #define CLASS_MAX_NREGS(CLASS, MODE)	\
- ((CLASS) == FP_REGS ? 1 \
+ ((CLASS) == FP_REGS ? GET_MODE_NUNITS (MODE) \
   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))
 
 /* Moves between fp regs and other regs are two insns.  */
@@ -473,11 +494,12 @@ extern enum reg_class regno_reg_class[];
 #define FIRST_PARM_OFFSET(FNDECL) 8
 
 /* On the m68k the return value defaults to D0.  */
+#undef FUNCTION_VALUE
 #define FUNCTION_VALUE(VALTYPE, FUNC)  \
-  gen_rtx_REG (TYPE_MODE (VALTYPE), D0_REG)
+  m68k_function_value (VALTYPE, FUNC, false)
 
 /* On the m68k the return value defaults to D0.  */
-#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, D0_REG)
+#define LIBCALL_VALUE(MODE)  m68k_libcall_value (MODE)
 
 /* On the m68k, D0 is usually the only register used.  */
 #define FUNCTION_VALUE_REGNO_P(N) ((N) == D0_REG)
@@ -488,15 +510,61 @@ extern enum reg_class regno_reg_class[];
 #define NEEDS_UNTYPED_CALL 0
 
 /* On the m68k, all arguments are usually pushed on the stack.  */
-#define FUNCTION_ARG_REGNO_P(N) 0
+/* 1 if N is a possible register number for function argument passing.  */
+#define FUNCTION_ARG_REGNO_P(N)			\
+  ((((int)N) >= 0 && (N) < M68K_FASTCALL_DATA_PARM)		\
+   || ((N) >= 8 && (N) < 8 + M68K_FASTCALL_ADDR_PARM)	\
+   || (TARGET_68881 && (N) >= 16 && (N) < 16 + M68K_FASTCALL_DATA_PARM))
 
-/* On the m68k, this is a single integer, which is a number of bytes
-   of arguments scanned so far.  */
-#define CUMULATIVE_ARGS int
 
-/* On the m68k, the offset starts at 0.  */
-#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \
- ((CUM) = 0)
+/* The number of data/float registers and address registers to use for
+   fast calls. */
+#define M68K_FASTCALL_DATA_PARM 3
+#define M68K_FASTCALL_ADDR_PARM 2
+
+/* Call clobbered regs. */
+#define M68K_STD_USED_REGS 2
+#define M68K_FASTCALL_USED_DATA_REGS 3
+#define M68K_FASTCALL_USED_ADDR_REGS 2
+
+/* On the m68k, this is a structure:
+   regs_already_used: bitmask of the already used registers.
+   last_arg_reg - register number of the most recently passed argument.
+     -1 if passed on stack.
+   last_arg_len - number of registers used by the most recently passed
+     argument.
+*/
+
+struct m68k_args
+{
+  unsigned long /* HARD_REG_SET */ regs_already_used;
+  int last_arg_reg;
+  int last_arg_len;
+  enum calling_abi call_abi;
+};
+
+#define CUMULATIVE_ARGS struct m68k_args
+
+/* The default number of data, address and float registers to use when
+   user specified '-mregparm' switch, not '-mregparm=<value>' option.  */
+
+#define ADJUST_REG_ALLOC_ORDER m68k_order_regs_for_local_alloc ()
+
+#define OVERRIDE_ABI_FORMAT(FNDECL) m68k_call_abi_override (FNDECL)
+
+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS) \
+  m68k_init_cumulative_args (&(CUM), (FNTYPE), (LIBNAME), (FNDECL), (N_NAMED_ARGS) != -1)
+
+#undef TARGET_FUNCTION_ARG_ADVANCE
+#define TARGET_FUNCTION_ARG_ADVANCE m68k_function_arg_advance
+
+/* On m68k all args are pushed, except if -mfastcall then d0-2, a0-1 and
+   fp0-2 are used for passing the first arguments.
+   Note: by default, the static-chain is passed in a0. Targets that want
+   to make full use of '-mfastcall' are advised to pass the static-chain
+   somewhere else.  */
+#undef TARGET_FUNCTION_ARG
+#define TARGET_FUNCTION_ARG m68k_function_arg
 
 #define FUNCTION_PROFILER(FILE, LABELNO)  \
   asm_fprintf (FILE, "\tlea %LLP%d,%Ra0\n\tjsr mcount\n", (LABELNO))
@@ -543,9 +611,10 @@ extern enum reg_class regno_reg_class[];
    The function name __transfer_from_trampoline is not actually used.
    The function definition just permits use of "asm with operands"
    (though the operand list is empty).  */
+void __transfer_from_trampoline (void);
 #define TRANSFER_FROM_TRAMPOLINE				\
 void								\
-__transfer_from_trampoline ()					\
+__transfer_from_trampoline (void)					\
 {								\
   register char *a0 asm (M68K_STATIC_CHAIN_REG_NAME);		\
   asm (GLOBAL_ASM_OP "___trampoline");				\
@@ -554,6 +623,7 @@ __transfer_from_trampoline ()					\
   asm volatile ("move%.l %1,%0" : "=a" (a0) : "m" (a0[18]));	\
   asm ("rts":);							\
 }
+
 
 /* There are two registers that can always be eliminated on the m68k.
    The frame pointer and the arg pointer can be replaced by either the
@@ -673,16 +743,24 @@ __transfer_from_trampoline ()					\
 
 /* Control the assembler format that we output.  */
 
+extern const char *m68k_text_section, *m68k_data_section, *m68k_rodata_section;
+
 #define ASM_APP_ON "#APP\n"
 #define ASM_APP_OFF "#NO_APP\n"
-#define TEXT_SECTION_ASM_OP "\t.text"
-#define DATA_SECTION_ASM_OP "\t.data"
+#define TEXT_SECTION_ASM_OP m68k_text_section
+#define DATA_SECTION_ASM_OP m68k_data_section
+#undef READONLY_DATA_SECTION_ASM_OP
+#define READONLY_DATA_SECTION_ASM_OP	m68k_rodata_section
 #define GLOBAL_ASM_OP "\t.globl\t"
 #define REGISTER_PREFIX ""
 #define LOCAL_LABEL_PREFIX ""
 #define USER_LABEL_PREFIX "_"
 #define IMMEDIATE_PREFIX "#"
 
+#define M68K_DEFAULT_TEXT_SECTION ".text"
+#define M68K_DEFAULT_DATA_SECTION ".data"
+#define M68K_DEFAULT_RODATA_SECTION ".rodata"
+
 #define REGISTER_NAMES \
 {REGISTER_PREFIX"d0", REGISTER_PREFIX"d1", REGISTER_PREFIX"d2",	\
  REGISTER_PREFIX"d3", REGISTER_PREFIX"d4", REGISTER_PREFIX"d5",	\
@@ -920,3 +998,11 @@ extern int m68k_sched_address_bypass_p (rtx_insn *, rtx_insn *);
 extern int m68k_sched_indexed_address_bypass_p (rtx_insn *, rtx_insn *);
 
 #define CPU_UNITS_QUERY 1
+
+#ifndef USED_FOR_TARGET
+struct GTY(()) machine_function {
+  /* This value is used for amd64 targets and specifies the current abi
+     to be used. STD_ABI means cdecl abi. Otherwise FASTCALL_ABI means fastcall abi.  */
+  ENUM_BITFIELD(calling_abi) call_abi : 8;
+};
+#endif
diff --git a/gcc/config/m68k/m68k.md b/gcc/config/m68k/m68k.md
index 35bf1c683c5..7fbc6ffaf8c 100644
--- a/gcc/config/m68k/m68k.md
+++ b/gcc/config/m68k/m68k.md
@@ -131,8 +131,11 @@
 ;; Registers by name.
 (define_constants
   [(D0_REG		0)
+   (D1_REG		1)
+   (D2_REG		2)
    (A0_REG		8)
    (A1_REG		9)
+   (A2_REG		10)
    (PIC_REG		13)
    (A6_REG		14)
    (SP_REG		15)
diff --git a/gcc/config/m68k/m68k.opt b/gcc/config/m68k/m68k.opt
index 35f86ba11ff..adaff26ef6b 100644
--- a/gcc/config/m68k/m68k.opt
+++ b/gcc/config/m68k/m68k.opt
@@ -163,6 +163,10 @@ mnoshort
 Target RejectNegative InverseMask(SHORT)
 Consider type 'int' to be 32 bits wide.
 
+mnofastcall
+Target RejectNegative InverseMask(FASTCALL)
+Use standard calling conventions.
+
 mpcrel
 Target Mask(PCREL)
 Generate pc-relative code.
@@ -183,6 +187,10 @@ mshort
 Target Mask(SHORT)
 Consider type 'int' to be 16 bits wide.
 
+mfastcall
+Target Mask(FASTCALL)
+Use calling convention passing arguments in registers.
+
 msoft-float
 Target RejectNegative InverseMask(HARD_FLOAT)
 Generate code with library calls for floating point.
@@ -202,3 +210,15 @@ Support more than 8192 GOT entries on ColdFire.
 mxtls
 Target Mask(XTLS)
 Support TLS segment larger than 64K.
+
+mtext=
+Target RejectNegative Joined Var(m68k_text_string) Init(0)
+Put functions in SECTION
+
+mdata=
+Target RejectNegative Joined Var(m68k_data_string) Init(0)
+Put data in SECTION
+
+mrodata=
+Target RejectNegative Joined Var(m68k_rodata_string) Init(0)
+Put read-only data in SECTION
diff --git a/gcc/config/m68k/m68kelf.h b/gcc/config/m68k/m68kelf.h
index 2358b615a90..863b710b1e0 100644
--- a/gcc/config/m68k/m68kelf.h
+++ b/gcc/config/m68k/m68kelf.h
@@ -89,7 +89,7 @@ do {								\
    structure return, so have to use a1 for the static chain.  */
 
 #undef STATIC_CHAIN_REGNUM
-#define STATIC_CHAIN_REGNUM A1_REG
+#define STATIC_CHAIN_REGNUM (M68K_STRUCT_VALUE_REGNUM == A0_REG ? A1_REG : A0_REG)
 #undef M68K_STATIC_CHAIN_REG_NAME
 #define M68K_STATIC_CHAIN_REG_NAME REGISTER_PREFIX "a1"
 
diff --git a/gcc/config/m68k/math-68881.h b/gcc/config/m68k/math-68881.h
index 6d9f8b2d4a1..9fad2950508 100644
--- a/gcc/config/m68k/math-68881.h
+++ b/gcc/config/m68k/math-68881.h
@@ -44,6 +44,16 @@
 
 #include <errno.h>
 
+/* GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
+   inline semantics, unless -fgnu89-inline is used.  */
+#ifdef __cplusplus
+# define __MATH_68881_INLINE inline
+#elif defined __GNUC_STDC_INLINE__
+# define __MATH_68881_INLINE extern __inline __attribute__ ((__gnu_inline__))
+#else
+# define __MATH_68881_INLINE extern __inline
+#endif
+
 #undef HUGE_VAL
 #ifdef __sun__
 /* The Sun assembler fails to handle the hex constant in the usual defn.  */
@@ -64,7 +74,7 @@
 })
 #endif
 
-__inline extern double
+__MATH_68881_INLINE double
 sin (double x)
 {
   double value;
@@ -75,7 +85,7 @@ sin (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 cos (double x)
 {
   double value;
@@ -86,7 +96,7 @@ cos (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 tan (double x)
 {
   double value;
@@ -97,7 +107,7 @@ tan (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 asin (double x)
 {
   double value;
@@ -108,7 +118,7 @@ asin (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 acos (double x)
 {
   double value;
@@ -119,7 +129,7 @@ acos (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 atan (double x)
 {
   double value;
@@ -130,7 +140,7 @@ atan (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 atan2 (double y, double x)
 {
   double pi, pi_over_2;
@@ -187,7 +197,7 @@ atan2 (double y, double x)
     }
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 sinh (double x)
 {
   double value;
@@ -198,7 +208,7 @@ sinh (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 cosh (double x)
 {
   double value;
@@ -209,7 +219,7 @@ cosh (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 tanh (double x)
 {
   double value;
@@ -220,7 +230,7 @@ tanh (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 atanh (double x)
 {
   double value;
@@ -231,7 +241,7 @@ atanh (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 exp (double x)
 {
   double value;
@@ -242,7 +252,7 @@ exp (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 expm1 (double x)
 {
   double value;
@@ -253,7 +263,7 @@ expm1 (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 log (double x)
 {
   double value;
@@ -264,7 +274,7 @@ log (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 log1p (double x)
 {
   double value;
@@ -275,7 +285,7 @@ log1p (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 log10 (double x)
 {
   double value;
@@ -286,7 +296,7 @@ log10 (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 sqrt (double x)
 {
   double value;
@@ -297,13 +307,13 @@ sqrt (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 hypot (double x, double y)
 {
   return sqrt (x*x + y*y);
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 pow (double x, double y)
 {
   if (x > 0)
@@ -352,7 +362,7 @@ pow (double x, double y)
     }
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 fabs (double x)
 {
   double value;
@@ -363,7 +373,7 @@ fabs (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 ceil (double x)
 {
   int rounding_mode, round_up;
@@ -385,7 +395,7 @@ ceil (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 floor (double x)
 {
   int rounding_mode, round_down;
@@ -408,7 +418,7 @@ floor (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 rint (double x)
 {
   int rounding_mode, round_nearest;
@@ -430,7 +440,7 @@ rint (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 fmod (double x, double y)
 {
   double value;
@@ -442,7 +452,7 @@ fmod (double x, double y)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 drem (double x, double y)
 {
   double value;
@@ -454,19 +464,20 @@ drem (double x, double y)
   return value;
 }
 
-__inline extern double
-scalb (double x, int n)
+__MATH_68881_INLINE double
+scalb (double x, double n)
 {
   double value;
+  int exp = (int)(n);
 
   __asm ("fscale%.l %2,%0"
 	 : "=f" (value)
 	 : "0" (x),
-	   "dmi" (n));
+	   "dmi" (exp));
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 logb (double x)
 {
   double exponent;
@@ -477,7 +488,7 @@ logb (double x)
   return exponent;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 ldexp (double x, int n)
 {
   double value;
@@ -489,7 +500,7 @@ ldexp (double x, int n)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 frexp (double x, int *exp)
 {
   double float_exponent;
@@ -514,7 +525,7 @@ frexp (double x, int *exp)
   return mantissa;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 modf (double x, double *ip)
 {
   double temp;
diff --git a/gcc/config/m68k/mint-stdint.h b/gcc/config/m68k/mint-stdint.h
new file mode 100644
index 00000000000..89538ccf0d6
--- /dev/null
+++ b/gcc/config/m68k/mint-stdint.h
@@ -0,0 +1,50 @@
+/* Definitions for <stdint.h> types on systems using MiNT.
+   Copyright (C) 2009-2018 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#define SIG_ATOMIC_TYPE "int"
+
+#define INT8_TYPE "signed char"
+#define INT16_TYPE (TARGET_SHORT ? "int" : "short int")
+#define INT32_TYPE (TARGET_SHORT ? "long int" : "int")
+#define INT64_TYPE "long long int"
+#define UINT8_TYPE "unsigned char"
+#define UINT16_TYPE (TARGET_SHORT ? "unsigned int" : "short unsigned int")
+#define UINT32_TYPE (TARGET_SHORT ? "long unsigned int" : "unsigned int")
+#define UINT64_TYPE "long long unsigned int"
+
+#define INT_LEAST8_TYPE INT8_TYPE
+#define INT_LEAST16_TYPE INT16_TYPE
+#define INT_LEAST32_TYPE INT32_TYPE
+#define INT_LEAST64_TYPE INT64_TYPE
+#define UINT_LEAST8_TYPE UINT8_TYPE
+#define UINT_LEAST16_TYPE UINT16_TYPE
+#define UINT_LEAST32_TYPE UINT32_TYPE
+#define UINT_LEAST64_TYPE UINT64_TYPE
+
+#define INT_FAST8_TYPE INT8_TYPE
+#define INT_FAST16_TYPE INT16_TYPE
+#define INT_FAST32_TYPE INT32_TYPE
+#define INT_FAST64_TYPE INT64_TYPE
+#define UINT_FAST8_TYPE UINT8_TYPE
+#define UINT_FAST16_TYPE UINT16_TYPE
+#define UINT_FAST32_TYPE UINT32_TYPE
+#define UINT_FAST64_TYPE UINT64_TYPE
+
+#define INTPTR_TYPE "long int"
+#define UINTPTR_TYPE "long unsigned int"
diff --git a/gcc/config/m68k/mint.h b/gcc/config/m68k/mint.h
new file mode 100644
index 00000000000..d9856f4edc9
--- /dev/null
+++ b/gcc/config/m68k/mint.h
@@ -0,0 +1,336 @@
+/* Definitions of target machine for GCC for Atari ST TOS/MiNT.
+   Copyright (C) 1994-2023 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Here are four prefixes that are used by asm_fprintf to
+   facilitate customization for alternate assembler syntaxes.
+   Machines with no likelihood of an alternate syntax need not
+   define these and need not use asm_fprintf.  */
+
+/* The prefix for register names.  Note that REGISTER_NAMES
+   is supposed to include this prefix. Also note that this is NOT an
+   fprintf format string, it is a literal string */
+
+#undef REGISTER_PREFIX
+#define REGISTER_PREFIX "%"
+
+/* The prefix for local (compiler generated) labels.
+   These labels will not appear in the symbol table.  */
+
+#undef LOCAL_LABEL_PREFIX
+#define LOCAL_LABEL_PREFIX "."
+
+#undef ASM_COMMENT_START
+#define ASM_COMMENT_START "|"
+
+/* with fdlibm, most of the c99 functions are available, including sincos */
+#undef TARGET_LIBC_HAS_FUNCTION
+#define TARGET_LIBC_HAS_FUNCTION bsd_libc_has_function
+
+#undef WCHAR_TYPE
+#define WCHAR_TYPE "short unsigned int"
+
+#undef WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE SHORT_TYPE_SIZE
+
+#if HAVE_INITFINI_ARRAY_SUPPORT
+#define GCC_HAVE_INITFINI_ARRAY_SUPPORT builtin_define ("__GCC_HAVE_INITFINI_ARRAY_SUPPORT");
+#else
+#define GCC_HAVE_INITFINI_ARRAY_SUPPORT
+#endif
+
+#undef TARGET_OS_CPP_BUILTINS
+#define TARGET_OS_CPP_BUILTINS()		\
+  do						\
+    {						\
+      builtin_define ("__MINT__");		\
+      GCC_HAVE_INITFINI_ARRAY_SUPPORT \
+      /* The GNU C++ standard library requires this.  */ \
+      if (c_dialect_cxx ()) \
+       builtin_define ("_GNU_SOURCE"); \
+      builtin_define_std ("atarist");		\
+      builtin_assert ("machine=atari");		\
+      builtin_assert ("system=mint");		\
+    }						\
+  while (0)
+
+/* The following defines are nonstandard
+   and are kept only for compatibility
+   with older versions of GCC for MiNT.  */
+
+#undef CPP_SPEC
+#define CPP_SPEC			\
+  "%{m68000|mcpu=68000:-D__M68000__} "		\
+  "%{m68020|mcpu=68020:-D__M68020__} "		\
+  "%{m68030|mcpu=68030:-D__M68020__} "		\
+  "%{m68040|mcpu=68040:-D__M68020__} "		\
+  "%{m68060|mcpu=68060:-D__M68020__} "		\
+  "%{m68020-40|mcpu=68020-40:-D__M68020__} "		\
+  "%{m68020-60|mcpu=68020-60:-D__M68020__} "		\
+  "%{!m680*:%{!mc680*:%{!mcpu=680*:-D__M68000__}}} "	\
+  "%{mshort:-D__MSHORT__}"
+
+#undef  LIB_SPEC
+#define LIB_SPEC	"-lc"
+
+/* The -g option generates stabs debug information.  */
+#define DBX_DEBUGGING_INFO 1
+
+/* Do not break .stabs pseudos into continuations.  */
+#define DBX_CONTIN_LENGTH 0
+
+/* This is the char to use for continuation (in case we need to turn
+   continuation back on).  */
+#define DBX_CONTIN_CHAR '?'
+
+/* This is the assembler directive to equate two values.  */
+#undef SET_ASM_OP
+#define SET_ASM_OP		"\t.set\t"
+
+/* This is how we tell the assembler that a symbol is weak.  */
+#undef ASM_WEAKEN_LABEL
+#define ASM_WEAKEN_LABEL(FILE,NAME) \
+  do { fputs ("\t.weak\t", FILE); assemble_name (FILE, NAME); \
+       fputc ('\n', FILE); } while (0)
+
+/* Don't default to pcc-struct-return, because gcc is the only compiler, and
+   we want to retain compatibility with older gcc versions.  */
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+/* Finalize the trampoline by flushing the insn cache.  */
+
+#undef FINALIZE_TRAMPOLINE
+#define FINALIZE_TRAMPOLINE(TRAMP)					\
+  if (TARGET_68020 || TARGET_COLDFIRE) \
+    maybe_emit_call_builtin___clear_cache ((TRAMP),			\
+					 plus_constant (Pmode,		\
+							(TRAMP),	\
+							TRAMPOLINE_SIZE))
+
+/* Clear the instruction cache from `beg' to `end'.  This makes an
+   inline system call to Ssystem(S_FLUSHCACHE).  The arguments are as
+   follows:
+
+	Ssystem(S_FLUSHCACHE, addr, len)
+
+   addr	  - the start address for the flush
+   len    - the number of bytes to flush
+
+   The kernel will push the instruction cache
+	    */
+
+#define CLEAR_INSN_CACHE(BEG, END)					\
+{									\
+  register unsigned long _beg __asm ("%d0") = (unsigned long) (BEG);	\
+  unsigned long _end = (unsigned long) (END);				\
+  register unsigned long _len __asm ("%d1") = (_end - _beg);	\
+  __asm __volatile							\
+    ("move%.l %1,-(%%sp)\n\t"	/* len */			\
+     "move%.l %0,-(%%sp)\n\t"	/* beg */			\
+     "move%.w #22,-(%%sp)\n\t"	/* S_FLUSHCACHE */			\
+     "move%.w #340,-(%%sp)\n\t"	/* system call nr */			\
+     "trap #1\n\t"								\
+     "lea 12(%%sp),%%sp" /* correct stack */ \
+     : /* no outputs */							\
+     : "r" (_beg), "r" (_len)						\
+     : "%d2", "%a0", "%a1", "%a2", "cc", "memory");						\
+}
+
+/* By default, the vtable entries are void pointers, the so the alignment
+   is the same as pointer alignment.  The value of this macro specifies
+   the alignment of the vtable entry in bits.  It should be defined only
+   when special alignment is necessary.
+
+   MiNT: The default value of 32 is too much and unsupported by a.out-mintprg.
+*/
+#define TARGET_VTABLE_ENTRY_ALIGN 16
+
+/* If we have a definition of INCOMING_RETURN_ADDR_RTX, assume that
+   the rest of the DWARF 2 frame unwind support is also provided.
+   
+   All configurations that don't use elf must be explicit about not using
+   dwarf unwind information.
+
+   MiNT: DWARF 2 frame unwind is not supported by a.out-mint.
+*/
+#undef DWARF2_UNWIND_INFO
+/* If configured with --disable-sjlj-exceptions, use DWARF2
+   else default to SJLJ.  */
+#if defined(USING_ELFOS_H) && defined (CONFIG_SJLJ_EXCEPTIONS) && !CONFIG_SJLJ_EXCEPTIONS
+/* The logic of this #if must be kept synchronised with the logic
+   for selecting the tmake_eh_file fragment in libgcc/config.host.  */
+#define DWARF2_UNWIND_INFO 1
+#else
+#define DWARF2_UNWIND_INFO 0
+#endif
+
+#if DWARF2_UNWIND_INFO
+/* the default of DW_EH_PE_absptr creates relocations at odd addresses, which we cannot handle */
+#undef ASM_PREFERRED_EH_DATA_FORMAT
+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL)			   \
+  (flag_pic								   \
+   && !((TARGET_ID_SHARED_LIBRARY || TARGET_SEP_DATA)			   \
+	&& ((GLOBAL) || (CODE)))					   \
+   ? ((GLOBAL) ? DW_EH_PE_indirect : 0) | DW_EH_PE_pcrel | DW_EH_PE_sdata4 \
+   : DW_EH_PE_aligned)
+
+/* Define how the m68k registers should be numbered for Dwarf output.
+   The numbering provided here should be compatible with the native
+   SVR4 debugger in the m68k/SVR4 reference port, where d0-d7
+   are 0-7, a0-a7 are 8-15, and fp0-fp7 are 16-23.  */
+
+#undef DEBUGGER_REGNO
+#define DEBUGGER_REGNO(REGNO) (REGNO)
+#endif
+
+/* config/m68k.md has an explicit reference to the program counter,
+   prefix this by the register prefix.  */
+
+#undef ASM_OUTPUT_CASE_LABEL
+#define ASM_RETURN_CASE_JUMP				\
+  do {							\
+    if (TARGET_COLDFIRE)				\
+      {							\
+	if (ADDRESS_REG_P (operands[0]))		\
+	  return "jmp %%pc@(2,%0:l)";			\
+	else if (TARGET_LONG_JUMP_TABLE_OFFSETS)	\
+	  return "jmp %%pc@(2,%0:l)";			\
+	else						\
+	  return "ext%.l %0\n\tjmp %%pc@(2,%0:l)";	\
+      }							\
+    else if (TARGET_LONG_JUMP_TABLE_OFFSETS)		\
+      return "jmp %%pc@(2,%0:l)";			\
+    else						\
+      return "jmp %%pc@(2,%0:w)";			\
+  } while (0)
+
+/* As offset 2 is hardcoded in the jmp instruction above,
+   the ADDR_VEC must immediately follow the jmp instruction.
+   https://gcc.gnu.org/bugzilla/show_bug.cgi?id=112413  */
+
+#undef ADDR_VEC_ALIGN
+#define ADDR_VEC_ALIGN(ADDR_VEC) 0
+
+/* we must define this to prevent alignment of the table,
+   otherwise the relative offset from ASM_RETURN_CASE_JUMP might not match */
+#undef ASM_OUTPUT_BEFORE_CASE_LABEL
+#define ASM_OUTPUT_BEFORE_CASE_LABEL(FILE,PREFIX,NUM,TABLE)
+
+/* If defined, a C expression whose value is a string containing the
+   assembler operation to identify the following data as uninitialized global
+   data.  */
+
+#ifdef USING_ELFOS_H
+#define BSS_SECTION_ASM_OP "\t.section\t.bss"
+
+#define TARGET_HAVE_NAMED_SECTIONS true
+
+/* Currently, JUMP_TABLES_IN_TEXT_SECTION must be defined in order to
+   keep switch tables in the text section.  */
+   
+#define JUMP_TABLES_IN_TEXT_SECTION 1
+
+#define EH_TABLES_CAN_BE_READ_ONLY 1
+
+/* avoid pulling in the tm_clone support which we don't need */
+#define USE_TM_CLONE_REGISTRY 0
+
+#undef INIT_SECTION_ASM_OP
+#undef FINI_SECTION_ASM_OP
+
+/* This is how to output an assembler line that says to advance the
+   location counter to a multiple of 2**LOG bytes.  */
+
+#undef ASM_OUTPUT_ALIGN
+#define ASM_OUTPUT_ALIGN(FILE,LOG)				\
+do {								\
+  if ((LOG) > 0)						\
+    fprintf ((FILE), "%s%u\n", ALIGN_ASM_OP, 1 << (LOG));	\
+} while (0)
+
+#undef  STARTFILE_SPEC
+#define STARTFILE_SPEC	"%{pg|p|profile:gcrt0.o%s;:crt0.o%s} crtbegin.o%s"
+ 
+#undef  ENDFILE_SPEC
+#define ENDFILE_SPEC "crtend.o%s"
+
+/* In order for bitfields to work on a 68000, or with -mnobitfield, we must
+   define either PCC_BITFIELD_TYPE_MATTERS or STRUCTURE_SIZE_BOUNDARY.
+   Defining STRUCTURE_SIZE_BOUNDARY results in structure packing problems,
+   so we define PCC_BITFIELD_TYPE_MATTERS.  */
+#define PCC_BITFIELD_TYPE_MATTERS 1
+
+#else
+/* We can only do STABS.  */
+#undef PREFERRED_DEBUGGING_TYPE
+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG
+
+#define BSS_SECTION_ASM_OP "\t.bss"
+
+#define TARGET_HAVE_NAMED_SECTIONS false
+
+#undef  STARTFILE_SPEC
+#define STARTFILE_SPEC	"%{pg|p|profile:gcrt0.o%s;:crt0.o%s}"
+ 
+#undef  ENDFILE_SPEC
+#define ENDFILE_SPEC ""
+
+/* Every structure or union's size must be a multiple of 2 bytes.  */
+#define STRUCTURE_SIZE_BOUNDARY 16
+
+#endif
+
+/* A C statement (sans semicolon) to output to the stdio stream
+   FILE the assembler definition of uninitialized global DECL named
+   NAME whose size is SIZE bytes and alignment is ALIGN bytes.
+   Try to use asm_output_aligned_bss to implement this macro.  */
+
+#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \
+  asm_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN)
+
+/* Disable -fpic and -fPIC since bsr.l _label@PLTPC
+   is unsupported by the assembler.  */
+
+#undef  SUBTARGET_OVERRIDE_OPTIONS
+#define SUBTARGET_OVERRIDE_OPTIONS					\
+do {									\
+  if (flag_pic && !TARGET_PCREL)					\
+      error ("%<-f%s%> is not supported on this target",			\
+	       (flag_pic > 1) ? "PIC" : "pic");				\
+} while (0)
+
+
+/* Workaround for GCC bug #35067 about multiple thunks.  */
+
+#undef MAKE_DECL_ONE_ONLY
+#define MAKE_DECL_ONE_ONLY(DECL) (DECL_WEAK (DECL) = 1)
+
+/* Avoid requiring -static with -fmudflap like in config/bfin/uclinux.h */
+#define MFWRAP_SPEC " %{fmudflap|fmudflapth: \
+ --wrap=malloc --wrap=free --wrap=calloc --wrap=realloc\
+ --wrap=mmap --wrap=munmap --wrap=alloca\
+ %{fmudflapth: --wrap=pthread_create\
+}} %{fmudflap|fmudflapth: --wrap=main}"
+
+/* Install the __sync libcalls.  */
+#undef TARGET_INIT_LIBFUNCS
+#define TARGET_INIT_LIBFUNCS  m68k_init_libfuncs
+
+#define STACK_CHECK_ATARI
+#define STACK_CHECK_BUILTIN 1
+int m68k_emit_stack_check(void);
diff --git a/gcc/config/m68k/netbsd-elf.h b/gcc/config/m68k/netbsd-elf.h
index 936512fb758..cc4ee3df474 100644
--- a/gcc/config/m68k/netbsd-elf.h
+++ b/gcc/config/m68k/netbsd-elf.h
@@ -210,7 +210,7 @@ while (0)
    regnum.  Make it a1 instead.  */
 
 #undef STATIC_CHAIN_REGNUM
-#define STATIC_CHAIN_REGNUM A1_REG
+#define STATIC_CHAIN_REGNUM (M68K_STRUCT_VALUE_REGNUM == A0_REG ? A1_REG : A0_REG)
 #undef M68K_STATIC_CHAIN_REG_NAME
 #define M68K_STATIC_CHAIN_REG_NAME REGISTER_PREFIX "a1"
 
@@ -250,7 +250,7 @@ while (0)
 
 #undef FUNCTION_VALUE
 #define FUNCTION_VALUE(VALTYPE, FUNC)					\
-  m68k_function_value (VALTYPE, FUNC)
+  m68k_function_value (VALTYPE, FUNC, true)
 
 
 /* Define how to find the value returned by a library function
diff --git a/gcc/config/m68k/t-mint b/gcc/config/m68k/t-mint
new file mode 100644
index 00000000000..347bf1a2331
--- /dev/null
+++ b/gcc/config/m68k/t-mint
@@ -0,0 +1,59 @@
+# 
+# Use multiple libraries
+# 
+
+M68K_AWK = $(strip $(shell $(AWK) 'BEGIN { FS="[ \t]*[,()][ \t]*"; ORS=" " }; \
+	/^M68K_DEVICE/ { CPU=$$3; FLAGS=$$8; \
+	CPU_NAME=substr($$2,2,length($$2)-2); \
+	MLIB=substr($$5,2,length($$5)-2); \
+	if ($1) print $2 }' $(srcdir)/config/m68k/m68k-devices.def))
+
+# Add a multilib for each distinct architecture.  M68K_MLIB_CPU, if defined,
+# adds additional restrictions.
+M68K_MLIB_CPUS := $(call M68K_AWK,\
+	(CPU_NAME == MLIB) $(M68K_MLIB_CPU), \
+	"m"MLIB)
+
+# Make the default cpu the default multilib.
+M68K_MLIB_DEFAULT := $(call M68K_AWK, CPU == "$(target_cpu_default)", MLIB)
+
+ifeq ($(filter m$(M68K_MLIB_DEFAULT),$(M68K_MLIB_CPUS)),)
+$(error Error default cpu '$(target_cpu_default)' is not in multilib set '$(M68K_MLIB_CPUS)')
+endif
+
+MULTILIB_OPTIONS = m68020-60/mcpu=5475 mshort mfastcall
+
+MULTILIB_DIRNAMES = m68020-60 m5475 mshort mfastcall
+
+MULTILIB_MATCHES = \
+	m68020-60=m68881 \
+	m68020-60=m68020 \
+	m68020-60=m68020-40 \
+	m68020-60=mc68020 \
+	m68020-60=m68030 \
+	m68020-60=m68040 \
+	m68020-60=m68060 \
+	m68020-60=mcpu?68020 \
+	m68020-60=mcpu?68030 \
+	m68020-60=mcpu?68040 \
+	m68020-60=mcpu?68060 \
+	m68020-60=march?68020 \
+	m68020-60=march?68030 \
+	m68020-60=march?68040 \
+	m68020-60=march?68060 \
+	mcpu?5475=mcfv4e \
+	mcpu?5475=mcpu?5470 \
+	mcpu?5475=mcpu?5471 \
+	mcpu?5475=mcpu?5472 \
+	mcpu?5475=mcpu?5473 \
+	mcpu?5475=mcpu?5474 \
+	mcpu?5475=mcpu?547x \
+	mcpu?5475=mcpu?5480 \
+	mcpu?5475=mcpu?5481 \
+	mcpu?5475=mcpu?5482 \
+	mcpu?5475=mcpu?5483 \
+	mcpu?5475=mcpu?5484 \
+	mcpu?5475=mcpu?5485 \
+	mcpu?5475=mcpu?548x
+
+MULTILIB_EXCEPTIONS :=
diff --git a/gcc/config/m68k/xm-mint.h b/gcc/config/m68k/xm-mint.h
new file mode 100644
index 00000000000..fab05dc0e42
--- /dev/null
+++ b/gcc/config/m68k/xm-mint.h
@@ -0,0 +1,3 @@
+/* This is the name of the null device on MiNT.  */
+#define HOST_BIT_BUCKET "/dev/null"
+#define HOST_BIT_BUCKET2 "nul:"
diff --git a/gcc/configure b/gcc/configure
index 16965953f05..10a2bb16279 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -5529,7 +5529,7 @@ case "${target}" in
 	;;
     i[34567]86-*-cygwin* | x86_64-*-cygwin*)
 	;;
-    i[34567]86-*-mingw* | x86_64-*-mingw*)
+    i[34567]86-*-mingw* | x86_64-*-mingw* | *-*-msys*)
 	;;
     i[34567]86-*-interix[3-9]*)
 	# Interix 3.x gcc -fpic/-fPIC options generate broken code.
@@ -7310,7 +7310,7 @@ ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
 
 strict_warn=
 save_CXXFLAGS="$CXXFLAGS"
-for real_option in -Wmissing-format-attribute -Wconditionally-supported -Woverloaded-virtual; do
+for real_option in -Wmissing-format-attribute -Woverloaded-virtual -Wno-array-bounds; do
   # Do the check with the no- prefix removed since gcc silently
   # accepts any -Wno-* option on purpose
   case $real_option in
@@ -10825,7 +10825,7 @@ else
    # Systems known to be in this category are Windows (all variants),
    # VMS, and Darwin.
    case "$host_os" in
-     *vms* | cygwin* | pe | mingw* | darwin* | ultrix* | hpux10* | hpux11.00)
+     *vms* | cygwin* | pe | mingw* | msys* | darwin* | ultrix* | hpux10* | hpux11.00)
         gcc_cv_func_mmap_dev_zero=no ;;
      *)
         gcc_cv_func_mmap_dev_zero=yes;;
@@ -10882,7 +10882,7 @@ else
    # above for use of /dev/zero.
    # Systems known to be in this category are Windows, VMS, and SCO Unix.
    case "$host_os" in
-     *vms* | cygwin* | pe | mingw* | sco* | udk* )
+     *vms* | cygwin* | pe | mingw* | msys* | sco* | udk* )
         gcc_cv_func_mmap_anon=no ;;
      *)
         gcc_cv_func_mmap_anon=yes;;
@@ -11185,7 +11185,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by GCC" >&5
 $as_echo_n "checking for ld used by GCC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -15617,7 +15617,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -15982,6 +15982,10 @@ else
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
+  mint*)
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
   netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
     # This has been around since 386BSD, at least.  Likely further.
     if test -x /sbin/sysctl; then
@@ -19193,7 +19197,7 @@ _LT_EOF
       fi
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
       # as there is no search path for DLLs.
       hardcode_libdir_flag_spec='-L$libdir'
@@ -19624,7 +19628,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
       export_dynamic_flag_spec=-rdynamic
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # When not using gcc, we currently assume that we are using
       # Microsoft Visual C++.
       # hardcode_libdir_flag_spec is actually meaningless, as there is
@@ -20572,14 +20576,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -20603,7 +20607,7 @@ cygwin* | mingw* | pw32* | cegcc*)
 
       sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -21248,7 +21252,7 @@ else
     lt_cv_dlopen_self=yes
     ;;
 
-  mingw* | pw32* | cegcc*)
+  mingw* | msys* | pw32* | cegcc*)
     lt_cv_dlopen="LoadLibrary"
     lt_cv_dlopen_libs=
     ;;
@@ -22122,7 +22126,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -22475,7 +22479,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
         esac
         ;;
 
-      cygwin* | mingw* | pw32* | cegcc*)
+      cygwin* | mingw* | msys* | pw32* | cegcc*)
         # _LT_TAGVAR(hardcode_libdir_flag_spec, CXX) is actually meaningless,
         # as there is no search path for DLLs.
         hardcode_libdir_flag_spec_CXX='-L$libdir'
@@ -24300,14 +24304,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -24330,7 +24334,7 @@ cygwin* | mingw* | pw32* | cegcc*)
       soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
 
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -27156,6 +27160,38 @@ cat >>confdefs.h <<_ACEOF
 _ACEOF
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for stabs directive" >&5
+$as_echo_n "checking assembler for stabs directive... " >&6; }
+if ${gcc_cv_as_stabs_directive+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  gcc_cv_as_stabs_directive=no
+  if test x$gcc_cv_as != x; then
+    $as_echo '.stabs "gcc2_compiled.",60,0,0,0' > conftest.s
+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags  -o conftest.o conftest.s >&5'
+  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }
+    then
+	gcc_cv_as_stabs_directive=yes
+    else
+      echo "configure: failed program was" >&5
+      cat conftest.s >&5
+    fi
+    rm -f conftest.o conftest.s
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_stabs_directive" >&5
+$as_echo "$gcc_cv_as_stabs_directive" >&6; }
+if test $gcc_cv_as_stabs_directive = yes; then
+
+$as_echo "#define HAVE_AS_STABS_DIRECTIVE 1" >>confdefs.h
+
+fi
+
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for COMDAT group support (GNU as)" >&5
 $as_echo_n "checking assembler for COMDAT group support (GNU as)... " >&6; }
 if ${gcc_cv_as_comdat_group+:} false; then :
@@ -27616,6 +27652,9 @@ x:
 	addiu $4, $4, %tprel_lo(x)'
 	tls_as_opt='-32 --fatal-warnings'
 	;;
+  m68k-*-mintelf*)
+	# the assembler will support that, but we want to use emutls at runtime
+	;;
   m68k-*-*)
     conftest_s='
 	.section .tdata,"awT",@progbits
@@ -30001,6 +30040,41 @@ _ACEOF
 
     ;;
 
+  m68k-*-*)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for .gnu_attribute support" >&5
+$as_echo_n "checking assembler for .gnu_attribute support... " >&6; }
+if ${gcc_cv_as_m68k_gnu_attribute+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  gcc_cv_as_m68k_gnu_attribute=no
+  if test x$gcc_cv_as != x; then
+    $as_echo '.gnu_attribute 4,1' > conftest.s
+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags  -o conftest.o conftest.s >&5'
+  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }
+    then
+	gcc_cv_as_m68k_gnu_attribute=yes
+    else
+      echo "configure: failed program was" >&5
+      cat conftest.s >&5
+    fi
+    rm -f conftest.o conftest.s
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_m68k_gnu_attribute" >&5
+$as_echo "$gcc_cv_as_m68k_gnu_attribute" >&6; }
+if test $gcc_cv_as_m68k_gnu_attribute = yes; then
+
+$as_echo "#define HAVE_AS_GNU_ATTRIBUTE 1" >>confdefs.h
+
+fi
+
+
+    ;;
+
   ia64*-*-*)
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for ltoffx and ldxmov relocs" >&5
 $as_echo_n "checking assembler for ltoffx and ldxmov relocs... " >&6; }
@@ -32110,6 +32184,38 @@ $as_echo "#define HAVE_AS_WORKING_DWARF_N_FLAG 1" >>confdefs.h
    fi
  fi
 
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for --gstabs option" >&5
+$as_echo_n "checking assembler for --gstabs option... " >&6; }
+if ${gcc_cv_as_gstabs_flag+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  gcc_cv_as_gstabs_flag=no
+  if test x$gcc_cv_as != x; then
+    $as_echo "$insn" > conftest.s
+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags --gstabs -o conftest.o conftest.s >&5'
+  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }
+    then
+	gcc_cv_as_gstabs_flag=yes
+    else
+      echo "configure: failed program was" >&5
+      cat conftest.s >&5
+    fi
+    rm -f conftest.o conftest.s
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_gstabs_flag" >&5
+$as_echo "$gcc_cv_as_gstabs_flag" >&6; }
+if test $gcc_cv_as_gstabs_flag = yes; then
+
+$as_echo "#define HAVE_AS_GSTABS_DEBUG_FLAG 1" >>confdefs.h
+
+fi
+
+
  { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for --debug-prefix-map option" >&5
 $as_echo_n "checking assembler for --debug-prefix-map option... " >&6; }
 if ${gcc_cv_as_debug_prefix_map_flag+:} false; then :
@@ -32377,7 +32483,7 @@ if ($AR --version | sed 1q | grep "GNU ar" \
     && $CC $CFLAGS -c conftest.c \
     && $AR rcT conftest.a conftest.o \
     && $CC $CFLAGS $LDFLAGS -o conftest conftest.a) >/dev/null 2>&1; then
-  thin_archive_support=yes
+  thin_archive_support=no
 fi
 rm -f conftest.c conftest.o conftest.a conftest
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $thin_archive_support" >&5
diff --git a/gcc/configure.ac b/gcc/configure.ac
index 9f67e62950a..352084e0ae4 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -3647,6 +3647,11 @@ AC_DEFINE_UNQUOTED(HAVE_GAS_SHF_MERGE,
     || test $gcc_cv_as_shf_merge_percent = yes; then echo 1; else echo 0; fi`],
 [Define 0/1 if your assembler supports marking sections with SHF_MERGE flag.])
 
+gcc_GAS_CHECK_FEATURE([stabs directive], gcc_cv_as_stabs_directive,,
+[.stabs "gcc2_compiled.",60,0,0,0],,
+[AC_DEFINE(HAVE_AS_STABS_DIRECTIVE, 1,
+  [Define if your assembler supports .stabs.])])
+
 gcc_GAS_CHECK_FEATURE([COMDAT group support (GNU as)],
  gcc_cv_as_comdat_group,
  [--fatal-warnings],
@@ -3984,6 +3989,9 @@ x:
 	addiu $4, $4, %tprel_lo(x)'
 	tls_as_opt='-32 --fatal-warnings'
 	;;
+  m68k-*-mintelf*)
+	# the assembler will support that, but we want to use emutls at runtime
+	;;
   m68k-*-*)
     conftest_s='
 	.section .tdata,"awT",@progbits
@@ -5155,6 +5163,14 @@ gd:
       [Define 0/1 if your assembler and linker support calling ___tls_get_addr via GOT.])
     ;;
 
+   m68k-*-*)
+     gcc_GAS_CHECK_FEATURE([.gnu_attribute support],
+      gcc_cv_as_m68k_gnu_attribute,,
+      [.gnu_attribute 4,1],,
+      [AC_DEFINE(HAVE_AS_GNU_ATTRIBUTE, 1,
+	  [Define if your assembler supports .gnu_attribute.])])
+    ;;
+
   ia64*-*-*)
     gcc_GAS_CHECK_FEATURE([ltoffx and ldxmov relocs],
 	gcc_cv_as_ia64_ltoffx_ldxmov_relocs,,
@@ -5970,6 +5986,12 @@ foo:
    fi
  fi
 
+ gcc_GAS_CHECK_FEATURE([--gstabs option],
+  gcc_cv_as_gstabs_flag,
+  [--gstabs], [$insn],,
+  [AC_DEFINE(HAVE_AS_GSTABS_DEBUG_FLAG, 1,
+[Define if your assembler supports the --gstabs option.])])
+
  gcc_GAS_CHECK_FEATURE([--debug-prefix-map option],
   gcc_cv_as_debug_prefix_map_flag,
   [--debug-prefix-map /a=/b], [$insn],,
@@ -6089,7 +6111,7 @@ if ($AR --version | sed 1q | grep "GNU ar" \
     && $CC $CFLAGS -c conftest.c \
     && $AR rcT conftest.a conftest.o \
     && $CC $CFLAGS $LDFLAGS -o conftest conftest.a) >/dev/null 2>&1; then
-  thin_archive_support=yes
+  thin_archive_support=no
 fi
 rm -f conftest.c conftest.o conftest.a conftest
 AC_MSG_RESULT($thin_archive_support)
diff --git a/gcc/cp/Make-lang.in b/gcc/cp/Make-lang.in
index 25143c820b0..73ba5a03188 100644
--- a/gcc/cp/Make-lang.in
+++ b/gcc/cp/Make-lang.in
@@ -81,7 +81,7 @@ GXX_OBJS = $(GCC_OBJS) cp/g++spec.o
 xg++$(exeext): $(GXX_OBJS) $(EXTRA_GCC_OBJS) libcommon-target.a $(LIBDEPS)
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \
 	  $(GXX_OBJS) $(EXTRA_GCC_OBJS) libcommon-target.a \
-	  $(EXTRA_GCC_LIBS) $(LIBS)
+	  $(EXTRA_GCC_LIBS) $(LIBS) $(GLIBC_SO)
 
 # Create a version of the g++ driver which calls the cross-compiler.
 g++-cross$(exeext): xg++$(exeext)
@@ -144,7 +144,7 @@ cc1plus$(exeext): $(CXX_OBJS) cc1plus-checksum.o $(BACKEND) $(CODYLIB) $(LIBDEPS
 	@$(call LINK_PROGRESS,$(INDEX.c++),start)
 	+$(LLINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \
 	      $(CXX_OBJS) cc1plus-checksum.o $(BACKEND) $(CODYLIB) \
-		$(LIBS) $(BACKENDLIBS)
+		$(LIBS) $(BACKENDLIBS) $(GLIBC_SO)
 	@$(call LINK_PROGRESS,$(INDEX.c++),end)
 
 ifeq ($(ENABLE_MAINTAINER_RULES), true)
diff --git a/gcc/d/Make-lang.in b/gcc/d/Make-lang.in
index 2d444c99953..628ded3d6c5 100644
--- a/gcc/d/Make-lang.in
+++ b/gcc/d/Make-lang.in
@@ -39,7 +39,7 @@ GDC_OBJS = $(GCC_OBJS) d/d-spec.o
 gdc$(exeext): $(GDC_OBJS) $(EXTRA_GCC_OBJS) libcommon-target.a $(LIBDEPS)
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \
 	  $(GDC_OBJS) $(EXTRA_GCC_OBJS) libcommon-target.a \
-	  $(EXTRA_GCC_LIBS) $(LIBS)
+	  $(EXTRA_GCC_LIBS) $(LIBS) $(GLIBC_SO)
 
 # Create a version of the gdc driver which calls the cross-compiler.
 gdc-cross$(exeext): gdc$(exeext)
@@ -244,7 +244,7 @@ d_OBJS = $(D_ALL_OBJS) d/d-spec.o
 d21$(exeext): $(D_ALL_OBJS) attribs.o $(BACKEND) $(LIBDEPS) $(d.prev)
 	@$(call LINK_PROGRESS,$(INDEX.d),start)
 	+$(DLLINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -static-libphobos -o $@ \
-		$(D_ALL_OBJS) attribs.o $(BACKEND) $(LIBS) $(BACKENDLIBS)
+		$(D_ALL_OBJS) attribs.o $(BACKEND) $(LIBS) $(BACKENDLIBS) $(GLIBC_SO)
 	@$(call LINK_PROGRESS,$(INDEX.d),end)
 
 # Documentation.
diff --git a/gcc/d/d-compiler.cc b/gcc/d/d-compiler.cc
index e18f5d33e6a..ceebf00e39d 100644
--- a/gcc/d/d-compiler.cc
+++ b/gcc/d/d-compiler.cc
@@ -19,7 +19,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "system.h"
 #include "coretypes.h"
 
-#include "dmd/compiler.h"
+#include "dmd/dcompiler.h"
 #include "dmd/errors.h"
 #include "dmd/expression.h"
 #include "dmd/identifier.h"
diff --git a/gcc/d/dmd/compiler.h b/gcc/d/dmd/dcompiler.h
similarity index 100%
rename from gcc/d/dmd/compiler.h
rename to gcc/d/dmd/dcompiler.h
diff --git a/gcc/d/dmd/globals.h b/gcc/d/dmd/globals.h
index 62a575e322e..3bc92c740dd 100644
--- a/gcc/d/dmd/globals.h
+++ b/gcc/d/dmd/globals.h
@@ -15,7 +15,7 @@
 #include "common/outbuffer.h"
 #include "common/charactertables.h"
 #include "root/filename.h"
-#include "compiler.h"
+#include "dcompiler.h"
 
 // Can't include arraytypes.h here, need to declare these directly.
 template <typename TYPE> struct Array;
diff --git a/gcc/dbxout.cc b/gcc/dbxout.cc
new file mode 100644
index 00000000000..6900043c90a
--- /dev/null
+++ b/gcc/dbxout.cc
@@ -0,0 +1,3936 @@
+/* Output dbx-format symbol table information from GNU compiler.
+   Copyright (C) 1987-2022 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+
+/* Output dbx-format symbol table data.
+   This consists of many symbol table entries, each of them
+   a .stabs assembler pseudo-op with four operands:
+   a "name" which is really a description of one symbol and its type,
+   a "code", which is a symbol defined in stab.h whose name starts with N_,
+   an unused operand always 0,
+   and a "value" which is an address or an offset.
+   The name is enclosed in doublequote characters.
+
+   Each function, variable, typedef, and structure tag
+   has a symbol table entry to define it.
+   The beginning and end of each level of name scoping within
+   a function are also marked by special symbol table entries.
+
+   The "name" consists of the symbol name, a colon, a kind-of-symbol letter,
+   and a data type number.  The data type number may be followed by
+   "=" and a type definition; normally this will happen the first time
+   the type number is mentioned.  The type definition may refer to
+   other types by number, and those type numbers may be followed
+   by "=" and nested definitions.
+
+   This can make the "name" quite long.
+   When a name is more than 80 characters, we split the .stabs pseudo-op
+   into two .stabs pseudo-ops, both sharing the same "code" and "value".
+   The first one is marked as continued with a double-backslash at the
+   end of its "name".
+
+   The kind-of-symbol letter distinguished function names from global
+   variables from file-scope variables from parameters from auto
+   variables in memory from typedef names from register variables.
+   See `dbxout_symbol'.
+
+   The "code" is mostly redundant with the kind-of-symbol letter
+   that goes in the "name", but not entirely: for symbols located
+   in static storage, the "code" says which segment the address is in,
+   which controls how it is relocated.
+
+   The "value" for a symbol in static storage
+   is the core address of the symbol (actually, the assembler
+   label for the symbol).  For a symbol located in a stack slot
+   it is the stack offset; for one in a register, the register number.
+   For a typedef symbol, it is zero.
+
+   If DEBUG_SYMS_TEXT is defined, all debugging symbols must be
+   output while in the text section.
+
+   For more on data type definitions, see `dbxout_type'.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "target.h"
+#include "function.h"
+#include "rtl.h"
+#include "tree.h"
+#include "memmodel.h"
+#include "tm_p.h"
+#include "stringpool.h"
+#include "insn-config.h"
+#include "emit-rtl.h"
+#include "cgraph.h"
+#include "diagnostic-core.h"
+#include "fold-const.h"
+#include "varasm.h"
+#include "stor-layout.h"
+#include "reload.h"
+#include "output.h"
+#include "dbxout.h"
+#include "toplev.h"
+#include "debug.h"
+#include "common/common-target.h"
+#include "langhooks.h"
+#include "expr.h"
+#include "file-prefix-map.h" /* remap_debug_filename()  */
+#include "flags.h"
+
+#ifdef XCOFF_DEBUGGING_INFO
+#include "xcoffout.h"
+#endif
+
+#ifndef ASM_STABS_OP
+# ifdef XCOFF_DEBUGGING_INFO
+#  define ASM_STABS_OP "\t.stabx\t"
+# else
+#  define ASM_STABS_OP "\t.stabs\t"
+# endif
+#endif
+
+#ifndef ASM_STABN_OP
+#define ASM_STABN_OP "\t.stabn\t"
+#endif
+
+#ifndef ASM_STABD_OP
+#define ASM_STABD_OP "\t.stabd\t"
+#endif
+
+#ifndef DBX_TYPE_DECL_STABS_CODE
+#define DBX_TYPE_DECL_STABS_CODE N_LSYM
+#endif
+
+#ifndef DBX_STATIC_CONST_VAR_CODE
+#define DBX_STATIC_CONST_VAR_CODE N_FUN
+#endif
+
+#ifndef DBX_REGPARM_STABS_CODE
+#define DBX_REGPARM_STABS_CODE N_RSYM
+#endif
+
+#ifndef DBX_REGPARM_STABS_LETTER
+#define DBX_REGPARM_STABS_LETTER 'P'
+#endif
+
+#ifndef NO_DBX_FUNCTION_END
+#define NO_DBX_FUNCTION_END 0
+#endif
+
+#ifndef NO_DBX_BNSYM_ENSYM
+#define NO_DBX_BNSYM_ENSYM 0
+#endif
+
+#ifndef NO_DBX_MAIN_SOURCE_DIRECTORY
+#define NO_DBX_MAIN_SOURCE_DIRECTORY 0
+#endif
+
+#ifndef DBX_BLOCKS_FUNCTION_RELATIVE
+#define DBX_BLOCKS_FUNCTION_RELATIVE 0
+#endif
+
+#ifndef DBX_LINES_FUNCTION_RELATIVE
+#define DBX_LINES_FUNCTION_RELATIVE 0
+#endif
+
+#ifndef DBX_CONTIN_LENGTH
+#define DBX_CONTIN_LENGTH 80
+#endif
+
+#ifndef DBX_CONTIN_CHAR
+#define DBX_CONTIN_CHAR '\\'
+#endif
+
+enum typestatus {TYPE_UNSEEN, TYPE_XREF, TYPE_DEFINED};
+
+/* Structure recording information about a C data type.
+   The status element says whether we have yet output
+   the definition of the type.  TYPE_XREF says we have
+   output it as a cross-reference only.
+   The file_number and type_number elements are used if DBX_USE_BINCL
+   is defined.  */
+
+struct GTY(()) typeinfo {
+  enum typestatus status;
+  int file_number;
+  int type_number;
+};
+
+/* Vector recording information about C data types.
+   When we first notice a data type (a tree node),
+   we assign it a number using next_type_number.
+   That is its index in this vector.  */
+
+static GTY ((length ("typevec_len"))) struct typeinfo *typevec;
+
+/* Number of elements of space allocated in `typevec'.  */
+
+static GTY(()) int typevec_len;
+
+/* In dbx output, each type gets a unique number.
+   This is the number for the next type output.
+   The number, once assigned, is in the TYPE_SYMTAB_ADDRESS field.  */
+
+static GTY(()) int next_type_number;
+
+/* The C front end may call dbxout_symbol before dbxout_init runs.
+   We save all such decls in this list and output them when we get
+   to dbxout_init.  */
+
+static GTY(()) tree preinit_symbols;
+
+enum binclstatus {BINCL_NOT_REQUIRED, BINCL_PENDING, BINCL_PROCESSED};
+
+/* When using N_BINCL in dbx output, each type number is actually a
+   pair of the file number and the type number within the file.
+   This is a stack of input files.  */
+
+struct dbx_file
+{
+  struct dbx_file *next;
+  int file_number;
+  int next_type_number;
+  enum binclstatus bincl_status;  /* Keep track of lazy bincl.  */
+  const char *pending_bincl_name; /* Name of bincl.  */
+  struct dbx_file *prev;          /* Chain to traverse all pending bincls.  */
+};
+
+/* This is the top of the stack.
+
+   This is not saved for PCH, because restoring a PCH should not change it.
+   next_file_number does have to be saved, because the PCH may use some
+   file numbers; however, just before restoring a PCH, next_file_number
+   should always be 0 because we should not have needed any file numbers
+   yet.  */
+
+#if (defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)) \
+    && defined (DBX_USE_BINCL)
+static struct dbx_file *current_file;
+#endif
+
+/* This is the next file number to use.  */
+
+static GTY(()) int next_file_number;
+
+/* A counter for dbxout_function_end.  */
+
+static GTY(()) int scope_labelno;
+
+/* A counter for dbxout_source_line.  */
+
+static GTY(()) int dbxout_source_line_counter;
+
+/* Number for the next N_SOL filename stabs label.  The number 0 is reserved
+   for the N_SO filename stabs label.  */
+
+static GTY(()) int source_label_number = 1;
+
+/* Last source file name mentioned in a NOTE insn.  */
+
+static GTY(()) const char *lastfile;
+
+/* Last line number mentioned in a NOTE insn.  */
+
+static GTY(()) unsigned int lastlineno;
+
+/* Used by PCH machinery to detect if 'lastfile' should be reset to
+   base_input_file.  */
+static GTY(()) int lastfile_is_base;
+
+/* Typical USG systems don't have stab.h, and they also have
+   no use for DBX-format debugging info.  */
+
+#if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)
+
+#ifdef DBX_USE_BINCL
+/* If zero then there is no pending BINCL.  */
+static int pending_bincls = 0;
+#endif
+
+/* The original input file name.  */
+static const char *base_input_file;
+
+#ifdef DEBUG_SYMS_TEXT
+#define FORCE_TEXT switch_to_section (current_function_section ())
+#else
+#define FORCE_TEXT
+#endif
+
+#include "gstab.h"
+
+/* 1 if PARM is passed to this function in memory.  */
+
+#define PARM_PASSED_IN_MEMORY(PARM) \
+ (MEM_P (DECL_INCOMING_RTL (PARM)))
+
+/* A C expression for the integer offset value of an automatic variable
+   (N_LSYM) having address X (an RTX).  */
+#ifndef DEBUGGER_AUTO_OFFSET
+#define DEBUGGER_AUTO_OFFSET(X) \
+  (GET_CODE (X) == PLUS ? INTVAL (XEXP (X, 1)) : 0)
+#endif
+
+/* A C expression for the integer offset value of an argument (N_PSYM)
+   having address X (an RTX).  The nominal offset is OFFSET.
+   Note that we use OFFSET + 0 here to avoid the self-assign warning
+   when the macro is called in a context like
+   number = DEBUGGER_ARG_OFFSET(number, X)  */
+#ifndef DEBUGGER_ARG_OFFSET
+#define DEBUGGER_ARG_OFFSET(OFFSET, X) (OFFSET + 0)
+#endif
+
+/* This obstack holds the stab string currently being constructed.  We
+   build it up here, then write it out, so we can split long lines up
+   properly (see dbxout_finish_complex_stabs).  */
+static struct obstack stabstr_ob;
+static size_t stabstr_last_contin_point;
+
+#ifdef DBX_USE_BINCL
+static void emit_bincl_stab             (const char *c);
+static void emit_pending_bincls         (void);
+#endif
+static inline void emit_pending_bincls_if_required (void);
+
+static void dbxout_init (const char *);
+
+static void dbxout_finish (const char *);
+static void dbxout_start_source_file (unsigned, const char *);
+static void dbxout_end_source_file (unsigned);
+static void dbxout_typedefs (tree);
+static void dbxout_type_index (tree);
+static void dbxout_args (tree);
+static void dbxout_type_fields (tree);
+static void dbxout_type_method_1 (tree);
+static void dbxout_type_methods (tree);
+static void dbxout_range_type (tree, tree, tree);
+static void dbxout_type (tree, int);
+static bool print_int_cst_bounds_in_octal_p (tree, tree, tree);
+static bool is_fortran (void);
+static void dbxout_type_name (tree);
+static void dbxout_class_name_qualifiers (tree);
+static int dbxout_symbol_location (tree, tree, const char *, rtx);
+static void dbxout_symbol_name (tree, const char *, int);
+static void dbxout_common_name (tree, const char *, stab_code_type);
+static const char *dbxout_common_check (tree, int *);
+static void dbxout_early_global_decl (tree);
+static void dbxout_late_global_decl (tree);
+static void dbxout_type_decl (tree, int);
+static void dbxout_handle_pch (unsigned);
+static void debug_free_queue (void);
+
+/* The debug hooks structure.  */
+#if defined (DBX_DEBUGGING_INFO)
+
+static void dbxout_source_line (unsigned int, unsigned int, const char *,
+				int, bool);
+static void dbxout_switch_text_section (void);
+static void dbxout_begin_prologue (unsigned int, unsigned int, const char *);
+static void dbxout_source_file (const char *);
+static void dbxout_function_end (tree);
+static void dbxout_begin_function (tree);
+static void dbxout_begin_block (unsigned, unsigned, tree);
+static void dbxout_end_block (unsigned, unsigned);
+static void dbxout_function_decl (tree);
+
+const struct gcc_debug_hooks dbx_debug_hooks =
+{
+  dbxout_init,
+  dbxout_finish,
+  debug_nothing_charstar,
+  debug_nothing_void,
+  debug_nothing_int_charstar,
+  debug_nothing_int_charstar,
+  dbxout_start_source_file,
+  dbxout_end_source_file,
+  dbxout_begin_block,
+  dbxout_end_block,
+  debug_true_const_tree,	         /* ignore_block */
+  dbxout_source_line,		         /* source_line */
+  debug_nothing_int_int_charstar,	 /* set_ignored_loc */
+  dbxout_begin_prologue,	         /* begin_prologue */
+  debug_nothing_int_charstar,	         /* end_prologue */
+  debug_nothing_int_charstar,	         /* begin_epilogue */
+  debug_nothing_int_charstar,	         /* end_epilogue */
+#ifdef DBX_FUNCTION_FIRST
+  dbxout_begin_function,
+#else
+  debug_nothing_tree,		         /* begin_function */
+#endif
+  debug_nothing_int,		         /* end_function */
+  debug_nothing_tree,			 /* register_main_translation_unit */
+  dbxout_function_decl,
+  dbxout_early_global_decl,		 /* early_global_decl */
+  dbxout_late_global_decl,		 /* late_global_decl */
+  dbxout_type_decl,			 /* type_decl */
+  debug_nothing_tree_tree_tree_bool_bool,/* imported_module_or_decl */
+  debug_false_tree_charstarstar_uhwistar,/* die_ref_for_decl */
+  debug_nothing_tree_charstar_uhwi,      /* register_external_die */
+  debug_nothing_tree,		         /* deferred_inline_function */
+  debug_nothing_tree,		         /* outlining_inline_function */
+  debug_nothing_rtx_code_label,	         /* label */
+  dbxout_handle_pch,		         /* handle_pch */
+  debug_nothing_rtx_insn,	         /* var_location */
+  debug_nothing_tree,	         	 /* inline_entry */
+  debug_nothing_tree,			 /* size_function */
+  dbxout_switch_text_section,            /* switch_text_section */
+  debug_nothing_tree_tree,		 /* set_name */
+  0,                                     /* start_end_main_source_file */
+  TYPE_SYMTAB_IS_ADDRESS                 /* tree_type_symtab_field */
+};
+#endif /* DBX_DEBUGGING_INFO  */
+
+#if defined (XCOFF_DEBUGGING_INFO)
+const struct gcc_debug_hooks xcoff_debug_hooks =
+{
+  dbxout_init,
+  dbxout_finish,
+  debug_nothing_charstar,
+  debug_nothing_void,
+  debug_nothing_int_charstar,
+  debug_nothing_int_charstar,
+  dbxout_start_source_file,
+  dbxout_end_source_file,
+  xcoffout_begin_block,
+  xcoffout_end_block,
+  debug_true_const_tree,	         /* ignore_block */
+  xcoffout_source_line,
+  debug_nothing_int_int_charstar,	 /* set_ignored_loc */
+  xcoffout_begin_prologue,	         /* begin_prologue */
+  debug_nothing_int_charstar,	         /* end_prologue */
+  debug_nothing_int_charstar,	         /* begin_epilogue */
+  xcoffout_end_epilogue,
+  debug_nothing_tree,		         /* begin_function */
+  xcoffout_end_function,
+  debug_nothing_tree,			 /* register_main_translation_unit */
+  debug_nothing_tree,		         /* function_decl */
+  dbxout_early_global_decl,		 /* early_global_decl */
+  dbxout_late_global_decl,		 /* late_global_decl */
+  dbxout_type_decl,			 /* type_decl */
+  debug_nothing_tree_tree_tree_bool_bool,/* imported_module_or_decl */
+  debug_false_tree_charstarstar_uhwistar,/* die_ref_for_decl */
+  debug_nothing_tree_charstar_uhwi,      /* register_external_die */
+  debug_nothing_tree,		         /* deferred_inline_function */
+  debug_nothing_tree,		         /* outlining_inline_function */
+  debug_nothing_rtx_code_label,	         /* label */
+  dbxout_handle_pch,		         /* handle_pch */
+  debug_nothing_rtx_insn,	         /* var_location */
+  debug_nothing_tree,	         	 /* inline_entry */
+  debug_nothing_tree,			 /* size_function */
+  debug_nothing_void,                    /* switch_text_section */
+  debug_nothing_tree_tree,	         /* set_name */
+  0,                                     /* start_end_main_source_file */
+  TYPE_SYMTAB_IS_ADDRESS                 /* tree_type_symtab_field */
+};
+#endif /* XCOFF_DEBUGGING_INFO  */
+
+/* Numeric formatting helper macro.  Note that this does not handle
+   hexadecimal.  */
+#define NUMBER_FMT_LOOP(P, NUM, BASE)		\
+  do						\
+    {						\
+      int digit = NUM % BASE;			\
+      NUM /= BASE;				\
+      *--P = digit + '0';			\
+    }						\
+  while (NUM > 0)
+
+/* Utility: write a decimal integer NUM to asm_out_file.  */
+void
+dbxout_int (int num)
+{
+  char buf[64];
+  char *p = buf + sizeof buf;
+  unsigned int unum;
+
+  if (num == 0)
+    {
+      putc ('0', asm_out_file);
+      return;
+    }
+  if (num < 0)
+    {
+      putc ('-', asm_out_file);
+      unum = -(unsigned int) num;
+    }
+  else
+    unum = num;
+
+  NUMBER_FMT_LOOP (p, unum, 10);
+
+  while (p < buf + sizeof buf)
+    {
+      putc (*p, asm_out_file);
+      p++;
+    }
+}
+
+
+/* Primitives for emitting simple stabs directives.  All other stabs
+   routines should use these functions instead of directly emitting
+   stabs.  They are exported because machine-dependent code may need
+   to invoke them, e.g. in a DBX_OUTPUT_* macro whose definition
+   forwards to code in CPU.c.  */
+
+/* The following functions should all be called immediately after one
+   of the dbxout_begin_stab* functions (below).  They write out
+   various things as the value of a stab.  */
+
+/* Write out a literal zero as the value of a stab.  */
+void
+dbxout_stab_value_zero (void)
+{
+  fputs ("0\n", asm_out_file);
+}
+
+/* Write out the label LABEL as the value of a stab.  */
+void
+dbxout_stab_value_label (const char *label)
+{
+  assemble_name (asm_out_file, label);
+  putc ('\n', asm_out_file);
+}
+
+/* Write out the difference of two labels, LABEL - BASE, as the value
+   of a stab.  */
+void
+dbxout_stab_value_label_diff (const char *label, const char *base)
+{
+  assemble_name (asm_out_file, label);
+  putc ('-', asm_out_file);
+  assemble_name (asm_out_file, base);
+  putc ('\n', asm_out_file);
+}
+
+/* Write out an internal label as the value of a stab, and immediately
+   emit that internal label.  This should be used only when
+   dbxout_stabd will not work.  STEM is the name stem of the label,
+   COUNTERP is a pointer to a counter variable which will be used to
+   guarantee label uniqueness.  */
+void
+dbxout_stab_value_internal_label (const char *stem, int *counterp)
+{
+  char label[100];
+  int counter = counterp ? (*counterp)++ : 0;
+
+  ASM_GENERATE_INTERNAL_LABEL (label, stem, counter);
+  dbxout_stab_value_label (label);
+  targetm.asm_out.internal_label (asm_out_file, stem, counter);
+}
+
+/* Write out the difference between BASE and an internal label as the
+   value of a stab, and immediately emit that internal label.  STEM and
+   COUNTERP are as for dbxout_stab_value_internal_label.  */
+void
+dbxout_stab_value_internal_label_diff (const char *stem, int *counterp,
+				       const char *base)
+{
+  char label[100];
+  int counter = counterp ? (*counterp)++ : 0;
+
+  ASM_GENERATE_INTERNAL_LABEL (label, stem, counter);
+  dbxout_stab_value_label_diff (label, base);
+  targetm.asm_out.internal_label (asm_out_file, stem, counter);
+}
+
+/* The following functions produce specific kinds of stab directives.  */
+
+/* Write a .stabd directive with type STYPE and desc SDESC to asm_out_file.  */
+void
+dbxout_stabd (int stype, int sdesc)
+{
+  fputs (ASM_STABD_OP, asm_out_file);
+  dbxout_int (stype);
+  fputs (",0,", asm_out_file);
+  dbxout_int (sdesc);
+  putc ('\n', asm_out_file);
+}
+
+/* Write a .stabn directive with type STYPE.  This function stops
+   short of emitting the value field, which is the responsibility of
+   the caller (normally it will be either a symbol or the difference
+   of two symbols).  */
+
+void
+dbxout_begin_stabn (int stype)
+{
+  fputs (ASM_STABN_OP, asm_out_file);
+  dbxout_int (stype);
+  fputs (",0,0,", asm_out_file);
+}
+
+/* Write a .stabn directive with type N_SLINE and desc LINE.  As above,
+   the value field is the responsibility of the caller.  */
+void
+dbxout_begin_stabn_sline (int lineno)
+{
+  fputs (ASM_STABN_OP, asm_out_file);
+  dbxout_int (N_SLINE);
+  fputs (",0,", asm_out_file);
+  dbxout_int (lineno);
+  putc (',', asm_out_file);
+}
+
+/* Begin a .stabs directive with string "", type STYPE, and desc and
+   other fields 0.  The value field is the responsibility of the
+   caller.  This function cannot be used for .stabx directives.  */
+void
+dbxout_begin_empty_stabs (int stype)
+{
+  fputs (ASM_STABS_OP, asm_out_file);
+  fputs ("\"\",", asm_out_file);
+  dbxout_int (stype);
+  fputs (",0,0,", asm_out_file);
+}
+
+/* Begin a .stabs directive with string STR, type STYPE, and desc 0.
+   The value field is the responsibility of the caller.  */
+void
+dbxout_begin_simple_stabs (const char *str, int stype)
+{
+  fputs (ASM_STABS_OP, asm_out_file);
+  output_quoted_string (asm_out_file, str);
+  putc (',', asm_out_file);
+  dbxout_int (stype);
+  fputs (",0,0,", asm_out_file);
+}
+
+/* As above but use SDESC for the desc field.  */
+void
+dbxout_begin_simple_stabs_desc (const char *str, int stype, int sdesc)
+{
+  fputs (ASM_STABS_OP, asm_out_file);
+  output_quoted_string (asm_out_file, str);
+  putc (',', asm_out_file);
+  dbxout_int (stype);
+  fputs (",0,", asm_out_file);
+  dbxout_int (sdesc);
+  putc (',', asm_out_file);
+}
+
+/* The next set of functions are entirely concerned with production of
+   "complex" .stabs directives: that is, .stabs directives whose
+   strings have to be constructed piecemeal.  dbxout_type,
+   dbxout_symbol, etc. use these routines heavily.  The string is queued
+   up in an obstack, then written out by dbxout_finish_complex_stabs, which
+   is also responsible for splitting it up if it exceeds DBX_CONTIN_LENGTH.
+   (You might think it would be more efficient to go straight to stdio
+   when DBX_CONTIN_LENGTH is 0 (i.e. no length limit) but that turns
+   out not to be the case, and anyway this needs fewer #ifdefs.)  */
+
+/* Begin a complex .stabs directive.  If we can, write the initial
+   ASM_STABS_OP to the asm_out_file.  */
+
+static void
+dbxout_begin_complex_stabs (void)
+{
+  emit_pending_bincls_if_required ();
+  FORCE_TEXT;
+  fputs (ASM_STABS_OP, asm_out_file);
+  putc ('"', asm_out_file);
+  gcc_assert (stabstr_last_contin_point == 0);
+}
+
+/* As above, but do not force text or emit pending bincls.  This is
+   used by dbxout_symbol_location, which needs to do something else.  */
+static void
+dbxout_begin_complex_stabs_noforcetext (void)
+{
+  fputs (ASM_STABS_OP, asm_out_file);
+  putc ('"', asm_out_file);
+  gcc_assert (stabstr_last_contin_point == 0);
+}
+
+/* Add CHR, a single character, to the string being built.  */
+#define stabstr_C(chr) obstack_1grow (&stabstr_ob, chr)
+
+/* Add STR, a normal C string, to the string being built.  */
+#define stabstr_S(str) obstack_grow (&stabstr_ob, str, strlen (str))
+
+/* Add the text of ID, an IDENTIFIER_NODE, to the string being built.  */
+#define stabstr_I(id) obstack_grow (&stabstr_ob, \
+                                    IDENTIFIER_POINTER (id), \
+                                    IDENTIFIER_LENGTH (id))
+
+/* Add NUM, a signed decimal number, to the string being built.  */
+static void
+stabstr_D (HOST_WIDE_INT num)
+{
+  char buf[64];
+  char *p = buf + sizeof buf;
+  unsigned HOST_WIDE_INT unum;
+
+  if (num == 0)
+    {
+      stabstr_C ('0');
+      return;
+    }
+  if (num < 0)
+    {
+      stabstr_C ('-');
+      unum = -(unsigned HOST_WIDE_INT) num;
+    }
+  else
+    unum = num;
+
+  NUMBER_FMT_LOOP (p, unum, 10);
+
+  obstack_grow (&stabstr_ob, p, (buf + sizeof buf) - p);
+}
+
+/* Add NUM, an unsigned decimal number, to the string being built.  */
+static void
+stabstr_U (unsigned HOST_WIDE_INT num)
+{
+  char buf[64];
+  char *p = buf + sizeof buf;
+  if (num == 0)
+    {
+      stabstr_C ('0');
+      return;
+    }
+  NUMBER_FMT_LOOP (p, num, 10);
+  obstack_grow (&stabstr_ob, p, (buf + sizeof buf) - p);
+}
+
+/* Add CST, an INTEGER_CST tree, to the string being built as an
+   unsigned octal number.  This routine handles values which are
+   larger than a single HOST_WIDE_INT.  */
+static void
+stabstr_O (tree cst)
+{
+  int prec = TYPE_PRECISION (TREE_TYPE (cst));
+  int res_pres = prec % 3;
+  int i;
+  unsigned int digit;
+
+  /* Leading zero for base indicator.  */
+  stabstr_C ('0');
+
+  /* If the value is zero, the base indicator will serve as the value
+     all by itself.  */
+  if (wi::to_wide (cst) == 0)
+    return;
+
+  /* GDB wants constants with no extra leading "1" bits, so
+     we need to remove any sign-extension that might be
+     present.  */
+  if (res_pres == 1)
+    {
+      digit = wi::extract_uhwi (wi::to_wide (cst), prec - 1, 1);
+      stabstr_C ('0' + digit);
+    }
+  else if (res_pres == 2)
+    {
+      digit = wi::extract_uhwi (wi::to_wide (cst), prec - 2, 2);
+      stabstr_C ('0' + digit);
+    }
+
+  prec -= res_pres;
+  for (i = prec - 3; i >= 0; i = i - 3)
+    {
+      digit = wi::extract_uhwi (wi::to_wide (cst), i, 3);
+      stabstr_C ('0' + digit);
+    }
+}
+
+/* Called whenever it is safe to break a stabs string into multiple
+   .stabs directives.  If the current string has exceeded the limit
+   set by DBX_CONTIN_LENGTH, mark the current position in the buffer
+   as a continuation point by inserting DBX_CONTIN_CHAR (doubled if
+   it is a backslash) and a null character.  */
+static inline void
+stabstr_continue (void)
+{
+  if (DBX_CONTIN_LENGTH > 0
+      && obstack_object_size (&stabstr_ob) - stabstr_last_contin_point
+	 > DBX_CONTIN_LENGTH)
+    {
+      if (DBX_CONTIN_CHAR == '\\')
+	obstack_1grow (&stabstr_ob, '\\');
+      obstack_1grow (&stabstr_ob, DBX_CONTIN_CHAR);
+      obstack_1grow (&stabstr_ob, '\0');
+      stabstr_last_contin_point = obstack_object_size (&stabstr_ob);
+    }
+}
+#define CONTIN stabstr_continue ()
+
+/* Macro subroutine of dbxout_finish_complex_stabs, which emits
+   all of the arguments to the .stabs directive after the string.
+   Overridden by xcoffout.h.  CODE is the stabs code for this symbol;
+   LINE is the source line to write into the desc field (in extended
+   mode); SYM is the symbol itself.
+
+   ADDR, LABEL, and NUMBER are three different ways to represent the
+   stabs value field.  At most one of these should be nonzero.
+
+     ADDR is used most of the time; it represents the value as an
+     RTL address constant.
+
+     LABEL is used (currently) only for N_CATCH stabs; it represents
+     the value as a string suitable for assemble_name.
+
+     NUMBER is used when the value is an offset from an implicit base
+     pointer (e.g. for a stack variable), or an index (e.g. for a
+     register variable).  It represents the value as a decimal integer.  */
+
+#ifndef DBX_FINISH_STABS
+#define DBX_FINISH_STABS(SYM, CODE, LINE, ADDR, LABEL, NUMBER)	\
+do {								\
+  int line_ = use_gnu_debug_info_extensions ? LINE : 0;		\
+								\
+  dbxout_int (CODE);						\
+  fputs (",0,", asm_out_file);					\
+  dbxout_int (line_);						\
+  putc (',', asm_out_file);					\
+  if (ADDR)							\
+    output_addr_const (asm_out_file, ADDR);			\
+  else if (LABEL)						\
+    assemble_name (asm_out_file, LABEL);			\
+  else								\
+    dbxout_int (NUMBER);					\
+  putc ('\n', asm_out_file);					\
+} while (0)
+#endif
+
+/* Finish the emission of a complex .stabs directive.  When DBX_CONTIN_LENGTH
+   is zero, this has only to emit the close quote and the remainder of
+   the arguments.  When it is nonzero, the string has been marshalled in
+   stabstr_ob, and this routine is responsible for breaking it up into
+   DBX_CONTIN_LENGTH-sized chunks.
+
+   SYM is the DECL of the symbol under consideration; it is used only
+   for its DECL_SOURCE_LINE.  The other arguments are all passed directly
+   to DBX_FINISH_STABS; see above for details.  */
+
+static void
+dbxout_finish_complex_stabs (tree sym, stab_code_type code,
+			     rtx addr, const char *label, int number)
+{
+  int line ATTRIBUTE_UNUSED;
+  char *str;
+  size_t len;
+
+  line = sym ? DECL_SOURCE_LINE (sym) : 0;
+  if (DBX_CONTIN_LENGTH > 0)
+    {
+      char *chunk;
+      size_t chunklen;
+
+      /* Nul-terminate the growing string, then get its size and
+	 address.  */
+      obstack_1grow (&stabstr_ob, '\0');
+
+      len = obstack_object_size (&stabstr_ob);
+      chunk = str = XOBFINISH (&stabstr_ob, char *);
+
+      /* Within the buffer are a sequence of NUL-separated strings,
+	 each of which is to be written out as a separate stab
+	 directive.  */
+      for (;;)
+	{
+	  chunklen = strlen (chunk);
+	  fwrite (chunk, 1, chunklen, asm_out_file);
+	  fputs ("\",", asm_out_file);
+
+	  /* Must add an extra byte to account for the NUL separator.  */
+	  chunk += chunklen + 1;
+	  len   -= chunklen + 1;
+
+	  /* Only put a line number on the last stab in the sequence.  */
+	  DBX_FINISH_STABS (sym, code, len == 0 ? line : 0,
+			    addr, label, number);
+	  if (len == 0)
+	    break;
+
+	  fputs (ASM_STABS_OP, asm_out_file);
+	  putc ('"', asm_out_file);
+	}
+      stabstr_last_contin_point = 0;
+    }
+  else
+    {
+      /* No continuations - we can put the whole string out at once.
+	 It is faster to augment the string with the close quote and
+	 comma than to do a two-character fputs.  */
+      obstack_grow (&stabstr_ob, "\",", 2);
+      len = obstack_object_size (&stabstr_ob);
+      str = XOBFINISH (&stabstr_ob, char *);
+
+      fwrite (str, 1, len, asm_out_file);
+      DBX_FINISH_STABS (sym, code, line, addr, label, number);
+    }
+  obstack_free (&stabstr_ob, str);
+}
+
+#if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)
+
+/* When -gused is used, emit debug info for only used symbols. But in
+   addition to the standard intercepted debug_hooks there are some
+   direct calls into this file, i.e., dbxout_symbol, dbxout_parms, and
+   dbxout_reg_params.  Those routines may also be called from a higher
+   level intercepted routine. So to prevent recording data for an inner
+   call to one of these for an intercept, we maintain an intercept
+   nesting counter (debug_nesting). We only save the intercepted
+   arguments if the nesting is 1.  */
+static int debug_nesting = 0;
+
+static tree *symbol_queue;
+static int symbol_queue_index = 0;
+static int symbol_queue_size = 0;
+
+#define DBXOUT_DECR_NESTING \
+  if (--debug_nesting == 0 && symbol_queue_index > 0) \
+    { emit_pending_bincls_if_required (); debug_flush_symbol_queue (); }
+
+#define DBXOUT_DECR_NESTING_AND_RETURN(x) \
+  do {--debug_nesting; return (x);} while (0)
+
+#endif /* DBX_DEBUGGING_INFO || XCOFF_DEBUGGING_INFO */
+
+#if defined (DBX_DEBUGGING_INFO)
+
+static void
+dbxout_function_end (tree decl ATTRIBUTE_UNUSED)
+{
+  char lscope_label_name[100];
+
+  /* The Lscope label must be emitted even if we aren't doing anything
+     else; dbxout_block needs it.  */
+  switch_to_section (current_function_section ());
+
+  /* Convert Lscope into the appropriate format for local labels in case
+     the system doesn't insert underscores in front of user generated
+     labels.  */
+  ASM_GENERATE_INTERNAL_LABEL (lscope_label_name, "Lscope", scope_labelno);
+  targetm.asm_out.internal_label (asm_out_file, "Lscope", scope_labelno);
+
+  /* The N_FUN tag at the end of the function is a GNU extension,
+     which may be undesirable, and is unnecessary if we do not have
+     named sections.  */
+  if (!use_gnu_debug_info_extensions
+      || NO_DBX_FUNCTION_END
+      || !targetm_common.have_named_sections)
+    return;
+
+  /* By convention, GCC will mark the end of a function with an N_FUN
+     symbol and an empty string.  */
+  if (crtl->has_bb_partition)
+    {
+      dbxout_begin_empty_stabs (N_FUN);
+      if (in_cold_section_p)
+	dbxout_stab_value_label_diff (crtl->subsections.cold_section_end_label,
+				      crtl->subsections.cold_section_label);
+      else
+	dbxout_stab_value_label_diff (crtl->subsections.hot_section_end_label,
+				      crtl->subsections.hot_section_label);
+    }
+  else
+    {
+      char begin_label[20];
+      /* Reference current function start using LFBB.  */
+      ASM_GENERATE_INTERNAL_LABEL (begin_label, "LFBB", scope_labelno);
+      dbxout_begin_empty_stabs (N_FUN);
+      dbxout_stab_value_label_diff (lscope_label_name, begin_label);
+    }
+
+  if (!NO_DBX_BNSYM_ENSYM && !flag_debug_only_used_symbols)
+    dbxout_stabd (N_ENSYM, 0);
+}
+#endif /* DBX_DEBUGGING_INFO */
+
+/* Get lang description for N_SO stab.  */
+static unsigned int ATTRIBUTE_UNUSED
+get_lang_number (void)
+{
+  const char *language_string = lang_hooks.name;
+  if (lang_GNU_C ())
+    return N_SO_C;
+  else if (lang_GNU_CXX ())
+    return N_SO_CC;
+  else if (strcmp (language_string, "GNU F77") == 0)
+    return N_SO_FORTRAN;
+  else if (lang_GNU_Fortran ())
+    return N_SO_FORTRAN90; /* CHECKME */
+  else if (strcmp (language_string, "GNU Objective-C") == 0)
+    return N_SO_OBJC;
+  else if (strcmp (language_string, "GNU Objective-C++") == 0)
+    return N_SO_OBJCPLUS;
+  else
+    return 0;
+
+}
+
+static bool
+is_fortran (void)
+{
+   unsigned int lang = get_lang_number ();
+
+   return (lang == N_SO_FORTRAN) || (lang == N_SO_FORTRAN90);
+}
+
+/* At the beginning of compilation, start writing the symbol table.
+   Initialize `typevec' and output the standard data types of C.  */
+
+static void
+dbxout_init (const char *input_file_name)
+{
+  char ltext_label_name[100];
+  bool used_ltext_label_name = false;
+  tree syms = lang_hooks.decls.getdecls ();
+  const char *mapped_name;
+
+  typevec_len = 100;
+  typevec = ggc_cleared_vec_alloc<typeinfo> (typevec_len);
+
+  /* stabstr_ob contains one string, which will be just fine with
+     1-byte alignment.  */
+  obstack_specify_allocation (&stabstr_ob, 0, 1, xmalloc, free);
+
+  /* Convert Ltext into the appropriate format for local labels in case
+     the system doesn't insert underscores in front of user generated
+     labels.  */
+  ASM_GENERATE_INTERNAL_LABEL (ltext_label_name, "Ltext", 0);
+
+  /* Put the current working directory in an N_SO symbol.  */
+  if (use_gnu_debug_info_extensions && !NO_DBX_MAIN_SOURCE_DIRECTORY)
+    {
+      static const char *cwd;
+
+      if (!cwd)
+	{
+	  cwd = get_src_pwd ();
+	  if (cwd[0] == '\0')
+	    cwd = "/";
+	  else if (!IS_DIR_SEPARATOR (cwd[strlen (cwd) - 1]))
+	    cwd = concat (cwd, "/", NULL);
+	  cwd = remap_debug_filename (cwd);
+	}
+#ifdef DBX_OUTPUT_MAIN_SOURCE_DIRECTORY
+      DBX_OUTPUT_MAIN_SOURCE_DIRECTORY (asm_out_file, cwd);
+#else /* no DBX_OUTPUT_MAIN_SOURCE_DIRECTORY */
+      dbxout_begin_simple_stabs_desc (cwd, N_SO, get_lang_number ());
+      dbxout_stab_value_label (ltext_label_name);
+      used_ltext_label_name = true;
+#endif /* no DBX_OUTPUT_MAIN_SOURCE_DIRECTORY */
+    }
+
+  mapped_name = remap_debug_filename (input_file_name);
+#ifdef DBX_OUTPUT_MAIN_SOURCE_FILENAME
+  DBX_OUTPUT_MAIN_SOURCE_FILENAME (asm_out_file, mapped_name);
+#else
+  dbxout_begin_simple_stabs_desc (mapped_name, N_SO, get_lang_number ());
+  dbxout_stab_value_label (ltext_label_name);
+  used_ltext_label_name = true;
+#endif
+
+  if (used_ltext_label_name)
+    {
+      switch_to_section (text_section);
+      targetm.asm_out.internal_label (asm_out_file, "Ltext", 0);
+    }
+
+  /* Emit an N_OPT stab to indicate that this file was compiled by GCC.
+     The string used is historical.  */
+#ifndef NO_DBX_GCC_MARKER
+  dbxout_begin_simple_stabs ("gcc2_compiled.", N_OPT);
+  dbxout_stab_value_zero ();
+#endif
+
+  base_input_file = lastfile = input_file_name;
+
+  next_type_number = 1;
+
+#ifdef DBX_USE_BINCL
+  current_file = XNEW (struct dbx_file);
+  current_file->next = NULL;
+  current_file->file_number = 0;
+  current_file->next_type_number = 1;
+  next_file_number = 1;
+  current_file->prev = NULL;
+  current_file->bincl_status = BINCL_NOT_REQUIRED;
+  current_file->pending_bincl_name = NULL;
+#endif
+
+  /* Get all permanent types that have typedef names, and output them
+     all, except for those already output.  Some language front ends
+     put these declarations in the top-level scope; some do not;
+     the latter are responsible for calling debug_hooks->type_decl from
+     their record_builtin_type function.  */
+  dbxout_typedefs (syms);
+
+  if (preinit_symbols)
+    {
+      tree t;
+      for (t = nreverse (preinit_symbols); t; t = TREE_CHAIN (t))
+	dbxout_symbol (TREE_VALUE (t), 0);
+      preinit_symbols = 0;
+    }
+}
+
+/* Output any typedef names for types described by TYPE_DECLs in SYMS.  */
+
+static void
+dbxout_typedefs (tree syms)
+{
+  for (; syms != NULL_TREE; syms = DECL_CHAIN (syms))
+    {
+      if (TREE_CODE (syms) == TYPE_DECL)
+	{
+	  tree type = TREE_TYPE (syms);
+	  if (TYPE_NAME (type)
+	      && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL
+	      && COMPLETE_OR_VOID_TYPE_P (type)
+	      && ! TREE_ASM_WRITTEN (TYPE_NAME (type)))
+	    dbxout_symbol (TYPE_NAME (type), 0);
+	}
+    }
+}
+
+#ifdef DBX_USE_BINCL
+/* Emit BINCL stab using given name.  */
+static void
+emit_bincl_stab (const char *name)
+{
+  dbxout_begin_simple_stabs (name, N_BINCL);
+  dbxout_stab_value_zero ();
+}
+
+/* If there are pending bincls then it is time to emit all of them.  */
+
+static inline void
+emit_pending_bincls_if_required (void)
+{
+  if (pending_bincls)
+    emit_pending_bincls ();
+}
+
+/* Emit all pending bincls.  */
+
+static void
+emit_pending_bincls (void)
+{
+  struct dbx_file *f = current_file;
+
+  /* Find first pending bincl.  */
+  while (f->bincl_status == BINCL_PENDING)
+    f = f->next;
+
+  /* Now emit all bincls.  */
+  f = f->prev;
+
+  while (f)
+    {
+      if (f->bincl_status == BINCL_PENDING)
+        {
+          emit_bincl_stab (f->pending_bincl_name);
+
+	  /* Update file number and status.  */
+          f->file_number = next_file_number++;
+          f->bincl_status = BINCL_PROCESSED;
+        }
+      if (f == current_file)
+        break;
+      f = f->prev;
+    }
+
+  /* All pending bincls have been emitted.  */
+  pending_bincls = 0;
+}
+
+#else
+
+static inline void
+emit_pending_bincls_if_required (void) {}
+#endif
+
+/* Change to reading from a new source file.  Generate a N_BINCL stab.  */
+
+static void
+dbxout_start_source_file (unsigned int line ATTRIBUTE_UNUSED,
+			  const char *filename ATTRIBUTE_UNUSED)
+{
+#ifdef DBX_USE_BINCL
+  struct dbx_file *n = XNEW (struct dbx_file);
+
+  n->next = current_file;
+  n->next_type_number = 1;
+  /* Do not assign file number now.
+     Delay it until we actually emit BINCL.  */
+  n->file_number = 0;
+  n->prev = NULL;
+  current_file->prev = n;
+  n->bincl_status = BINCL_PENDING;
+  n->pending_bincl_name = remap_debug_filename (filename);
+  pending_bincls = 1;
+  current_file = n;
+#endif
+}
+
+/* Revert to reading a previous source file.  Generate a N_EINCL stab.  */
+
+static void
+dbxout_end_source_file (unsigned int line ATTRIBUTE_UNUSED)
+{
+#ifdef DBX_USE_BINCL
+  /* Emit EINCL stab only if BINCL is not pending.  */
+  if (current_file->bincl_status == BINCL_PROCESSED)
+    {
+      dbxout_begin_stabn (N_EINCL);
+      dbxout_stab_value_zero ();
+    }
+  current_file->bincl_status = BINCL_NOT_REQUIRED;
+  current_file = current_file->next;
+#endif
+}
+
+/* Handle a few odd cases that occur when trying to make PCH files work.  */
+
+static void
+dbxout_handle_pch (unsigned at_end)
+{
+  if (! at_end)
+    {
+      /* When using the PCH, this file will be included, so we need to output
+	 a BINCL.  */
+      dbxout_start_source_file (0, lastfile);
+
+      /* The base file when using the PCH won't be the same as
+	 the base file when it's being generated.  */
+      lastfile = NULL;
+    }
+  else
+    {
+      /* ... and an EINCL.  */
+      dbxout_end_source_file (0);
+
+      /* Deal with cases where 'lastfile' was never actually changed.  */
+      lastfile_is_base = lastfile == NULL;
+    }
+}
+
+#if defined (DBX_DEBUGGING_INFO)
+
+static bool dbxout_block (tree, int, tree, int);
+
+/* Output debugging info to FILE to switch to sourcefile FILENAME.  */
+
+static void
+dbxout_source_file (const char *filename)
+{
+  if (lastfile == 0 && lastfile_is_base)
+    {
+      lastfile = base_input_file;
+      lastfile_is_base = 0;
+    }
+
+  if (filename && (lastfile == 0 || strcmp (filename, lastfile)))
+    {
+      /* Don't change section amid function.  */
+      if (current_function_decl == NULL_TREE)
+	switch_to_section (text_section);
+
+      dbxout_begin_simple_stabs (remap_debug_filename (filename), N_SOL);
+      dbxout_stab_value_internal_label ("Ltext", &source_label_number);
+      lastfile = filename;
+    }
+}
+
+/* Output N_BNSYM, line number symbol entry, and local symbol at
+   function scope  */
+
+static void
+dbxout_begin_prologue (unsigned int lineno,
+		       unsigned int column ATTRIBUTE_UNUSED,
+		       const char *filename)
+{
+  if (use_gnu_debug_info_extensions
+      && !NO_DBX_FUNCTION_END
+      && !NO_DBX_BNSYM_ENSYM
+      && !flag_debug_only_used_symbols)
+    dbxout_stabd (N_BNSYM, 0);
+
+  /* pre-increment the scope counter */
+  scope_labelno++;
+
+  dbxout_source_line (lineno, 0, filename, 0, true);
+  /* Output function begin block at function scope, referenced
+     by dbxout_block, dbxout_source_line and dbxout_function_end.  */
+  emit_pending_bincls_if_required ();
+  targetm.asm_out.internal_label (asm_out_file, "LFBB", scope_labelno);
+}
+
+/* Output a line number symbol entry for source file FILENAME and line
+   number LINENO.  */
+
+static void
+dbxout_source_line (unsigned int lineno, unsigned int column ATTRIBUTE_UNUSED,
+		    const char *filename, int discriminator ATTRIBUTE_UNUSED,
+                    bool is_stmt ATTRIBUTE_UNUSED)
+{
+  dbxout_source_file (filename);
+
+#ifdef DBX_OUTPUT_SOURCE_LINE
+  DBX_OUTPUT_SOURCE_LINE (asm_out_file, lineno, dbxout_source_line_counter);
+#else
+  if (DBX_LINES_FUNCTION_RELATIVE)
+    {
+      char begin_label[20];
+      dbxout_begin_stabn_sline (lineno);
+      /* Reference current function start using LFBB.  */
+      ASM_GENERATE_INTERNAL_LABEL (begin_label, "LFBB", scope_labelno);
+      dbxout_stab_value_internal_label_diff ("LM", &dbxout_source_line_counter,
+					     begin_label);
+    }
+  else
+    dbxout_stabd (N_SLINE, lineno);
+#endif
+  lastlineno = lineno;
+}
+
+/* Unfortunately, at least when emitting relative addresses, STABS
+   has no way to express multiple partitions.  Represent a function
+   as two functions in this case.  */
+
+static void
+dbxout_switch_text_section (void)
+{
+  /* The N_FUN tag at the end of the function is a GNU extension,
+     which may be undesirable, and is unnecessary if we do not have
+     named sections.  */
+  in_cold_section_p = !in_cold_section_p;
+  switch_to_section (current_function_section ());
+  dbxout_block (DECL_INITIAL (current_function_decl), 0,
+		DECL_ARGUMENTS (current_function_decl), -1);
+  dbxout_function_end (current_function_decl);
+  in_cold_section_p = !in_cold_section_p;
+
+  switch_to_section (current_function_section ());
+
+  tree context = decl_function_context (current_function_decl);
+  extern tree cold_function_name;
+
+  dbxout_begin_complex_stabs ();
+  stabstr_I (cold_function_name);
+  stabstr_S (":f");
+
+  tree type = TREE_TYPE (current_function_decl);
+  if (TREE_TYPE (type))
+    dbxout_type (TREE_TYPE (type), 0);
+  else
+    dbxout_type (void_type_node, 0);
+
+  if (context != 0)
+    {
+      stabstr_C (',');
+      stabstr_I (cold_function_name);
+      stabstr_C (',');
+      stabstr_I (DECL_NAME (context));
+    }
+
+  dbxout_finish_complex_stabs (current_function_decl, N_FUN, 0,
+			       crtl->subsections.cold_section_label, 0);
+
+  /* pre-increment the scope counter */
+  scope_labelno++;
+
+  dbxout_source_line (lastlineno, 0, lastfile, 0, true);
+  /* Output function begin block at function scope, referenced
+     by dbxout_block, dbxout_source_line and dbxout_function_end.  */
+  emit_pending_bincls_if_required ();
+  targetm.asm_out.internal_label (asm_out_file, "LFBB", scope_labelno);
+}
+
+/* Describe the beginning of an internal block within a function.  */
+
+static void
+dbxout_begin_block (unsigned int line ATTRIBUTE_UNUSED, unsigned int n, tree block ATTRIBUTE_UNUSED)
+{
+  emit_pending_bincls_if_required ();
+  targetm.asm_out.internal_label (asm_out_file, "LBB", n);
+}
+
+/* Describe the end line-number of an internal block within a function.  */
+
+static void
+dbxout_end_block (unsigned int line ATTRIBUTE_UNUSED, unsigned int n)
+{
+  emit_pending_bincls_if_required ();
+  targetm.asm_out.internal_label (asm_out_file, "LBE", n);
+}
+
+/* Output dbx data for a function definition.
+   This includes a definition of the function name itself (a symbol),
+   definitions of the parameters (locating them in the parameter list)
+   and then output the block that makes up the function's body
+   (including all the auto variables of the function).  */
+
+static void
+dbxout_function_decl (tree decl)
+{
+  emit_pending_bincls_if_required ();
+#ifndef DBX_FUNCTION_FIRST
+  dbxout_begin_function (decl);
+#endif
+  dbxout_block (DECL_INITIAL (decl), 0, DECL_ARGUMENTS (decl), -1);
+  dbxout_function_end (decl);
+}
+
+#endif /* DBX_DEBUGGING_INFO  */
+
+static void
+dbxout_early_global_decl (tree decl ATTRIBUTE_UNUSED)
+{
+  /* NYI for non-dwarf.  */
+}
+
+/* Debug information for a global DECL.  Called from toplev.cc after
+   compilation proper has finished.  */
+static void
+dbxout_late_global_decl (tree decl)
+{
+  if (VAR_P (decl) && !DECL_EXTERNAL (decl))
+    {
+      int saved_tree_used = TREE_USED (decl);
+      TREE_USED (decl) = 1;
+      dbxout_symbol (decl, 0);
+      TREE_USED (decl) = saved_tree_used;
+    }
+}
+
+/* This is just a function-type adapter; dbxout_symbol does exactly
+   what we want but returns an int.  */
+static void
+dbxout_type_decl (tree decl, int local)
+{
+  dbxout_symbol (decl, local);
+}
+
+/* At the end of compilation, finish writing the symbol table.
+   The default is to call debug_free_queue but do nothing else.  */
+
+static void
+dbxout_finish (const char *filename ATTRIBUTE_UNUSED)
+{
+#ifdef DBX_OUTPUT_MAIN_SOURCE_FILE_END
+  DBX_OUTPUT_MAIN_SOURCE_FILE_END (asm_out_file, filename);
+#elif defined DBX_OUTPUT_NULL_N_SO_AT_MAIN_SOURCE_FILE_END
+ {
+   switch_to_section (text_section);
+   dbxout_begin_empty_stabs (N_SO);
+   dbxout_stab_value_internal_label ("Letext", 0);
+ }
+#endif
+  debug_free_queue ();
+}
+
+/* Output the index of a type.  */
+
+static void
+dbxout_type_index (tree type)
+{
+#ifndef DBX_USE_BINCL
+  stabstr_D (TYPE_SYMTAB_ADDRESS (type));
+#else
+  struct typeinfo *t = &typevec[TYPE_SYMTAB_ADDRESS (type)];
+  stabstr_C ('(');
+  stabstr_D (t->file_number);
+  stabstr_C (',');
+  stabstr_D (t->type_number);
+  stabstr_C (')');
+#endif
+}
+
+
+/* Generate the symbols for any queued up type symbols we encountered
+   while generating the type info for some originally used symbol.
+   This might generate additional entries in the queue.  Only when
+   the nesting depth goes to 0 is this routine called.  */
+
+static void
+debug_flush_symbol_queue (void)
+{
+  int i;
+
+  /* Make sure that additionally queued items are not flushed
+     prematurely.  */
+
+  ++debug_nesting;
+
+  for (i = 0; i < symbol_queue_index; ++i)
+    {
+      /* If we pushed queued symbols then such symbols must be
+         output no matter what anyone else says.  Specifically,
+         we need to make sure dbxout_symbol() thinks the symbol was
+         used and also we need to override TYPE_DECL_SUPPRESS_DEBUG
+         which may be set for outside reasons.  */
+      int saved_tree_used = TREE_USED (symbol_queue[i]);
+      int saved_suppress_debug = TYPE_DECL_SUPPRESS_DEBUG (symbol_queue[i]);
+      TREE_USED (symbol_queue[i]) = 1;
+      TYPE_DECL_SUPPRESS_DEBUG (symbol_queue[i]) = 0;
+
+#ifdef DBX_DEBUGGING_INFO
+      dbxout_symbol (symbol_queue[i], 0);
+#endif
+
+      TREE_USED (symbol_queue[i]) = saved_tree_used;
+      TYPE_DECL_SUPPRESS_DEBUG (symbol_queue[i]) = saved_suppress_debug;
+    }
+
+  symbol_queue_index = 0;
+  --debug_nesting;
+}
+
+/* Queue a type symbol needed as part of the definition of a decl
+   symbol.  These symbols are generated when debug_flush_symbol_queue()
+   is called.  */
+
+static void
+debug_queue_symbol (tree decl)
+{
+  if (symbol_queue_index >= symbol_queue_size)
+    {
+      symbol_queue_size += 10;
+      symbol_queue = XRESIZEVEC (tree, symbol_queue, symbol_queue_size);
+    }
+
+  symbol_queue[symbol_queue_index++] = decl;
+}
+
+/* Free symbol queue.  */
+static void
+debug_free_queue (void)
+{
+  if (symbol_queue)
+    {
+      free (symbol_queue);
+      symbol_queue = NULL;
+      symbol_queue_size = 0;
+    }
+}
+
+/* Used in several places: evaluates to '0' for a private decl,
+   '1' for a protected decl, '2' for a public decl.  */
+#define DECL_ACCESSIBILITY_CHAR(DECL) \
+(TREE_PRIVATE (DECL) ? '0' : TREE_PROTECTED (DECL) ? '1' : '2')
+
+/* Subroutine of `dbxout_type'.  Output the type fields of TYPE.
+   This must be a separate function because anonymous unions require
+   recursive calls.  */
+
+static void
+dbxout_type_fields (tree type)
+{
+  tree tem;
+
+  /* Output the name, type, position (in bits), size (in bits) of each
+     field that we can support.  */
+  for (tem = TYPE_FIELDS (type); tem; tem = DECL_CHAIN (tem))
+    {
+      /* If one of the nodes is an error_mark or its type is then
+	 return early.  */
+      if (error_operand_p (tem))
+	return;
+
+      /* Omit here local type decls until we know how to support them.  */
+      if (TREE_CODE (tem) == TYPE_DECL
+	  || TREE_CODE (tem) == TEMPLATE_DECL
+	  /* Member functions emitted after fields.  */
+	  || TREE_CODE (tem) == FUNCTION_DECL
+	  /* Omit here the nameless fields that are used to skip bits.  */
+	  || DECL_IGNORED_P (tem)
+	  /* Omit fields whose position or size are variable or too large to
+	     represent.  */
+	  || (TREE_CODE (tem) == FIELD_DECL
+	      && (! tree_fits_shwi_p (bit_position (tem))
+		  || ! DECL_SIZE (tem)
+		  || ! tree_fits_uhwi_p (DECL_SIZE (tem)))))
+	continue;
+
+      else if (TREE_CODE (tem) != CONST_DECL)
+	{
+	  /* Continue the line if necessary,
+	     but not before the first field.  */
+	  if (tem != TYPE_FIELDS (type))
+	    CONTIN;
+
+	  if (DECL_NAME (tem))
+	    stabstr_I (DECL_NAME (tem));
+	  stabstr_C (':');
+
+	  if (use_gnu_debug_info_extensions
+	      && (TREE_PRIVATE (tem) || TREE_PROTECTED (tem)
+		  || TREE_CODE (tem) != FIELD_DECL))
+	    {
+	      stabstr_C ('/');
+	      stabstr_C (DECL_ACCESSIBILITY_CHAR (tem));
+	    }
+
+	  dbxout_type ((TREE_CODE (tem) == FIELD_DECL
+			&& DECL_BIT_FIELD_TYPE (tem))
+		       ? DECL_BIT_FIELD_TYPE (tem) : TREE_TYPE (tem), 0);
+
+	  if (VAR_P (tem))
+	    {
+	      if (TREE_STATIC (tem) && use_gnu_debug_info_extensions)
+		{
+		  tree name = DECL_ASSEMBLER_NAME (tem);
+
+		  stabstr_C (':');
+		  stabstr_I (name);
+		  stabstr_C (';');
+		}
+	      else
+		/* If TEM is non-static, GDB won't understand it.  */
+		stabstr_S (",0,0;");
+	    }
+	  else
+	    {
+	      stabstr_C (',');
+	      stabstr_D (int_bit_position (tem));
+	      stabstr_C (',');
+	      stabstr_D (tree_to_uhwi (DECL_SIZE (tem)));
+	      stabstr_C (';');
+	    }
+	}
+    }
+}
+
+/* Subroutine of `dbxout_type_methods'.  Output debug info about the
+   method described DECL.  */
+
+static void
+dbxout_type_method_1 (tree decl)
+{
+  char c1 = 'A', c2;
+
+  if (TREE_CODE (TREE_TYPE (decl)) == FUNCTION_TYPE)
+    c2 = '?';
+  else /* it's a METHOD_TYPE.  */
+    {
+      tree firstarg = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (decl)));
+      /* A for normal functions.
+	 B for `const' member functions.
+	 C for `volatile' member functions.
+	 D for `const volatile' member functions.  */
+      if (TYPE_READONLY (TREE_TYPE (firstarg)))
+	c1 += 1;
+      if (TYPE_VOLATILE (TREE_TYPE (firstarg)))
+	c1 += 2;
+
+      if (DECL_VINDEX (decl))
+	c2 = '*';
+      else
+	c2 = '.';
+    }
+
+  /* ??? Output the mangled name, which contains an encoding of the
+     method's type signature.  May not be necessary anymore.  */
+  stabstr_C (':');
+  stabstr_I (DECL_ASSEMBLER_NAME (decl));
+  stabstr_C (';');
+  stabstr_C (DECL_ACCESSIBILITY_CHAR (decl));
+  stabstr_C (c1);
+  stabstr_C (c2);
+
+  if (DECL_VINDEX (decl) && tree_fits_shwi_p (DECL_VINDEX (decl)))
+    {
+      stabstr_D (tree_to_shwi (DECL_VINDEX (decl)));
+      stabstr_C (';');
+      dbxout_type (DECL_CONTEXT (decl), 0);
+      stabstr_C (';');
+    }
+}
+
+/* Subroutine of `dbxout_type'.  Output debug info about the member
+   functions defined in TYPE.  */
+
+static void
+dbxout_type_methods (tree type)
+{
+  for (tree fndecl = TYPE_FIELDS (type); fndecl;)
+    {
+      int need_prefix = 1;
+
+      /* Group together all the methods for the same operation.
+	 These differ in the types of the arguments.  */
+      for (tree last = NULL_TREE;
+	   fndecl && (last == NULL_TREE || DECL_NAME (fndecl) == DECL_NAME (last));
+	   fndecl = DECL_CHAIN (fndecl))
+	/* Output the name of the field (after overloading), as
+	   well as the name of the field before overloading, along
+	   with its parameter list */
+	{
+	  /* Skip non-functions.  */
+	  if (TREE_CODE (fndecl) != FUNCTION_DECL)
+	    continue;
+
+	  /* Also ignore abstract methods; those are only interesting to
+	     the DWARF backends.  */
+	  if (DECL_IGNORED_P (fndecl) || DECL_ABSTRACT_P (fndecl))
+	    continue;
+
+	  CONTIN;
+
+	  last = fndecl;
+
+	  /* Redundantly output the plain name, since that's what gdb
+	     expects.  */
+	  if (need_prefix)
+	    {
+	      stabstr_I (DECL_NAME (fndecl));
+	      stabstr_S ("::");
+	      need_prefix = 0;
+	    }
+
+	  dbxout_type (TREE_TYPE (fndecl), 0);
+	  dbxout_type_method_1 (fndecl);
+	}
+      if (!need_prefix)
+	stabstr_C (';');
+    }
+}
+
+/* Emit a "range" type specification, which has the form:
+   "r<index type>;<lower bound>;<upper bound>;".
+   TYPE is an INTEGER_TYPE, LOW and HIGH are the bounds.  */
+
+static void
+dbxout_range_type (tree type, tree low, tree high)
+{
+  stabstr_C ('r');
+  if (TREE_TYPE (type))
+    dbxout_type (TREE_TYPE (type), 0);
+  else if (TREE_CODE (type) != INTEGER_TYPE)
+    dbxout_type (type, 0);
+  else
+    {
+      /* Traditionally, we made sure 'int' was type 1, and builtin types
+	 were defined to be sub-ranges of int.  Unfortunately, this
+	 does not allow us to distinguish true sub-ranges from integer
+	 types.  So, instead we define integer (non-sub-range) types as
+	 sub-ranges of themselves.  This matters for Chill.  If this isn't
+	 a subrange type, then we want to define it in terms of itself.
+	 However, in C, this may be an anonymous integer type, and we don't
+	 want to emit debug info referring to it.  Just calling
+	 dbxout_type_index won't work anyways, because the type hasn't been
+	 defined yet.  We make this work for both cases by checked to see
+	 whether this is a defined type, referring to it if it is, and using
+	 'int' otherwise.  */
+      if (TYPE_SYMTAB_ADDRESS (type) != 0)
+	dbxout_type_index (type);
+      else
+	dbxout_type_index (integer_type_node);
+    }
+
+  stabstr_C (';');
+  if (low && tree_fits_shwi_p (low))
+    {
+      if (print_int_cst_bounds_in_octal_p (type, low, high))
+        stabstr_O (low);
+      else
+        stabstr_D (tree_to_shwi (low));
+    }
+  else
+    stabstr_C ('0');
+
+  stabstr_C (';');
+  if (high && tree_fits_shwi_p (high))
+    {
+      if (print_int_cst_bounds_in_octal_p (type, low, high))
+        stabstr_O (high);
+      else
+        stabstr_D (tree_to_shwi (high));
+      stabstr_C (';');
+    }
+  else
+    stabstr_S ("-1;");
+}
+
+
+/* Output a reference to a type.  If the type has not yet been
+   described in the dbx output, output its definition now.
+   For a type already defined, just refer to its definition
+   using the type number.
+
+   If FULL is nonzero, and the type has been described only with
+   a forward-reference, output the definition now.
+   If FULL is zero in this case, just refer to the forward-reference
+   using the number previously allocated.  */
+
+static void
+dbxout_type (tree type, int full)
+{
+  static int anonymous_type_number = 0;
+  tree tem, main_variant, low, high;
+
+  if (TREE_CODE (type) == INTEGER_TYPE)
+    {
+      if (TREE_TYPE (type) == 0)
+	{
+	  low = TYPE_MIN_VALUE (type);
+	  high = TYPE_MAX_VALUE (type);
+	}
+
+      else if (subrange_type_for_debug_p (type, &low, &high))
+	;
+
+      /* If this is a subtype that should not be emitted as a subrange type,
+	 use the base type.  */
+      else
+	{
+	  type = TREE_TYPE (type);
+	  low = TYPE_MIN_VALUE (type);
+	  high = TYPE_MAX_VALUE (type);
+	}
+    }
+
+  /* If there was an input error and we don't really have a type,
+     avoid crashing and write something that is at least valid
+     by assuming `int'.  */
+  if (type == error_mark_node)
+    type = integer_type_node;
+  else
+    {
+      if (TYPE_NAME (type)
+	  && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL
+	  && TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (type)))
+	full = 0;
+    }
+
+  /* Try to find the "main variant" with the same name.  */
+  if (TYPE_NAME (type) && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL
+      && DECL_ORIGINAL_TYPE (TYPE_NAME (type)))
+    main_variant = TREE_TYPE (TYPE_NAME (type));
+  else
+    main_variant = TYPE_MAIN_VARIANT (type);
+
+  /* If we are not using extensions, stabs does not distinguish const and
+     volatile, so there is no need to make them separate types.  */
+  if (!use_gnu_debug_info_extensions)
+    type = main_variant;
+
+  if (TYPE_SYMTAB_ADDRESS (type) == 0)
+    {
+      /* Type has no dbx number assigned.  Assign next available number.  */
+      TYPE_SYMTAB_ADDRESS (type) = next_type_number++;
+
+      /* Make sure type vector is long enough to record about this type.  */
+
+      if (next_type_number == typevec_len)
+	{
+	  typevec = GGC_RESIZEVEC (struct typeinfo, typevec, typevec_len * 2);
+	  memset (typevec + typevec_len, 0, typevec_len * sizeof typevec[0]);
+	  typevec_len *= 2;
+	}
+
+#ifdef DBX_USE_BINCL
+      emit_pending_bincls_if_required ();
+      typevec[TYPE_SYMTAB_ADDRESS (type)].file_number
+	= current_file->file_number;
+      typevec[TYPE_SYMTAB_ADDRESS (type)].type_number
+	= current_file->next_type_number++;
+#endif
+    }
+
+  if (flag_debug_only_used_symbols)
+    {
+      if ((TREE_CODE (type) == RECORD_TYPE
+	   || TREE_CODE (type) == UNION_TYPE
+	   || TREE_CODE (type) == QUAL_UNION_TYPE
+	   || TREE_CODE (type) == ENUMERAL_TYPE)
+	  && TYPE_STUB_DECL (type)
+	  && DECL_P (TYPE_STUB_DECL (type))
+	  && ! DECL_IGNORED_P (TYPE_STUB_DECL (type)))
+	debug_queue_symbol (TYPE_STUB_DECL (type));
+      else if (TYPE_NAME (type)
+	       && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL)
+	debug_queue_symbol (TYPE_NAME (type));
+    }
+
+  /* Output the number of this type, to refer to it.  */
+  dbxout_type_index (type);
+
+#ifdef DBX_TYPE_DEFINED
+  if (DBX_TYPE_DEFINED (type))
+    return;
+#endif
+
+  /* If this type's definition has been output or is now being output,
+     that is all.  */
+
+  switch (typevec[TYPE_SYMTAB_ADDRESS (type)].status)
+    {
+    case TYPE_UNSEEN:
+      break;
+    case TYPE_XREF:
+      /* If we have already had a cross reference,
+	 and either that's all we want or that's the best we could do,
+	 don't repeat the cross reference.
+	 Sun dbx crashes if we do.  */
+      if (! full || !COMPLETE_TYPE_P (type)
+	  /* No way in DBX fmt to describe a variable size.  */
+	  || ! tree_fits_uhwi_p (TYPE_SIZE (type)))
+	return;
+      break;
+    case TYPE_DEFINED:
+      return;
+    }
+
+#ifdef DBX_NO_XREFS
+  /* For systems where dbx output does not allow the `=xsNAME:' syntax,
+     leave the type-number completely undefined rather than output
+     a cross-reference.  If we have already used GNU debug info extensions,
+     then it is OK to output a cross reference.  This is necessary to get
+     proper C++ debug output.  */
+  if ((TREE_CODE (type) == RECORD_TYPE || TREE_CODE (type) == UNION_TYPE
+       || TREE_CODE (type) == QUAL_UNION_TYPE
+       || TREE_CODE (type) == ENUMERAL_TYPE)
+      && ! use_gnu_debug_info_extensions)
+    /* We must use the same test here as we use twice below when deciding
+       whether to emit a cross-reference.  */
+    if ((TYPE_NAME (type) != 0
+	 && ! (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL
+	       && DECL_IGNORED_P (TYPE_NAME (type)))
+	 && !full)
+	|| !COMPLETE_TYPE_P (type)
+	/* No way in DBX fmt to describe a variable size.  */
+	|| ! tree_fits_uhwi_p (TYPE_SIZE (type)))
+      {
+	typevec[TYPE_SYMTAB_ADDRESS (type)].status = TYPE_XREF;
+	return;
+      }
+#endif
+
+  /* Output a definition now.  */
+  stabstr_C ('=');
+
+  /* Mark it as defined, so that if it is self-referent
+     we will not get into an infinite recursion of definitions.  */
+
+  typevec[TYPE_SYMTAB_ADDRESS (type)].status = TYPE_DEFINED;
+
+  /* If this type is a variant of some other, hand off.  Types with
+     different names are usefully distinguished.  We only distinguish
+     cv-qualified types if we're using extensions.  */
+  if (TYPE_READONLY (type) > TYPE_READONLY (main_variant))
+    {
+      stabstr_C ('k');
+      dbxout_type (build_type_variant (type, 0, TYPE_VOLATILE (type)), 0);
+      return;
+    }
+  else if (TYPE_VOLATILE (type) > TYPE_VOLATILE (main_variant))
+    {
+      stabstr_C ('B');
+      dbxout_type (build_type_variant (type, TYPE_READONLY (type), 0), 0);
+      return;
+    }
+  else if (main_variant != TYPE_MAIN_VARIANT (type))
+    {
+      if (flag_debug_only_used_symbols)
+        {
+          tree orig_type = DECL_ORIGINAL_TYPE (TYPE_NAME (type));
+
+          if ((TREE_CODE (orig_type) == RECORD_TYPE
+               || TREE_CODE (orig_type) == UNION_TYPE
+               || TREE_CODE (orig_type) == QUAL_UNION_TYPE
+               || TREE_CODE (orig_type) == ENUMERAL_TYPE)
+              && TYPE_STUB_DECL (orig_type)
+              && ! DECL_IGNORED_P (TYPE_STUB_DECL (orig_type)))
+            debug_queue_symbol (TYPE_STUB_DECL (orig_type));
+        }
+      /* 'type' is a typedef; output the type it refers to.  */
+      dbxout_type (DECL_ORIGINAL_TYPE (TYPE_NAME (type)), 0);
+      return;
+    }
+  /* else continue.  */
+
+  switch (TREE_CODE (type))
+    {
+    case VOID_TYPE:
+    case NULLPTR_TYPE:
+    case LANG_TYPE:
+    case OPAQUE_TYPE:
+      /* For a void type, just define it as itself; i.e., "5=5".
+	 This makes us consider it defined
+	 without saying what it is.  The debugger will make it
+	 a void type when the reference is seen, and nothing will
+	 ever override that default.  */
+      dbxout_type_index (type);
+      break;
+
+    case INTEGER_TYPE:
+      if (type == char_type_node && ! TYPE_UNSIGNED (type))
+	{
+	  /* Output the type `char' as a subrange of itself!
+	     I don't understand this definition, just copied it
+	     from the output of pcc.
+	     This used to use `r2' explicitly and we used to
+	     take care to make sure that `char' was type number 2.  */
+	  stabstr_C ('r');
+	  dbxout_type_index (type);
+	  stabstr_S (";0;127;");
+	}
+
+      /* If this is a subtype of another integer type, always prefer to
+	 write it as a subtype.  */
+      else if (TREE_TYPE (type) != 0
+	       && TREE_CODE (TREE_TYPE (type)) == INTEGER_TYPE)
+	{
+	  /* If the size is non-standard, say what it is if we can use
+	     GDB extensions.  */
+
+	  if (use_gnu_debug_info_extensions
+	      && TYPE_PRECISION (type) != TYPE_PRECISION (integer_type_node))
+	    {
+	      stabstr_S ("@s");
+	      stabstr_D (TYPE_PRECISION (type));
+	      stabstr_C (';');
+	    }
+
+	  dbxout_range_type (type, low, high);
+	}
+
+      else
+	{
+	  /* If the size is non-standard, say what it is if we can use
+	     GDB extensions.  */
+
+	  if (use_gnu_debug_info_extensions
+	      && TYPE_PRECISION (type) != TYPE_PRECISION (integer_type_node))
+	    {
+	      stabstr_S ("@s");
+	      stabstr_D (TYPE_PRECISION (type));
+	      stabstr_C (';');
+	    }
+
+	  if (print_int_cst_bounds_in_octal_p (type, low, high))
+	    {
+	      stabstr_C ('r');
+
+              /* If this type derives from another type, output type index of
+		 parent type. This is particularly important when parent type
+		 is an enumerated type, because not generating the parent type
+		 index would transform the definition of this enumerated type
+		 into a plain unsigned type.  */
+              if (TREE_TYPE (type) != 0)
+                dbxout_type_index (TREE_TYPE (type));
+              else
+                dbxout_type_index (type);
+
+	      stabstr_C (';');
+	      stabstr_O (low);
+	      stabstr_C (';');
+	      stabstr_O (high);
+	      stabstr_C (';');
+	    }
+
+	  else
+	    /* Output other integer types as subranges of `int'.  */
+	    dbxout_range_type (type, low, high);
+	}
+
+      break;
+
+    case REAL_TYPE:
+    case FIXED_POINT_TYPE:
+      /* This used to say `r1' and we used to take care
+	 to make sure that `int' was type number 1.  */
+      stabstr_C ('r');
+      dbxout_type_index (integer_type_node);
+      stabstr_C (';');
+      stabstr_D (int_size_in_bytes (type));
+      stabstr_S (";0;");
+      break;
+
+    case BOOLEAN_TYPE:
+      if (use_gnu_debug_info_extensions)
+	{
+	  stabstr_S ("@s");
+	  stabstr_D (BITS_PER_UNIT * int_size_in_bytes (type));
+	  stabstr_S (";-16;");
+	}
+      else /* Define as enumeral type (False, True) */
+	stabstr_S ("eFalse:0,True:1,;");
+      break;
+
+    case COMPLEX_TYPE:
+      /* Differs from the REAL_TYPE by its new data type number.
+	 R3 is NF_COMPLEX.  We don't try to use any of the other NF_*
+	 codes since gdb doesn't care anyway.  */
+
+      if (TREE_CODE (TREE_TYPE (type)) == REAL_TYPE)
+	{
+	  stabstr_S ("R3;");
+	  stabstr_D (2 * int_size_in_bytes (TREE_TYPE (type)));
+	  stabstr_S (";0;");
+	}
+      else
+	{
+	  /* Output a complex integer type as a structure,
+	     pending some other way to do it.  */
+	  stabstr_C ('s');
+	  stabstr_D (int_size_in_bytes (type));
+
+	  stabstr_S ("real:");
+	  dbxout_type (TREE_TYPE (type), 0);
+	  stabstr_S (",0,");
+	  stabstr_D (TYPE_PRECISION (TREE_TYPE (type)));
+
+	  stabstr_S (";imag:");
+	  dbxout_type (TREE_TYPE (type), 0);
+	  stabstr_C (',');
+	  stabstr_D (TYPE_PRECISION (TREE_TYPE (type)));
+	  stabstr_C (',');
+	  stabstr_D (TYPE_PRECISION (TREE_TYPE (type)));
+	  stabstr_S (";;");
+	}
+      break;
+
+    case ARRAY_TYPE:
+      /* Make arrays of packed bits look like bitstrings for chill.  */
+      if (TYPE_PACKED (type) && use_gnu_debug_info_extensions)
+	{
+	  stabstr_S ("@s");
+	  stabstr_D (BITS_PER_UNIT * int_size_in_bytes (type));
+	  stabstr_S (";@S;S");
+	  dbxout_type (TYPE_DOMAIN (type), 0);
+	  break;
+	}
+
+      /* Output "a" followed by a range type definition
+	 for the index type of the array
+	 followed by a reference to the target-type.
+	 ar1;0;N;M for a C array of type M and size N+1.  */
+      /* Check if a character string type, which in Chill is
+	 different from an array of characters.  */
+      if (TYPE_STRING_FLAG (type) && use_gnu_debug_info_extensions)
+	{
+	  stabstr_S ("@S;");
+	}
+      tem = TYPE_DOMAIN (type);
+      if (tem == NULL)
+	{
+	  stabstr_S ("ar");
+	  dbxout_type_index (integer_type_node);
+	  stabstr_S (";0;-1;");
+	}
+      else
+	{
+	  stabstr_C ('a');
+	  dbxout_range_type (tem, TYPE_MIN_VALUE (tem), TYPE_MAX_VALUE (tem));
+	}
+
+      dbxout_type (TREE_TYPE (type), 0);
+      break;
+
+    case VECTOR_TYPE:
+      /* Make vectors look like an array.  */
+      if (use_gnu_debug_info_extensions)
+	stabstr_S ("@V;");
+
+      /* Output "a" followed by a range type definition
+	 for the index type of the array
+	 followed by a reference to the target-type.
+	 ar1;0;N;M for a C array of type M and size N+1.  */
+      stabstr_C ('a');
+      dbxout_range_type (integer_type_node, size_zero_node,
+			 size_int (TYPE_VECTOR_SUBPARTS (type) - 1));
+
+      dbxout_type (TREE_TYPE (type), 0);
+      break;
+
+    case RECORD_TYPE:
+    case UNION_TYPE:
+    case QUAL_UNION_TYPE:
+      {
+	tree binfo = TYPE_BINFO (type);
+
+	/* Output a structure type.  We must use the same test here as we
+	   use in the DBX_NO_XREFS case above.  */
+	if ((TYPE_NAME (type) != 0
+	     && ! (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL
+		   && DECL_IGNORED_P (TYPE_NAME (type)))
+	     && !full)
+	    || !COMPLETE_TYPE_P (type)
+	    /* No way in DBX fmt to describe a variable size.  */
+	    || ! tree_fits_uhwi_p (TYPE_SIZE (type)))
+	  {
+	    /* If the type is just a cross reference, output one
+	       and mark the type as partially described.
+	       If it later becomes defined, we will output
+	       its real definition.
+	       If the type has a name, don't nest its definition within
+	       another type's definition; instead, output an xref
+	       and let the definition come when the name is defined.  */
+	    stabstr_S ((TREE_CODE (type) == RECORD_TYPE) ? "xs" : "xu");
+	    if (TYPE_IDENTIFIER (type))
+	      {
+		/* Note that the C frontend creates for anonymous variable
+		   length records/unions TYPE_NAME with DECL_NAME NULL.  */
+		dbxout_type_name (type);
+	      }
+	    else
+	      {
+		stabstr_S ("$$");
+		stabstr_D (anonymous_type_number++);
+	      }
+
+	    stabstr_C (':');
+	    typevec[TYPE_SYMTAB_ADDRESS (type)].status = TYPE_XREF;
+	    break;
+	  }
+
+	/* Identify record or union, and print its size.  */
+	stabstr_C ((TREE_CODE (type) == RECORD_TYPE) ? 's' : 'u');
+	stabstr_D (int_size_in_bytes (type));
+
+	if (binfo)
+	  {
+	    int i;
+	    tree child;
+	    vec<tree, va_gc> *accesses = BINFO_BASE_ACCESSES (binfo);
+
+	    if (use_gnu_debug_info_extensions)
+	      {
+		if (BINFO_N_BASE_BINFOS (binfo))
+		  {
+		    stabstr_C ('!');
+		    stabstr_U (BINFO_N_BASE_BINFOS (binfo));
+		    stabstr_C (',');
+		  }
+	      }
+	    for (i = 0; BINFO_BASE_ITERATE (binfo, i, child); i++)
+	      {
+		tree access = (accesses ? (*accesses)[i] : access_public_node);
+
+		if (use_gnu_debug_info_extensions)
+		  {
+		    stabstr_C (BINFO_VIRTUAL_P (child) ? '1' : '0');
+		    stabstr_C (access == access_public_node ? '2' :
+				   access == access_protected_node
+				   ? '1' :'0');
+		    if (BINFO_VIRTUAL_P (child)
+			&& (lang_GNU_CXX ()
+			    || strcmp (lang_hooks.name, "GNU Objective-C++") == 0))
+		      /* For a virtual base, print the (negative)
+		     	 offset within the vtable where we must look
+		     	 to find the necessary adjustment.  */
+		      stabstr_D
+			(tree_to_shwi (BINFO_VPTR_FIELD (child))
+			 * BITS_PER_UNIT);
+		    else
+		      stabstr_D (tree_to_shwi (BINFO_OFFSET (child))
+				       * BITS_PER_UNIT);
+		    stabstr_C (',');
+		    dbxout_type (BINFO_TYPE (child), 0);
+		    stabstr_C (';');
+		  }
+		else
+		  {
+		    /* Print out the base class information with
+		       fields which have the same names at the types
+		       they hold.  */
+		    dbxout_type_name (BINFO_TYPE (child));
+		    stabstr_C (':');
+		    dbxout_type (BINFO_TYPE (child), full);
+		    stabstr_C (',');
+		    stabstr_D (tree_to_shwi (BINFO_OFFSET (child))
+				     * BITS_PER_UNIT);
+		    stabstr_C (',');
+		    stabstr_D
+		      (tree_to_shwi (TYPE_SIZE (BINFO_TYPE (child)))
+		       * BITS_PER_UNIT);
+		    stabstr_C (';');
+		  }
+	      }
+	  }
+      }
+
+      /* Write out the field declarations.  */
+      dbxout_type_fields (type);
+      if (use_gnu_debug_info_extensions)
+	dbxout_type_methods (type);
+
+      stabstr_C (';');
+
+      if (use_gnu_debug_info_extensions && TREE_CODE (type) == RECORD_TYPE
+	  /* Avoid the ~ if we don't really need it--it confuses dbx.  */
+	  && TYPE_VFIELD (type))
+	{
+
+	  /* We need to write out info about what field this class
+	     uses as its "main" vtable pointer field, because if this
+	     field is inherited from a base class, GDB cannot necessarily
+	     figure out which field it's using in time.  */
+	  stabstr_S ("~%");
+	  dbxout_type (DECL_FCONTEXT (TYPE_VFIELD (type)), 0);
+	  stabstr_C (';');
+	}
+      break;
+
+    case ENUMERAL_TYPE:
+      /* We must use the same test here as we use in the DBX_NO_XREFS case
+	 above.  We simplify it a bit since an enum will never have a variable
+	 size.  */
+      if ((TYPE_NAME (type) != 0
+	   && ! (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL
+		 && DECL_IGNORED_P (TYPE_NAME (type)))
+	   && !full)
+	  || !COMPLETE_TYPE_P (type))
+	{
+	  stabstr_S ("xe");
+	  dbxout_type_name (type);
+	  typevec[TYPE_SYMTAB_ADDRESS (type)].status = TYPE_XREF;
+	  stabstr_C (':');
+	  return;
+	}
+      if (use_gnu_debug_info_extensions
+	  && TYPE_PRECISION (type) != TYPE_PRECISION (integer_type_node))
+	{
+	  stabstr_S ("@s");
+	  stabstr_D (TYPE_PRECISION (type));
+	  stabstr_C (';');
+	}
+
+      stabstr_C ('e');
+      for (tem = TYPE_VALUES (type); tem; tem = TREE_CHAIN (tem))
+	{
+          tree value = TREE_VALUE (tem);
+
+	  stabstr_I (TREE_PURPOSE (tem));
+	  stabstr_C (':');
+
+          if (TREE_CODE (value) == CONST_DECL)
+            value = DECL_INITIAL (value);
+
+	  if (cst_and_fits_in_hwi (value))
+	    stabstr_D (TREE_INT_CST_LOW (value));
+	  else
+	    stabstr_O (value);
+
+	  stabstr_C (',');
+	  if (TREE_CHAIN (tem) != 0)
+	    CONTIN;
+	}
+
+      stabstr_C (';');
+      break;
+
+    case POINTER_TYPE:
+      stabstr_C ('*');
+      dbxout_type (TREE_TYPE (type), 0);
+      break;
+
+    case METHOD_TYPE:
+      if (use_gnu_debug_info_extensions)
+	{
+	  stabstr_C ('#');
+
+	  /* Write the argument types out longhand.  */
+	  dbxout_type (TYPE_METHOD_BASETYPE (type), 0);
+	  stabstr_C (',');
+	  dbxout_type (TREE_TYPE (type), 0);
+	  dbxout_args (TYPE_ARG_TYPES (type));
+	  stabstr_C (';');
+	}
+      else
+	/* Treat it as a function type.  */
+	dbxout_type (TREE_TYPE (type), 0);
+      break;
+
+    case OFFSET_TYPE:
+      if (use_gnu_debug_info_extensions)
+	{
+	  stabstr_C ('@');
+	  dbxout_type (TYPE_OFFSET_BASETYPE (type), 0);
+	  stabstr_C (',');
+	  dbxout_type (TREE_TYPE (type), 0);
+	}
+      else
+	/* Should print as an int, because it is really just an offset.  */
+	dbxout_type (integer_type_node, 0);
+      break;
+
+    case REFERENCE_TYPE:
+      if (use_gnu_debug_info_extensions)
+	{
+	  stabstr_C ('&');
+	}
+      else
+	stabstr_C ('*');
+      dbxout_type (TREE_TYPE (type), 0);
+      break;
+
+    case FUNCTION_TYPE:
+      stabstr_C ('f');
+      dbxout_type (TREE_TYPE (type), 0);
+      break;
+
+    default:
+      /* A C++ function with deduced return type can have a TEMPLATE_TYPE_PARM
+	 named 'auto' in its type.
+	 No debug info for TEMPLATE_TYPE_PARM type supported yet.  */
+      if (lang_GNU_CXX ())
+	{
+	  tree name = TYPE_IDENTIFIER (type);
+	  if (name == get_identifier ("auto")
+	      || name == get_identifier ("decltype(auto)"))
+	    break;
+	}
+
+      gcc_unreachable ();
+    }
+}
+
+/* Return nonzero if the given type represents an integer whose bounds
+   should be printed in octal format.  */
+
+static bool
+print_int_cst_bounds_in_octal_p (tree type, tree low, tree high)
+{
+  /* If we can use GDB extensions and the size is wider than a long
+     (the size used by GDB to read them) or we may have trouble writing
+     the bounds the usual way, write them in octal.  Note the test is for
+     the *target's* size of "long", not that of the host.  The host test
+     is just to make sure we can write it out in case the host wide int
+     is narrower than the target "long".
+
+     For unsigned types, we use octal if they are the same size or larger.
+     This is because we print the bounds as signed decimal, and hence they
+     can't span same size unsigned types.  */
+
+  if (use_gnu_debug_info_extensions
+      && low && TREE_CODE (low) == INTEGER_CST
+      && high && TREE_CODE (high) == INTEGER_CST
+      && (TYPE_PRECISION (type) > TYPE_PRECISION (integer_type_node)
+	  || ((TYPE_PRECISION (type) == TYPE_PRECISION (integer_type_node))
+	      && TYPE_UNSIGNED (type))
+	  || TYPE_PRECISION (type) > HOST_BITS_PER_WIDE_INT
+	  || (TYPE_PRECISION (type) == HOST_BITS_PER_WIDE_INT
+	      && TYPE_UNSIGNED (type))))
+    return TRUE;
+  else
+    return FALSE;
+}
+
+/* Output the name of type TYPE, with no punctuation.
+   Such names can be set up either by typedef declarations
+   or by struct, enum and union tags.  */
+
+static void
+dbxout_type_name (tree type)
+{
+  tree t = TYPE_NAME (type);
+
+  gcc_assert (t);
+  switch (TREE_CODE (t))
+    {
+    case IDENTIFIER_NODE:
+      break;
+    case TYPE_DECL:
+      t = DECL_NAME (t);
+      break;
+    default:
+      gcc_unreachable ();
+    }
+
+  stabstr_I (t);
+}
+
+/* Output leading struct or class names needed for qualifying type
+   whose scope is limited to a struct or class.  */
+
+static void
+dbxout_class_name_qualifiers (tree decl)
+{
+  tree context = decl_type_context (decl);
+
+  if (context != NULL_TREE
+      && TREE_CODE (context) == RECORD_TYPE
+      && TYPE_NAME (context) != 0
+      && (TREE_CODE (TYPE_NAME (context)) == IDENTIFIER_NODE
+          || (DECL_NAME (TYPE_NAME (context)) != 0)))
+    {
+      tree name = TYPE_NAME (context);
+
+      if (TREE_CODE (name) == TYPE_DECL)
+	{
+	  dbxout_class_name_qualifiers (name);
+	  name = DECL_NAME (name);
+	}
+      stabstr_I (name);
+      stabstr_S ("::");
+    }
+}
+
+/* This is a specialized subset of expand_expr for use by dbxout_symbol in
+   evaluating DECL_VALUE_EXPR.  In particular, we stop if we find decls that
+   haven't been expanded, or if the expression is getting so complex we won't
+   be able to represent it in stabs anyway.  Returns NULL on failure.  */
+
+static rtx
+dbxout_expand_expr (tree expr)
+{
+  switch (TREE_CODE (expr))
+    {
+    case VAR_DECL:
+      /* We can't handle emulated tls variables, because the address is an
+	 offset to the return value of __emutls_get_address, and there is no
+	 way to express that in stabs.  Also, there are name mangling issues
+	 here.  We end up with references to undefined symbols if we don't
+	 disable debug info for these variables.  */
+      if (!targetm.have_tls && DECL_THREAD_LOCAL_P (expr))
+	return NULL;
+      if (TREE_STATIC (expr)
+	  && !TREE_ASM_WRITTEN (expr)
+	  && !DECL_HAS_VALUE_EXPR_P (expr)
+	  && !TREE_PUBLIC (expr)
+	  && DECL_RTL_SET_P (expr)
+	  && MEM_P (DECL_RTL (expr)))
+	{
+	  /* If this is a var that might not be actually output,
+	     return NULL, otherwise stabs might reference an undefined
+	     symbol.  */
+	  varpool_node *node = varpool_node::get (expr);
+	  if (!node || !node->definition)
+	    return NULL;
+	}
+      /* FALLTHRU */
+
+    case PARM_DECL:
+    case RESULT_DECL:
+      if (DECL_HAS_VALUE_EXPR_P (expr))
+	return dbxout_expand_expr (DECL_VALUE_EXPR (expr));
+      /* FALLTHRU */
+
+    case CONST_DECL:
+      return DECL_RTL_IF_SET (expr);
+
+    case INTEGER_CST:
+      return expand_expr (expr, NULL_RTX, VOIDmode, EXPAND_INITIALIZER);
+
+    case COMPONENT_REF:
+    case ARRAY_REF:
+    case ARRAY_RANGE_REF:
+    case BIT_FIELD_REF:
+      {
+	machine_mode mode;
+	poly_int64 bitsize, bitpos;
+	tree offset, tem;
+	int unsignedp, reversep, volatilep = 0;
+	rtx x;
+
+	tem = get_inner_reference (expr, &bitsize, &bitpos, &offset, &mode,
+				   &unsignedp, &reversep, &volatilep);
+
+	x = dbxout_expand_expr (tem);
+	if (x == NULL || !MEM_P (x))
+	  return NULL;
+	if (offset != NULL)
+	  {
+	    if (!tree_fits_shwi_p (offset))
+	      return NULL;
+	    x = adjust_address_nv (x, mode, tree_to_shwi (offset));
+	  }
+	if (maybe_ne (bitpos, 0))
+	  x = adjust_address_nv (x, mode, bits_to_bytes_round_down (bitpos));
+
+	return x;
+      }
+
+    default:
+      return NULL;
+    }
+}
+
+/* Helper function for output_used_types.  Queue one entry from the
+   used types hash to be output.  */
+
+bool
+output_used_types_helper (tree const &type, vec<tree> *types_p)
+{
+  if ((TREE_CODE (type) == RECORD_TYPE
+       || TREE_CODE (type) == UNION_TYPE
+       || TREE_CODE (type) == QUAL_UNION_TYPE
+       || TREE_CODE (type) == ENUMERAL_TYPE)
+      && TYPE_STUB_DECL (type)
+      && DECL_P (TYPE_STUB_DECL (type))
+      && ! DECL_IGNORED_P (TYPE_STUB_DECL (type)))
+    types_p->quick_push (TYPE_STUB_DECL (type));
+  else if (TYPE_NAME (type)
+	   && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL)
+    types_p->quick_push (TYPE_NAME (type));
+
+  return true;
+}
+
+/* This is a qsort callback which sorts types and declarations into a
+   predictable order (types, then declarations, sorted by UID
+   within).  */
+
+static int
+output_types_sort (const void *pa, const void *pb)
+{
+  const tree lhs = *((const tree *)pa);
+  const tree rhs = *((const tree *)pb);
+
+  if (TYPE_P (lhs))
+    {
+      if (TYPE_P (rhs))
+	return TYPE_UID (lhs) - TYPE_UID (rhs);
+      else
+	return 1;
+    }
+  else
+    {
+      if (TYPE_P (rhs))
+	return -1;
+      else
+	return DECL_UID (lhs) - DECL_UID (rhs);
+    }
+}
+
+
+/* Force all types used by this function to be output in debug
+   information.  */
+
+static void
+output_used_types (void)
+{
+  if (cfun && cfun->used_types_hash)
+    {
+      vec<tree> types;
+      int i;
+      tree type;
+
+      types.create (cfun->used_types_hash->elements ());
+      cfun->used_types_hash->traverse<vec<tree> *, output_used_types_helper>
+       	(&types);
+
+      /* Sort by UID to prevent dependence on hash table ordering.  */
+      types.qsort (output_types_sort);
+
+      FOR_EACH_VEC_ELT (types, i, type)
+	debug_queue_symbol (type);
+
+      types.release ();
+    }
+}
+
+/* Output a .stabs for the symbol defined by DECL,
+   which must be a ..._DECL node in the normal namespace.
+   It may be a CONST_DECL, a FUNCTION_DECL, a PARM_DECL or a VAR_DECL.
+   LOCAL is nonzero if the scope is less than the entire file.
+   Return 1 if a stabs might have been emitted.  */
+
+int
+dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)
+{
+  tree type = TREE_TYPE (decl);
+  tree context = NULL_TREE;
+  int result = 0;
+  rtx decl_rtl;
+
+  /* "Intercept" dbxout_symbol() calls like we do all debug_hooks.  */
+  ++debug_nesting;
+
+  /* Ignore nameless syms, but don't ignore type tags.  */
+
+  if ((DECL_NAME (decl) == 0 && TREE_CODE (decl) != TYPE_DECL)
+      || DECL_IGNORED_P (decl))
+    DBXOUT_DECR_NESTING_AND_RETURN (0);
+
+  /* If we are to generate only the symbols actually used then such
+     symbol nodes are flagged with TREE_USED.  Ignore any that
+     aren't flagged as TREE_USED.  */
+
+  if (flag_debug_only_used_symbols
+      && (!TREE_USED (decl)
+          && (!VAR_P (decl) || !DECL_INITIAL (decl))))
+    DBXOUT_DECR_NESTING_AND_RETURN (0);
+
+  /* If dbxout_init has not yet run, queue this symbol for later.  */
+  if (!typevec)
+    {
+      preinit_symbols = tree_cons (0, decl, preinit_symbols);
+      DBXOUT_DECR_NESTING_AND_RETURN (0);
+    }
+
+  if (flag_debug_only_used_symbols)
+    {
+      tree t;
+
+      /* We now have a used symbol.  We need to generate the info for
+         the symbol's type in addition to the symbol itself.  These
+         type symbols are queued to be generated after were done with
+         the symbol itself (otherwise they would fight over the
+         stabstr obstack).
+
+         Note, because the TREE_TYPE(type) might be something like a
+         pointer to a named type we need to look for the first name
+         we see following the TREE_TYPE chain.  */
+
+      t = type;
+      while (POINTER_TYPE_P (t))
+        t = TREE_TYPE (t);
+
+      /* RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE, and ENUMERAL_TYPE
+         need special treatment.  The TYPE_STUB_DECL field in these
+         types generally represents the tag name type we want to
+         output.  In addition there  could be a typedef type with
+         a different name.  In that case we also want to output
+         that.  */
+
+      if (TREE_CODE (t) == RECORD_TYPE
+           || TREE_CODE (t) == UNION_TYPE
+           || TREE_CODE (t) == QUAL_UNION_TYPE
+           || TREE_CODE (t) == ENUMERAL_TYPE)
+        {
+	    if (TYPE_STUB_DECL (t)
+		&& TYPE_STUB_DECL (t) != decl
+		&& DECL_P (TYPE_STUB_DECL (t))
+		&& ! DECL_IGNORED_P (TYPE_STUB_DECL (t)))
+	    {
+	      debug_queue_symbol (TYPE_STUB_DECL (t));
+	      if (TYPE_NAME (t)
+		  && TYPE_NAME (t) != TYPE_STUB_DECL (t)
+		  && TYPE_NAME (t) != decl
+		  && DECL_P (TYPE_NAME (t)))
+		debug_queue_symbol (TYPE_NAME (t));
+	    }
+	}
+      else if (TYPE_NAME (t)
+	       && TYPE_NAME (t) != decl
+	       && DECL_P (TYPE_NAME (t)))
+        debug_queue_symbol (TYPE_NAME (t));
+    }
+
+  emit_pending_bincls_if_required ();
+
+  switch (TREE_CODE (decl))
+    {
+    case CONST_DECL:
+      /* Enum values are defined by defining the enum type.  */
+      break;
+
+    case FUNCTION_DECL:
+      decl_rtl = DECL_RTL_IF_SET (decl);
+      if (!decl_rtl)
+	DBXOUT_DECR_NESTING_AND_RETURN (0);
+      if (DECL_EXTERNAL (decl))
+	break;
+      /* Don't mention a nested function under its parent.  */
+      context = decl_function_context (decl);
+      if (context == current_function_decl)
+	break;
+      /* Don't mention an inline instance of a nested function.  */
+      if (context && DECL_FROM_INLINE (decl))
+	break;
+      if (!MEM_P (decl_rtl)
+	  || GET_CODE (XEXP (decl_rtl, 0)) != SYMBOL_REF)
+	break;
+
+      if (flag_debug_only_used_symbols)
+	output_used_types ();
+
+      dbxout_begin_complex_stabs ();
+      stabstr_I (DECL_ASSEMBLER_NAME (decl));
+      stabstr_S (TREE_PUBLIC (decl) ? ":F" : ":f");
+      result = 1;
+
+      if (TREE_TYPE (type))
+	dbxout_type (TREE_TYPE (type), 0);
+      else
+	dbxout_type (void_type_node, 0);
+
+      /* For a nested function, when that function is compiled,
+	 mention the containing function name
+	 as well as (since dbx wants it) our own assembler-name.  */
+      if (context != 0)
+	{
+	  stabstr_C (',');
+	  stabstr_I (DECL_ASSEMBLER_NAME (decl));
+	  stabstr_C (',');
+	  stabstr_I (DECL_NAME (context));
+	}
+
+      dbxout_finish_complex_stabs (decl, N_FUN, XEXP (decl_rtl, 0), 0, 0);
+      break;
+
+    case TYPE_DECL:
+      /* Don't output the same typedef twice.
+         And don't output what language-specific stuff doesn't want output.  */
+      if (TREE_ASM_WRITTEN (decl) || TYPE_DECL_SUPPRESS_DEBUG (decl))
+	DBXOUT_DECR_NESTING_AND_RETURN (0);
+
+      /* Don't output typedefs for types with magic type numbers (XCOFF).  */
+#ifdef DBX_ASSIGN_FUNDAMENTAL_TYPE_NUMBER
+      {
+	int fundamental_type_number =
+	  DBX_ASSIGN_FUNDAMENTAL_TYPE_NUMBER (decl);
+
+	if (fundamental_type_number != 0)
+	  {
+	    TREE_ASM_WRITTEN (decl) = 1;
+	    TYPE_SYMTAB_ADDRESS (TREE_TYPE (decl)) = fundamental_type_number;
+	    DBXOUT_DECR_NESTING_AND_RETURN (0);
+	  }
+      }
+#endif
+      FORCE_TEXT;
+      result = 1;
+      {
+	int tag_needed = 1;
+	int did_output = 0;
+
+	if (DECL_NAME (decl))
+	  {
+	    /* Nonzero means we must output a tag as well as a typedef.  */
+	    tag_needed = 0;
+
+	    /* Handle the case of a C++ structure or union
+	       where the TYPE_NAME is a TYPE_DECL
+	       which gives both a typedef name and a tag.  */
+	    /* dbx requires the tag first and the typedef second.  */
+	    if ((TREE_CODE (type) == RECORD_TYPE
+		 || TREE_CODE (type) == UNION_TYPE
+		 || TREE_CODE (type) == QUAL_UNION_TYPE)
+		&& TYPE_NAME (type) == decl
+		&& !use_gnu_debug_info_extensions
+		&& !TREE_ASM_WRITTEN (TYPE_NAME (type))
+		/* Distinguish the implicit typedefs of C++
+		   from explicit ones that might be found in C.  */
+		&& DECL_ARTIFICIAL (decl)
+                /* Do not generate a tag for incomplete records.  */
+                && COMPLETE_TYPE_P (type)
+		/* Do not generate a tag for records of variable size,
+		   since this type cannot be properly described in the
+		   DBX format, and it confuses some tools such as objdump.  */
+		&& tree_fits_uhwi_p (TYPE_SIZE (type)))
+	      {
+		tree name = TYPE_IDENTIFIER (type);
+
+		dbxout_begin_complex_stabs ();
+		stabstr_I (name);
+		stabstr_S (":T");
+		dbxout_type (type, 1);
+		dbxout_finish_complex_stabs (0, DBX_TYPE_DECL_STABS_CODE,
+					     0, 0, 0);
+	      }
+
+	    dbxout_begin_complex_stabs ();
+
+	    /* Output leading class/struct qualifiers.  */
+	    if (use_gnu_debug_info_extensions)
+	      dbxout_class_name_qualifiers (decl);
+
+	    /* Output typedef name.  */
+	    stabstr_I (DECL_NAME (decl));
+	    stabstr_C (':');
+
+	    /* Short cut way to output a tag also.  */
+	    if ((TREE_CODE (type) == RECORD_TYPE
+		 || TREE_CODE (type) == UNION_TYPE
+		 || TREE_CODE (type) == QUAL_UNION_TYPE)
+		&& TYPE_NAME (type) == decl
+		/* Distinguish the implicit typedefs of C++
+		   from explicit ones that might be found in C.  */
+		&& DECL_ARTIFICIAL (decl))
+	      {
+		if (use_gnu_debug_info_extensions)
+		  {
+		    stabstr_C ('T');
+		    TREE_ASM_WRITTEN (TYPE_NAME (type)) = 1;
+		  }
+	      }
+
+	    stabstr_C ('t');
+	    dbxout_type (type, 1);
+	    dbxout_finish_complex_stabs (decl, DBX_TYPE_DECL_STABS_CODE,
+					 0, 0, 0);
+	    did_output = 1;
+	  }
+
+	/* Don't output a tag if this is an incomplete type.  This prevents
+	   the sun4 Sun OS 4.x dbx from crashing.  */
+
+	if (tag_needed && TYPE_NAME (type) != 0
+	    && (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE
+		|| (DECL_NAME (TYPE_NAME (type)) != 0))
+	    && COMPLETE_TYPE_P (type)
+	    && !TREE_ASM_WRITTEN (TYPE_NAME (type)))
+	  {
+	    /* For a TYPE_DECL with no name, but the type has a name,
+	       output a tag.
+	       This is what represents `struct foo' with no typedef.  */
+	    /* In C++, the name of a type is the corresponding typedef.
+	       In C, it is an IDENTIFIER_NODE.  */
+	    tree name = TYPE_IDENTIFIER (type);
+
+	    dbxout_begin_complex_stabs ();
+	    stabstr_I (name);
+	    stabstr_S (":T");
+	    dbxout_type (type, 1);
+	    dbxout_finish_complex_stabs (0, DBX_TYPE_DECL_STABS_CODE, 0, 0, 0);
+	    did_output = 1;
+	  }
+
+	/* If an enum type has no name, it cannot be referred to, but
+	   we must output it anyway, to record the enumeration
+	   constants.  */
+
+	if (!did_output && TREE_CODE (type) == ENUMERAL_TYPE)
+	  {
+	    dbxout_begin_complex_stabs ();
+	    /* Some debuggers fail when given NULL names, so give this a
+	       harmless name of " " (Why not "(anon)"?).  */
+	    stabstr_S (" :T");
+	    dbxout_type (type, 1);
+	    dbxout_finish_complex_stabs (0, DBX_TYPE_DECL_STABS_CODE, 0, 0, 0);
+	  }
+
+	/* Prevent duplicate output of a typedef.  */
+	TREE_ASM_WRITTEN (decl) = 1;
+	break;
+      }
+
+    case PARM_DECL:
+      if (DECL_HAS_VALUE_EXPR_P (decl))
+	decl = DECL_VALUE_EXPR (decl);
+
+      /* PARM_DECLs go in their own separate chain and are output by
+	 dbxout_reg_parms and dbxout_parms, except for those that are
+	 disguised VAR_DECLs like Out parameters in Ada.  */
+      gcc_assert (VAR_P (decl));
+
+      /* fall through */
+
+    case RESULT_DECL:
+    case VAR_DECL:
+      /* Don't mention a variable that is external.
+	 Let the file that defines it describe it.  */
+      if (DECL_EXTERNAL (decl))
+	break;
+
+      /* If the variable is really a constant
+	 and not written in memory, inform the debugger.
+
+	 ??? Why do we skip emitting the type and location in this case?  */
+      if (TREE_STATIC (decl) && TREE_READONLY (decl)
+	  && DECL_INITIAL (decl) != 0
+	  && tree_fits_shwi_p (DECL_INITIAL (decl))
+	  && ! TREE_ASM_WRITTEN (decl)
+	  && (DECL_FILE_SCOPE_P (decl)
+	      || TREE_CODE (DECL_CONTEXT (decl)) == BLOCK
+	      || TREE_CODE (DECL_CONTEXT (decl)) == NAMESPACE_DECL)
+	  && TREE_PUBLIC (decl) == 0)
+	{
+	  /* The sun4 assembler does not grok this.  */
+
+	  if (TREE_CODE (TREE_TYPE (decl)) == INTEGER_TYPE
+	      || TREE_CODE (TREE_TYPE (decl)) == ENUMERAL_TYPE)
+	    {
+	      HOST_WIDE_INT ival = tree_to_shwi (DECL_INITIAL (decl));
+
+	      dbxout_begin_complex_stabs ();
+	      dbxout_symbol_name (decl, NULL, 'c');
+	      stabstr_S ("=i");
+	      stabstr_D (ival);
+	      dbxout_finish_complex_stabs (0, N_LSYM, 0, 0, 0);
+	      DBXOUT_DECR_NESTING;
+	      return 1;
+	    }
+	  else
+	    break;
+	}
+      /* else it is something we handle like a normal variable.  */
+
+      decl_rtl = dbxout_expand_expr (decl);
+      if (!decl_rtl)
+	DBXOUT_DECR_NESTING_AND_RETURN (0);
+
+      if (!is_global_var (decl))
+	decl_rtl = eliminate_regs (decl_rtl, VOIDmode, NULL_RTX);
+#ifdef LEAF_REG_REMAP
+      if (crtl->uses_only_leaf_regs)
+	leaf_renumber_regs_insn (decl_rtl);
+#endif
+
+      result = dbxout_symbol_location (decl, type, 0, decl_rtl);
+      break;
+
+    default:
+      break;
+    }
+  DBXOUT_DECR_NESTING;
+  return result;
+}
+
+/* Output the stab for DECL, a VAR_DECL, RESULT_DECL or PARM_DECL.
+   Add SUFFIX to its name, if SUFFIX is not 0.
+   Describe the variable as residing in HOME
+   (usually HOME is DECL_RTL (DECL), but not always).
+   Returns 1 if the stab was really emitted.  */
+
+static int
+dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)
+{
+  int letter = 0;
+  stab_code_type code;
+  rtx addr = 0;
+  int number = 0;
+  int regno = -1;
+
+  /* Don't mention a variable at all
+     if it was completely optimized into nothingness.
+
+     If the decl was from an inline function, then its rtl
+     is not identically the rtl that was used in this
+     particular compilation.  */
+  if (GET_CODE (home) == SUBREG)
+    {
+      rtx value = home;
+
+      while (GET_CODE (value) == SUBREG)
+	value = SUBREG_REG (value);
+      if (REG_P (value))
+	{
+	  if (REGNO (value) >= FIRST_PSEUDO_REGISTER)
+	    return 0;
+	}
+      home = alter_subreg (&home, true);
+    }
+  if (REG_P (home))
+    {
+      regno = REGNO (home);
+      if (regno >= FIRST_PSEUDO_REGISTER)
+	return 0;
+    }
+
+  /* The kind-of-variable letter depends on where
+     the variable is and on the scope of its name:
+     G and N_GSYM for static storage and global scope,
+     S for static storage and file scope,
+     V for static storage and local scope,
+     for those two, use N_LCSYM if data is in bss segment,
+     N_STSYM if in data segment, N_FUN otherwise.
+     (We used N_FUN originally, then changed to N_STSYM
+     to please GDB.  However, it seems that confused ld.
+     Now GDB has been fixed to like N_FUN, says Kingdon.)
+     no letter at all, and N_LSYM, for auto variable,
+     r and N_RSYM for register variable.  */
+
+  if (MEM_P (home) && GET_CODE (XEXP (home, 0)) == SYMBOL_REF)
+    {
+      if (TREE_PUBLIC (decl))
+	{
+	  int offs;
+	  letter = 'G';
+	  code = N_GSYM;
+	  if (dbxout_common_check (decl, &offs) != NULL)
+	    {
+	      letter = 'V';
+	      addr = 0;
+	      number = offs;
+	    }
+	}
+      else
+	{
+	  addr = XEXP (home, 0);
+
+	  letter = decl_function_context (decl) ? 'V' : 'S';
+
+	  /* Some ports can transform a symbol ref into a label ref,
+	     because the symbol ref is too far away and has to be
+	     dumped into a constant pool.  Alternatively, the symbol
+	     in the constant pool might be referenced by a different
+	     symbol.  */
+	  if (GET_CODE (addr) == SYMBOL_REF
+	      && CONSTANT_POOL_ADDRESS_P (addr))
+	    {
+	      bool marked;
+	      rtx tmp = get_pool_constant_mark (addr, &marked);
+
+	      if (GET_CODE (tmp) == SYMBOL_REF)
+		{
+		  addr = tmp;
+		  if (CONSTANT_POOL_ADDRESS_P (addr))
+		    get_pool_constant_mark (addr, &marked);
+		  else
+		    marked = true;
+		}
+	      else if (GET_CODE (tmp) == LABEL_REF)
+		{
+		  addr = tmp;
+		  marked = true;
+		}
+
+	      /* If all references to the constant pool were optimized
+		 out, we just ignore the symbol.  */
+	      if (!marked)
+		return 0;
+	    }
+
+	  /* This should be the same condition as in assemble_variable, but
+	     we don't have access to dont_output_data here.  So, instead,
+	     we rely on the fact that error_mark_node initializers always
+	     end up in bss for C++ and never end up in bss for C.  */
+	  if (DECL_INITIAL (decl) == 0
+	      || (lang_GNU_CXX ()
+		  && DECL_INITIAL (decl) == error_mark_node))
+	    {
+	      int offs;
+	      code = N_LCSYM;
+	      if (dbxout_common_check (decl, &offs) != NULL)
+	        {
+		  addr = 0;
+		  number = offs;
+		  letter = 'V';
+		  code = N_GSYM;
+		}
+	    }
+	  else if (DECL_IN_TEXT_SECTION (decl))
+	    /* This is not quite right, but it's the closest
+	       of all the codes that Unix defines.  */
+	    code = DBX_STATIC_CONST_VAR_CODE;
+	  else
+	    {
+	      /* Ultrix `as' seems to need this.  */
+#ifdef DBX_STATIC_STAB_DATA_SECTION
+	      switch_to_section (data_section);
+#endif
+	      code = N_STSYM;
+	    }
+	}
+    }
+  else if (regno >= 0)
+    {
+      letter = 'r';
+      code = N_RSYM;
+      number = DEBUGGER_REGNO (regno);
+    }
+  else if (MEM_P (home)
+	   && (MEM_P (XEXP (home, 0))
+	       || (REG_P (XEXP (home, 0))
+		   && REGNO (XEXP (home, 0)) != HARD_FRAME_POINTER_REGNUM
+		   && REGNO (XEXP (home, 0)) != STACK_POINTER_REGNUM
+#if !HARD_FRAME_POINTER_IS_ARG_POINTER
+		   && REGNO (XEXP (home, 0)) != ARG_POINTER_REGNUM
+#endif
+		   )))
+    /* If the value is indirect by memory or by a register
+       that isn't the frame pointer
+       then it means the object is variable-sized and address through
+       that register or stack slot.  DBX has no way to represent this
+       so all we can do is output the variable as a pointer.
+       If it's not a parameter, ignore it.  */
+    {
+      if (REG_P (XEXP (home, 0)))
+	{
+	  letter = 'r';
+	  code = N_RSYM;
+	  if (REGNO (XEXP (home, 0)) >= FIRST_PSEUDO_REGISTER)
+	    return 0;
+	  number = DEBUGGER_REGNO (REGNO (XEXP (home, 0)));
+	}
+      else
+	{
+	  code = N_LSYM;
+	  /* RTL looks like (MEM (MEM (PLUS (REG...) (CONST_INT...)))).
+	     We want the value of that CONST_INT.  */
+	  number = DEBUGGER_AUTO_OFFSET (XEXP (XEXP (home, 0), 0));
+	}
+
+      /* Effectively do build_pointer_type, but don't cache this type,
+	 since it might be temporary whereas the type it points to
+	 might have been saved for inlining.  */
+      /* Don't use REFERENCE_TYPE because dbx can't handle that.  */
+      type = make_node (POINTER_TYPE);
+      TREE_TYPE (type) = TREE_TYPE (decl);
+    }
+  else if (MEM_P (home)
+	   && REG_P (XEXP (home, 0)))
+    {
+      code = N_LSYM;
+      number = DEBUGGER_AUTO_OFFSET (XEXP (home, 0));
+    }
+  else if (MEM_P (home)
+	   && GET_CODE (XEXP (home, 0)) == PLUS
+	   && CONST_INT_P (XEXP (XEXP (home, 0), 1)))
+    {
+      code = N_LSYM;
+      /* RTL looks like (MEM (PLUS (REG...) (CONST_INT...)))
+	 We want the value of that CONST_INT.  */
+      number = DEBUGGER_AUTO_OFFSET (XEXP (home, 0));
+    }
+  else if (MEM_P (home)
+	   && GET_CODE (XEXP (home, 0)) == CONST)
+    {
+      /* Handle an obscure case which can arise when optimizing and
+	 when there are few available registers.  (This is *always*
+	 the case for i386/i486 targets).  The RTL looks like
+	 (MEM (CONST ...)) even though this variable is a local `auto'
+	 or a local `register' variable.  In effect, what has happened
+	 is that the reload pass has seen that all assignments and
+	 references for one such a local variable can be replaced by
+	 equivalent assignments and references to some static storage
+	 variable, thereby avoiding the need for a register.  In such
+	 cases we're forced to lie to debuggers and tell them that
+	 this variable was itself `static'.  */
+      int offs;
+      code = N_LCSYM;
+      letter = 'V';
+      if (dbxout_common_check (decl, &offs) == NULL)
+        addr = XEXP (XEXP (home, 0), 0);
+      else
+        {
+	  addr = 0;
+	  number = offs;
+	  code = N_GSYM;
+	}
+    }
+  else if (GET_CODE (home) == CONCAT)
+    {
+      tree subtype;
+
+      /* If TYPE is not a COMPLEX_TYPE (it might be a RECORD_TYPE,
+	 for example), then there is no easy way to figure out
+	 what SUBTYPE should be.  So, we give up.  */
+      if (TREE_CODE (type) != COMPLEX_TYPE)
+	return 0;
+
+      subtype = TREE_TYPE (type);
+
+      /* If the variable's storage is in two parts,
+	 output each as a separate stab with a modified name.  */
+      if (WORDS_BIG_ENDIAN)
+	dbxout_symbol_location (decl, subtype, "$imag", XEXP (home, 0));
+      else
+	dbxout_symbol_location (decl, subtype, "$real", XEXP (home, 0));
+
+      if (WORDS_BIG_ENDIAN)
+	dbxout_symbol_location (decl, subtype, "$real", XEXP (home, 1));
+      else
+	dbxout_symbol_location (decl, subtype, "$imag", XEXP (home, 1));
+      return 1;
+    }
+  else
+    /* Address might be a MEM, when DECL is a variable-sized object.
+       Or it might be const0_rtx, meaning previous passes
+       want us to ignore this variable.  */
+    return 0;
+
+  /* Ok, start a symtab entry and output the variable name.  */
+  emit_pending_bincls_if_required ();
+  FORCE_TEXT;
+
+#ifdef DBX_STATIC_BLOCK_START
+  DBX_STATIC_BLOCK_START (asm_out_file, code);
+#endif
+
+  dbxout_begin_complex_stabs_noforcetext ();
+  dbxout_symbol_name (decl, suffix, letter);
+  dbxout_type (type, 0);
+  dbxout_finish_complex_stabs (decl, code, addr, 0, number);
+
+#ifdef DBX_STATIC_BLOCK_END
+  DBX_STATIC_BLOCK_END (asm_out_file, code);
+#endif
+  return 1;
+}
+
+/* Output the symbol name of DECL for a stabs, with suffix SUFFIX.
+   Then output LETTER to indicate the kind of location the symbol has.  */
+
+static void
+dbxout_symbol_name (tree decl, const char *suffix, int letter)
+{
+  tree name;
+
+  if (DECL_CONTEXT (decl)
+      && (TYPE_P (DECL_CONTEXT (decl))
+	  || TREE_CODE (DECL_CONTEXT (decl)) == NAMESPACE_DECL))
+    /* One slight hitch: if this is a VAR_DECL which is a class member
+       or a namespace member, we must put out the mangled name instead of the
+       DECL_NAME.  Note also that static member (variable) names DO NOT begin
+       with underscores in .stabs directives.  */
+    name = DECL_ASSEMBLER_NAME (decl);
+  else
+    /* ...but if we're function-local, we don't want to include the junk
+       added by ASM_FORMAT_PRIVATE_NAME.  */
+    name = DECL_NAME (decl);
+
+  if (name)
+    stabstr_I (name);
+  else
+    stabstr_S ("(anon)");
+
+  if (suffix)
+    stabstr_S (suffix);
+  stabstr_C (':');
+  if (letter)
+    stabstr_C (letter);
+}
+
+
+/* Output the common block name for DECL in a stabs.
+
+   Symbols in global common (.comm) get wrapped with an N_BCOMM/N_ECOMM pair
+   around each group of symbols in the same .comm area.  The N_GSYM stabs
+   that are emitted only contain the offset in the common area.  This routine
+   emits the N_BCOMM and N_ECOMM stabs.  */
+
+static void
+dbxout_common_name (tree decl, const char *name, stab_code_type op)
+{
+  dbxout_begin_complex_stabs ();
+  stabstr_S (name);
+  dbxout_finish_complex_stabs (decl, op, NULL_RTX, NULL, 0);
+}
+
+/* Check decl to determine whether it is a VAR_DECL destined for storage in a
+   common area.  If it is, the return value will be a non-null string giving
+   the name of the common storage block it will go into.  If non-null, the
+   value is the offset into the common block for that symbol's storage.  */
+
+static const char *
+dbxout_common_check (tree decl, int *value)
+{
+  rtx home;
+  rtx sym_addr;
+  const char *name = NULL;
+
+  /* If the decl isn't a VAR_DECL, or if it isn't static, or if
+     it does not have a value (the offset into the common area), or if it
+     is thread local (as opposed to global) then it isn't common, and shouldn't
+     be handled as such.
+
+     ??? DECL_THREAD_LOCAL_P check prevents problems with improper .stabs
+     for thread-local symbols.  Can be handled via same mechanism as used
+     in dwarf2out.cc.  */
+  if (!VAR_P (decl)
+      || !TREE_STATIC (decl)
+      || !DECL_HAS_VALUE_EXPR_P (decl)
+      || DECL_THREAD_LOCAL_P (decl)
+      || !is_fortran ())
+    return NULL;
+
+  home = DECL_RTL (decl);
+  if (home == NULL_RTX || GET_CODE (home) != MEM)
+    return NULL;
+
+  sym_addr = dbxout_expand_expr (DECL_VALUE_EXPR (decl));
+  if (sym_addr == NULL_RTX || GET_CODE (sym_addr) != MEM)
+    return NULL;
+
+  sym_addr = XEXP (sym_addr, 0);
+  if (GET_CODE (sym_addr) == CONST)
+    sym_addr = XEXP (sym_addr, 0);
+  if ((GET_CODE (sym_addr) == SYMBOL_REF || GET_CODE (sym_addr) == PLUS)
+      && DECL_INITIAL (decl) == 0)
+    {
+
+      /* We have a sym that will go into a common area, meaning that it
+         will get storage reserved with a .comm/.lcomm assembler pseudo-op.
+
+         Determine name of common area this symbol will be an offset into,
+         and offset into that area.  Also retrieve the decl for the area
+         that the symbol is offset into.  */
+      tree cdecl = NULL;
+
+      switch (GET_CODE (sym_addr))
+        {
+        case PLUS:
+          if (CONST_INT_P (XEXP (sym_addr, 0)))
+            {
+              name =
+                targetm.strip_name_encoding (XSTR (XEXP (sym_addr, 1), 0));
+              *value = INTVAL (XEXP (sym_addr, 0));
+              cdecl = SYMBOL_REF_DECL (XEXP (sym_addr, 1));
+            }
+          else
+            {
+              name =
+                targetm.strip_name_encoding (XSTR (XEXP (sym_addr, 0), 0));
+              *value = INTVAL (XEXP (sym_addr, 1));
+              cdecl = SYMBOL_REF_DECL (XEXP (sym_addr, 0));
+            }
+          break;
+
+        case SYMBOL_REF:
+          name = targetm.strip_name_encoding (XSTR (sym_addr, 0));
+          *value = 0;
+          cdecl = SYMBOL_REF_DECL (sym_addr);
+          break;
+
+        default:
+          error ("common symbol debug info is not structured as "
+                 "symbol+offset");
+        }
+
+      /* Check area common symbol is offset into.  If this is not public, then
+         it is not a symbol in a common block.  It must be a .lcomm symbol, not
+         a .comm symbol.  */
+      if (cdecl == NULL || !TREE_PUBLIC (cdecl))
+        name = NULL;
+    }
+  else
+    name = NULL;
+
+  return name;
+}
+
+/* Output definitions of all the decls in a chain. Return nonzero if
+   anything was output */
+
+int
+dbxout_syms (tree syms)
+{
+  int result = 0;
+  const char *comm_prev = NULL;
+  tree syms_prev = NULL;
+
+  while (syms)
+    {
+      int temp, copen, cclos;
+      const char *comm_new;
+
+      /* Check for common symbol, and then progression into a new/different
+         block of common symbols.  Emit closing/opening common bracket if
+         necessary.  */
+      comm_new = dbxout_common_check (syms, &temp);
+      copen = comm_new != NULL
+              && (comm_prev == NULL || strcmp (comm_new, comm_prev));
+      cclos = comm_prev != NULL
+              && (comm_new == NULL || strcmp (comm_new, comm_prev));
+      if (cclos)
+        dbxout_common_name (syms_prev, comm_prev, N_ECOMM);
+      if (copen)
+        {
+          dbxout_common_name (syms, comm_new, N_BCOMM);
+          syms_prev = syms;
+        }
+      comm_prev = comm_new;
+
+      result += dbxout_symbol (syms, 1);
+      syms = DECL_CHAIN (syms);
+    }
+
+  if (comm_prev != NULL)
+    dbxout_common_name (syms_prev, comm_prev, N_ECOMM);
+
+  return result;
+}
+
+/* The following two functions output definitions of function parameters.
+   Each parameter gets a definition locating it in the parameter list.
+   Each parameter that is a register variable gets a second definition
+   locating it in the register.
+
+   Printing or argument lists in gdb uses the definitions that
+   locate in the parameter list.  But reference to the variable in
+   expressions uses preferentially the definition as a register.  */
+
+/* Output definitions, referring to storage in the parmlist,
+   of all the parms in PARMS, which is a chain of PARM_DECL nodes.  */
+
+void
+dbxout_parms (tree parms)
+{
+  ++debug_nesting;
+  emit_pending_bincls_if_required ();
+  fixed_size_mode rtl_mode, type_mode;
+
+  for (; parms; parms = DECL_CHAIN (parms))
+    if (DECL_NAME (parms)
+	&& TREE_TYPE (parms) != error_mark_node
+	&& DECL_RTL_SET_P (parms)
+	&& DECL_INCOMING_RTL (parms)
+	/* We can't represent variable-sized types in this format.  */
+	&& is_a <fixed_size_mode> (TYPE_MODE (TREE_TYPE (parms)), &type_mode)
+	&& is_a <fixed_size_mode> (GET_MODE (DECL_RTL (parms)), &rtl_mode))
+      {
+	tree eff_type;
+	char letter;
+	stab_code_type code;
+	int number;
+
+	/* Perform any necessary register eliminations on the parameter's rtl,
+	   so that the debugging output will be accurate.  */
+	DECL_INCOMING_RTL (parms)
+	  = eliminate_regs (DECL_INCOMING_RTL (parms), VOIDmode, NULL_RTX);
+	SET_DECL_RTL (parms,
+		      eliminate_regs (DECL_RTL (parms), VOIDmode, NULL_RTX));
+#ifdef LEAF_REG_REMAP
+	if (crtl->uses_only_leaf_regs)
+	  {
+	    leaf_renumber_regs_insn (DECL_INCOMING_RTL (parms));
+	    leaf_renumber_regs_insn (DECL_RTL (parms));
+	  }
+#endif
+
+	if (PARM_PASSED_IN_MEMORY (parms))
+	  {
+	    rtx inrtl = XEXP (DECL_INCOMING_RTL (parms), 0);
+
+	    /* ??? Here we assume that the parm address is indexed
+	       off the frame pointer or arg pointer.
+	       If that is not true, we produce meaningless results,
+	       but do not crash.  */
+	    if (GET_CODE (inrtl) == PLUS
+		&& CONST_INT_P (XEXP (inrtl, 1)))
+	      number = INTVAL (XEXP (inrtl, 1));
+	    else
+	      number = 0;
+
+	    code = N_PSYM;
+	    number = DEBUGGER_ARG_OFFSET (number, inrtl);
+	    letter = 'p';
+
+	    /* It is quite tempting to use TREE_TYPE (parms) instead
+	       of DECL_ARG_TYPE (parms) for the eff_type, so that gcc
+	       reports the actual type of the parameter, rather than
+	       the promoted type.  This certainly makes GDB's life
+	       easier, at least for some ports.  The change is a bad
+	       idea however, since GDB expects to be able access the
+	       type without performing any conversions.  So for
+	       example, if we were passing a float to an unprototyped
+	       function, gcc will store a double on the stack, but if
+	       we emit a stab saying the type is a float, then gdb
+	       will only read in a single value, and this will produce
+	       an erroneous value.  */
+	    eff_type = DECL_ARG_TYPE (parms);
+	  }
+	else if (REG_P (DECL_RTL (parms)))
+	  {
+	    rtx best_rtl;
+
+	    /* Parm passed in registers and lives in registers or nowhere.  */
+	    code = DBX_REGPARM_STABS_CODE;
+	    letter = DBX_REGPARM_STABS_LETTER;
+
+	    /* For parms passed in registers, it is better to use the
+	       declared type of the variable, not the type it arrived in.  */
+	    eff_type = TREE_TYPE (parms);
+
+	    /* If parm lives in a register, use that register; pretend
+	       the parm was passed there.  It would be more consistent
+	       to describe the register where the parm was passed, but
+	       in practice that register usually holds something else.
+	       If the parm lives nowhere, use the register where it
+	       was passed.  */
+	    if (REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER)
+	      best_rtl = DECL_RTL (parms);
+	    else if (GET_CODE (DECL_INCOMING_RTL (parms)) == PARALLEL)
+	      best_rtl = XEXP (XVECEXP (DECL_INCOMING_RTL (parms), 0, 0), 0);
+	    else
+	      best_rtl = DECL_INCOMING_RTL (parms);
+
+	    number = DEBUGGER_REGNO (REGNO (best_rtl));
+	  }
+	else if (MEM_P (DECL_RTL (parms))
+		 && REG_P (XEXP (DECL_RTL (parms), 0))
+		 && REGNO (XEXP (DECL_RTL (parms), 0)) != HARD_FRAME_POINTER_REGNUM
+		 && REGNO (XEXP (DECL_RTL (parms), 0)) != STACK_POINTER_REGNUM
+#if !HARD_FRAME_POINTER_IS_ARG_POINTER
+		 && REGNO (XEXP (DECL_RTL (parms), 0)) != ARG_POINTER_REGNUM
+#endif
+		 )
+	  {
+	    /* Parm was passed via invisible reference.
+	       That is, its address was passed in a register.
+	       Output it as if it lived in that register.
+	       The debugger will know from the type
+	       that it was actually passed by invisible reference.  */
+
+	    code = DBX_REGPARM_STABS_CODE;
+
+	    /* GDB likes this marked with a special letter.  */
+	    letter = (use_gnu_debug_info_extensions
+		      ? 'a' : DBX_REGPARM_STABS_LETTER);
+	    eff_type = TREE_TYPE (parms);
+
+	    /* DECL_RTL looks like (MEM (REG...).  Get the register number.
+	       If it is an unallocated pseudo-reg, then use the register where
+	       it was passed instead.
+	       ??? Why is DEBUGGER_REGNO not used here?  */
+
+	    if (REGNO (XEXP (DECL_RTL (parms), 0)) < FIRST_PSEUDO_REGISTER)
+	      number = REGNO (XEXP (DECL_RTL (parms), 0));
+	    else
+	      number = REGNO (DECL_INCOMING_RTL (parms));
+	  }
+	else if (MEM_P (DECL_RTL (parms))
+		 && MEM_P (XEXP (DECL_RTL (parms), 0)))
+	  {
+	    /* Parm was passed via invisible reference, with the reference
+	       living on the stack.  DECL_RTL looks like
+	       (MEM (MEM (PLUS (REG ...) (CONST_INT ...)))) or it
+	       could look like (MEM (MEM (REG))).  */
+
+	    code = N_PSYM;
+	    letter = 'v';
+	    eff_type = TREE_TYPE (parms);
+
+	    if (!REG_P (XEXP (XEXP (DECL_RTL (parms), 0), 0)))
+	      number = INTVAL (XEXP (XEXP (XEXP (DECL_RTL (parms), 0), 0), 1));
+	    else
+	      number = 0;
+
+	    number = DEBUGGER_ARG_OFFSET (number,
+					  XEXP (XEXP (DECL_RTL (parms), 0), 0));
+	  }
+	else if (MEM_P (DECL_RTL (parms))
+		 && XEXP (DECL_RTL (parms), 0) != const0_rtx
+		 /* ??? A constant address for a parm can happen
+		    when the reg it lives in is equiv to a constant in memory.
+		    Should make this not happen, after 2.4.  */
+		 && ! CONSTANT_P (XEXP (DECL_RTL (parms), 0)))
+	  {
+	    /* Parm was passed in registers but lives on the stack.  */
+
+	    code = N_PSYM;
+	    letter = 'p';
+	    eff_type = TREE_TYPE (parms);
+
+	    /* DECL_RTL looks like (MEM (PLUS (REG...) (CONST_INT...))),
+	       in which case we want the value of that CONST_INT,
+	       or (MEM (REG ...)),
+	       in which case we use a value of zero.  */
+	    if (!REG_P (XEXP (DECL_RTL (parms), 0)))
+	      number = INTVAL (XEXP (XEXP (DECL_RTL (parms), 0), 1));
+	    else
+	      number = 0;
+
+	    /* Make a big endian correction if the mode of the type of the
+	       parameter is not the same as the mode of the rtl.  */
+	    if (BYTES_BIG_ENDIAN
+		&& type_mode != rtl_mode
+		&& GET_MODE_SIZE (type_mode) < UNITS_PER_WORD)
+	      number += GET_MODE_SIZE (rtl_mode) - GET_MODE_SIZE (type_mode);
+	  }
+	else
+	  /* ??? We don't know how to represent this argument.  */
+	  continue;
+
+	dbxout_begin_complex_stabs ();
+
+	if (DECL_NAME (parms))
+	  {
+	    stabstr_I (DECL_NAME (parms));
+	    stabstr_C (':');
+	  }
+	else
+	  stabstr_S ("(anon):");
+	stabstr_C (letter);
+	dbxout_type (eff_type, 0);
+	dbxout_finish_complex_stabs (parms, code, 0, 0, number);
+      }
+  DBXOUT_DECR_NESTING;
+}
+
+/* Output definitions for the places where parms live during the function,
+   when different from where they were passed, when the parms were passed
+   in memory.
+
+   It is not useful to do this for parms passed in registers
+   that live during the function in different registers, because it is
+   impossible to look in the passed register for the passed value,
+   so we use the within-the-function register to begin with.
+
+   PARMS is a chain of PARM_DECL nodes.  */
+
+void
+dbxout_reg_parms (tree parms)
+{
+  ++debug_nesting;
+
+  for (; parms; parms = DECL_CHAIN (parms))
+    if (DECL_NAME (parms) && PARM_PASSED_IN_MEMORY (parms))
+      {
+	/* Report parms that live in registers during the function
+	   but were passed in memory.  */
+	if (REG_P (DECL_RTL (parms))
+	    && REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER)
+	  dbxout_symbol_location (parms, TREE_TYPE (parms),
+				  0, DECL_RTL (parms));
+	else if (GET_CODE (DECL_RTL (parms)) == CONCAT)
+	  dbxout_symbol_location (parms, TREE_TYPE (parms),
+				  0, DECL_RTL (parms));
+	/* Report parms that live in memory but not where they were passed.  */
+	else if (MEM_P (DECL_RTL (parms))
+		 && ! rtx_equal_p (DECL_RTL (parms), DECL_INCOMING_RTL (parms)))
+	  dbxout_symbol_location (parms, TREE_TYPE (parms),
+				  0, DECL_RTL (parms));
+      }
+  DBXOUT_DECR_NESTING;
+}
+
+/* Given a chain of ..._TYPE nodes (as come in a parameter list),
+   output definitions of those names, in raw form */
+
+static void
+dbxout_args (tree args)
+{
+  while (args)
+    {
+      stabstr_C (',');
+      dbxout_type (TREE_VALUE (args), 0);
+      args = TREE_CHAIN (args);
+    }
+}
+
+#if defined (DBX_DEBUGGING_INFO)
+
+/* Subroutine of dbxout_block.  Emit an N_LBRAC stab referencing LABEL.
+   BEGIN_LABEL is the name of the beginning of the function, which may
+   be required.  */
+static void
+dbx_output_lbrac (const char *label,
+		  const char *begin_label ATTRIBUTE_UNUSED)
+{
+  dbxout_begin_stabn (N_LBRAC);
+  if (DBX_BLOCKS_FUNCTION_RELATIVE)
+    dbxout_stab_value_label_diff (label, begin_label);
+  else
+    dbxout_stab_value_label (label);
+}
+
+/* Subroutine of dbxout_block.  Emit an N_RBRAC stab referencing LABEL.
+   BEGIN_LABEL is the name of the beginning of the function, which may
+   be required.  */
+static void
+dbx_output_rbrac (const char *label,
+		  const char *begin_label ATTRIBUTE_UNUSED)
+{
+  dbxout_begin_stabn (N_RBRAC);
+  if (DBX_BLOCKS_FUNCTION_RELATIVE)
+    dbxout_stab_value_label_diff (label, begin_label);
+  else
+    dbxout_stab_value_label (label);
+}
+
+/* Return true if at least one block among BLOCK, its children or siblings
+   has TREE_USED, TREE_ASM_WRITTEN and BLOCK_IN_COLD_SECTION_P
+   set.  If there is none, clear TREE_USED bit on such blocks.  */
+
+static bool
+dbx_block_with_cold_children (tree block)
+{
+  bool ret = false;
+  for (; block; block = BLOCK_CHAIN (block))
+    if (TREE_USED (block) && TREE_ASM_WRITTEN (block))
+      {
+	bool children = dbx_block_with_cold_children (BLOCK_SUBBLOCKS (block));
+	if (BLOCK_IN_COLD_SECTION_P (block) || children)
+	  ret = true;
+	else
+	  TREE_USED (block) = false;
+      }
+  return ret;
+}
+
+/* Output everything about a symbol block (a BLOCK node
+   that represents a scope level),
+   including recursive output of contained blocks.
+
+   BLOCK is the BLOCK node.
+   DEPTH is its depth within containing symbol blocks.
+   ARGS is usually zero; but for the outermost block of the
+   body of a function, it is a chain of PARM_DECLs for the function parameters.
+   We output definitions of all the register parms
+   as if they were local variables of that block.
+
+   If -g1 was used, we count blocks just the same, but output nothing
+   except for the outermost block.
+
+   Actually, BLOCK may be several blocks chained together.
+   We handle them all in sequence.
+
+   Return true if we emitted any LBRAC/RBRAC.  */
+
+static bool
+dbxout_block (tree block, int depth, tree args, int parent_blocknum)
+{
+  bool ret = false;
+  char begin_label[20];
+  /* Reference current function start using LFBB.  */
+  ASM_GENERATE_INTERNAL_LABEL (begin_label, "LFBB", scope_labelno);
+
+  /* If called for the second partition, ignore blocks that don't have
+     any children in the second partition.  */
+  if (crtl->has_bb_partition && in_cold_section_p && depth == 0)
+    dbx_block_with_cold_children (block);
+
+  for (; block; block = BLOCK_CHAIN (block))
+    {
+      /* Ignore blocks never expanded or otherwise marked as real.  */
+      if (TREE_USED (block) && TREE_ASM_WRITTEN (block))
+	{
+	  int did_output;
+	  int blocknum = BLOCK_NUMBER (block);
+	  int this_parent = parent_blocknum;
+
+	  /* In dbx format, the syms of a block come before the N_LBRAC.
+	     If nothing is output, we don't need the N_LBRAC, either.  */
+	  did_output = 0;
+	  if (debug_info_level != DINFO_LEVEL_TERSE || depth == 0)
+	    did_output = dbxout_syms (BLOCK_VARS (block));
+	  if (args)
+	    dbxout_reg_parms (args);
+
+	  /* Now output an N_LBRAC symbol to represent the beginning of
+	     the block.  Use the block's tree-walk order to generate
+	     the assembler symbols LBBn and LBEn
+	     that final will define around the code in this block.  */
+	  if (did_output
+	      && BLOCK_IN_COLD_SECTION_P (block) == in_cold_section_p)
+	    {
+	      char buf[20];
+	      const char *scope_start;
+
+	      ret = true;
+	      if (depth == 0)
+		/* The outermost block doesn't get LBB labels; use
+		   the LFBB local symbol emitted by dbxout_begin_prologue.  */
+		scope_start = begin_label;
+	      else
+		{
+		  ASM_GENERATE_INTERNAL_LABEL (buf, "LBB", blocknum);
+		  scope_start = buf;
+		  this_parent = blocknum;
+		}
+
+	      dbx_output_lbrac (scope_start, begin_label);
+	    }
+
+	  /* Output the subblocks.  */
+	  bool children
+	    = dbxout_block (BLOCK_SUBBLOCKS (block), depth + 1, NULL_TREE,
+			    this_parent);
+	  ret |= children;
+
+	  /* Refer to the marker for the end of the block.  */
+	  if (did_output
+	      && BLOCK_IN_COLD_SECTION_P (block) == in_cold_section_p)
+	    {
+	      char buf[100];
+	      if (depth == 0)
+		/* The outermost block doesn't get LBE labels;
+		   use the "scope" label which will be emitted
+		   by dbxout_function_end.  */
+		ASM_GENERATE_INTERNAL_LABEL (buf, "Lscope", scope_labelno);
+	      else
+		ASM_GENERATE_INTERNAL_LABEL (buf, "LBE", blocknum);
+
+	      dbx_output_rbrac (buf, begin_label);
+	    }
+	  else if (did_output && !children)
+	    {
+	      /* If we emitted any vars and didn't output any LBRAC/RBRAC,
+		 either at this level or any lower level, we need to emit
+		 an empty LBRAC/RBRAC pair now.  */
+	      char buf[30];
+	      const char *scope_start;
+
+	      ret = true;
+	      if (parent_blocknum == -1)
+		scope_start = begin_label;
+	      else
+		{
+		  ASM_GENERATE_INTERNAL_LABEL (buf, "LBB", parent_blocknum);
+		  scope_start = buf;
+		}
+
+	      dbx_output_lbrac (scope_start, begin_label);
+	      dbx_output_rbrac (scope_start, begin_label);
+	    }
+	}
+    }
+  return ret;
+}
+
+/* Output the information about a function and its arguments and result.
+   Usually this follows the function's code,
+   but on some systems, it comes before.  */
+
+static void
+dbxout_begin_function (tree decl)
+{
+  int saved_tree_used1;
+
+  saved_tree_used1 = TREE_USED (decl);
+  TREE_USED (decl) = 1;
+  if (DECL_NAME (DECL_RESULT (decl)) != 0)
+    {
+      int saved_tree_used2 = TREE_USED (DECL_RESULT (decl));
+      TREE_USED (DECL_RESULT (decl)) = 1;
+      dbxout_symbol (decl, 0);
+      TREE_USED (DECL_RESULT (decl)) = saved_tree_used2;
+    }
+  else
+    dbxout_symbol (decl, 0);
+  TREE_USED (decl) = saved_tree_used1;
+
+  dbxout_parms (DECL_ARGUMENTS (decl));
+  if (DECL_NAME (DECL_RESULT (decl)) != 0)
+    dbxout_symbol (DECL_RESULT (decl), 1);
+}
+#endif /* DBX_DEBUGGING_INFO */
+
+#endif /* DBX_DEBUGGING_INFO || XCOFF_DEBUGGING_INFO */
+
+/* Record an element in the table of global destructors.  SYMBOL is
+   a SYMBOL_REF of the function to be called; PRIORITY is a number
+   between 0 and MAX_INIT_PRIORITY.  */
+
+void
+default_stabs_asm_out_destructor (rtx symbol ATTRIBUTE_UNUSED,
+				  int priority ATTRIBUTE_UNUSED)
+{
+#if defined DBX_DEBUGGING_INFO || defined XCOFF_DEBUGGING_INFO
+  /* Tell GNU LD that this is part of the static destructor set.
+     This will work for any system that uses stabs, most usefully
+     aout systems.  */
+  dbxout_begin_simple_stabs ("___DTOR_LIST__", 22 /* N_SETT */);
+  dbxout_stab_value_label (XSTR (symbol, 0));
+#else
+  sorry ("global destructors not supported on this target");
+#endif
+}
+
+/* Likewise for global constructors.  */
+
+void
+default_stabs_asm_out_constructor (rtx symbol ATTRIBUTE_UNUSED,
+				   int priority ATTRIBUTE_UNUSED)
+{
+#if defined DBX_DEBUGGING_INFO || defined XCOFF_DEBUGGING_INFO
+  /* Tell GNU LD that this is part of the static destructor set.
+     This will work for any system that uses stabs, most usefully
+     aout systems.  */
+  dbxout_begin_simple_stabs ("___CTOR_LIST__", 22 /* N_SETT */);
+  dbxout_stab_value_label (XSTR (symbol, 0));
+#else
+  sorry ("global constructors not supported on this target");
+#endif
+}
+
+#include "gt-dbxout.h"
diff --git a/gcc/dbxout.h b/gcc/dbxout.h
new file mode 100644
index 00000000000..2c38e76c238
--- /dev/null
+++ b/gcc/dbxout.h
@@ -0,0 +1,60 @@
+/* dbxout.h - Various declarations for functions found in dbxout.cc
+   Copyright (C) 1998-2022 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef GCC_DBXOUT_H
+#define GCC_DBXOUT_H
+
+extern int dbxout_symbol (tree, int);
+extern void dbxout_parms (tree);
+extern void dbxout_reg_parms (tree);
+extern int dbxout_syms (tree);
+
+extern void default_stabs_asm_out_destructor (rtx, int);
+extern void default_stabs_asm_out_constructor (rtx, int);
+
+/* dbxout helper functions */
+#if defined DBX_DEBUGGING_INFO || defined XCOFF_DEBUGGING_INFO
+
+extern void dbxout_int (int);
+extern void dbxout_stabd (int, int);
+extern void dbxout_begin_stabn (int);
+extern void dbxout_begin_stabn_sline (int);
+extern void dbxout_begin_empty_stabs (int);
+extern void dbxout_begin_simple_stabs (const char *, int);
+extern void dbxout_begin_simple_stabs_desc (const char *, int, int);
+
+extern void dbxout_stab_value_zero (void);
+extern void dbxout_stab_value_label (const char *);
+extern void dbxout_stab_value_label_diff (const char *, const char *);
+extern void dbxout_stab_value_internal_label (const char *, int *);
+extern void dbxout_stab_value_internal_label_diff (const char *, int *,
+						   const char *);
+#endif
+
+/* Language description for N_SO stabs.  */
+#define N_SO_AS          1
+#define N_SO_C           2
+#define N_SO_ANSI_C      3
+#define N_SO_CC          4 /* c++*/
+#define N_SO_FORTRAN     5
+#define N_SO_FORTRAN90   7
+#define N_SO_OBJC        50
+#define N_SO_OBJCPLUS    51
+
+#endif /* GCC_DBXOUT_H */
diff --git a/gcc/debug.h b/gcc/debug.h
index 259881a5494..7778d88eaaf 100644
--- a/gcc/debug.h
+++ b/gcc/debug.h
@@ -239,6 +239,7 @@ extern void debug_nothing_tree_charstar_uhwi (tree, const char *,
 
 /* Hooks for various debug formats.  */
 extern const struct gcc_debug_hooks do_nothing_debug_hooks;
+extern const struct gcc_debug_hooks dbx_debug_hooks;
 extern const struct gcc_debug_hooks xcoff_debug_hooks;
 extern const struct gcc_debug_hooks dwarf2_debug_hooks;
 extern const struct gcc_debug_hooks dwarf2_lineno_debug_hooks;
diff --git a/gcc/diagnostic-color.cc b/gcc/diagnostic-color.cc
index b3bd6f997c6..33373c8bb71 100644
--- a/gcc/diagnostic-color.cc
+++ b/gcc/diagnostic-color.cc
@@ -28,6 +28,90 @@
 #  include <windows.h>
 #endif
 
+/* Select Graphic Rendition (SGR, "\33[...m") strings.  */
+/* Also Erase in Line (EL) to Right ("\33[K") by default.  */
+/*    Why have EL to Right after SGR?
+	 -- The behavior of line-wrapping when at the bottom of the
+	    terminal screen and at the end of the current line is often
+	    such that a new line is introduced, entirely cleared with
+	    the current background color which may be different from the
+	    default one (see the boolean back_color_erase terminfo(5)
+	    capability), thus scrolling the display by one line.
+	    The end of this new line will stay in this background color
+	    even after reverting to the default background color with
+	    "\33[m', unless it is explicitly cleared again with "\33[K"
+	    (which is the behavior the user would instinctively expect
+	    from the whole thing).  There may be some unavoidable
+	    background-color flicker at the end of this new line because
+	    of this (when timing with the monitor's redraw is just right).
+	 -- The behavior of HT (tab, "\t") is usually the same as that of
+	    Cursor Forward Tabulation (CHT) with a default parameter
+	    of 1 ("\33[I"), i.e., it performs pure movement to the next
+	    tab stop, without any clearing of either content or screen
+	    attributes (including background color); try
+	       printf 'asdfqwerzxcv\rASDF\tZXCV\n'
+	    in a bash(1) shell to demonstrate this.  This is not what the
+	    user would instinctively expect of HT (but is ok for CHT).
+	    The instinctive behavior would include clearing the terminal
+	    cells that are skipped over by HT with blank cells in the
+	    current screen attributes, including background color;
+	    the boolean dest_tabs_magic_smso terminfo(5) capability
+	    indicates this saner behavior for HT, but only some rare
+	    terminals have it (although it also indicates a special
+	    glitch with standout mode in the Teleray terminal for which
+	    it was initially introduced).  The remedy is to add "\33K"
+	    after each SGR sequence, be it START (to fix the behavior
+	    of any HT after that before another SGR) or END (to fix the
+	    behavior of an HT in default background color that would
+	    follow a line-wrapping at the bottom of the screen in another
+	    background color, and to complement doing it after START).
+	    Piping GCC's output through a pager such as less(1) avoids
+	    any HT problems since the pager performs tab expansion.
+
+      Generic disadvantages of this remedy are:
+	 -- Some very rare terminals might support SGR but not EL (nobody
+	    will use "gcc -fdiagnostics-color" on a terminal that does not
+	    support SGR in the first place).
+	 -- Having these extra control sequences might somewhat complicate
+	    the task of any program trying to parse "gcc -fdiagnostics-color"
+	    output in order to extract structuring information from it.
+      A specific disadvantage to doing it after SGR START is:
+	 -- Even more possible background color flicker (when timing
+	    with the monitor's redraw is just right), even when not at the
+	    bottom of the screen.
+      There are no additional disadvantages specific to doing it after
+      SGR END.
+
+      It would be impractical for GCC to become a full-fledged
+      terminal program linked against ncurses or the like, so it will
+      not detect terminfo(5) capabilities.  */
+#define COLOR_SEPARATOR		";"
+#define COLOR_NONE		"00"
+#define COLOR_BOLD		"01"
+#define COLOR_UNDERSCORE	"04"
+#define COLOR_BLINK		"05"
+#define COLOR_REVERSE		"07"
+#define COLOR_FG_BLACK		"30"
+#define COLOR_FG_RED		"31"
+#define COLOR_FG_GREEN		"32"
+#define COLOR_FG_YELLOW		"33"
+#define COLOR_FG_BLUE		"34"
+#define COLOR_FG_MAGENTA	"35"
+#define COLOR_FG_CYAN		"36"
+#define COLOR_FG_WHITE		"37"
+#define COLOR_BG_BLACK		"40"
+#define COLOR_BG_RED		"41"
+#define COLOR_BG_GREEN		"42"
+#define COLOR_BG_YELLOW		"43"
+#define COLOR_BG_BLUE		"44"
+#define COLOR_BG_MAGENTA	"45"
+#define COLOR_BG_CYAN		"46"
+#define COLOR_BG_WHITE		"47"
+#define SGR_START		"\33["
+#define SGR_END			"m\33[K"
+#define SGR_SEQ(str)		SGR_START str SGR_END
+#define SGR_RESET		SGR_SEQ("")
+
 #include "color-macros.h"
 #include "selftest.h"
 
diff --git a/gcc/explow.cc b/gcc/explow.cc
index 7799a98053b..cb64436c34b 100644
--- a/gcc/explow.cc
+++ b/gcc/explow.cc
@@ -1629,7 +1629,12 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,
       stack_pointer_delta = saved_stack_pointer_delta;
 
       if (STACK_GROWS_DOWNWARD)
+	{
 	emit_move_insn (target, force_operand (addr, target));
+#ifdef STACK_CHECK_ATARI
+	m68k_emit_stack_check();
+#endif
+	}
     }
 
   suppress_reg_args_size = false;
diff --git a/gcc/file-find.cc b/gcc/file-find.cc
index ecdca50fe5e..37427ca2d99 100644
--- a/gcc/file-find.cc
+++ b/gcc/file-find.cc
@@ -22,6 +22,20 @@ along with GCC; see the file COPYING3.  If not see
 #include "filenames.h"
 #include "file-find.h"
 
+/*
+ * these are from xm-mingw32.h, but this is only included
+ * for the target; we need those definitions here also
+ * when using MinGW as host for a cross-compiler
+ */
+#if defined(__MSDOS__) || defined(_WIN32) || defined(__OS2__) || defined (__CYGWIN__)
+#undef HOST_EXECUTABLE_SUFFIX
+#define HOST_EXECUTABLE_SUFFIX ".exe"
+#endif
+#if defined(__MSDOS__) || defined(_WIN32) || defined(__OS2__)
+#undef PATH_SEPARATOR
+#define PATH_SEPARATOR ';'
+#endif
+
 static bool debug = false;
 
 void
diff --git a/gcc/final.cc b/gcc/final.cc
index 12c6eb0ac09..dc103eaa9d6 100644
--- a/gcc/final.cc
+++ b/gcc/final.cc
@@ -86,6 +86,10 @@ along with GCC; see the file COPYING3.  If not see
 
 #include "dwarf2out.h"
 
+#ifdef DBX_DEBUGGING_INFO
+#include "dbxout.h"
+#endif
+
 /* Most ports don't need to define CC_STATUS_INIT.
    So define a null default for it to save conditionalization later.  */
 #ifndef CC_STATUS_INIT
@@ -2311,6 +2315,19 @@ final_scan_insn_1 (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,
 	      TREE_ASM_WRITTEN (NOTE_BLOCK (insn)) = 1;
 	      BLOCK_IN_COLD_SECTION_P (NOTE_BLOCK (insn)) = in_cold_section_p;
 	    }
+	  if (write_symbols == DBX_DEBUG)
+	    {
+	      location_t *locus_ptr
+		= block_nonartificial_location (NOTE_BLOCK (insn));
+
+	      if (locus_ptr != NULL)
+		{
+		  override_filename = LOCATION_FILE (*locus_ptr);
+		  override_linenum = LOCATION_LINE (*locus_ptr);
+		  override_columnnum = LOCATION_COLUMN (*locus_ptr);
+		  override_discriminator = compute_discriminator (*locus_ptr);
+		}
+	    }
 	  break;
 
 	case NOTE_INSN_BLOCK_END:
@@ -2333,6 +2350,27 @@ final_scan_insn_1 (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,
 	      gcc_assert (BLOCK_IN_COLD_SECTION_P (NOTE_BLOCK (insn))
 			  == in_cold_section_p);
 	    }
+	  if (write_symbols == DBX_DEBUG)
+	    {
+	      tree outer_block = BLOCK_SUPERCONTEXT (NOTE_BLOCK (insn));
+	      location_t *locus_ptr
+		= block_nonartificial_location (outer_block);
+
+	      if (locus_ptr != NULL)
+		{
+		  override_filename = LOCATION_FILE (*locus_ptr);
+		  override_linenum = LOCATION_LINE (*locus_ptr);
+		  override_columnnum = LOCATION_COLUMN (*locus_ptr);
+		  override_discriminator = compute_discriminator (*locus_ptr);
+		}
+	      else
+		{
+		  override_filename = NULL;
+		  override_linenum = 0;
+		  override_columnnum = 0;
+		  override_discriminator = 0;
+		}
+	    }
 	  break;
 
 	case NOTE_INSN_DELETED_LABEL:
@@ -4270,6 +4308,8 @@ rest_of_handle_final (void)
   if (! quiet_flag)
     fflush (asm_out_file);
 
+  /* Write DBX symbols if requested.  */
+
   /* Note that for those inline functions where we don't initially
      know for certain that we will be generating an out-of-line copy,
      the first invocation of this routine (rest_of_compilation) will
diff --git a/gcc/flag-types.h b/gcc/flag-types.h
index 9a3cc4a2e16..f80286e754a 100644
--- a/gcc/flag-types.h
+++ b/gcc/flag-types.h
@@ -25,7 +25,8 @@ along with GCC; see the file COPYING3.  If not see
 enum debug_info_type
 {
   DINFO_TYPE_NONE,		  /* No debug info.  */
-  DINFO_TYPE_DWARF2,		  /* Dwarf v2 debug info.  */
+  DINFO_TYPE_DBX,		  /* BSD .stabs for DBX.  */
+  DINFO_TYPE_DWARF2,	  /* Dwarf v2 debug info.  */
   DINFO_TYPE_VMS,		  /* VMS debug info.  */
   DINFO_TYPE_CTF,		  /* CTF debug info.  */
   DINFO_TYPE_BTF,		  /* BTF debug info.  */
@@ -35,6 +36,8 @@ enum debug_info_type
 };
 
 #define NO_DEBUG      (0U)
+/* Write DBX debug info (using dbxout.cc).  */
+#define DBX_DEBUG     (1U << DINFO_TYPE_DBX)
 /* Write DWARF2 debug info (using dwarf2out.cc).  */
 #define DWARF2_DEBUG  (1U << DINFO_TYPE_DWARF2)
 /* Write VMS debug info (using vmsdbgout.cc).  */
diff --git a/gcc/fortran/Make-lang.in b/gcc/fortran/Make-lang.in
index 5b2f921bf2e..7b7472440c0 100644
--- a/gcc/fortran/Make-lang.in
+++ b/gcc/fortran/Make-lang.in
@@ -85,7 +85,7 @@ gfortran$(exeext): $(GFORTRAN_D_OBJS) $(EXTRA_GCC_OBJS) libcommon-target.a \
 	$(LIBDEPS)
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \
 	  $(GFORTRAN_D_OBJS) $(EXTRA_GCC_OBJS) libcommon-target.a \
-	  $(EXTRA_GCC_LIBS) $(LIBS)
+	  $(EXTRA_GCC_LIBS) $(LIBS) $(GLIBC_SO)
 
 # Create a version of the gfortran driver which calls the cross-compiler.
 gfortran-cross$(exeext): gfortran$(exeext)
@@ -97,7 +97,7 @@ f951$(exeext): $(F95_OBJS) $(BACKEND) $(LIBDEPS) attribs.o $(fortran.prev)
 	@$(call LINK_PROGRESS,$(INDEX.fortran),start)
 	+$(LLINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \
 		$(F95_OBJS) $(BACKEND) $(ZLIB) $(LIBS) attribs.o \
-		$(BACKENDLIBS)
+		$(BACKENDLIBS) $(GLIBC_SO)
 	@$(call LINK_PROGRESS,$(INDEX.fortran),end)
 
 gt-fortran-trans.h    : s-gtype; @true
diff --git a/gcc/gcc-ar.cc b/gcc/gcc-ar.cc
index 2bf727a268d..48361e09778 100644
--- a/gcc/gcc-ar.cc
+++ b/gcc/gcc-ar.cc
@@ -122,6 +122,8 @@ setup_prefixes (const char *exec_path)
   prefix_from_env ("PATH", &path);
 }
 
+#include "libcmain.h"
+
 int
 main (int ac, char **av)
 {
diff --git a/gcc/gcc-main.cc b/gcc/gcc-main.cc
index 9754b0887ee..0eb47604fad 100644
--- a/gcc/gcc-main.cc
+++ b/gcc/gcc-main.cc
@@ -38,6 +38,8 @@ along with GCC; see the file COPYING3.  If not see
 
 extern int main (int, char **);
 
+#include "libcmain.h"
+
 int
 main (int argc, char **argv)
 {
diff --git a/gcc/gcc.cc b/gcc/gcc.cc
index 4fd87f2c4a1..de763b3ab31 100644
--- a/gcc/gcc.cc
+++ b/gcc/gcc.cc
@@ -54,6 +54,27 @@ compilation is specified by a string called a "spec".  */
 #include "gcc-urlifier.h"
 #include "opts-diagnostic.h"
 
+/*
+ * these are from xm-mingw32.h, but this is only included
+ * for the target; we need those definitions here also
+ * when using MinGW as host for a cross-compiler
+ */
+#ifdef __MINGW32__
+#undef HOST_BIT_BUCKET
+#undef HOST_BIT_BUCKET2
+#undef HOST_EXECUTABLE_SUFFIX
+/* This is the name of the null device on windows.  */
+#define HOST_BIT_BUCKET "nul"
+#define HOST_BIT_BUCKET2 "/dev/null"
+#define HOST_EXECUTABLE_SUFFIX ".exe"
+#endif
+
+#if defined(__MSDOS__) || defined(_WIN32) || defined(__OS2__)
+#  define HOST_LACKS_INODE_NUMBERS 1
+#  undef PATH_SEPARATOR
+#  define PATH_SEPARATOR ';'
+#endif
+
 #ifndef MATH_LIBRARY
 #define MATH_LIBRARY "m"
 #endif
@@ -954,11 +975,26 @@ proper position among the other output files.  */
 # else
 #  define ASM_DEBUG_DWARF_OPTION "--gdwarf2"
 # endif
+# if defined(DBX_DEBUGGING_INFO) && defined(DWARF2_DEBUGGING_INFO) \
+     && defined(HAVE_AS_GDWARF2_DEBUG_FLAG) && defined(HAVE_AS_GSTABS_DEBUG_FLAG)
+#  define ASM_DEBUG_SPEC						\
+      (PREFERRED_DEBUGGING_TYPE == DBX_DEBUG				\
+       ? "%{%:debug-level-gt(0):"					\
+	 "%{gdwarf*:" ASM_DEBUG_DWARF_OPTION "};"			\
+	 ":%{g*:--gstabs}}" ASM_MAP					\
+       : "%{%:debug-level-gt(0):"					\
+	 "%{gstabs*:--gstabs;"						\
+	 ":%{g*:" ASM_DEBUG_DWARF_OPTION "}}}" ASM_MAP)
+# else
+#  if defined(DBX_DEBUGGING_INFO) && defined(HAVE_AS_GSTABS_DEBUG_FLAG)
+#   define ASM_DEBUG_SPEC "%{g*:%{%:debug-level-gt(0):--gstabs}}" ASM_MAP
+#  endif
 #  if defined(DWARF2_DEBUGGING_INFO) && defined(HAVE_AS_GDWARF2_DEBUG_FLAG)
 #   define ASM_DEBUG_SPEC "%{g*:%{%:debug-level-gt(0):" \
 	ASM_DEBUG_DWARF_OPTION "}}" ASM_MAP
 #  endif
 # endif
+#endif
 #ifndef ASM_DEBUG_SPEC
 # define ASM_DEBUG_SPEC ""
 #endif
@@ -972,7 +1008,14 @@ proper position among the other output files.  */
 	"%:dwarf-version-gt(3):--gdwarf-4 ;"				\
 	"%:dwarf-version-gt(2):--gdwarf-3 ;"				\
 	":--gdwarf2 }"
-# if defined(DWARF2_DEBUGGING_INFO)
+#  if defined(DBX_DEBUGGING_INFO) && defined(DWARF2_DEBUGGING_INFO)
+#  define ASM_DEBUG_OPTION_SPEC						\
+      (PREFERRED_DEBUGGING_TYPE == DBX_DEBUG				\
+       ? "%{%:debug-level-gt(0):"					\
+	 "%{gdwarf*:" ASM_DEBUG_OPTION_DWARF_OPT "}}" 			\
+       : "%{%:debug-level-gt(0):"					\
+	 "%{!gstabs*:%{g*:" ASM_DEBUG_OPTION_DWARF_OPT "}}}")
+# elif defined(DWARF2_DEBUGGING_INFO)
 #   define ASM_DEBUG_OPTION_SPEC "%{g*:%{%:debug-level-gt(0):" \
 	ASM_DEBUG_OPTION_DWARF_OPT "}}"
 #  endif
@@ -5076,7 +5119,8 @@ process_command (unsigned int decoded_options_count,
 
   if (output_file
       && strcmp (output_file, "-") != 0
-      && strcmp (output_file, HOST_BIT_BUCKET) != 0)
+      && strcmp (output_file, HOST_BIT_BUCKET) != 0
+      && strcmp (output_file, HOST_BIT_BUCKET2) != 0)
     {
       int i;
       for (i = 0; i < n_infiles; i++)
@@ -7722,6 +7766,13 @@ print_configuration (FILE *file)
 #endif
 
   fnotice (file, "Thread model: %s\n", thrmod);
+  enum unwind_info_type unwind_info = targetm_common.except_unwind_info (&global_options);
+  fnotice (file, "Exceptions: %s\n",
+    unwind_info == UI_NONE ? "none" :
+    unwind_info == UI_SJLJ ? "SJLJ" :
+    unwind_info == UI_DWARF2 ? "Dwarf2" :
+    unwind_info == UI_SEH ? "SEH" :
+    "target");
   fnotice (file, "Supported LTO compression algorithms: zlib");
 #ifdef HAVE_ZSTD_H
   fnotice (file, " zstd");
diff --git a/gcc/gcov-dump.cc b/gcc/gcov-dump.cc
index cc7f8a9ebfb..6331604cdd0 100644
--- a/gcc/gcov-dump.cc
+++ b/gcc/gcov-dump.cc
@@ -84,6 +84,8 @@ static const tag_format_t tag_table[] =
   {0, NULL, NULL}
 };
 
+#include "libcmain.h"
+
 int
 main (int argc ATTRIBUTE_UNUSED, char **argv)
 {
diff --git a/gcc/gcov-tool.cc b/gcc/gcov-tool.cc
index d8f2790b110..05926d6f026 100644
--- a/gcc/gcov-tool.cc
+++ b/gcc/gcov-tool.cc
@@ -54,7 +54,7 @@ extern void gcov_set_verbose (void);
 /* Set to verbose output mode.  */
 static bool verbose;
 
-#if HAVE_FTW_H
+#if defined(HAVE_FTW_H) && defined(FTW_DEPTH)
 
 /* Remove file NAME if it has a gcda suffix. */
 
@@ -83,7 +83,7 @@ unlink_gcda_file (const char *name,
 static int
 unlink_profile_dir (const char *path ATTRIBUTE_UNUSED)
 {
-#if HAVE_FTW_H
+#if defined(HAVE_FTW_H) && defined(FTW_DEPTH)
     return nftw(path, unlink_gcda_file, 64, FTW_DEPTH | FTW_PHYS);
 #else
     return -1;
@@ -635,6 +635,8 @@ process_args (int argc, char **argv)
   return optind;
 }
 
+#include "libcmain.h"
+
 /* Main function for gcov-tool.  */
 
 int
diff --git a/gcc/gcov.cc b/gcc/gcov.cc
index e1ad80162b3..241d61a1ce8 100644
--- a/gcc/gcov.cc
+++ b/gcc/gcov.cc
@@ -1030,6 +1030,8 @@ get_cycles_count (line_info &linfo)
   return count;
 }
 
+#include "libcmain.h"
+
 int
 main (int argc, char **argv)
 {
diff --git a/gcc/ggc-common.cc b/gcc/ggc-common.cc
index 426671e9564..2b67bb2f0b4 100644
--- a/gcc/ggc-common.cc
+++ b/gcc/ggc-common.cc
@@ -778,6 +778,8 @@ gt_pch_restore (FILE *f)
   size_t i;
   struct mmap_info mmi;
   int result;
+  long pch_tabs_off;
+  long pch_data_off;
 
   /* We are about to reload the line maps along with the rest of the PCH
      data, which means that the (loaded) ones cannot be guaranteed to be
@@ -793,19 +795,22 @@ gt_pch_restore (FILE *f)
     for (rti = *rt; rti->base != NULL; rti++)
       memset (rti->base, 0, rti->stride);
 
-  /* Read in all the scalar variables.  */
+  /* We need to read tables after mapping, or fatal_error will
+     segfault when gt_pch_use_address returns -1. Skip them for now. */
+  pch_tabs_off = ftell(f);
+     
+  /* Skip all the scalar variables. */
   for (rt = gt_pch_scalar_rtab; *rt; rt++)
     for (rti = *rt; rti->base != NULL; rti++)
-      if (fread (rti->base, rti->stride, 1, f) != 1)
-	fatal_error (input_location, "cannot read PCH file: %m");
+      if (fseek (f, rti->stride, SEEK_CUR) != 0)
+        fatal_error (input_location, "cannot read PCH file: %m");
 
-  /* Read in all the global pointers, in 6 easy loops.  */
+  /* Skip all the global pointers. */
   bool error_reading_pointers = false;
   for (rt = gt_ggc_rtab; *rt; rt++)
     for (rti = *rt; rti->base != NULL; rti++)
       for (i = 0; i < rti->nelt; i++)
-	if (fread ((char *)rti->base + rti->stride * i,
-		   sizeof (void *), 1, f) != 1)
+        if (fseek (f, sizeof (void *), SEEK_CUR) != 0)
 	  error_reading_pointers = true;
 
   /* Stash the newly read-in line table pointer - it does not point to
@@ -815,6 +820,7 @@ gt_pch_restore (FILE *f)
   if (error_reading_pointers)
     fatal_error (input_location, "cannot read PCH file: %m");
 
+  /* mmi still has to be read now. */          
   if (fread (&mmi, sizeof (mmi), 1, f) != 1)
     fatal_error (input_location, "cannot read PCH file: %m");
 
@@ -844,6 +850,30 @@ gt_pch_restore (FILE *f)
   else if (fseek (f, mmi.offset + mmi.size, SEEK_SET) != 0)
     fatal_error (input_location, "cannot read PCH file: %m");
 
+    
+  /* File mapping done, read tables now. */
+  pch_data_off = ftell(f);
+  
+  if (fseek (f, pch_tabs_off, SEEK_SET) != 0)
+    fatal_error (input_location, "cannot read PCH file: %m");
+
+  /* Read in all the scalar variables.  */
+  for (rt = gt_pch_scalar_rtab; *rt; rt++)
+    for (rti = *rt; rti->base != NULL; rti++)
+      if (fread (rti->base, rti->stride, 1, f) != 1)
+        fatal_error (input_location, "cannot read PCH file: %m");
+
+  /* Read in all the global pointers, in 6 easy loops.  */
+  for (rt = gt_ggc_rtab; *rt; rt++)
+    for (rti = *rt; rti->base != NULL; rti++)
+      for (i = 0; i < rti->nelt; i++)
+        if (fread ((char *)rti->base + rti->stride * i,
+            sizeof (void *), 1, f) != 1)
+          fatal_error (input_location, "cannot read PCH file: %m");
+
+  if (fseek (f, pch_data_off, SEEK_SET) != 0)
+    fatal_error (input_location, "cannot read PCH file: %m");
+            
   size_t reloc_addrs_size;
   if (fread (&reloc_addrs_size, sizeof (reloc_addrs_size), 1, f) != 1)
     fatal_error (input_location, "cannot read PCH file: %m");
diff --git a/gcc/glibc.so b/gcc/glibc.so
new file mode 100644
index 00000000000..408ef8ba856
--- /dev/null
+++ b/gcc/glibc.so
@@ -0,0 +1,3 @@
+/* GNU ld script  */
+OUTPUT_FORMAT(elf64-x86-64)
+GROUP ( /lib64/libdl.so.2 /lib64/libc.so.6 /usr/lib64/libc_nonshared.a AS_NEEDED ( /lib64/ld-linux-x86-64.so.2 ) )
diff --git a/gcc/go/gospec.cc b/gcc/go/gospec.cc
index 2943499edcd..99d44492294 100644
--- a/gcc/go/gospec.cc
+++ b/gcc/go/gospec.cc
@@ -215,6 +215,8 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,
 	case OPT_gdwarf:
 	case OPT_gdwarf_:
 	case OPT_ggdb:
+	case OPT_gstabs:
+	case OPT_gstabs_:
 	case OPT_gvms:
 	  saw_opt_g = true;
 	  break;
diff --git a/gcc/gstab.h b/gcc/gstab.h
new file mode 100644
index 00000000000..c597d1200b4
--- /dev/null
+++ b/gcc/gstab.h
@@ -0,0 +1,35 @@
+/* Copyright (C) 1997-2022 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef GCC_GSTAB_H
+#define GCC_GSTAB_H
+
+#define __define_stab(NAME, CODE, STRING) NAME=CODE,
+
+enum
+{
+#include "stab.def"
+LAST_UNUSED_STAB_CODE
+};
+
+/* stabs debug codes really are integers with expressive names.  */
+typedef int stab_code_type;
+
+#undef __define_stab
+
+#endif /* ! GCC_GSTAB_H */
diff --git a/gcc/incpath.cc b/gcc/incpath.cc
index c1bbfd3872a..532806df72b 100644
--- a/gcc/incpath.cc
+++ b/gcc/incpath.cc
@@ -27,6 +27,12 @@
 #include "incpath.h"
 #include "cppdefault.h"
 
+#if defined(__MSDOS__) || defined(_WIN32) || defined(__OS2__)
+#  define HOST_LACKS_INODE_NUMBERS 1
+#  undef PATH_SEPARATOR
+#  define PATH_SEPARATOR ';'
+#endif
+
 /* Microsoft Windows does not natively support inodes.
    VMS has non-numeric inodes.  */
 #ifdef VMS
@@ -183,10 +189,17 @@ add_standard_paths (const char *sysroot, const char *iprefix,
 	    {
 	      char *sysroot_no_trailing_dir_separator = xstrdup (sysroot);
 	      size_t sysroot_len = strlen (sysroot);
+	      const char *fname;
 
 	      if (sysroot_len > 0 && sysroot[sysroot_len - 1] == DIR_SEPARATOR)
 		sysroot_no_trailing_dir_separator[sysroot_len - 1] = '\0';
-	      str = concat (sysroot_no_trailing_dir_separator, p->fname, NULL);
+	      fname = p->fname;
+#if defined(__MSDOS__) || defined(_WIN32) || defined(__OS2__)
+	      /* skip the C:/msys64/ part of p->fname */
+	      if (HAS_DRIVE_SPEC(fname))
+		fname = strchr(fname + 3, DIR_SEPARATOR);
+#endif
+	      str = concat (sysroot_no_trailing_dir_separator, fname, NULL);
 	      free (sysroot_no_trailing_dir_separator);
 	    }
 	  else if (!p->add_sysroot && relocated
diff --git a/gcc/input.cc b/gcc/input.cc
index fabfbfb6eaa..851529d5f8e 100644
--- a/gcc/input.cc
+++ b/gcc/input.cc
@@ -2673,12 +2673,14 @@ class ebcdic_execution_charset : public lexer_test_options
     gcc_assert (s_singleton);
     /* Avoid exgettext from picking this up, it is translated in libcpp.  */
     const char *msg = "conversion from %s to %s not supported by iconv";
+    const char *msg2 = "no iconv implementation, cannot convert from %s to %s";
 #ifdef ENABLE_NLS
     msg = dgettext ("cpplib", msg);
+    msg2 = dgettext ("cpplib", msg2);
 #endif
     /* Detect and record errors emitted by libcpp/charset.cc:init_iconv_desc
        when the local iconv build doesn't support the conversion.  */
-    if (strcmp (msgid, msg) == 0)
+    if (strcmp (msgid, msg) == 0 || strcmp (msgid, msg2) == 0)
       {
 	s_singleton->m_num_iconv_errors++;
 	return true;
diff --git a/gcc/libcmain.h b/gcc/libcmain.h
new file mode 100644
index 00000000000..311fea9acca
--- /dev/null
+++ b/gcc/libcmain.h
@@ -0,0 +1,39 @@
+#if defined(__LINUX_GLIBC_WRAP_H)
+
+/* ugly hack to get __libc_start_main versioned */
+
+#if __GLIBC_PREREQ(2, 34)
+
+#define STR_(s) #s
+#define STR(s)  STR_(s)
+#include <dlfcn.h>
+
+#ifdef __UCLIBC__
+#define __libc_start_main       __uClibc_main
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+int __libc_start_main(
+	int (*main)(int,char**,char**), int ac, char **av,
+	int (*init)(void), void (*fini)(void),
+	void (*rtld_fini)(void), void *stack_end);
+int __libc_start_main(
+	int (*main)(int,char**,char**), int ac, char **av,
+	int (*init)(void), void (*fini)(void),
+	void (*rtld_fini)(void), void *stack_end)
+{
+	typeof(__libc_start_main) *real_lsm;
+	if ((*(void**)&real_lsm = dlsym(RTLD_NEXT, STR(__libc_start_main))) != 0)
+		return real_lsm(main, ac, av, init, fini, rtld_fini, stack_end);
+	fputs("BUG: dlsym error\n", stderr);
+	return 1;
+}
+#ifdef __cplusplus
+}
+#endif
+#undef STR
+#undef STR_
+#endif
+#endif
diff --git a/gcc/libcwrap.h b/gcc/libcwrap.h
new file mode 100644
index 00000000000..f4cc6aea365
--- /dev/null
+++ b/gcc/libcwrap.h
@@ -0,0 +1,1561 @@
+/* glibc bindings for target ABI version glibc 2.14 */
+#if defined(__linux__) && !defined (__LIBC_CUSTOM_BINDINGS_H__) && !defined(__ANDROID__)
+
+#if defined(__x86_64__)
+
+#define __LINUX_GLIBC_WRAP_H
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+#undef SYMVER
+#undef SYMVER1
+#ifdef __ASSEMBLER__
+#define SYMVER1(name, ver) .symver name, name##@##ver
+#else
+#define SYMVER1(name, ver) __asm__(".symver " #name ", " #name "@" #ver );
+#endif
+#define SYMVER(name, ver) SYMVER1(name, ver)
+
+
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+#include <features.h>
+
+/*
+ * avoid references to __isoc23_strtol*,
+ * which are only available in glibc >= 2.38
+ */
+#undef __GLIBC_USE_C2X_STRTOL
+#define __GLIBC_USE_C2X_STRTOL 0
+
+
+/* Symbols redirected to earlier glibc versions */
+SYMVER(__libc_start_main, GLIBC_2.2.5)
+SYMVER(__libpthread_version_placeholder, GLIBC_2.12)
+SYMVER(__mq_open_2, GLIBC_2.7)
+SYMVER(__pthread_cleanup_routine, GLIBC_2.3.3)
+SYMVER(__pthread_key_create, GLIBC_2.2.5)
+SYMVER(__pthread_register_cancel, GLIBC_2.3.3)
+SYMVER(__pthread_register_cancel_defer, GLIBC_2.3.3)
+SYMVER(__pthread_unregister_cancel, GLIBC_2.3.3)
+SYMVER(__pthread_unregister_cancel_restore, GLIBC_2.3.3)
+SYMVER(__pthread_unwind_next, GLIBC_2.3.3)
+SYMVER(_pthread_cleanup_pop, GLIBC_2.2.5)
+SYMVER(_pthread_cleanup_push, GLIBC_2.2.5)
+SYMVER(aio_cancel, GLIBC_2.2.5)
+SYMVER(aio_cancel64, GLIBC_2.2.5)
+SYMVER(aio_error, GLIBC_2.2.5)
+SYMVER(aio_error64, GLIBC_2.2.5)
+SYMVER(aio_fsync, GLIBC_2.2.5)
+SYMVER(aio_fsync64, GLIBC_2.2.5)
+SYMVER(aio_init, GLIBC_2.2.5)
+SYMVER(aio_read, GLIBC_2.2.5)
+SYMVER(aio_read64, GLIBC_2.2.5)
+SYMVER(aio_return, GLIBC_2.2.5)
+SYMVER(aio_return64, GLIBC_2.2.5)
+SYMVER(aio_suspend, GLIBC_2.2.5)
+SYMVER(aio_suspend64, GLIBC_2.2.5)
+SYMVER(aio_write, GLIBC_2.2.5)
+SYMVER(aio_write64, GLIBC_2.2.5)
+SYMVER(clock_adjtime, GLIBC_2.14)
+SYMVER(clock_getcpuclockid, GLIBC_2.2.5)
+SYMVER(clock_getres, GLIBC_2.2.5)
+SYMVER(clock_gettime, GLIBC_2.2.5)
+SYMVER(clock_nanosleep, GLIBC_2.2.5)
+SYMVER(clock_settime, GLIBC_2.2.5)
+SYMVER(dladdr, GLIBC_2.2.5)
+SYMVER(dladdr1, GLIBC_2.3.3)
+SYMVER(dlclose, GLIBC_2.2.5)
+SYMVER(dlerror, GLIBC_2.2.5)
+SYMVER(dlinfo, GLIBC_2.3.3)
+SYMVER(dlmopen, GLIBC_2.3.4)
+SYMVER(dlopen, GLIBC_2.2.5)
+SYMVER(dlsym, GLIBC_2.2.5)
+SYMVER(dlvsym, GLIBC_2.2.5)
+SYMVER(exp, GLIBC_2.2.5)
+SYMVER(exp10f, GLIBC_2.2.5)
+SYMVER(exp2, GLIBC_2.2.5)
+SYMVER(exp2f, GLIBC_2.2.5)
+SYMVER(expf, GLIBC_2.2.5)
+SYMVER(fmemopen, GLIBC_2.2.5)
+SYMVER(forkpty, GLIBC_2.2.5)
+SYMVER(gai_cancel, GLIBC_2.2.5)
+SYMVER(gai_error, GLIBC_2.2.5)
+SYMVER(gai_suspend, GLIBC_2.2.5)
+SYMVER(getaddrinfo_a, GLIBC_2.2.5)
+SYMVER(glob, GLIBC_2.2.5)
+SYMVER(glob64, GLIBC_2.2.5)
+SYMVER(hypot, GLIBC_2.2.5)
+SYMVER(hypotf, GLIBC_2.2.5)
+SYMVER(lgamma, GLIBC_2.2.5)
+SYMVER(lgammaf, GLIBC_2.2.5)
+SYMVER(lgammal, GLIBC_2.2.5)
+SYMVER(lio_listio, GLIBC_2.4)
+SYMVER(lio_listio64, GLIBC_2.4)
+SYMVER(log, GLIBC_2.2.5)
+SYMVER(log2, GLIBC_2.2.5)
+SYMVER(log2f, GLIBC_2.2.5)
+SYMVER(logf, GLIBC_2.2.5)
+SYMVER(login, GLIBC_2.2.5)
+SYMVER(login_tty, GLIBC_2.2.5)
+SYMVER(logout, GLIBC_2.2.5)
+SYMVER(logwtmp, GLIBC_2.2.5)
+SYMVER(memcpy, GLIBC_2.14)
+SYMVER(mq_close, GLIBC_2.3.4)
+SYMVER(mq_getattr, GLIBC_2.3.4)
+SYMVER(mq_notify, GLIBC_2.3.4)
+SYMVER(mq_open, GLIBC_2.3.4)
+SYMVER(mq_receive, GLIBC_2.3.4)
+SYMVER(mq_send, GLIBC_2.3.4)
+SYMVER(mq_setattr, GLIBC_2.3.4)
+SYMVER(mq_timedreceive, GLIBC_2.3.4)
+SYMVER(mq_timedsend, GLIBC_2.3.4)
+SYMVER(mq_unlink, GLIBC_2.3.4)
+SYMVER(name_to_handle_at, GLIBC_2.14)
+SYMVER(ns_name_compress, GLIBC_2.9)
+SYMVER(ns_name_ntop, GLIBC_2.9)
+SYMVER(ns_name_pack, GLIBC_2.9)
+SYMVER(ns_name_pton, GLIBC_2.9)
+SYMVER(ns_name_skip, GLIBC_2.9)
+SYMVER(ns_name_uncompress, GLIBC_2.9)
+SYMVER(ns_name_unpack, GLIBC_2.9)
+SYMVER(open_by_handle_at, GLIBC_2.14)
+SYMVER(openpty, GLIBC_2.2.5)
+SYMVER(posix_spawn, GLIBC_2.2.5)
+SYMVER(posix_spawnp, GLIBC_2.2.5)
+SYMVER(pow, GLIBC_2.2.5)
+SYMVER(powf, GLIBC_2.2.5)
+SYMVER(pthread_attr_getaffinity_np, GLIBC_2.3.4)
+SYMVER(pthread_attr_getguardsize, GLIBC_2.2.5)
+SYMVER(pthread_attr_getstack, GLIBC_2.2.5)
+SYMVER(pthread_attr_getstackaddr, GLIBC_2.2.5)
+SYMVER(pthread_attr_getstacksize, GLIBC_2.2.5)
+SYMVER(pthread_attr_setaffinity_np, GLIBC_2.3.4)
+SYMVER(pthread_attr_setguardsize, GLIBC_2.2.5)
+SYMVER(pthread_attr_setstack, GLIBC_2.2.5)
+SYMVER(pthread_attr_setstackaddr, GLIBC_2.2.5)
+SYMVER(pthread_attr_setstacksize, GLIBC_2.2.5)
+SYMVER(pthread_barrier_destroy, GLIBC_2.2.5)
+SYMVER(pthread_barrier_init, GLIBC_2.2.5)
+SYMVER(pthread_barrier_wait, GLIBC_2.2.5)
+SYMVER(pthread_barrierattr_destroy, GLIBC_2.2.5)
+SYMVER(pthread_barrierattr_getpshared, GLIBC_2.3.3)
+SYMVER(pthread_barrierattr_init, GLIBC_2.2.5)
+SYMVER(pthread_barrierattr_setpshared, GLIBC_2.2.5)
+SYMVER(pthread_cancel, GLIBC_2.2.5)
+SYMVER(pthread_condattr_getclock, GLIBC_2.3.3)
+SYMVER(pthread_condattr_getpshared, GLIBC_2.2.5)
+SYMVER(pthread_condattr_setclock, GLIBC_2.3.3)
+SYMVER(pthread_condattr_setpshared, GLIBC_2.2.5)
+SYMVER(pthread_create, GLIBC_2.2.5)
+SYMVER(pthread_detach, GLIBC_2.2.5)
+SYMVER(pthread_getaffinity_np, GLIBC_2.3.4)
+SYMVER(pthread_getattr_np, GLIBC_2.2.5)
+SYMVER(pthread_getconcurrency, GLIBC_2.2.5)
+SYMVER(pthread_getcpuclockid, GLIBC_2.2.5)
+SYMVER(pthread_getname_np, GLIBC_2.12)
+SYMVER(pthread_getspecific, GLIBC_2.2.5)
+SYMVER(pthread_join, GLIBC_2.2.5)
+SYMVER(pthread_key_create, GLIBC_2.2.5)
+SYMVER(pthread_key_delete, GLIBC_2.2.5)
+SYMVER(pthread_kill, GLIBC_2.2.5)
+SYMVER(pthread_mutex_consistent, GLIBC_2.12)
+SYMVER(pthread_mutex_getprioceiling, GLIBC_2.4)
+SYMVER(pthread_mutex_setprioceiling, GLIBC_2.4)
+SYMVER(pthread_mutex_timedlock, GLIBC_2.2.5)
+SYMVER(pthread_mutex_trylock, GLIBC_2.2.5)
+SYMVER(pthread_mutexattr_destroy, GLIBC_2.2.5)
+SYMVER(pthread_mutexattr_getprioceiling, GLIBC_2.4)
+SYMVER(pthread_mutexattr_getprotocol, GLIBC_2.4)
+SYMVER(pthread_mutexattr_getpshared, GLIBC_2.2.5)
+SYMVER(pthread_mutexattr_getrobust, GLIBC_2.12)
+SYMVER(pthread_mutexattr_gettype, GLIBC_2.2.5)
+SYMVER(pthread_mutexattr_init, GLIBC_2.2.5)
+SYMVER(pthread_mutexattr_setprioceiling, GLIBC_2.4)
+SYMVER(pthread_mutexattr_setprotocol, GLIBC_2.4)
+SYMVER(pthread_mutexattr_setpshared, GLIBC_2.2.5)
+SYMVER(pthread_mutexattr_setrobust, GLIBC_2.12)
+SYMVER(pthread_mutexattr_settype, GLIBC_2.2.5)
+SYMVER(pthread_once, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_destroy, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_init, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_rdlock, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_timedrdlock, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_timedwrlock, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_tryrdlock, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_trywrlock, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_unlock, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_wrlock, GLIBC_2.2.5)
+SYMVER(pthread_rwlockattr_destroy, GLIBC_2.2.5)
+SYMVER(pthread_rwlockattr_getkind_np, GLIBC_2.2.5)
+SYMVER(pthread_rwlockattr_getpshared, GLIBC_2.2.5)
+SYMVER(pthread_rwlockattr_init, GLIBC_2.2.5)
+SYMVER(pthread_rwlockattr_setkind_np, GLIBC_2.2.5)
+SYMVER(pthread_rwlockattr_setpshared, GLIBC_2.2.5)
+SYMVER(pthread_setaffinity_np, GLIBC_2.3.4)
+SYMVER(pthread_setconcurrency, GLIBC_2.2.5)
+SYMVER(pthread_setname_np, GLIBC_2.12)
+SYMVER(pthread_setschedprio, GLIBC_2.3.4)
+SYMVER(pthread_setspecific, GLIBC_2.2.5)
+SYMVER(pthread_sigmask, GLIBC_2.2.5)
+SYMVER(pthread_sigqueue, GLIBC_2.11)
+SYMVER(pthread_spin_destroy, GLIBC_2.2.5)
+SYMVER(pthread_spin_init, GLIBC_2.2.5)
+SYMVER(pthread_spin_lock, GLIBC_2.2.5)
+SYMVER(pthread_spin_trylock, GLIBC_2.2.5)
+SYMVER(pthread_spin_unlock, GLIBC_2.2.5)
+SYMVER(pthread_testcancel, GLIBC_2.2.5)
+SYMVER(pthread_timedjoin_np, GLIBC_2.3.3)
+SYMVER(pthread_tryjoin_np, GLIBC_2.3.3)
+SYMVER(quick_exit, GLIBC_2.10)
+SYMVER(sem_close, GLIBC_2.2.5)
+SYMVER(sem_destroy, GLIBC_2.2.5)
+SYMVER(sem_getvalue, GLIBC_2.2.5)
+SYMVER(sem_init, GLIBC_2.2.5)
+SYMVER(sem_open, GLIBC_2.2.5)
+SYMVER(sem_post, GLIBC_2.2.5)
+SYMVER(sem_timedwait, GLIBC_2.2.5)
+SYMVER(sem_trywait, GLIBC_2.2.5)
+SYMVER(sem_unlink, GLIBC_2.2.5)
+SYMVER(sem_wait, GLIBC_2.2.5)
+SYMVER(sendmmsg, GLIBC_2.14)
+SYMVER(setns, GLIBC_2.14)
+SYMVER(shm_open, GLIBC_2.2.5)
+SYMVER(shm_unlink, GLIBC_2.2.5)
+SYMVER(syncfs, GLIBC_2.14)
+SYMVER(timer_create, GLIBC_2.3.3)
+SYMVER(timer_delete, GLIBC_2.3.3)
+SYMVER(timer_getoverrun, GLIBC_2.3.3)
+SYMVER(timer_gettime, GLIBC_2.3.3)
+SYMVER(timer_settime, GLIBC_2.3.3)
+
+/* Symbols introduced in newer glibc versions, which must not be used */
+SYMVER(_Fork, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(_ZGVbN2v_acos, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_acosh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_asin, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_asinh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_atan, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_atanh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_cbrt, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_cos, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN2v_cosh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_erf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_erfc, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_exp, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN2v_exp10, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_exp2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_expm1, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_log, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN2v_log10, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_log1p, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_log2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_sin, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN2v_sinh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_tan, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_tanh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2vv_atan2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2vv_hypot, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2vv_pow, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN2vvv_sincos, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN4v_acosf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_acoshf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_asinf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_asinhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_atanf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_atanhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_cbrtf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_cosf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN4v_coshf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_erfcf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_erff, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_exp10f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_exp2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_expf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN4v_expm1f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_log10f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_log1pf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_log2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_logf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN4v_sinf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN4v_sinhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_tanf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_tanhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4vv_atan2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4vv_hypotf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4vv_powf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN4vvv_sincosf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN4v_acos, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_acosh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_asin, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_asinh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_atan, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_atanh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_cbrt, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_cos, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN4v_cosh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_erf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_erfc, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_exp, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN4v_exp10, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_exp2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_expm1, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_log, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN4v_log10, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_log1p, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_log2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_sin, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN4v_sinh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_tan, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_tanh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4vv_atan2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4vv_hypot, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4vv_pow, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN4vvv_sincos, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN8v_acosf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_acoshf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_asinf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_asinhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_atanf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_atanhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_cbrtf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_cosf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN8v_coshf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_erfcf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_erff, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_exp10f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_exp2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_expf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN8v_expm1f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_log10f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_log1pf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_log2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_logf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN8v_sinf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN8v_sinhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_tanf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_tanhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8vv_atan2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8vv_hypotf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8vv_powf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN8vvv_sincosf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN4v_acos, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_acosh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_asin, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_asinh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_atan, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_atanh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_cbrt, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_cos, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN4v_cosh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_erf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_erfc, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_exp, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN4v_exp10, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_exp2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_expm1, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_log, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN4v_log10, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_log1p, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_log2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_sin, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN4v_sinh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_tan, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_tanh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4vv_atan2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4vv_hypot, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4vv_pow, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN4vvv_sincos, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN8v_acosf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_acoshf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_asinf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_asinhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_atanf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_atanhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_cbrtf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_cosf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN8v_coshf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_erfcf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_erff, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_exp10f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_exp2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_expf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN8v_expm1f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_log10f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_log1pf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_log2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_logf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN8v_sinf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN8v_sinhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_tanf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_tanhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8vv_atan2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8vv_hypotf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8vv_powf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN8vvv_sincosf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN16v_acosf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_acoshf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_asinf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_asinhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_atanf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_atanhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_cbrtf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_cosf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN16v_coshf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_erfcf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_erff, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_exp10f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_exp2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_expf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN16v_expm1f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_log10f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_log1pf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_log2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_logf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN16v_sinf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN16v_sinhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_tanf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_tanhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16vv_atan2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16vv_hypotf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16vv_powf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN16vvv_sincosf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN8v_acos, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_acosh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_asin, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_asinh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_atan, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_atanh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_cbrt, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_cos, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN8v_cosh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_erf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_erfc, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_exp, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN8v_exp10, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_exp2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_expm1, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_log, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN8v_log10, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_log1p, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_log2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_sin, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN8v_sinh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_tan, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_tanh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8vv_atan2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8vv_hypot, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8vv_pow, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN8vvv_sincos, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(__acos_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__acosf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__acosf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__acosh_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__acoshf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__acoshf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__acoshl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__acosl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__asin_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__asinf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__asinf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__asinl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__atan2_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__atan2f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__atan2f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__atan2l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__atanh_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__atanhf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__atanhf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__atanhl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__cosh_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__coshf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__coshf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__coshl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__cxa_thread_atexit_impl, GLIBC_DONT_USE_THIS_VERSION_2.18)
+SYMVER(__exp10_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__exp10f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__exp10f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__exp10l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__exp2_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__exp2f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__exp2f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__exp2l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__exp_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__expf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__expf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__expl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__explicit_bzero_chk, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(__fdelt_chk, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__fdelt_warn, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__finitef128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__fmod_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__fmodf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__fmodf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__fmodl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__fpclassifyf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__gamma_r_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__gammaf128_r_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__gammaf_r_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__gammal_r_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__getauxval, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(__hypot_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__hypotf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__hypotf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__hypotl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__iscanonicall, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(__iseqsig, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(__iseqsigf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(__iseqsigf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__iseqsigl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(__isinff128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__isnanf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__issignaling, GLIBC_DONT_USE_THIS_VERSION_2.18)
+SYMVER(__issignalingf, GLIBC_DONT_USE_THIS_VERSION_2.18)
+SYMVER(__issignalingf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__issignalingl, GLIBC_DONT_USE_THIS_VERSION_2.18)
+SYMVER(__j0_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__j0f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__j0f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__j0l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__j1_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__j1f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__j1f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__j1l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__jn_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__jnf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__jnf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__jnl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__lgamma_r_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__lgammaf128_r_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__lgammaf_r_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__lgammal_r_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__libc_single_threaded, GLIBC_DONT_USE_THIS_VERSION_2.32)
+SYMVER(__log10_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__log10f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__log10f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__log10l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__log2_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__log2f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__log2f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__log2l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__log_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__logf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__logf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__logl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__memcmpeq, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(__poll_chk, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(__pow_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__powf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__powf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__powl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__ppoll_chk, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(__remainder_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__remainderf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__remainderf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__remainderl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__rseq_flags, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(__rseq_offset, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(__rseq_size, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(__rtld_version_placeholder, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(__scalb_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__scalbf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__scalbl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__signbitf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__signgam, GLIBC_DONT_USE_THIS_VERSION_2.23)
+SYMVER(__sinh_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__sinhf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__sinhf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__sinhl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__sqrt_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__sqrtf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__sqrtf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__sqrtl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__strtof128_internal, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__wcstof128_internal, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__x86_get_cpuid_feature_leaf, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(__y0_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__y0f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__y0f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__y0l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__y1_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__y1f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__y1f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__y1l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__yn_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__ynf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__ynf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__ynl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(_dl_find_object, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(acosf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(acosf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(acosf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(acosf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(acosf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(acoshf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(acoshf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(acoshf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(acoshf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(acoshf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(aligned_alloc, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(arc4random, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(arc4random_buf, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(arc4random_uniform, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(asinf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(asinf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(asinf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(asinf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(asinf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(asinhf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(asinhf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(asinhf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(asinhf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(asinhf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atan2f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(atan2f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atan2f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atan2f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atan2f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atanf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(atanf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atanf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atanf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atanf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atanhf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(atanhf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atanhf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atanhf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atanhf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(c16rtomb, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(c32rtomb, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(c8rtomb, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(cabsf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cabsf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cabsf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cabsf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cabsf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cacosf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cacosf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cacosf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cacosf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cacosf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cacoshf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cacoshf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cacoshf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cacoshf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cacoshf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(call_once, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(canonicalize, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(canonicalizef, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(canonicalizef128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(canonicalizef32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(canonicalizef32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(canonicalizef64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(canonicalizef64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(canonicalizel, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(cargf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cargf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cargf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cargf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cargf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(casinf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(casinf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(casinf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(casinf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(casinf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(casinhf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(casinhf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(casinhf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(casinhf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(casinhf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(catanf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(catanf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(catanf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(catanf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(catanf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(catanhf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(catanhf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(catanhf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(catanhf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(catanhf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cbrtf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cbrtf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cbrtf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cbrtf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cbrtf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ccosf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ccosf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ccosf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ccosf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ccosf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ccoshf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ccoshf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ccoshf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ccoshf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ccoshf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ceilf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ceilf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ceilf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ceilf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ceilf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cexpf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cexpf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cexpf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cexpf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cexpf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cimagf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cimagf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cimagf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cimagf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cimagf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(clog10f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(clog10f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(clog10f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(clog10f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(clog10f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(clogf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(clogf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(clogf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(clogf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(clogf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(close_range, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(closefrom, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(cnd_broadcast, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(cnd_destroy, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(cnd_init, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(cnd_signal, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(cnd_timedwait, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(cnd_wait, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(conjf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(conjf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(conjf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(conjf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(conjf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(copy_file_range, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(copysignf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(copysignf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(copysignf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(copysignf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(copysignf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cosf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cosf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cosf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cosf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cosf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(coshf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(coshf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(coshf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(coshf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(coshf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cpowf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cpowf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cpowf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cpowf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cpowf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cprojf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cprojf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cprojf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cprojf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cprojf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(crealf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(crealf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(crealf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(crealf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(crealf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csinf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(csinf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csinf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csinf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csinf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csinhf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(csinhf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csinhf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csinhf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csinhf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csqrtf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(csqrtf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csqrtf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csqrtf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csqrtf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ctanf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ctanf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ctanf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ctanf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ctanf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ctanhf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ctanhf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ctanhf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ctanhf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ctanhf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(daddl, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(ddivl, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(dfmal, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(dmull, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(dn_comp, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(dn_expand, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(dn_skipname, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(dsqrtl, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(dsubl, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(epoll_pwait2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(erfcf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(erfcf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(erfcf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(erfcf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(erfcf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(erff128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(erff32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(erff32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(erff64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(erff64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(execveat, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(exp10f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(exp10f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(exp10f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(exp10f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(exp10f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(exp2f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(exp2f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(exp2f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(exp2f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(exp2f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(expf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(expf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(expf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(expf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(expf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(explicit_bzero, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(expm1f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(expm1f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(expm1f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(expm1f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(expm1f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(f32addf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32addf32x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32addf64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32addf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32divf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32divf32x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32divf64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32divf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32fmaf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32fmaf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32fmaf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32fmaf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32mulf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32mulf32x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32mulf64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32mulf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32sqrtf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32sqrtf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32sqrtf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32sqrtf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32subf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32subf32x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32subf64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32subf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xaddf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xaddf64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xaddf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xdivf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xdivf64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xdivf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xfmaf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32xfmaf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32xfmaf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32xmulf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xmulf64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xmulf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xsqrtf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32xsqrtf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32xsqrtf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32xsubf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xsubf64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xsubf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64addf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64addf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64divf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64divf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64fmaf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f64fmaf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f64mulf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64mulf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64sqrtf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f64sqrtf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f64subf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64subf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64xaddf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64xdivf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64xfmaf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f64xmulf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64xsqrtf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f64xsubf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(fabsf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fabsf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fabsf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fabsf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fabsf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fadd, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(faddl, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(fcntl64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(fdimf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fdimf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fdimf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fdimf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fdimf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fdiv, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(fdivl, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(fegetmode, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fesetexcept, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fesetmode, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fetestexceptflag, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(ffma, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(ffmal, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(floorf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(floorf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(floorf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(floorf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(floorf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fmaf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaxf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fmaxf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaxf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaxf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaxf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaximum, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag_num, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag_numf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag_numf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag_numf32, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag_numf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag_numf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag_numf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag_numl, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_magf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_magf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_magf32, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_magf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_magf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_magf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_magl, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_num, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_numf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_numf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_numf32, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_numf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_numf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_numf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_numl, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximumf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximumf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximumf32, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximumf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximumf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximumf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximuml, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaxmag, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fmaxmagf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fmaxmagf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fmaxmagf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaxmagf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaxmagf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaxmagf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaxmagl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fminf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fminf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fminf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fminf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fminf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fminimum, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag_num, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag_numf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag_numf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag_numf32, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag_numf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag_numf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag_numf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag_numl, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_magf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_magf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_magf32, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_magf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_magf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_magf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_magl, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_num, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_numf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_numf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_numf32, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_numf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_numf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_numf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_numl, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimumf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimumf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimumf32, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimumf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimumf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimumf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimuml, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminmag, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fminmagf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fminmagf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fminmagf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fminmagf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fminmagf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fminmagf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fminmagl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fmodf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fmodf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmodf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmodf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmodf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmul, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(fmull, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(frexpf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(frexpf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(frexpf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(frexpf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(frexpf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfp, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fromfpf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fromfpf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fromfpf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfpf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfpf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfpf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfpl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fromfpx, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fromfpxf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fromfpxf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fromfpxf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfpxf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfpxf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfpxf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfpxl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fsconfig, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(fsmount, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(fsopen, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(fspick, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(fsqrt, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fsqrtl, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fstat, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(fstat64, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(fstatat, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(fstatat64, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(fsub, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(fsubl, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(fts64_children, GLIBC_DONT_USE_THIS_VERSION_2.23)
+SYMVER(fts64_close, GLIBC_DONT_USE_THIS_VERSION_2.23)
+SYMVER(fts64_open, GLIBC_DONT_USE_THIS_VERSION_2.23)
+SYMVER(fts64_read, GLIBC_DONT_USE_THIS_VERSION_2.23)
+SYMVER(fts64_set, GLIBC_DONT_USE_THIS_VERSION_2.23)
+SYMVER(getauxval, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(getcpu, GLIBC_DONT_USE_THIS_VERSION_2.29)
+SYMVER(getdents64, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(getentropy, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(getpayload, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(getpayloadf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(getpayloadf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(getpayloadf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(getpayloadf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(getpayloadf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(getpayloadf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(getpayloadl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(getrandom, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(gettid, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(hypotf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(hypotf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(hypotf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(hypotf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(hypotf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ilogbf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ilogbf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ilogbf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ilogbf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ilogbf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(j0f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(j0f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(j0f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(j0f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(j0f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(j1f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(j1f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(j1f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(j1f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(j1f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(jnf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(jnf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(jnf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(jnf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(jnf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ldexpf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ldexpf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ldexpf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ldexpf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ldexpf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lgammaf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(lgammaf128_r, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(lgammaf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lgammaf32_r, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lgammaf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lgammaf32x_r, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lgammaf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lgammaf64_r, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lgammaf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lgammaf64x_r, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llogb, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(llogbf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(llogbf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(llogbf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llogbf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llogbf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llogbf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llogbl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(llrintf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(llrintf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llrintf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llrintf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llrintf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llroundf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(llroundf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llroundf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llroundf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llroundf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log10f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(log10f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log10f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log10f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log10f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log1pf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(log1pf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log1pf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log1pf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log1pf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log2f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(log2f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log2f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log2f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log2f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(logbf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(logbf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(logbf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(logbf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(logbf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(logf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(logf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(logf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(logf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(logf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lrintf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(lrintf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lrintf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lrintf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lrintf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lroundf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(lroundf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lroundf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lroundf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lroundf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lstat, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(lstat64, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(mallinfo2, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(mbrtoc16, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(mbrtoc32, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(mbrtoc8, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(memfd_create, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(mknod, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(mknodat, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(mlock2, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(modff128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(modff32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(modff32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(modff64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(modff64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(mount_setattr, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(move_mount, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(mtx_destroy, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(mtx_init, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(mtx_lock, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(mtx_timedlock, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(mtx_trylock, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(mtx_unlock, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(nanf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(nanf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nanf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nanf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nanf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nearbyintf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(nearbyintf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nearbyintf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nearbyintf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nearbyintf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextafterf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(nextafterf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextafterf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextafterf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextafterf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextdown, GLIBC_DONT_USE_THIS_VERSION_2.24)
+SYMVER(nextdownf, GLIBC_DONT_USE_THIS_VERSION_2.24)
+SYMVER(nextdownf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(nextdownf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextdownf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextdownf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextdownf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextdownl, GLIBC_DONT_USE_THIS_VERSION_2.24)
+SYMVER(nextup, GLIBC_DONT_USE_THIS_VERSION_2.24)
+SYMVER(nextupf, GLIBC_DONT_USE_THIS_VERSION_2.24)
+SYMVER(nextupf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(nextupf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextupf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextupf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextupf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextupl, GLIBC_DONT_USE_THIS_VERSION_2.24)
+SYMVER(open_tree, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(pidfd_getfd, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(pidfd_open, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(pidfd_send_signal, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(pkey_alloc, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(pkey_free, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(pkey_get, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(pkey_mprotect, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(pkey_set, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(posix_spawn_file_actions_addchdir_np, GLIBC_DONT_USE_THIS_VERSION_2.29)
+SYMVER(posix_spawn_file_actions_addclosefrom_np, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(posix_spawn_file_actions_addfchdir_np, GLIBC_DONT_USE_THIS_VERSION_2.29)
+SYMVER(posix_spawn_file_actions_addtcsetpgrp_np, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(powf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(powf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(powf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(powf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(powf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(preadv2, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(preadv64v2, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(process_madvise, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(process_mrelease, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(process_vm_readv, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(process_vm_writev, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(pthread_attr_getsigmask_np, GLIBC_DONT_USE_THIS_VERSION_2.32)
+SYMVER(pthread_attr_setsigmask_np, GLIBC_DONT_USE_THIS_VERSION_2.32)
+SYMVER(pthread_clockjoin_np, GLIBC_DONT_USE_THIS_VERSION_2.31)
+SYMVER(pthread_cond_clockwait, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(pthread_getattr_default_np, GLIBC_DONT_USE_THIS_VERSION_2.18)
+SYMVER(pthread_mutex_clocklock, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(pthread_rwlock_clockrdlock, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(pthread_rwlock_clockwrlock, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(pthread_setattr_default_np, GLIBC_DONT_USE_THIS_VERSION_2.18)
+SYMVER(pwritev2, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(pwritev64v2, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(reallocarray, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(remainderf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(remainderf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(remainderf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(remainderf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(remainderf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(remquof128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(remquof32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(remquof32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(remquof64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(remquof64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(renameat2, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(res_dnok, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_hnok, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_mailok, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_mkquery, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_nmkquery, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_nquery, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_nquerydomain, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_nsearch, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_nsend, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_ownok, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_query, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_querydomain, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_search, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_send, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(rintf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(rintf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(rintf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(rintf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(rintf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(roundeven, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(roundevenf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(roundevenf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(roundevenf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(roundevenf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(roundevenf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(roundevenf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(roundevenl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(roundf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(roundf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(roundf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(roundf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(roundf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scalblnf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(scalblnf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scalblnf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scalblnf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scalblnf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scalbnf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(scalbnf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scalbnf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scalbnf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scalbnf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scandirat, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(scandirat64, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(secure_getenv, GLIBC_DONT_USE_THIS_VERSION_2.17)
+SYMVER(sem_clockwait, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(setpayload, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(setpayloadf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(setpayloadf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(setpayloadf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(setpayloadf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(setpayloadf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(setpayloadf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(setpayloadl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(setpayloadsig, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(setpayloadsigf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(setpayloadsigf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(setpayloadsigf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(setpayloadsigf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(setpayloadsigf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(setpayloadsigf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(setpayloadsigl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(sigabbrev_np, GLIBC_DONT_USE_THIS_VERSION_2.32)
+SYMVER(sigdescr_np, GLIBC_DONT_USE_THIS_VERSION_2.32)
+SYMVER(sincosf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(sincosf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sincosf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sincosf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sincosf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sinf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(sinf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sinf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sinf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sinf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sinhf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(sinhf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sinhf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sinhf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sinhf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sqrtf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(sqrtf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sqrtf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sqrtf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sqrtf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(stat, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(stat64, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(statx, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(strerrordesc_np, GLIBC_DONT_USE_THIS_VERSION_2.32)
+SYMVER(strerrorname_np, GLIBC_DONT_USE_THIS_VERSION_2.32)
+SYMVER(strfromd, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(strfromf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(strfromf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(strfromf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strfromf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strfromf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strfromf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strfroml, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(strtof128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(strtof128_l, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(strtof32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strtof32_l, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strtof32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strtof32x_l, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strtof64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strtof64_l, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strtof64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strtof64x_l, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tanf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(tanf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tanf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tanf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tanf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tanhf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(tanhf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tanhf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tanhf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tanhf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tgammaf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(tgammaf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tgammaf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tgammaf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tgammaf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tgkill, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(thrd_create, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(thrd_current, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(thrd_detach, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(thrd_equal, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(thrd_exit, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(thrd_join, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(thrd_sleep, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(thrd_yield, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(timespec_get, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(timespec_getres, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(totalorder, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(totalorderf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(totalorderf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(totalorderf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(totalorderf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(totalorderf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(totalorderf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(totalorderl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(totalordermag, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(totalordermagf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(totalordermagf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(totalordermagf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(totalordermagf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(totalordermagf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(totalordermagf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(totalordermagl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(truncf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(truncf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(truncf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(truncf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(truncf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tss_create, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(tss_delete, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(tss_get, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(tss_set, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(twalk_r, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(ufromfp, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(ufromfpf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(ufromfpf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ufromfpf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ufromfpf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ufromfpf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ufromfpf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ufromfpl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(ufromfpx, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(ufromfpxf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(ufromfpxf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ufromfpxf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ufromfpxf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ufromfpxf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ufromfpxf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ufromfpxl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(wcstof128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(wcstof128_l, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(wcstof32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(wcstof32_l, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(wcstof32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(wcstof32x_l, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(wcstof64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(wcstof64_l, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(wcstof64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(wcstof64x_l, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(y0f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(y0f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(y0f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(y0f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(y0f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(y1f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(y1f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(y1f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(y1f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(y1f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ynf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ynf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ynf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ynf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ynf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+
+#undef SYMVER
+#undef SYMVER1
+
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+#include <sys/stat.h>
+
+#if __GLIBC_PREREQ(2, 33)
+
+/*
+ * avoid references to stat/lstat/fstat, which are only available in glibc >= 2.33
+ */
+
+extern int __fxstat(int __ver, int __fildes, struct stat *__stat_buf)
+     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
+extern int __xstat(int __ver, const char *__filename,
+      struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
+extern int __lxstat(int __ver, const char *__filename,
+       struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
+extern int __fxstatat (int __ver, int __fildes, const char *__filename,
+	struct stat *__stat_buf, int __flag)
+     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));
+#ifdef __USE_LARGEFILE64
+extern int __xstat64(int __ver, const char *__filename,
+	struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
+extern int __lxstat64(int __ver, const char *__filename,
+       struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
+extern int __fxstat64(int __ver, int __fildes, struct stat64 *__stat_buf)
+     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
+#endif
+
+extern __inline __attribute__((__gnu_inline__))
+__attribute__((__nothrow__))
+int stat(const char *__path, struct stat *__statbuf)
+{
+	return __xstat(1, __path, __statbuf);
+}
+
+extern __inline __attribute__((__gnu_inline__))
+__attribute__((__nothrow__))
+int lstat (const char *__path, struct stat *__statbuf)
+{
+	return __lxstat(1, __path, __statbuf);
+}
+
+extern __inline __attribute__((__gnu_inline__))
+__attribute__((__nothrow__))
+int fstat(int __fd, struct stat *__statbuf)
+{
+	return __fxstat(1, __fd, __statbuf);
+}
+
+extern __inline __attribute__((__gnu_inline__))
+__attribute__((__nothrow__))
+int fstatat(int __fd, const char *__filename, struct stat *__statbuf, int __flag)
+{
+	return __fxstatat(1, __fd, __filename, __statbuf, __flag);
+}
+
+#ifdef __USE_LARGEFILE64
+extern __inline __attribute__((__gnu_inline__))
+__attribute__((__nothrow__))
+int stat64(const char *__path, struct stat64 *__statbuf)
+{
+	return __xstat64(1, __path, __statbuf);
+}
+
+extern __inline __attribute__((__gnu_inline__))
+__attribute__((__nothrow__))
+int lstat64 (const char *__path, struct stat64 *__statbuf)
+{
+	return __lxstat64(1, __path, __statbuf);
+}
+
+extern __inline __attribute__((__gnu_inline__))
+__attribute__((__nothrow__))
+int fstat64(int __fd, struct stat64 *__statbuf)
+{
+	return __fxstat64(1, __fd, __statbuf);
+}
+
+#endif /* __USE_LARGEFILE64 */
+
+#endif /* __GLIBC_PREREQ */
+
+#if defined (__cplusplus)
+}
+#endif
+
+
+#endif /* __x86_64__ */
+#endif /* __linux__ */
diff --git a/gcc/lto-wrapper.cc b/gcc/lto-wrapper.cc
index a980b208783..1d6d5f464f2 100644
--- a/gcc/lto-wrapper.cc
+++ b/gcc/lto-wrapper.cc
@@ -1712,7 +1712,8 @@ run_gcc (unsigned argc, char *argv[])
   if (!dumppfx)
     {
       if (!linker_output
-	  || strcmp (linker_output, HOST_BIT_BUCKET) == 0)
+	  || strcmp (linker_output, HOST_BIT_BUCKET) == 0
+	  || strcmp (linker_output, HOST_BIT_BUCKET2) == 0)
 	dumppfx = "a.";
       else
 	{
@@ -2289,6 +2290,8 @@ public:
 
 /* Entry point.  */
 
+#include "libcmain.h"
+
 int
 main (int argc, char *argv[])
 {
diff --git a/gcc/m2/Make-lang.in b/gcc/m2/Make-lang.in
index 470825ca2cc..ecd7b9ba06f 100644
--- a/gcc/m2/Make-lang.in
+++ b/gcc/m2/Make-lang.in
@@ -46,6 +46,7 @@ else
   PLUGINLDFLAGS = -Wl,-undefined,dynamic_lookup
   PLUGINLDFLAGS += -Wl,-install_name,m2rte$(soext)
   PLUGINLDFLAGS += -nodefaultlibs
+  PLUGINLDFLAGS += -lSystem
   PLUGINLDFLAGS += -lc
 endif
 
diff --git a/gcc/m2/gm2-compiler/M2Quads.mod b/gcc/m2/gm2-compiler/M2Quads.mod
index 748ce2498db..6a155555945 100644
--- a/gcc/m2/gm2-compiler/M2Quads.mod
+++ b/gcc/m2/gm2-compiler/M2Quads.mod
@@ -28,7 +28,7 @@ FROM NameKey IMPORT Name, NulName, MakeKey, GetKey, makekey, KeyToCharStar, Writ
 FROM FormatStrings IMPORT Sprintf0, Sprintf1, Sprintf2, Sprintf3 ;
 FROM M2DebugStack IMPORT DebugStack ;
 FROM StrLib IMPORT StrLen ;
-FROM M2Scaffold IMPORT DeclareScaffold, mainFunction, initFunction,
+FROM M2Scaffold IMPORT DeclareScaffold, mainFunction, main__Function, initFunction,
                        finiFunction, linkFunction, PopulateCtorArray,
                        ForeachModuleCallInit, ForeachModuleCallFinish ;
 
@@ -2775,6 +2775,13 @@ BEGIN
       BuildProcedureBegin ;
       StartScope (mainFunction) ;
       BuildTry (tokno) ;
+      IF main__Function # NulSym
+      THEN
+          (* __main ();  *)
+          PushTtok (main__Function, tokno) ;
+          PushT (0) ;
+          BuildProcedureCall (tokno) ;
+      END;
       (* _M2_init (argc, argv, envp);  *)
       PushTtok (initFunction, tokno) ;
       PushTtok (RequestSym (tokno, MakeKey ("argc")), tokno) ;
@@ -12590,9 +12597,9 @@ BEGIN
    GetConstructorFromFifoQueue (constValue) ;
    IF type # GetSType (constValue)
    THEN
-      MetaErrorT3 (cbratokpos,
+      (* MetaErrorT3 (cbratokpos,
                    '{%E}the constructor type is {%1ad} and this is different from the constant {%2ad} which has a type {%2tad}',
-                   type, constValue, constValue)
+                   type, constValue, constValue) *)
    END ;
    PushTtok (constValue, cbratokpos) ;
    PushConstructor (type)
diff --git a/gcc/m2/gm2-compiler/M2Scaffold.def b/gcc/m2/gm2-compiler/M2Scaffold.def
index 8473303c3de..0a89181f62e 100644
--- a/gcc/m2/gm2-compiler/M2Scaffold.def
+++ b/gcc/m2/gm2-compiler/M2Scaffold.def
@@ -27,6 +27,7 @@ VAR
    linkFunction,
    finiFunction,
    initFunction,
+   main__Function,
    mainFunction: CARDINAL ;
 
 
@@ -71,4 +72,6 @@ PROCEDURE ForeachModuleCallInit (tok: CARDINAL; argc, argv, envp: CARDINAL) ;
 PROCEDURE ForeachModuleCallFinish (tok: CARDINAL; argc, argv, envp: CARDINAL) ;
 
 
+PROCEDURE SetNeedsMain();
+
 END M2Scaffold.
diff --git a/gcc/m2/gm2-compiler/M2Scaffold.mod b/gcc/m2/gm2-compiler/M2Scaffold.mod
index ff8e20f65a3..60831a65542 100644
--- a/gcc/m2/gm2-compiler/M2Scaffold.mod
+++ b/gcc/m2/gm2-compiler/M2Scaffold.mod
@@ -83,7 +83,7 @@ VAR
    ctorGlobals   : List ;
    ctorArrayType : CARDINAL ;
    initialized   : BOOLEAN ;
-
+   needs__main: BOOLEAN ;
 
 (* The dynamic scaffold takes the form:
 
@@ -597,6 +597,11 @@ BEGIN
       DeclareArgEnvParams (tokenno, initFunction) ;
       DeclareArgEnvParams (tokenno, finiFunction) ;
 
+      IF needs__main
+      THEN
+          main__Function := MakeProcedure (tokenno, MakeKey ("__main")) ;
+          PutMonoName (main__Function, TRUE)
+      END;
       mainFunction := MakeProcedure (tokenno, MakeKey ("main")) ;
       PutMonoName (mainFunction, TRUE) ;
       StartScope (mainFunction) ;
@@ -640,11 +645,18 @@ BEGIN
 END DeclareScaffold ;
 
 
+PROCEDURE SetNeedsMain();
+BEGIN
+   needs__main := TRUE
+END SetNeedsMain ;
+
 BEGIN
    initialized := FALSE ;
+   needs__main := FALSE ;
    finiFunction := NulSym ;
    initFunction := NulSym ;
    mainFunction := NulSym ;
+   main__Function := NulSym ;
    linkFunction := NulSym ;
    ctorArray := NulSym ;
    ctorGlobals := NIL ;
diff --git a/gcc/m2/gm2-compiler/M2Students.mod b/gcc/m2/gm2-compiler/M2Students.mod
index e539eb0757a..1f70faa4855 100644
--- a/gcc/m2/gm2-compiler/M2Students.mod
+++ b/gcc/m2/gm2-compiler/M2Students.mod
@@ -105,9 +105,13 @@ BEGIN
    THEN
       IF IsNotADuplicateName (name)
       THEN
+         (* do not warn about "in" because that is implemented in ISO standard *)
+         IF token <> intok
+         THEN
          MetaErrorString0 (Sprintf2 (Mark (InitString ('either the identifier has the same name as a keyword or alternatively a keyword has the wrong case ({%%K%s} and {!%%O:{%%K%s}})')),
                                      upperS, orig)) ;
-         MetaErrorString0 (Sprintf1 (Mark (InitString ('the symbol name {!%%O:{%%K%s}} is legal as an identifier, however as such it might cause confusion and is considered bad programming practice')), orig))
+         MetaErrorString0 (Sprintf1 (Mark (InitString ('the symbol name {!%%O:{%%K%s}} is legal as an identifier, however as such it might cause confusion and is considered bad programming practice')), orig));
+         END
       END
    END ;
    upperS := KillString (upperS) ;
diff --git a/gcc/m2/gm2-gcc/m2configure.cc b/gcc/m2/gm2-gcc/m2configure.cc
index 6ae14a2fd9f..9924c8722af 100644
--- a/gcc/m2/gm2-gcc/m2configure.cc
+++ b/gcc/m2/gm2-gcc/m2configure.cc
@@ -50,22 +50,21 @@ along with GNU Modula-2; see the file COPYING3.  If not see
 /* gen_gm2_libexec returns a string containing libexec /
    DEFAULT_TARGET_MACHINE string / DEFAULT_TARGET_MACHINE.  */
 
+extern const char *toplev_argv0;
+
 static char *
-gen_gm2_libexec (const char *libexec)
+gen_gm2_libexec (void)
 {
-  int l = strlen (libexec) + 1 + strlen (DEFAULT_TARGET_MACHINE) + 1
-          + strlen (DEFAULT_TARGET_VERSION) + 1;
+  int l = strlen (toplev_argv0) + 1;
   char *s = (char *)xmalloc (l);
-  char dir_sep[2];
-
-  dir_sep[0] = DIR_SEPARATOR;
-  dir_sep[1] = (char)0;
-
-  strcpy (s, libexec);
-  strcat (s, dir_sep);
-  strcat (s, DEFAULT_TARGET_MACHINE);
-  strcat (s, dir_sep);
-  strcat (s, DEFAULT_TARGET_VERSION);
+  char *p;
+
+  strcpy (s, toplev_argv0);
+  p = strrchr(s, DIR_SEPARATOR);
+  if (p)
+    *p = '\0';
+  else
+    *s = '\0';
   return s;
 }
 
@@ -77,19 +76,19 @@ m2configure_FullPathCPP (void)
   if (M2Options_GetCpp ())
     {
       char *path = (char *) M2Options_GetB ();
+      char dir_sep[2];
 
       if (path == NULL)
-	path = gen_gm2_libexec (STANDARD_LIBEXEC_PREFIX);
+	path = gen_gm2_libexec ();
 
       if (strcmp (path, "") == 0)
 	return xstrdup (CPPPROGRAM);
 
       char *full = (char *)xmalloc (strlen (path) + 1 + strlen (CPPPROGRAM) + 1);
       strcpy (full, path);
-      char *sep = (char *)alloca (2);
-      sep[0] = DIR_SEPARATOR;
-      sep[1] = (char)0;
-      strcat (full, sep);
+      dir_sep[0] = DIR_SEPARATOR;
+      dir_sep[1] = (char)0;
+      strcat (full, dir_sep);
       strcat (full, CPPPROGRAM);
       return full;
     }
diff --git a/gcc/m2/gm2-gcc/m2options.h b/gcc/m2/gm2-gcc/m2options.h
index 041de26cf8d..68f4eb9ce25 100644
--- a/gcc/m2/gm2-gcc/m2options.h
+++ b/gcc/m2/gm2-gcc/m2options.h
@@ -171,5 +171,7 @@ EXTERN bool M2Options_GetDumpGimple (void);
 EXTERN void M2Options_SetStrictTypeAssignment (bool value);
 EXTERN void M2Options_SetStrictTypeReason (bool value);
 
+EXTERN void M2Scaffold_SetNeedsMain(void);
+
 #undef EXTERN
 #endif /* m2options_h.  */
diff --git a/gcc/m2/gm2-lang.cc b/gcc/m2/gm2-lang.cc
index e8820daf474..c21ed383eab 100644
--- a/gcc/m2/gm2-lang.cc
+++ b/gcc/m2/gm2-lang.cc
@@ -160,6 +160,13 @@ gm2_langhook_init_options_struct (struct gcc_options *opts)
   /* Exceptions are used.  */
   opts->x_flag_exceptions = 1;
   init_FrontEndInit ();
+#if (defined(INVOKE__main)				\
+     || (!defined(HAS_INIT_SECTION)			\
+	 && !defined(INIT_SECTION_ASM_OP)		\
+	 && !defined(INIT_ARRAY_SECTION_ASM_OP) \
+	 && !HAVE_INITFINI_ARRAY_SUPPORT))
+  M2Scaffold_SetNeedsMain();
+#endif
 }
 
 /* Infrastructure for a VEC of bool values.  */
@@ -1245,6 +1252,11 @@ gm2_langhook_new_dispose_storage_substitution (void)
   return true;
 }
 
+static bool gm2_langhook_complain_wrong_lang (const struct cl_option *option ATTRIBUTE_UNUSED)
+{
+  return false;
+}
+
 #undef LANG_HOOKS_NAME
 #undef LANG_HOOKS_INIT
 #undef LANG_HOOKS_INIT_OPTIONS
@@ -1262,6 +1274,7 @@ gm2_langhook_new_dispose_storage_substitution (void)
 #undef LANG_HOOKS_GIMPLIFY_EXPR
 #undef LANG_HOOKS_EH_PERSONALITY
 #undef LANG_HOOKS_NEW_DISPOSE_STORAGE_SUBSTITUTION
+#undef LANG_HOOKS_COMPLAIN_WRONG_LANG_P
 
 #define LANG_HOOKS_NAME "GNU Modula-2"
 #define LANG_HOOKS_INIT gm2_langhook_init
@@ -1281,6 +1294,7 @@ gm2_langhook_new_dispose_storage_substitution (void)
 #define LANG_HOOKS_EH_PERSONALITY gm2_langhook_eh_personality
 #define LANG_HOOKS_NEW_DISPOSE_STORAGE_SUBSTITUTION \
   gm2_langhook_new_dispose_storage_substitution
+#define LANG_HOOKS_COMPLAIN_WRONG_LANG_P gm2_langhook_complain_wrong_lang
 
 struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;
 
diff --git a/gcc/m2/gm2-libs-ch/wrapc.c b/gcc/m2/gm2-libs-ch/wrapc.c
index cb3a77ae89f..6be21fe4501 100644
--- a/gcc/m2/gm2-libs-ch/wrapc.c
+++ b/gcc/m2/gm2-libs-ch/wrapc.c
@@ -62,7 +62,7 @@ wrapc_filesize (int f, unsigned int *low, unsigned int *high)
   if (res == 0)
     {
       *low = (unsigned int)s.st_size;
-      *high = (unsigned int)(s.st_size >> (sizeof (unsigned int) * 8));
+      *high = sizeof(s.st_size) > sizeof (unsigned int) ? (unsigned int)(s.st_size >> (sizeof (unsigned int) * 8)) : 0;
     }
   return res;
 }
@@ -91,7 +91,7 @@ wrapc_fileinode (int f, unsigned int *low, unsigned int *high)
   if (fstat (f, (struct stat *)&s) == 0)
     {
       *low = (unsigned int)s.st_ino;
-      *high = (unsigned int)(s.st_ino >> (sizeof (unsigned int) * 8));
+	  *high = sizeof (s.st_ino) > sizeof (unsigned int) ? (unsigned int)(s.st_ino >> (sizeof (unsigned int) * 8)) : 0;
       return 0;
     }
   else
diff --git a/gcc/m2/tools-src/mklink.c b/gcc/m2/tools-src/mklink.c
index e489e2ffcb4..9215b5c7438 100644
--- a/gcc/m2/tools-src/mklink.c
+++ b/gcc/m2/tools-src/mklink.c
@@ -137,6 +137,8 @@ addGccArg (char *arg)
     }
 }
 
+#include "libcmain.h"
+
 int
 main (int argc, char *argv[])
 {
diff --git a/gcc/main.cc b/gcc/main.cc
index 5f682c2bf52..34a0599585c 100644
--- a/gcc/main.cc
+++ b/gcc/main.cc
@@ -24,6 +24,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "diagnostic-core.h"
 #include "toplev.h"
 
+#include "libcmain.h"
+
 int main (int argc, char **argv);
 
 /* We define main() to call toplev::main(), which is defined in toplev.cc.
diff --git a/gcc/opts.cc b/gcc/opts.cc
index ffcbdfef0bd..672879e25f2 100644
--- a/gcc/opts.cc
+++ b/gcc/opts.cc
@@ -54,7 +54,7 @@ static void set_Wstrict_aliasing (struct gcc_options *opts, int onoff);
 
 const char *const debug_type_names[] =
 {
-  "none", "dwarf-2", "vms", "ctf", "btf", "codeview"
+  "none", "dbx", "dwarf-2", "vms", "ctf", "btf", "codeview"
 };
 
 /* Bitmasks of fundamental debug info formats indexed by enum
@@ -62,7 +62,7 @@ const char *const debug_type_names[] =
 
 static uint32_t debug_type_masks[] =
 {
-  NO_DEBUG, DWARF2_DEBUG, VMS_DEBUG,
+  NO_DEBUG, DBX_DEBUG, DWARF2_DEBUG, VMS_DEBUG,
   CTF_DEBUG, BTF_DEBUG, CODEVIEW_DEBUG
 };
 
@@ -3312,6 +3312,12 @@ common_handle_option (struct gcc_options *opts,
       set_debug_level (VMS_DEBUG, false, arg, opts, opts_set, loc);
       break;
 
+    case OPT_gstabs:
+    case OPT_gstabs_:
+      set_debug_level (DBX_DEBUG, code == OPT_gstabs_, arg, opts, opts_set,
+		       loc);
+      break;
+
     case OPT_gz:
     case OPT_gz_:
       /* Handled completely via specs.  */
@@ -3518,6 +3524,8 @@ set_debug_level (uint32_t dinfo, int extended, const char *arg,
 		 struct gcc_options *opts, struct gcc_options *opts_set,
 		 location_t loc)
 {
+  opts->x_use_gnu_debug_info_extensions = extended;
+
   if (dinfo == NO_DEBUG)
     {
       if (opts->x_write_symbols == NO_DEBUG)
@@ -3531,11 +3539,15 @@ set_debug_level (uint32_t dinfo, int extended, const char *arg,
 		opts->x_write_symbols |= DWARF2_DEBUG;
 	      else
 		opts->x_write_symbols = DWARF2_DEBUG;
+#elif defined DBX_DEBUGGING_INFO
+	      opts->x_write_symbols = DBX_DEBUG;
 #endif
 	    }
 
+#if 0
 	  if (opts->x_write_symbols == NO_DEBUG)
 	    warning_at (loc, 0, "target system does not support debug output");
+#endif
 	}
       else if ((opts->x_write_symbols & CTF_DEBUG)
 	       || (opts->x_write_symbols & BTF_DEBUG)
diff --git a/gcc/params.opt b/gcc/params.opt
index 64e453d29b7..b9e2a16c789 100644
--- a/gcc/params.opt
+++ b/gcc/params.opt
@@ -657,7 +657,7 @@ Common Joined UInteger Var(param_max_modulo_backtrack_attempts) Init(40) Param O
 The maximum number of backtrack attempts the scheduler should make when modulo scheduling a loop.
 
 -param=min-pagesize=
-Common Joined UInteger Var(param_min_pagesize) Init(4096) Param Optimization
+Common Joined UInteger Var(param_min_pagesize) Init(0) Param Optimization
 Minimum page size for warning purposes.
 
 -param=max-partial-antic-length=
diff --git a/gcc/poly-int.h b/gcc/poly-int.h
index 77f78752e74..d99f63b671f 100644
--- a/gcc/poly-int.h
+++ b/gcc/poly-int.h
@@ -374,7 +374,7 @@ template<> struct poly_int_fullness<true> { using type = poly_int_full; };
 /* A class containing polynomial integers.  The polynomial has N coefficients
    of type C, and N - 1 indeterminates.  */
 template<unsigned int N, typename C>
-struct poly_int
+class poly_int
 {
 public:
   poly_int () = default;
diff --git a/gcc/pretty-print.cc b/gcc/pretty-print.cc
index abd6c0b528f..1d547997e35 100644
--- a/gcc/pretty-print.cc
+++ b/gcc/pretty-print.cc
@@ -49,6 +49,13 @@ along with GCC; see the file COPYING3.  If not see
 #define WIN32_LEAN_AND_MEAN 1
 #include <windows.h>
 
+#ifndef COMMON_LVB_REVERSE_VIDEO
+#define COMMON_LVB_REVERSE_VIDEO 0x4000
+#endif
+#ifndef COMMON_LVB_UNDERSCORE
+#define COMMON_LVB_UNDERSCORE 0x8000
+#endif
+
 /* Write all bytes in [s,s+n) into the specified stream.
    Errors are ignored.  */
 static void
diff --git a/gcc/stab.def b/gcc/stab.def
new file mode 100644
index 00000000000..e5af19b2bd8
--- /dev/null
+++ b/gcc/stab.def
@@ -0,0 +1,239 @@
+/* Table of DBX symbol codes for the GNU system.
+   Copyright (C) 1988-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 3 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING3.  If
+   not see <http://www.gnu.org/licenses/>.  */
+
+/* This contains contribution from Cygnus Support.  */
+
+/* Global variable.  Only the name is significant.
+   To find the address, look in the corresponding external symbol.  */
+__define_stab (N_GSYM, 0x20, "GSYM")
+
+/* Function name for BSD Fortran.  Only the name is significant.
+   To find the address, look in the corresponding external symbol.  */
+__define_stab (N_FNAME, 0x22, "FNAME")
+
+/* Function name or text-segment variable for C.  Value is its address.
+   Desc is supposedly starting line number, but GCC doesn't set it
+   and DBX seems not to miss it.  */
+__define_stab (N_FUN, 0x24, "FUN")
+
+/* Data-segment variable with internal linkage.  Value is its address.
+   "Static Sym".  */
+__define_stab (N_STSYM, 0x26, "STSYM")
+
+/* BSS-segment variable with internal linkage.  Value is its address.  */
+__define_stab (N_LCSYM, 0x28, "LCSYM")
+
+/* Begin function marker.  */
+__define_stab (N_BNSYM, 0x2e, "BNSYM")
+
+/* End function marker.  */
+__define_stab (N_ENSYM, 0x4e, "ENSYM")
+
+/* Name of main routine.  Only the name is significant.
+   This is not used in C.  */
+__define_stab (N_MAIN, 0x2a, "MAIN")
+
+/* Global symbol in Pascal.
+   Supposedly the value is its line number; I'm skeptical.  */
+__define_stab (N_PC, 0x30, "PC")
+
+/* Number of symbols:  0, files,,funcs,lines according to Ultrix V4.0.  */
+__define_stab (N_NSYMS, 0x32, "NSYMS")
+
+/* "No DST map for sym: name, ,0,type,ignored"  according to Ultrix V4.0.  */
+__define_stab (N_NOMAP, 0x34, "NOMAP")
+
+/* New stab from Solaris.  I don't know what it means, but it
+   don't seem to contain useful information.  */
+__define_stab (N_OBJ, 0x38, "OBJ")
+
+/* New stab from Solaris.  I don't know what it means, but it
+   don't seem to contain useful information.  Possibly related to the
+   optimization flags used in this module.  */
+__define_stab (N_OPT, 0x3c, "OPT")
+
+/* Register variable.  Value is number of register.  */
+__define_stab (N_RSYM, 0x40, "RSYM")
+
+/* Modula-2 compilation unit.  Can someone say what info it contains?  */
+__define_stab (N_M2C, 0x42, "M2C")
+
+/* Line number in text segment.  Desc is the line number;
+   value is corresponding address.  */
+__define_stab (N_SLINE, 0x44, "SLINE")
+
+/* Similar, for data segment.  */
+__define_stab (N_DSLINE, 0x46, "DSLINE")
+
+/* Similar, for bss segment.  */
+__define_stab (N_BSLINE, 0x48, "BSLINE")
+
+/* Sun's source-code browser stabs.  ?? Don't know what the fields are.
+   Supposedly the field is "path to associated .cb file".  THIS VALUE
+   OVERLAPS WITH N_BSLINE!  */
+__define_stab (N_BROWS, 0x48, "BROWS")
+
+/* GNU Modula-2 definition module dependency.  Value is the modification time
+   of the definition file.  Other is nonzero if it is imported with the
+   GNU M2 keyword %INITIALIZE.  Perhaps N_M2C can be used if there
+   are enough empty fields? */
+__define_stab(N_DEFD, 0x4a, "DEFD")
+
+/* THE FOLLOWING TWO STAB VALUES CONFLICT.  Happily, one is for Modula-2
+   and one is for C++.   Still,...  */
+/* GNU C++ exception variable.  Name is variable name.  */
+__define_stab (N_EHDECL, 0x50, "EHDECL")
+/* Modula2 info "for imc":  name,,0,0,0  according to Ultrix V4.0.  */
+__define_stab (N_MOD2, 0x50, "MOD2")
+
+/* GNU C++ `catch' clause.  Value is its address.  Desc is nonzero if
+   this entry is immediately followed by a CAUGHT stab saying what exception
+   was caught.  Multiple CAUGHT stabs means that multiple exceptions
+   can be caught here.  If Desc is 0, it means all exceptions are caught
+   here.  */
+__define_stab (N_CATCH, 0x54, "CATCH")
+
+/* Structure or union element.  Value is offset in the structure.  */
+__define_stab (N_SSYM, 0x60, "SSYM")
+
+/* Name of main source file.
+   Value is starting text address of the compilation.  */
+__define_stab (N_SO, 0x64, "SO")
+
+/* Automatic variable in the stack.  Value is offset from frame pointer.
+   Also used for type descriptions.  */
+__define_stab (N_LSYM, 0x80, "LSYM")
+
+/* Beginning of an include file.  Only Sun uses this.
+   In an object file, only the name is significant.
+   The Sun linker puts data into some of the other fields.  */
+__define_stab (N_BINCL, 0x82, "BINCL")
+
+/* Name of sub-source file (#include file).
+   Value is starting text address of the compilation.  */
+__define_stab (N_SOL, 0x84, "SOL")
+
+/* Parameter variable.  Value is offset from argument pointer.
+   (On most machines the argument pointer is the same as the frame pointer.  */
+__define_stab (N_PSYM, 0xa0, "PSYM")
+
+/* End of an include file.  No name.
+   This and N_BINCL act as brackets around the file's output.
+   In an object file, there is no significant data in this entry.
+   The Sun linker puts data into some of the fields.  */
+__define_stab (N_EINCL, 0xa2, "EINCL")
+
+/* Alternate entry point.  Value is its address.  */
+__define_stab (N_ENTRY, 0xa4, "ENTRY")
+
+/* Beginning of lexical block.
+   The desc is the nesting level in lexical blocks.
+   The value is the address of the start of the text for the block.
+   The variables declared inside the block *precede* the N_LBRAC symbol.  */
+__define_stab (N_LBRAC, 0xc0, "LBRAC")
+
+/* Place holder for deleted include file.  Replaces a N_BINCL and everything
+   up to the corresponding N_EINCL.  The Sun linker generates these when
+   it finds multiple identical copies of the symbols from an include file.
+   This appears only in output from the Sun linker.  */
+__define_stab (N_EXCL, 0xc2, "EXCL")
+
+/* Modula-2 scope information.  Can someone say what info it contains?  */
+__define_stab (N_SCOPE, 0xc4, "SCOPE")
+
+/* End of a lexical block.  Desc matches the N_LBRAC's desc.
+   The value is the address of the end of the text for the block.  */
+__define_stab (N_RBRAC, 0xe0, "RBRAC")
+
+/* Begin named common block.  Only the name is significant.  */
+__define_stab (N_BCOMM, 0xe2, "BCOMM")
+
+/* End named common block.  Only the name is significant
+   (and it should match the N_BCOMM).  */
+__define_stab (N_ECOMM, 0xe4, "ECOMM")
+
+/* End common (local name): value is address.
+   I'm not sure how this is used.  */
+__define_stab (N_ECOML, 0xe8, "ECOML")
+
+/* These STAB's are used on Gould systems for Non-Base register symbols
+   or something like that.  FIXME.  I have assigned the values at random
+   since I don't have a Gould here.  Fixups from Gould folk welcome...  */
+__define_stab (N_NBTEXT, 0xF0, "NBTEXT")
+__define_stab (N_NBDATA, 0xF2, "NBDATA")
+__define_stab (N_NBBSS,  0xF4, "NBBSS")
+__define_stab (N_NBSTS,  0xF6, "NBSTS")
+__define_stab (N_NBLCS,  0xF8, "NBLCS")
+
+/* Second symbol entry containing a length-value for the preceding entry.
+   The value is the length.  */
+__define_stab (N_LENG, 0xfe, "LENG")
+
+/* The above information, in matrix format.
+
+			STAB MATRIX
+	_________________________________________________
+	| 00 - 1F are not dbx stab symbols		|
+	| In most cases, the low bit is the EXTernal bit|
+
+	| 00 UNDEF  | 02 ABS	| 04 TEXT   | 06 DATA	|
+	| 01  |EXT  | 03  |EXT	| 05  |EXT  | 07  |EXT	|
+
+	| 08 BSS    | 0A INDR	| 0C FN_SEQ | 0E   	|
+	| 09  |EXT  | 0B 	| 0D	    | 0F	|
+
+	| 10 	    | 12 COMM	| 14 SETA   | 16 SETT	|
+	| 11	    | 13	| 15 	    | 17	|
+
+	| 18 SETD   | 1A SETB	| 1C SETV   | 1E WARNING|
+	| 19	    | 1B	| 1D 	    | 1F FN	|
+
+	|_______________________________________________|
+	| Debug entries with bit 01 set are unused.	|
+	| 20 GSYM   | 22 FNAME	| 24 FUN    | 26 STSYM	|
+	| 28 LCSYM  | 2A MAIN	| 2C	    | 2E BNSYM	|
+	| 30 PC	    | 32 NSYMS	| 34 NOMAP  | 36	|
+	| 38 OBJ    | 3A	| 3C OPT    | 3E	|
+	| 40 RSYM   | 42 M2C	| 44 SLINE  | 46 DSLINE |
+	| 48 BSLINE*| 4A DEFD	| 4C        | 4E ENSYM	|
+	| 50 EHDECL*| 52	| 54 CATCH  | 56        |
+	| 58        | 5A        | 5C        | 5E	|
+	| 60 SSYM   | 62	| 64 SO	    | 66 	|
+	| 68 	    | 6A	| 6C	    | 6E	|
+	| 70	    | 72	| 74	    | 76	|
+	| 78	    | 7A	| 7C	    | 7E	|
+	| 80 LSYM   | 82 BINCL	| 84 SOL    | 86	|
+	| 88	    | 8A	| 8C	    | 8E	|
+	| 90	    | 92	| 94	    | 96	|
+	| 98	    | 9A	| 9C	    | 9E	|
+	| A0 PSYM   | A2 EINCL	| A4 ENTRY  | A6	|
+	| A8	    | AA	| AC	    | AE	|
+	| B0	    | B2	| B4	    | B6	|
+	| B8	    | BA	| BC	    | BE	|
+	| C0 LBRAC  | C2 EXCL	| C4 SCOPE  | C6	|
+	| C8	    | CA	| CC	    | CE	|
+	| D0	    | D2	| D4	    | D6	|
+	| D8	    | DA	| DC	    | DE	|
+	| E0 RBRAC  | E2 BCOMM	| E4 ECOMM  | E6	|
+	| E8 ECOML  | EA	| EC	    | EE	|
+	| F0	    | F2	| F4	    | F6	|
+	| F8	    | FA	| FC	    | FE LENG	|
+	+-----------------------------------------------+
+ * 50 EHDECL is also MOD2.
+ * 48 BSLINE is also BROWS.
+ */
diff --git a/gcc/system.h b/gcc/system.h
index e516b49d04a..fbd106169fa 100644
--- a/gcc/system.h
+++ b/gcc/system.h
@@ -204,16 +204,16 @@ extern int fprintf_unlocked (FILE *, const char *, ...);
 #ifdef INCLUDE_LIST
 # include <list>
 #endif
-#ifdef INCLUDE_MAP
+#if defined(INCLUDE_MAP) || defined(__APPLE__)
 # include <map>
 #endif
 #ifdef INCLUDE_SET
 # include <set>
 #endif
-#ifdef INCLUDE_STRING
+#if defined(INCLUDE_STRING) || defined(__APPLE__)
 # include <string>
 #endif
-#ifdef INCLUDE_VECTOR
+#if defined(INCLUDE_VECTOR) || defined(__APPLE__)
 # include <vector>
 #endif
 #ifdef INCLUDE_ARRAY
@@ -740,6 +740,9 @@ private:
 #ifndef HOST_BIT_BUCKET
 #define HOST_BIT_BUCKET "/dev/null"
 #endif
+#ifndef HOST_BIT_BUCKET2
+#define HOST_BIT_BUCKET2 ""
+#endif
 
 #ifndef offsetof
 #define offsetof(TYPE, MEMBER)	((size_t) &((TYPE *) 0)->MEMBER)
@@ -1020,7 +1023,8 @@ extern void fancy_abort (const char *, int, const char *)
 	ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL HOST_WORDS_BIG_ENDIAN	   \
 	OBJC_PROLOGUE ALLOCATE_TRAMPOLINE HANDLE_PRAGMA ROUND_TYPE_SIZE	   \
 	ROUND_TYPE_SIZE_UNIT CONST_SECTION_ASM_OP CRT_GET_RFIB_TEXT	   \
-	INSN_CACHE_DEPTH INSN_CACHE_SIZE				   \
+	DBX_LBRAC_FIRST DBX_OUTPUT_ENUM DBX_OUTPUT_SOURCE_FILENAME	   \
+	DBX_WORKING_DIRECTORY INSN_CACHE_DEPTH INSN_CACHE_SIZE		   \
 	INSN_CACHE_LINE_WIDTH INIT_SECTION_PREAMBLE NEED_ATEXIT ON_EXIT	   \
 	EXIT_BODY OBJECT_FORMAT_ROSE MULTIBYTE_CHARS MAP_CHARACTER	   \
 	LIBGCC_NEEDS_DOUBLE FINAL_PRESCAN_LABEL DEFAULT_CALLER_SAVES	   \
@@ -1033,14 +1037,15 @@ extern void fancy_abort (const char *, int, const char *)
 	MAX_WCHAR_TYPE_SIZE SHARED_SECTION_ASM_OP INTEGRATE_THRESHOLD      \
 	FINAL_REG_PARM_STACK_SPACE MAYBE_REG_PARM_STACK_SPACE		   \
 	TRADITIONAL_PIPELINE_INTERFACE DFA_PIPELINE_INTERFACE		   \
-	BUILTIN_SETJMP_FRAME_VALUE					   \
+	DBX_OUTPUT_STANDARD_TYPES BUILTIN_SETJMP_FRAME_VALUE		   \
 	SUNOS4_SHARED_LIBRARIES PROMOTE_FOR_CALL_ONLY			   \
 	SPACE_AFTER_L_OPTION NO_RECURSIVE_FUNCTION_CSE			   \
 	DEFAULT_MAIN_RETURN TARGET_MEM_FUNCTIONS EXPAND_BUILTIN_VA_ARG	   \
 	COLLECT_PARSE_FLAG DWARF2_GENERATE_TEXT_SECTION_LABEL WINNING_GDB  \
 	ASM_OUTPUT_FILENAME ASM_OUTPUT_SOURCE_LINE FILE_NAME_JOINER	   \
-	GDB_INV_REF_REGPARM_STABS_LETTER				   \
-	PUT_SDB_SRC_FILE STABS_GCC_MARKER SDB_GENERATE_FAKE		   \
+	GDB_INV_REF_REGPARM_STABS_LETTER DBX_MEMPARM_STABS_LETTER	   \
+	PUT_SDB_SRC_FILE STABS_GCC_MARKER DBX_OUTPUT_FUNCTION_END	   \
+	DBX_OUTPUT_GCC_MARKER DBX_FINISH_SYMBOL SDB_GENERATE_FAKE	   \
 	NON_SAVING_SETJMP TARGET_LATE_RTL_PROLOGUE_EPILOGUE		   \
 	CASE_DROPS_THROUGH TARGET_BELL TARGET_BS TARGET_CR TARGET_DIGIT0   \
         TARGET_ESC TARGET_FF TARGET_NEWLINE TARGET_TAB TARGET_VT	   \
@@ -1065,8 +1070,8 @@ extern void fancy_abort (const char *, int, const char *)
 	PREFERRED_OUTPUT_RELOAD_CLASS SYSTEM_INCLUDE_DIR		   \
 	STANDARD_INCLUDE_DIR STANDARD_INCLUDE_COMPONENT			   \
 	LINK_ELIMINATE_DUPLICATE_LDIRECTORIES MIPS_DEBUGGING_INFO	   \
-	IDENT_ASM_OP ALL_COP_ADDITIONAL_REGISTER_NAMES			   \
-	RANGE_TEST_NON_SHORT_CIRCUIT					   \
+	IDENT_ASM_OP ALL_COP_ADDITIONAL_REGISTER_NAMES DBX_OUTPUT_LBRAC	   \
+	DBX_OUTPUT_NFUN DBX_OUTPUT_RBRAC RANGE_TEST_NON_SHORT_CIRCUIT	   \
 	REAL_VALUE_TRUNCATE REVERSE_CONDEXEC_PREDICATES_P		   \
 	TARGET_ALIGN_ANON_BITFIELDS TARGET_NARROW_VOLATILE_BITFIELDS	   \
 	IDENT_ASM_OP UNALIGNED_SHORT_ASM_OP UNALIGNED_INT_ASM_OP	   \
diff --git a/gcc/target-def.h b/gcc/target-def.h
index a262f7d34be..40e3f05fd6e 100644
--- a/gcc/target-def.h
+++ b/gcc/target-def.h
@@ -63,7 +63,7 @@
 #  ifdef TARGET_ASM_NAMED_SECTION
 #   define TARGET_ASM_CONSTRUCTOR default_named_section_asm_out_constructor
 #  else
-#   define TARGET_ASM_CONSTRUCTOR default_asm_out_constructor
+#   define TARGET_ASM_CONSTRUCTOR default_stabs_asm_out_constructor
 #  endif
 # endif
 #endif
@@ -75,7 +75,7 @@
 #  ifdef TARGET_ASM_NAMED_SECTION
 #   define TARGET_ASM_DESTRUCTOR default_named_section_asm_out_destructor
 #  else
-#   define TARGET_ASM_DESTRUCTOR default_asm_out_destructor
+#   define TARGET_ASM_DESTRUCTOR default_stabs_asm_out_destructor
 #  endif
 # endif
 #endif
diff --git a/gcc/toplev.cc b/gcc/toplev.cc
index 6d8b8852fb8..255bf5fc463 100644
--- a/gcc/toplev.cc
+++ b/gcc/toplev.cc
@@ -96,12 +96,23 @@ along with GCC; see the file COPYING3.  If not see
 #include "unique-argv.h"
 #include "make-unique.h"
 
+#if defined(DBX_DEBUGGING_INFO) || defined(XCOFF_DEBUGGING_INFO)
+#include "dbxout.h"
+#endif
 #include "selftest.h"
 
 #ifdef HAVE_isl
 #include <isl/version.h>
 #endif
 
+#ifdef __MINGW32__
+#undef HOST_BIT_BUCKET
+#undef HOST_BIT_BUCKET2
+/* This is the name of the null device on windows.  */
+#define HOST_BIT_BUCKET "nul"
+#define HOST_BIT_BUCKET2 "/dev/null"
+#endif
+
 static void general_init (const char *, bool, unique_argv original_argv);
 static void backend_init (void);
 static int lang_dependent_init (const char *);
@@ -708,7 +719,8 @@ init_asm_output (const char *name)
       if (!strcmp (asm_file_name, "-"))
 	asm_out_file = stdout;
       else if (!canonical_filename_eq (asm_file_name, name)
-	       || !strcmp (asm_file_name, HOST_BIT_BUCKET))
+	       || !strcmp (asm_file_name, HOST_BIT_BUCKET)
+	       || !strcmp (asm_file_name, HOST_BIT_BUCKET2))
 	asm_out_file = fopen (asm_file_name, "w");
       else
 	/* Use UNKOWN_LOCATION to prevent gcc from printing the first
@@ -1035,6 +1047,8 @@ internal_error_function (diagnostic_context *, const char *, va_list *)
   emergency_dump_function ();
 }
 
+const char *toplev_argv0;
+
 /* Initialization of the front end environment, before command line
    options are parsed.  Signal handlers, internationalization etc.
    ARGV0 is main's argv[0].  */
@@ -1043,6 +1057,7 @@ general_init (const char *argv0, bool init_signals, unique_argv original_argv)
 {
   const char *p;
 
+  toplev_argv0 = argv0;
   p = argv0 + strlen (argv0);
   while (p != argv0 && !IS_DIR_SEPARATOR (p[-1]))
     --p;
@@ -1462,8 +1477,17 @@ process_options ()
       && ctf_debug_info_level == CTFINFO_LEVEL_NONE)
     write_symbols = NO_DEBUG;
 
+  /* Warn if STABS debug gets enabled and is not the default.  */
+  if (PREFERRED_DEBUGGING_TYPE != DBX_DEBUG && (write_symbols & DBX_DEBUG))
+    warning (0, "STABS debugging information is obsolete and not "
+	     "supported anymore");
+
   if (write_symbols == NO_DEBUG)
     ;
+#if defined(DBX_DEBUGGING_INFO)
+  else if (write_symbols == DBX_DEBUG)
+    debug_hooks = &dbx_debug_hooks;
+#endif
 #ifdef DWARF2_DEBUGGING_INFO
   else if (dwarf_debuginfo_p ())
     debug_hooks = &dwarf2_debug_hooks;
diff --git a/gcc/tree-data-ref.cc b/gcc/tree-data-ref.cc
index 8a46e6daabb..7c39ebce5de 100644
--- a/gcc/tree-data-ref.cc
+++ b/gcc/tree-data-ref.cc
@@ -103,6 +103,10 @@ along with GCC; see the file COPYING3.  If not see
 #include "tree-ssa-loop-ivopts.h"
 #include "calls.h"
 
+#ifdef __mc68000__
+#pragma GCC optimize "-Os"
+#endif
+
 static struct datadep_stats
 {
   int num_dependence_tests;
diff --git a/gcc/tree-loop-distribution.cc b/gcc/tree-loop-distribution.cc
index fc0cd3952d5..dd2996d5369 100644
--- a/gcc/tree-loop-distribution.cc
+++ b/gcc/tree-loop-distribution.cc
@@ -1771,6 +1771,7 @@ classify_builtin_st (loop_p loop, partition *partition, data_reference_p dr)
   gimple *stmt = DR_STMT (dr);
   tree base, size, rhs = gimple_assign_rhs1 (stmt);
 
+  return;
   if (const_with_all_bytes_same (rhs) == -1
       && (!INTEGRAL_TYPE_P (TREE_TYPE (rhs))
 	  || (TYPE_MODE (TREE_TYPE (rhs))
diff --git a/gcc/varasm.cc b/gcc/varasm.cc
index 10c1d2e3137..388e19b5b9d 100644
--- a/gcc/varasm.cc
+++ b/gcc/varasm.cc
@@ -1109,9 +1109,15 @@ align_variable (tree decl, bool dont_output_data)
      In particular, a.out format supports a maximum alignment of 4.  */
   if (align > MAX_OFILE_ALIGNMENT)
     {
+#if 0
       error ("alignment of %q+D is greater than maximum object "
 	     "file alignment %d", decl,
 	     MAX_OFILE_ALIGNMENT/BITS_PER_UNIT);
+#else
+      warning (OPT_Wattributes, "alignment of %q+D is greater than maximum object "
+	     "file alignment %d", decl,
+	     MAX_OFILE_ALIGNMENT/BITS_PER_UNIT);
+#endif
       align = MAX_OFILE_ALIGNMENT;
     }
 
@@ -1295,7 +1301,7 @@ get_variable_section (tree decl, bool prefer_noswitch_p)
       && !(prefer_noswitch_p && targetm.have_switchable_bss_sections)
       && bss_initializer_p (decl))
     {
-      if (!TREE_PUBLIC (decl)
+      if (!TREE_PUBLIC (decl) && !flag_no_common
 	  && !((flag_sanitize & SANITIZE_ADDRESS)
 	       && asan_protect_global (decl)))
 	return lcomm_section;
diff --git a/gnattools/Makefile.in b/gnattools/Makefile.in
index 996e600c196..2c33bf12782 100644
--- a/gnattools/Makefile.in
+++ b/gnattools/Makefile.in
@@ -204,7 +204,7 @@ gnattools-native: $(GCC_DIR)/stamp-tools $(GCC_DIR)/stamp-gnatlib-rts
 	  ../../gnatmake$(exeext) ../../gnatlink$(exeext)
 	# gnattools2
 	$(MAKE) -C $(GCC_DIR)/ada/tools -f ../Makefile \
-	  $(TOOLS_FLAGS_TO_PASS_NATIVE) common-tools
+	  $(TOOLS_FLAGS_TO_PASS_NATIVE) common-tools $(EXTRA_GNATTOOLS)
 
 # gnatmake/link can be built with recent gnatmake/link if they are available.
 # This is especially convenient for building cross tools or for rebuilding
@@ -216,7 +216,7 @@ regnattools: $(GCC_DIR)/stamp-gnatlib-rts
 	  gnatmake-re gnatlink-re
 	# gnattools2
 	$(MAKE) -C $(GCC_DIR)/ada/tools -f ../Makefile \
-	  $(TOOLS_FLAGS_TO_PASS_NATIVE) common-tools
+	  $(TOOLS_FLAGS_TO_PASS_NATIVE) common-tools $(EXTRA_GNATTOOLS)
 
 gnattools-cross: $(GCC_DIR)/stamp-tools
 	# gnattools1-re
diff --git a/gnattools/configure b/gnattools/configure
index 1eb0debc2ce..119fc5304d2 100755
--- a/gnattools/configure
+++ b/gnattools/configure
@@ -2081,7 +2081,7 @@ case "${target}" in
   *-*-vxworks*)
     TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     ;;
-  *-*-cygwin32* | *-*-mingw32* | *-*-pe)
+  *-*-cygwin32* | *-*-mingw* | *-*-pe)
     TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     EXTRA_GNATTOOLS='../../gnatdll$(exeext)'
     ;;
diff --git a/libatomic/configure b/libatomic/configure
index d579bab96f8..301bf16f22d 100755
--- a/libatomic/configure
+++ b/libatomic/configure
@@ -5284,7 +5284,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -9129,7 +9129,7 @@ _LT_EOF
       fi
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
       # as there is no search path for DLLs.
       hardcode_libdir_flag_spec='-L$libdir'
@@ -9560,7 +9560,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
       export_dynamic_flag_spec=-rdynamic
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # When not using gcc, we currently assume that we are using
       # Microsoft Visual C++.
       # hardcode_libdir_flag_spec is actually meaningless, as there is
@@ -10508,14 +10508,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -10539,7 +10539,7 @@ cygwin* | mingw* | pw32* | cegcc*)
 
       sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -11184,7 +11184,7 @@ else
     lt_cv_dlopen_self=yes
     ;;
 
-  mingw* | pw32* | cegcc*)
+  mingw* | msys* | pw32* | cegcc*)
     lt_cv_dlopen="LoadLibrary"
     lt_cv_dlopen_libs=
     ;;
@@ -11803,7 +11803,7 @@ CC="$lt_save_CC"
 
 
 case $host in
-  *-cygwin* | *-mingw*)
+  *-cygwin* | *-mingw* | *-msys*)
     # 'host' will be top-level target in the case of a target lib,
     # we must compare to with_cross_host to decide if this is a native
     # or cross-compiler and select where to install dlls appropriately.
@@ -15162,7 +15162,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
diff --git a/libbacktrace/configure b/libbacktrace/configure
index 85be043009a..3976b5b02a6 100755
--- a/libbacktrace/configure
+++ b/libbacktrace/configure
@@ -5732,7 +5732,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -9309,7 +9309,7 @@ _LT_EOF
       fi
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
       # as there is no search path for DLLs.
       hardcode_libdir_flag_spec='-L$libdir'
@@ -9740,7 +9740,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
       export_dynamic_flag_spec=-rdynamic
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # When not using gcc, we currently assume that we are using
       # Microsoft Visual C++.
       # hardcode_libdir_flag_spec is actually meaningless, as there is
@@ -10688,14 +10688,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -10719,7 +10719,7 @@ cygwin* | mingw* | pw32* | cegcc*)
 
       sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -11364,7 +11364,7 @@ else
     lt_cv_dlopen_self=yes
     ;;
 
-  mingw* | pw32* | cegcc*)
+  mingw* | msys* | pw32* | cegcc*)
     lt_cv_dlopen="LoadLibrary"
     lt_cv_dlopen_libs=
     ;;
@@ -13575,7 +13575,7 @@ done
 # Check for the fcntl function.
 if test -n "${with_target_subdir}"; then
    case "${host}" in
-   *-*-mingw*) have_fcntl=no ;;
+   *-*-mingw* | *-*-msys*) have_fcntl=no ;;
    *) have_fcntl=yes ;;
    esac
 else
diff --git a/libbacktrace/configure.ac b/libbacktrace/configure.ac
index 6549cdeacf4..77bccc10308 100644
--- a/libbacktrace/configure.ac
+++ b/libbacktrace/configure.ac
@@ -405,7 +405,7 @@ AC_CHECK_HEADERS(tlhelp32.h, [], [],
 # Check for the fcntl function.
 if test -n "${with_target_subdir}"; then
    case "${host}" in
-   *-*-mingw*) have_fcntl=no ;;
+   *-*-mingw* | *-*-msys*) have_fcntl=no ;;
    *) have_fcntl=yes ;;
    esac
 else
diff --git a/libcc1/configure b/libcc1/configure
index ea689a353c8..6e5c7ff5aae 100755
--- a/libcc1/configure
+++ b/libcc1/configure
@@ -4987,7 +4987,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -8563,7 +8563,7 @@ _LT_EOF
       fi
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
       # as there is no search path for DLLs.
       hardcode_libdir_flag_spec='-L$libdir'
@@ -8994,7 +8994,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
       export_dynamic_flag_spec=-rdynamic
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # When not using gcc, we currently assume that we are using
       # Microsoft Visual C++.
       # hardcode_libdir_flag_spec is actually meaningless, as there is
@@ -9942,14 +9942,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -9973,7 +9973,7 @@ cygwin* | mingw* | pw32* | cegcc*)
 
       sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -10618,7 +10618,7 @@ else
     lt_cv_dlopen_self=yes
     ;;
 
-  mingw* | pw32* | cegcc*)
+  mingw* | msys* | pw32* | cegcc*)
     lt_cv_dlopen="LoadLibrary"
     lt_cv_dlopen_libs=
     ;;
@@ -11898,7 +11898,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -12251,7 +12251,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
         esac
         ;;
 
-      cygwin* | mingw* | pw32* | cegcc*)
+      cygwin* | mingw* | msys* | pw32* | cegcc*)
         # _LT_TAGVAR(hardcode_libdir_flag_spec, CXX) is actually meaningless,
         # as there is no search path for DLLs.
         hardcode_libdir_flag_spec_CXX='-L$libdir'
@@ -14076,14 +14076,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -14106,7 +14106,7 @@ cygwin* | mingw* | pw32* | cegcc*)
       soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
 
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
diff --git a/libcody/cody.hh b/libcody/cody.hh
index 789ce9e70b7..8f5b30ab5f1 100644
--- a/libcody/cody.hh
+++ b/libcody/cody.hh
@@ -9,7 +9,7 @@
 // generally only good for requesting no networking
 #if !defined (CODY_NETWORKING)
 // Have a known-good list of networking systems
-#if defined (__unix__) || defined (__MACH__)
+#if (defined (__unix__) || defined (__MACH__)) && !defined(__MINT__)
 #define CODY_NETWORKING 1
 #else
 #define CODY_NETWORKING 0
@@ -792,10 +792,12 @@ int OpenLocal (char const **, char const *name);
 int ListenLocal (char const **, char const *name, unsigned backlog = 0);
 
 // ipv6 socket
+#ifdef AF_INET6
 int OpenInet6 (char const **e, char const *name, int port);
 int ListenInet6 (char const **, char const *name, int port,
 		 unsigned backlog = 0);
 #endif
+#endif
 
 // FIXME: Mapping file utilities?
 
diff --git a/libcody/netclient.cc b/libcody/netclient.cc
index 558808be485..9ee05b0176c 100644
--- a/libcody/netclient.cc
+++ b/libcody/netclient.cc
@@ -69,6 +69,7 @@ int OpenLocal (char const **e, char const *name)
   return OpenSocket (e, (sockaddr *)&addr, sizeof (addr));
 }
 
+#ifdef AF_INET6
 int OpenInet6 (char const **e, char const *name, int port)
 {
   addrinfo *addrs = nullptr;
@@ -133,6 +134,7 @@ int OpenInet6 (char const **e, char const *name, int port)
 
   return fd;
 }
+#endif
 
 }
 
diff --git a/libcody/netserver.cc b/libcody/netserver.cc
index 0499b5790b4..c44ae34faeb 100644
--- a/libcody/netserver.cc
+++ b/libcody/netserver.cc
@@ -76,6 +76,7 @@ int ListenLocal (char const **e, char const *name, unsigned backlog)
   return ListenSocket (e, (sockaddr *)&addr, sizeof (addr), backlog);
 }
 
+#ifdef AF_INET6
 int ListenInet6 (char const **e, char const *name, int port, unsigned backlog)
 {
   addrinfo *addrs = nullptr;
@@ -150,6 +151,7 @@ int ListenInet6 (char const **e, char const *name, int port, unsigned backlog)
 
   return fd;
 }
+#endif
 
 }
 #endif
diff --git a/libcody/resolver.cc b/libcody/resolver.cc
index 034fd63b9a8..480d9189fba 100644
--- a/libcody/resolver.cc
+++ b/libcody/resolver.cc
@@ -21,6 +21,10 @@
 #else
 #define HAVE_FSTATAT 0
 #endif
+#ifdef __MINT__
+#undef HAVE_FSTATAT
+#define HAVE_FSTATAT 0
+#endif
 
 // Resolver code
 
diff --git a/libcpp/configure b/libcpp/configure
index e3c39f4d7bd..3cde426fbb3 100755
--- a/libcpp/configure
+++ b/libcpp/configure
@@ -6954,7 +6954,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by GCC" >&5
 $as_echo_n "checking for ld used by GCC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
diff --git a/libcpp/files.cc b/libcpp/files.cc
index d80c4bfd907..a7dc50c1974 100644
--- a/libcpp/files.cc
+++ b/libcpp/files.cc
@@ -30,6 +30,13 @@ along with this program; see the file COPYING3.  If not see
 #include "md5.h"
 #include <dirent.h>
 
+/* Needed for stat_st_mode_symlink below */
+#if defined(_WIN32)
+#  include <windows.h>
+#  define S_IFLNK 0xF000
+#  define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
+#endif
+
 /* Variable length record files on VMS will have a stat size that includes
    record control characters that won't be included in the read size.  */
 #ifdef VMS
@@ -212,6 +219,49 @@ static int pchf_save_compare (const void *e1, const void *e2);
 static int pchf_compare (const void *d_p, const void *e_p);
 static bool check_file_against_entries (cpp_reader *, _cpp_file *, bool);
 
+#if defined(_WIN32)
+
+static int stat_st_mode_symlink (char const* path, struct stat* buf)
+{
+  WIN32_FILE_ATTRIBUTE_DATA attr;
+  memset(buf,0,sizeof(*buf));
+  int err = GetFileAttributesExA (path, GetFileExInfoStandard, &attr) ? 0 : 1;
+  if (!err)
+    {
+      WIN32_FIND_DATAA finddata;
+      HANDLE h = FindFirstFileA (path, &finddata);
+      if (h != INVALID_HANDLE_VALUE)
+        {
+          FindClose (h);
+          if ((finddata.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) &&
+              (finddata.dwReserved0 == IO_REPARSE_TAG_SYMLINK))
+              buf->st_mode = S_IFLNK;
+          else if (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
+              buf->st_mode = S_IFDIR;
+          else if (finddata.dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE)
+              buf->st_mode = S_IFDIR;
+          else
+              buf->st_mode = S_IFREG;
+          buf->st_mode |= S_IREAD;
+          if (!(finddata.dwFileAttributes & FILE_ATTRIBUTE_READONLY))
+              buf->st_mode |= S_IWRITE;
+        }
+      else
+        {
+          buf->st_mode = S_IFDIR;
+        }
+      return 0;
+    }
+  return -1;
+}
+
+#else
+
+#define stat_st_mode_symlink(_name, _buf) stat ((_name), (_buf))
+
+#endif
+
+
 /* Given a filename in FILE->PATH, with the empty string interpreted
    as <stdin>, open it.
 
@@ -241,6 +291,43 @@ open_file (_cpp_file *file)
     }
   else
     file->fd = open (file->path, O_RDONLY | O_NOCTTY | O_BINARY, 0666);
+#if defined(_WIN32) || defined(__CYGWIN__)
+  /* Windows and Posix differ in the face of paths of the form:
+     nonexistantdir/.. in that Posix will return ENOENT whereas
+     Windows won't care that we stepped into a non-existant dir
+     Only do these slow checks if ".." appears in file->path.
+     Cygwin also suffers from the same problem (but doesn't need
+     a new stat function):
+     http://cygwin.com/ml/cygwin/2013-05/msg00222.html
+  */
+  if (file->fd > 0)
+    {
+      char *filepath = xstrdup(file->path);
+      char* dirsep = filepath;
+      while ( (dirsep = strchr (dirsep, '\\')) != NULL)
+        *dirsep = '/';
+      if (strstr(file->path, "/../"))
+	{
+	  dirsep = filepath;
+	  char dirsepc;
+	  /* Check each directory in the chain. */
+	  while ( (dirsep = strpbrk (dirsep, "\\/")) != NULL)
+	    {
+	      dirsepc = *(++dirsep);
+	      *dirsep = '\0';
+	      if (stat_st_mode_symlink (filepath, &file->st) == -1)
+	        {
+		  free(filepath);
+	          close (file->fd);
+	          file->fd = -1;
+	          return false;
+	        }
+	      *dirsep++ = dirsepc;
+	    }
+	}
+	free(filepath);
+    }
+#endif
 
   if (file->fd != -1)
     {
diff --git a/libcpp/include/mkdeps.h b/libcpp/include/mkdeps.h
index 49aa0494463..fc53a96fc2d 100644
--- a/libcpp/include/mkdeps.h
+++ b/libcpp/include/mkdeps.h
@@ -52,15 +52,15 @@ extern void deps_add_target (class mkdeps *, const char *, int);
 extern void deps_add_default_target (class mkdeps *, const char *);
 
 /* Adds a module target.  The module name and cmi name are copied.  */
-extern void deps_add_module_target (struct mkdeps *, const char *module,
+extern void deps_add_module_target (class mkdeps *, const char *module,
 				    const char *cmi, bool is_header,
 				    bool is_exported);
 
 /* Adds a module dependency.  The module name is copied.  */
-extern void deps_add_module_dep (struct mkdeps *, const char *module);
+extern void deps_add_module_dep (class mkdeps *, const char *module);
 
 /* Add a structured dependency target.  */
-extern void fdeps_add_target (struct mkdeps *, const char *, bool);
+extern void fdeps_add_target (class mkdeps *, const char *, bool);
 
 /* Add a dependency (appears on the right side of the colon) to the
    deps list.  Dependencies will be printed in the order that they
@@ -73,7 +73,7 @@ extern void deps_add_dep (class mkdeps *, const char *);
 extern void deps_write (const cpp_reader *, FILE *, unsigned int);
 
 /* Write out a deps buffer to a specified file in P1689R5 format.  */
-extern void deps_write_p1689r5 (const struct mkdeps *, FILE *);
+extern void deps_write_p1689r5 (const class mkdeps *, FILE *);
 
 /* Write out a deps buffer to a file, in a form that can be read back
    with deps_restore.  Returns nonzero on error, in which case the
diff --git a/libcpp/init.cc b/libcpp/init.cc
index e9732afeb2c..adb92efa6c0 100644
--- a/libcpp/init.cc
+++ b/libcpp/init.cc
@@ -50,7 +50,7 @@ static void post_options (cpp_reader *);
 __extension__ const uchar _cpp_trigraph_map[UCHAR_MAX + 1] = {
 
 #define END };
-#define s(p, v) [p] = v,
+#define s(p, v) [(uchar)(p)] = v,
 
 #elif __cpp_constexpr >= 201304L
 
@@ -68,7 +68,7 @@ constexpr _cpp_trigraph_map_s _cpp_trigraph_map_d;
  unsigned char *x = _cpp_trigraph_map;
 
 #define END }
-#define s(p, v) x[p] = v;
+#define s(p, v) x[(uchar)(p)] = v;
 
 #endif
 
diff --git a/libcpp/internal.h b/libcpp/internal.h
index 9973836068b..59314f5a6b8 100644
--- a/libcpp/internal.h
+++ b/libcpp/internal.h
@@ -26,6 +26,12 @@ along with this program; see the file COPYING3.  If not see
 #include "cpplib.h"
 #include "rich-location.h"
 
+#ifdef __MINGW32__
+/* neither the configure script here nor in gcc checks whether it needs -liconv */
+#undef HAVE_ICONV
+#define HAVE_ICONV 0
+#endif
+
 #if HAVE_ICONV
 #include <iconv.h>
 #else
diff --git a/libcpp/macro.cc b/libcpp/macro.cc
index be257103471..b2a6891387b 100644
--- a/libcpp/macro.cc
+++ b/libcpp/macro.cc
@@ -3625,7 +3625,8 @@ parse_params (cpp_reader *pfile, unsigned *n_ptr, bool *variadic_ptr)
 		   ? N_("anonymous variadic macros were introduced in C++11")
 		   : N_("anonymous variadic macros were introduced in C99"));
 	      else if (CPP_OPTION (pfile, cpp_warn_c90_c99_compat) > 0
-		       && ! CPP_OPTION (pfile, cplusplus))
+		       && ! CPP_OPTION (pfile, cplusplus)
+		  && CPP_OPTION (pfile, warn_variadic_macros))
 		cpp_error (pfile, CPP_DL_WARNING,
 			   "anonymous variadic macros were introduced in C99");
 	    }
diff --git a/libdecnumber/decNumberLocal.h b/libdecnumber/decNumberLocal.h
index bf378d41954..127b31364ef 100644
--- a/libdecnumber/decNumberLocal.h
+++ b/libdecnumber/decNumberLocal.h
@@ -187,7 +187,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
   #if (DECNUMMAXE != DEC_MAX_EMAX)
     #error Maximum exponent mismatch
   #endif
-  #if (DECNUMMINE != DEC_MIN_EMIN)
+  #if !(DECNUMMINE == DEC_MIN_EMIN) /* gcc 2.95.3 has bug in '!=' operator for negative constants */
     #error Minimum exponent mismatch
   #endif
 
diff --git a/libffi/acinclude.m4 b/libffi/acinclude.m4
index 1a70efb010d..0af866ecb2f 100644
--- a/libffi/acinclude.m4
+++ b/libffi/acinclude.m4
@@ -37,7 +37,7 @@ else
    # Systems known to be in this category are Windows (all variants),
    # VMS, and Darwin.
    case "$host_os" in
-     vms* | cygwin* | pe | mingw* | darwin* | ultrix* | hpux10* | hpux11.00)
+     vms* | cygwin* | pe | mingw* | msys* | darwin* | ultrix* | hpux10* | hpux11.00)
 	ac_cv_func_mmap_dev_zero=no ;;
      *)
 	ac_cv_func_mmap_dev_zero=yes;;
@@ -69,7 +69,7 @@ else
    # above for use of /dev/zero.
    # Systems known to be in this category are Windows, VMS, and SCO Unix.
    case "$host_os" in
-     vms* | cygwin* | pe | mingw* | sco* | udk* )
+     vms* | cygwin* | pe | mingw* | mwys* | sco* | udk* )
 	ac_cv_func_mmap_anon=no ;;
      *)
 	ac_cv_func_mmap_anon=yes;;
diff --git a/libffi/configure b/libffi/configure
index f82a45b13bc..51f131bc5be 100755
--- a/libffi/configure
+++ b/libffi/configure
@@ -5516,7 +5516,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -5875,6 +5875,12 @@ else
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
+  mint*)
+    # On MiNT this test can take minutes to run, and I'm not sure it's
+    # healthy for this platform. Let's restrict it to 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
   amigaos*)
     # On AmigaOS with pdksh, this test takes hours, literally.
     # So we just punt and use a minimum line length of 8192.
@@ -9361,7 +9367,7 @@ _LT_EOF
       fi
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
       # as there is no search path for DLLs.
       hardcode_libdir_flag_spec='-L$libdir'
@@ -9792,7 +9798,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
       export_dynamic_flag_spec=-rdynamic
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # When not using gcc, we currently assume that we are using
       # Microsoft Visual C++.
       # hardcode_libdir_flag_spec is actually meaningless, as there is
@@ -10740,14 +10746,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -10771,7 +10777,7 @@ cygwin* | mingw* | pw32* | cegcc*)
 
       sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -11416,7 +11422,7 @@ else
     lt_cv_dlopen_self=yes
     ;;
 
-  mingw* | pw32* | cegcc*)
+  mingw* | msys* | pw32* | cegcc*)
     lt_cv_dlopen="LoadLibrary"
     lt_cv_dlopen_libs=
     ;;
@@ -12290,7 +12296,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -12643,7 +12649,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
         esac
         ;;
 
-      cygwin* | mingw* | pw32* | cegcc*)
+      cygwin* | mingw* | msys* | pw32* | cegcc*)
         # _LT_TAGVAR(hardcode_libdir_flag_spec, CXX) is actually meaningless,
         # as there is no search path for DLLs.
         hardcode_libdir_flag_spec_CXX='-L$libdir'
@@ -14468,14 +14474,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -14498,7 +14504,7 @@ cygwin* | mingw* | pw32* | cegcc*)
       soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
 
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -15386,7 +15392,7 @@ else
    # Systems known to be in this category are Windows (all variants),
    # VMS, and Darwin.
    case "$host_os" in
-     vms* | cygwin* | pe | mingw* | darwin* | ultrix* | hpux10* | hpux11.00)
+     vms* | cygwin* | pe | mingw* | msys* | darwin* | ultrix* | hpux10* | hpux11.00)
 	ac_cv_func_mmap_dev_zero=no ;;
      *)
 	ac_cv_func_mmap_dev_zero=yes;;
@@ -15443,7 +15449,7 @@ else
    # above for use of /dev/zero.
    # Systems known to be in this category are Windows, VMS, and SCO Unix.
    case "$host_os" in
-     vms* | cygwin* | pe | mingw* | sco* | udk* )
+     vms* | cygwin* | pe | mingw* | msys* | sco* | udk* )
 	ac_cv_func_mmap_anon=no ;;
      *)
 	ac_cv_func_mmap_anon=yes;;
@@ -16693,7 +16699,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
diff --git a/libffi/configure.host b/libffi/configure.host
index 9d73f18ee8c..26d2f2b89de 100644
--- a/libffi/configure.host
+++ b/libffi/configure.host
@@ -84,7 +84,7 @@ case "${host}" in
 	;;
 
   i?86-*-cygwin* | i?86-*-mingw* | i?86-*-win* | i?86-*-os2* | i?86-*-interix* \
-  | x86_64-*-cygwin* | x86_64-*-mingw* | x86_64-*-win* )
+  | x86_64-*-cygwin* | x86_64-*-mingw* | x86_64-*-win* | *-*-msys* )
 	TARGETDIR=x86
 	if test $ac_cv_sizeof_size_t = 4; then
 	  TARGET=X86_WIN32
diff --git a/libgcc/Makefile.in b/libgcc/Makefile.in
index 0719fd0615d..78e729f6098 100644
--- a/libgcc/Makefile.in
+++ b/libgcc/Makefile.in
@@ -509,7 +509,7 @@ endif
 # Build lib2funcs.  For the static library also include LIB2FUNCS_ST.
 lib2funcs-o = $(patsubst %,%$(objext),$(lib2funcs) $(LIB2FUNCS_ST))
 $(lib2funcs-o): %$(objext): $(srcdir)/libgcc2.c
-	$(gcc_compile) -DL$* -c $< $(vis_hide)
+	$(gcc_compile) -fcommon -DL$* -c $< $(vis_hide)
 libgcc-objects += $(lib2funcs-o)
 
 ifeq ($(enable_shared),yes)
diff --git a/libgcc/config.host b/libgcc/config.host
index 6a88ee5a2dd..fcdf848a6ff 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -1042,6 +1042,13 @@ m68k-*-linux*)			# Motorola m68k's running GNU/Linux
 	fi
 	md_unwind_header=m68k/linux-unwind.h
 	;;
+m68k-*-mintelf*)
+	tmake_file="$tmake_file m68k/t-floatlib m68k/t-mint"
+	extra_parts="$extra_parts crtbegin.o crtend.o"
+	;;
+m68k-*-mint*)
+	tmake_file="$tmake_file m68k/t-floatlib m68k/t-mint"
+	;;
 m68k-*-rtems*)
 	tmake_file="$tmake_file m68k/t-floatlib"
 	extra_parts="$extra_parts crti.o crtn.o"
diff --git a/libgcc/config/m68k/addxf.S b/libgcc/config/m68k/addxf.S
new file mode 100644
index 00000000000..3cf97b1039f
--- /dev/null
+++ b/libgcc/config/m68k/addxf.S
@@ -0,0 +1,648 @@
+|=============================================================================
+|                              __addxf3
+|=============================================================================
+
+| long double __addxf3(long double, long double);
+	FUNC(__addxf3)
+SYM (__addxf3):
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+	moveml	a6@(8),d0-d1/a4	| get first operand into d0-d1/a4
+	clrw	d0
+	moveml	a6@(20),d2-d3/a5 | and second operand into d2-d3/a5
+	clrw	d2
+
+	movel	d0,d7		| get d0's sign bit in d7
+	bclr	IMM(31),d0
+	movel	a4,d4
+	orl		d0,d4
+	orl		d1,d4
+	beq	Laddxf$b	| if zero return second operand
+
+	movel	d2,d6		| save sign in d6
+	bclr	IMM(31),d2
+	movel	a5,d4
+	orl		d2,d4
+	orl		d3,d4
+	beq	Laddxf$a	| if zero return first operand
+
+	andl	IMM (0x80000000),d7 | isolate a's sign bit
+    swap	d6		| and also b's sign bit
+#ifndef __mcoldfire__
+	andw	IMM (0x8000),d6	|
+	orw	d6,d7		| and combine them into d7, so that a's sign
+				| bit is in the high word and b's is in the
+				| low word, so d6 is free to be used
+#else
+	andl	IMM (0x8000),d6
+	orl	d6,d7
+#endif
+	movel	d7,a0		| now save d7 into a0, so d7 is free to
+                		| be used also
+
+| Get the exponents and check for denormalized and/or infinity.
+
+	movel	IMM (0x7fffffff),d6 | mask for the fraction
+	movel	IMM (0x80000000),d7 | mask to put hidden bit back
+
+	andl	d6,d1		| get fraction in d1
+	movel	d0,d4		|
+	swap	d4			| get exponent in d4
+	beq	Laddxf$a$den	| branch if a is denormalized
+#ifndef __mcoldfire__
+	cmpw	IMM(X_MAX_EXP),d4		| check for INFINITY or NaN
+#else
+	cmpl	IMM(X_MAX_EXP),d4		| check for INFINITY or NaN
+#endif
+	beq	Laddxf$nf       |
+	orl	d7,d1		| and put hidden bit back
+Laddxf$1:
+	movel	d1,d0
+	movel	a4,d1
+| Now we have a's exponent in d4 and fraction in d0-d1
+
+	andl	d6,d3		| get fraction in d3
+	movel	d2,d5
+	swap	d5		| get exponent in d5
+	beq	Laddxf$b$den	| branch if b is denormalized
+#ifndef __mcoldfire__
+	cmpw	IMM(X_MAX_EXP),d5		| check for INFINITY or NaN
+#else
+	cmpl	IMM(X_MAX_EXP),d5		| check for INFINITY or NaN
+#endif
+	beq	Laddxf$nf
+	orl	d7,d3		| and put hidden bit back
+Laddxf$2:
+
+	movel	d3,d2
+	movel	a5,d3
+| Now we have b's exponent in d5 and fraction in d2-d3.
+
+| The situation now is as follows: the signs are combined in a0, the
+| numbers are in d0-d1 (a) and d2-d3 (b), and the exponents in d4 (a)
+| and d5 (b). To do the rounding correctly we need to keep all the
+| bits until the end, so we need to use d0-d1-d2-d3 for the first number
+| and d4-d5-d6-d7 for the second. To do this we store (temporarily) the
+| exponents in a2-a3.
+
+	movel	d4,a2		| save the exponents
+	movel	d5,a3		|
+
+	movel	IMM (0),d7	| and move the numbers around
+	movel	d7,d6		|
+	movel	d3,d5		|
+	movel	d2,d4		|
+	movel	d7,d3		|
+	movel	d7,d2		|
+
+| Here we shift the numbers until the exponents are the same, and put
+| the largest exponent in a2.
+#ifndef __mcoldfire__
+	exg	d4,a2		| get exponents back
+	exg	d5,a3		|
+	cmpw	d4,d5		| compare the exponents
+#else
+	movel	d4,a4		| get exponents back
+	movel	a2,d4
+	movel	a4,a2
+	movel	d5,a4
+	movel	a3,d5
+	movel	a4,a3
+	cmpl	d4,d5		| compare the exponents
+#endif
+	beq	Laddxf$3	| if equal don't shift
+	bhi	9f		| branch if second exponent is higher
+
+| Here we have a's exponent larger than b's, so we have to shift b. We do
+| this by using as counter d2:
+1:	movew	d4,d2		| move largest exponent to d2
+#ifndef __mcoldfire__
+	subw	d5,d2		| and subtract second exponent
+	exg	d4,a2		| get back the longs we saved
+	exg	d5,a3		|
+#else
+	subl	d5,d2		| and subtract second exponent
+	movel	d4,a4		| get back the longs we saved
+	movel	a2,d4
+	movel	a4,a2
+	movel	d5,a4
+	movel	a3,d5
+	movel	a4,a3
+#endif
+| if difference is too large we don't shift (actually, we can just exit)
+#ifndef __mcoldfire__
+	cmpw	IMM (LDBL_MANT_DIG),d2
+#else
+	cmpl	IMM (LDBL_MANT_DIG),d2
+#endif
+	bge	Laddxf$b$small
+#ifndef __mcoldfire__
+	cmpw	IMM (32),d2	| if difference >= 32, shift by longs
+#else
+	cmpl	IMM (32),d2	| if difference >= 32, shift by longs
+#endif
+	bge	5f
+2:
+#ifndef __mcoldfire__
+	cmpw	IMM (16),d2	| if difference >= 16, shift by words
+#else
+	cmpl	IMM (16),d2	| if difference >= 16, shift by words
+#endif
+	bge	6f
+	bra	3f		| enter dbra loop
+
+4:
+#ifndef __mcoldfire__
+	lsrl	IMM (1),d4
+	roxrl	IMM (1),d5
+	roxrl	IMM (1),d6
+	roxrl	IMM (1),d7
+#else
+	lsrl	IMM (1),d7
+	btst	IMM (0),d6
+	beq	10f
+	bset	IMM (31),d7
+10:	lsrl	IMM (1),d6
+	btst	IMM (0),d5
+	beq	11f
+	bset	IMM (31),d6
+11:	lsrl	IMM (1),d5
+	btst	IMM (0),d4
+	beq	12f
+	bset	IMM (31),d5
+12:	lsrl	IMM (1),d4
+#endif
+3:
+#ifndef __mcoldfire__
+	dbra	d2,4b
+#else
+	subql	IMM (1),d2
+	bpl	4b
+#endif
+	movel	IMM (0),d2
+	movel	d2,d3
+	bra	Laddxf$4
+5:
+	movel	d6,d7
+	movel	d5,d6
+	movel	d4,d5
+	movel	IMM (0),d4
+#ifndef __mcoldfire__
+	subw	IMM (32),d2
+#else
+	subl	IMM (32),d2
+#endif
+	bra	2b
+6:
+	movew	d6,d7
+	swap	d7
+	movew	d5,d6
+	swap	d6
+	movew	d4,d5
+	swap	d5
+	movew	IMM (0),d4
+	swap	d4
+#ifndef __mcoldfire__
+	subw	IMM (16),d2
+#else
+	subl	IMM (16),d2
+#endif
+	bra	3b
+
+9:
+#ifndef __mcoldfire__
+	exg	d4,d5
+	movew	d4,d6
+	subw	d5,d6		| keep d5 (largest exponent) in d4
+	exg	d4,a2
+	exg	d5,a3
+#else
+	movel	d5,d6
+	movel	d4,d5
+	movel	d6,d4
+	subl	d5,d6
+	movel	d4,a4
+	movel	a2,d4
+	movel	a4,a2
+	movel	d5,a4
+	movel	a3,d5
+	movel	a4,a3
+#endif
+| if difference is too large we don't shift (actually, we can just exit)
+#ifndef __mcoldfire__
+	cmpw	IMM (LDBL_MANT_DIG),d6
+#else
+	cmpl	IMM (LDBL_MANT_DIG),d6
+#endif
+	bge	Laddxf$a$small
+#ifndef __mcoldfire__
+	cmpw	IMM (32),d6	| if difference >= 32, shift by longs
+#else
+	cmpl	IMM (32),d6	| if difference >= 32, shift by longs
+#endif
+	bge	5f
+2:
+#ifndef __mcoldfire__
+	cmpw	IMM (16),d6	| if difference >= 16, shift by words
+#else
+	cmpl	IMM (16),d6	| if difference >= 16, shift by words
+#endif
+	bge	6f
+	bra	3f		| enter dbra loop
+
+4:
+#ifndef __mcoldfire__
+	lsrl	IMM (1),d0
+	roxrl	IMM (1),d1
+	roxrl	IMM (1),d2
+	roxrl	IMM (1),d3
+#else
+	lsrl	IMM (1),d3
+	btst	IMM (0),d2
+	beq	10f
+	bset	IMM (31),d3
+10:	lsrl	IMM (1),d2
+	btst	IMM (0),d1
+	beq	11f
+	bset	IMM (31),d2
+11:	lsrl	IMM (1),d1
+	btst	IMM (0),d0
+	beq	12f
+	bset	IMM (31),d1
+12:	lsrl	IMM (1),d0
+#endif
+3:
+#ifndef __mcoldfire__
+	dbra	d6,4b
+#else
+	subql	IMM (1),d6
+	bpl	4b
+#endif
+	movel	IMM (0),d7
+	movel	d7,d6
+	bra	Laddxf$4
+5:
+	movel	d2,d3
+	movel	d1,d2
+	movel	d0,d1
+	movel	IMM (0),d0
+#ifndef __mcoldfire__
+	subw	IMM (32),d6
+#else
+	subl	IMM (32),d6
+#endif
+	bra	2b
+6:
+	movew	d2,d3
+	swap	d3
+	movew	d1,d2
+	swap	d2
+	movew	d0,d1
+	swap	d1
+	movew	IMM (0),d0
+	swap	d0
+#ifndef __mcoldfire__
+	subw	IMM (16),d6
+#else
+	subl	IMM (16),d6
+#endif
+	bra	3b
+Laddxf$3:
+#ifndef __mcoldfire__
+	exg	d4,a2
+	exg	d5,a3
+#else
+	movel	d4,a4
+	movel	a2,d4
+	movel	a4,a2
+	movel	d5,a4
+	movel	a3,d5
+	movel	a4,a3
+#endif
+Laddxf$4:
+| Now we have the numbers in d0--d3 and d4--d7, the exponent in a2, and
+| the signs in a0.
+
+| Here we have to decide whether to add or subtract the numbers:
+#ifndef __mcoldfire__
+	exg	d7,a0		| get the signs
+	exg	d6,a3		| a3 is free to be used
+#else
+	movel	d7,a4
+	movel	a0,d7
+	movel	a4,a0
+	movel	d6,a4
+	movel	a3,d6
+	movel	a4,a3
+#endif
+	movel	d7,d6		|
+	movew	IMM (0),d7	| get a's sign in d7
+	swap	d6              |
+	movew	IMM (0),d6	| and b's sign in d6
+	eorl	d7,d6		| compare the signs
+	bmi	Lsubxf$0	| if the signs are different we have
+				| to subtract
+#ifndef __mcoldfire__
+	exg	d7,a0		| else we add the numbers
+	exg	d6,a3		|
+#else
+	movel	d7,a4
+	movel	a0,d7
+	movel	a4,a0
+	movel	d6,a4
+	movel	a3,d6
+	movel	a4,a3
+#endif
+	addl	d7,d3		|
+	addxl	d6,d2		|
+	addxl	d5,d1		|
+	addxl	d4,d0           |
+
+	movel	a2,d4		| return exponent to d4
+	movel	a0,d7		|
+	andl	IMM (0x80000000),d7 | d7 now has the sign
+
+| Before rounding normalize so bit #LDBL_MANT_DIG is set (we will consider
+| the case of denormalized numbers in the rounding routine itself).
+| As in the addition (not in the subtraction!) we could have set
+| one more bit we check this:
+	btst	IMM (LDBL_MANT_DIG-1-32),d0
+	beq	1f
+#ifndef __mcoldfire__
+	lsrl	IMM (1),d0
+	roxrl	IMM (1),d1
+	roxrl	IMM (1),d2
+	roxrl	IMM (1),d3
+	addw	IMM (1),d4
+#else
+	lsrl	IMM (1),d3
+	btst	IMM (0),d2
+	beq	10f
+	bset	IMM (31),d3
+10:	lsrl	IMM (1),d2
+	btst	IMM (0),d1
+	beq	11f
+	bset	IMM (31),d2
+11:	lsrl	IMM (1),d1
+	btst	IMM (0),d0
+	beq	12f
+	bset	IMM (31),d1
+12:	lsrl	IMM (1),d0
+	addl	IMM (1),d4
+#endif
+1:
+	PICLEA	SYM (_fpCCR),a0	| check the rounding mode
+#ifdef __mcoldfire__
+	clrl	d6
+#endif
+	movew	a0@(6),d6	| rounding mode in d6
+	lea	pc@(Laddxf$5),a0 | to return from rounding routine
+	beq	Lround$to$nearest
+#ifndef __mcoldfire__
+	cmpw	IMM (ROUND_TO_PLUS),d6
+#else
+	cmpl	IMM (ROUND_TO_PLUS),d6
+#endif
+	bhi	Lround$to$minus
+	blt	Lround$to$zero
+	bra	Lround$to$plus
+Laddxf$5:
+| Put back the exponent and check for overflow
+	movel	d2,a4
+#ifndef __mcoldfire__
+	cmpw	IMM (X_MAX_EXP),d4	| is the exponent big?
+#else
+	cmpl	IMM (X_MAX_EXP),d4	| is the exponent big?
+#endif
+	bcc	1f
+	bset	IMM (31),d0 | put hidden bit back
+	swap	d4	| put exponent back into position
+| Put back the numbers
+	movel	d2,a4
+	movel	d0,d1
+	movel	d4,d0
+	bra	Laddxf$ret
+1:
+	moveq	IMM (ADD),d5
+	bra	Lx$overflow
+
+Lsubxf$0:
+| Here we do the subtraction.
+#ifndef __mcoldfire__
+	exg	d7,a0		| put sign back in a0
+	exg	d6,a3		|
+#else
+	movel	d7,a4
+	movel	a0,d7
+	movel	a4,a0
+	movel	d6,a4
+	movel	a3,d6
+	movel	a4,a3
+#endif
+	subl	d7,d3		|
+	subxl	d6,d2		|
+	subxl	d5,d1		|
+	subxl	d4,d0		|
+	beq	Laddxf$ret$1	| if zero just exit
+	bpl	1f		| if positive skip the following
+	movel	a0,d7		|
+	bchg	IMM (31),d7	| change sign bit in d7
+	movel	d7,a0		|
+	negl	d3		|
+	negxl	d2		|
+	negxl	d1              | and negate result
+	negxl	d0              |
+1:
+	movel	a2,d4		| return exponent to d4
+	movel	a0,d7
+	andl	IMM (0x80000000),d7 | isolate sign bit
+
+| Before rounding normalize so bit #LDBL_MANT_DIG is set (we will consider
+| the case of denormalized numbers in the rounding routine itself).
+| As in the addition (not in the subtraction!) we could have set
+| one more bit we check this:
+	btst	IMM (LDBL_MANT_DIG-1-32),d0
+	beq	1f
+#ifndef __mcoldfire__
+	lsrl	IMM (1),d0
+	roxrl	IMM (1),d1
+	roxrl	IMM (1),d2
+	roxrl	IMM (1),d3
+	addw	IMM (1),d4
+#else
+	lsrl	IMM (1),d3
+	btst	IMM (0),d2
+	beq	10f
+	bset	IMM (31),d3
+10:	lsrl	IMM (1),d2
+	btst	IMM (0),d1
+	beq	11f
+	bset	IMM (31),d2
+11:	lsrl	IMM (1),d1
+	btst	IMM (0),d0
+	beq	12f
+	bset	IMM (31),d1
+12:	lsrl	IMM (1),d0
+	addl	IMM (1),d4
+#endif
+1:
+	lea	pc@(Lsubxf$1),a0 | to return from rounding routine
+	PICLEA	SYM (_fpCCR),a1	| check the rounding mode
+#ifdef __mcoldfire__
+	clrl	d6
+#endif
+	movew	a1@(6),d6	| rounding mode in d6
+	beq	Lround$to$nearest
+#ifndef __mcoldfire__
+	cmpw	IMM (ROUND_TO_PLUS),d6
+#else
+	cmpl	IMM (ROUND_TO_PLUS),d6
+#endif
+	bhi	Lround$to$minus
+	blt	Lround$to$zero
+	bra	Lround$to$plus
+Lsubxf$1:
+| Put back the exponent and sign (we don't have overflow).
+	bset	IMM (31),d0 | put hidden bit back
+	swap	d4	| put exponent back into position
+| Put back the numbers
+	movel	d2,a4
+	movel	d0,d1
+	movel	d4,d0
+	bra	Laddxf$ret
+
+| If one of the numbers was too small (difference of exponents >=
+| LDBL_MANT_DIG) we return the other (and now we don't have to
+| check for finiteness or zero).
+Laddxf$a$small:
+	moveml a6@(20),d0-d1/a4
+	bra Laddxf$retnorm
+
+Laddxf$b$small:
+	moveml a6@(8),d0-d1/a4
+	bra Laddxf$retnorm
+
+Laddxf$a$den:
+	movel	d7,d4		| d7 contains 0x00200000
+	bra	Laddxf$1
+
+Laddxf$b$den:
+	movel	d7,d5           | d7 contains 0x00200000
+	notl	d6
+	bra	Laddxf$2
+
+Laddxf$b:
+| Return b (if a is zero)
+	movel	d2,d0
+	movel	d3,d1
+	movel	a5,d5
+	bne	1f			| Check if b is -0
+	tstl	d1
+	bne	1f			| Check if b is -0
+	cmpl	IMM (0x80000000),d0
+	bne	1f
+	andl	IMM (0x80000000),d7	| Use the sign of a
+	clrl	d0
+	bra	Laddxf$ret
+Laddxf$a:
+	moveml	a6@(8),d0-d1/d5
+1:
+	movel	d5,a4
+	moveq	IMM (ADD),d5
+| Check for NaN and +/-INFINITY.
+	movel	d0,d7         		|
+	andl	IMM (0x80000000),d7	|
+	andl	IMM (0x7fff0000),d0		|
+	cmpl	IMM (0x7fff0000),d0	|
+	bge	2f			|
+	movel	a4,d4           	| check for zero, since we don't
+	orl		d0,d4		| want to return -0 by mistake
+	orl		d1,d4
+	bne	Laddxf$ret		| want to return -0 by mistake
+	bclr	IMM (31),d7		|
+	bra	Laddxf$ret		|
+2:
+	movel	a4,d0	| check for NaN (nonzero fraction)
+	orl	d1,d0			|
+	bne	Lx$inop         	|
+	bra	Lx$infty		|
+
+Laddxf$ret$1:
+	movel	d0,a4
+	movel	d0,d1
+
+Laddxf$ret:
+| Normal exit.
+	orl	d7,d0		| put sign bit back
+Laddxf$retnorm:
+	PICLEA	SYM (_fpCCR),a0
+	clrw	a0@
+	moveml	d0-d1/a4,a1@
+	movel	a1,d0
+	moveml	sp@,d2-d7/a2-a5
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6
+	rts
+
+Laddxf$ret$den:
+| Return a denormalized number.
+#ifndef __mcoldfire__
+	lsrl	IMM (1),d0	| shift right once more
+	roxrl	IMM (1),d1	|
+#else
+	lsrl	IMM (1),d1
+	btst	IMM (0),d0
+	beq	10f
+	bset	IMM (31),d1
+10:	lsrl	IMM (1),d0
+#endif
+	bra	Laddxf$ret
+
+Laddxf$nf:
+	moveq	IMM (ADD),d5
+| This could be faster but it is not worth the effort, since it is not
+| executed very often. We sacrifice speed for clarity here.
+	movel	a6@(8),d0	| get the numbers back (remember that we
+	movel	a6@(12),d1	| did some processing already)
+	movel	a6@(16),d2	|
+	movel	a6@(20),d3	|
+	movel	IMM (INFINITY),d4 | useful constant (INFINITY)
+	movel	d0,d7		| save sign bits
+	movel	d2,d6		|
+	bclr	IMM (31),d0	| clear sign bits
+	bclr	IMM (31),d2	|
+| We know that one of them is either NaN of +/-INFINITY
+| Check for NaN (if either one is NaN return NaN)
+	cmpl	d4,d0		| check first a (d0)
+	bhi	Lx$inop		| if d0 > 0x7ff00000 or equal and
+	bne	2f
+	tstl	d1		| d1 > 0, a is NaN
+	bne	Lx$inop		|
+2:	cmpl	d4,d2		| check now b (d1)
+	bhi	Lx$inop		|
+	bne	3f
+	tstl	d3		|
+	bne	Lx$inop		|
+3:
+| Now comes the check for +/-INFINITY. We know that both are (maybe not
+| finite) numbers, but we have to check if both are infinite whether we
+| are adding or subtracting them.
+	eorl	d7,d6		| to check sign bits
+	bmi	1f
+	andl	IMM (0x80000000),d7 | get (common) sign bit
+	bra	Lx$infty
+1:
+| We know one (or both) are infinite, so we test for equality between the
+| two numbers (if they are equal they have to be infinite both, so we
+| return NaN).
+	cmpl	d2,d0		| are both infinite?
+	bne	1f		| if d0 <> d2 they are not equal
+	cmpl	d3,d1		| if d0 == d2 test d3 and d1
+	beq	Lx$inop		| if equal return NaN
+1:
+	andl	IMM (0x80000000),d7 | get a's sign bit
+	cmpl	d4,d0		| test now for infinity
+	beq	Lx$infty	| if a is INFINITY return with this sign
+	bchg	IMM (31),d7	| else we know b is INFINITY and has
+	bra	Lx$infty	| the opposite sign
diff --git a/libgcc/config/m68k/addxf3.c b/libgcc/config/m68k/addxf3.c
new file mode 100644
index 00000000000..d8a718fe32b
--- /dev/null
+++ b/libgcc/config/m68k/addxf3.c
@@ -0,0 +1 @@
+#include "soft-fp/addxf3.c"
diff --git a/libgcc/config/m68k/crti.S b/libgcc/config/m68k/crti.S
index a054a19d4ec..470892e1f00 100644
--- a/libgcc/config/m68k/crti.S
+++ b/libgcc/config/m68k/crti.S
@@ -42,3 +42,9 @@ _init:
 	.type   _fini,@function
 _fini:
 	linkw %fp,#0
+
+
+#if defined (__ELF__)
+	/* Make stack non-executable for ELF linux targets.  */
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libgcc/config/m68k/crtn.S b/libgcc/config/m68k/crtn.S
index f5414cbe223..9cc63e13fe0 100644
--- a/libgcc/config/m68k/crtn.S
+++ b/libgcc/config/m68k/crtn.S
@@ -38,3 +38,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 	.section .fini
 	unlk %fp
 	rts
+
+
+#if defined (__ELF__)
+	/* Make stack non-executable for ELF linux targets.  */
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libgcc/config/m68k/divxf3.c b/libgcc/config/m68k/divxf3.c
new file mode 100644
index 00000000000..b8be020eaae
--- /dev/null
+++ b/libgcc/config/m68k/divxf3.c
@@ -0,0 +1 @@
+#include "soft-fp/divxf3.c"
diff --git a/libgcc/config/m68k/extenddfxf2.c b/libgcc/config/m68k/extenddfxf2.c
new file mode 100644
index 00000000000..9480b1d4806
--- /dev/null
+++ b/libgcc/config/m68k/extenddfxf2.c
@@ -0,0 +1,2 @@
+#define L_extenddfxf2
+#include "fpgnulib.c"
diff --git a/libgcc/config/m68k/extendsfdf2.c b/libgcc/config/m68k/extendsfdf2.c
new file mode 100644
index 00000000000..d323cf2fa35
--- /dev/null
+++ b/libgcc/config/m68k/extendsfdf2.c
@@ -0,0 +1,2 @@
+#define L_extendsfdf2
+#include "fpgnulib.c"
diff --git a/libgcc/config/m68k/extendsfxf2.c b/libgcc/config/m68k/extendsfxf2.c
new file mode 100644
index 00000000000..5bd4bea784f
--- /dev/null
+++ b/libgcc/config/m68k/extendsfxf2.c
@@ -0,0 +1,2 @@
+#define L_extendsfxf2
+#include "fpgnulib.c"
diff --git a/libgcc/config/m68k/fixdfsi.c b/libgcc/config/m68k/fixdfsi.c
new file mode 100644
index 00000000000..1d811017e2c
--- /dev/null
+++ b/libgcc/config/m68k/fixdfsi.c
@@ -0,0 +1,2 @@
+#define L_fixdfsi
+#include "fpgnulib.c"
diff --git a/libgcc/config/m68k/fixsfsi.c b/libgcc/config/m68k/fixsfsi.c
new file mode 100644
index 00000000000..c76353b3bd6
--- /dev/null
+++ b/libgcc/config/m68k/fixsfsi.c
@@ -0,0 +1,2 @@
+#define L_fixsfsi
+#include "fpgnulib.c"
diff --git a/libgcc/config/m68k/fixxfsi.c b/libgcc/config/m68k/fixxfsi.c
new file mode 100644
index 00000000000..ba166b14308
--- /dev/null
+++ b/libgcc/config/m68k/fixxfsi.c
@@ -0,0 +1,2 @@
+#define L_fixxfsi
+#include "fpgnulib.c"
diff --git a/libgcc/config/m68k/floatsidf.c b/libgcc/config/m68k/floatsidf.c
new file mode 100644
index 00000000000..0fe443ca183
--- /dev/null
+++ b/libgcc/config/m68k/floatsidf.c
@@ -0,0 +1,2 @@
+#define L_floatsidf
+#include "fpgnulib.c"
diff --git a/libgcc/config/m68k/floatsisf.c b/libgcc/config/m68k/floatsisf.c
new file mode 100644
index 00000000000..7ce07487f40
--- /dev/null
+++ b/libgcc/config/m68k/floatsisf.c
@@ -0,0 +1,2 @@
+#define L_floatsisf
+#include "fpgnulib.c"
diff --git a/libgcc/config/m68k/floatsixf.c b/libgcc/config/m68k/floatsixf.c
new file mode 100644
index 00000000000..5c10b8081ed
--- /dev/null
+++ b/libgcc/config/m68k/floatsixf.c
@@ -0,0 +1,2 @@
+#define L_floatsixf
+#include "fpgnulib.c"
diff --git a/libgcc/config/m68k/floatunsidf.c b/libgcc/config/m68k/floatunsidf.c
new file mode 100644
index 00000000000..f901056f428
--- /dev/null
+++ b/libgcc/config/m68k/floatunsidf.c
@@ -0,0 +1,2 @@
+#define L_floatunsidf
+#include "fpgnulib.c"
diff --git a/libgcc/config/m68k/floatunsisf.c b/libgcc/config/m68k/floatunsisf.c
new file mode 100644
index 00000000000..8a143a26cdc
--- /dev/null
+++ b/libgcc/config/m68k/floatunsisf.c
@@ -0,0 +1,2 @@
+#define L_floatunsisf
+#include "fpgnulib.c"
diff --git a/libgcc/config/m68k/floatunsixf.c b/libgcc/config/m68k/floatunsixf.c
new file mode 100644
index 00000000000..d67949bd696
--- /dev/null
+++ b/libgcc/config/m68k/floatunsixf.c
@@ -0,0 +1,2 @@
+#define L_floatunsixf
+#include "fpgnulib.c"
diff --git a/libgcc/config/m68k/fpgnulib.c b/libgcc/config/m68k/fpgnulib.c
index a7d4258dff0..917acfd0748 100644
--- a/libgcc/config/m68k/fpgnulib.c
+++ b/libgcc/config/m68k/fpgnulib.c
@@ -1,10 +1,6 @@
 /* This is a stripped down version of floatlib.c.  It supplies only those
    functions which exist in libgcc, but for which there is not assembly
-   language versions in m68k/lb1sf68.S.
-
-   It also includes simplistic support for extended floats (by working in
-   double precision).  You must compile this file again with -DEXTFLOAT
-   to get this support.  */
+   language versions in m68k/lb1sf68.S.  */
 
 /*
 ** gnulib support for software floating point.
@@ -54,7 +50,7 @@
 #define SIGNBIT		0x80000000L
 #define HIDDEN		(1L << 23L)
 #define SIGN(fp)	((fp) & SIGNBIT)
-#define EXPMASK		0xFFL
+#define EXPFMASK	0xFFL
 #define EXP(fp)		(((fp) >> 23L) & 0xFF)
 #define MANT(fp)	(((fp) & 0x7FFFFFL) | HIDDEN)
 #define PACK(s,e,m)	((s) | ((e) << 23L) | (m))
@@ -103,23 +99,61 @@ union long_double_long
       unsigned long lower;
     } l;
 };
-
-#ifndef EXTFLOAT
 
+/* Prototypes for functions defined here in case we use them.  */
+int __unordsf2(float a, float b);
+int __unorddf2(double a, double b);
+double __floatunsidf (unsigned long a1);
+double __floatsidf (long a1);
+float __floatunsisf (unsigned long l);
+float __floatsisf (long l);
+double __extendsfdf2 (float a1);
+float __truncdfsf2 (double a1);
+long __fixdfsi (double a1);
+long __fixsfsi (float a1);
+long __cmpdf2 (double x1, double x2);
+
+#if !defined (__mcoldfire__)
+int __unordxf2(long double a, long double b);
+long double __extenddfxf2 (double d);
+double __truncxfdf2 (long double ld);
+long double __extendsfxf2 (float f);
+float __truncxfsf2 (long double ld);
+long double __floatsixf (long l);
+long double __floatunsixf (unsigned long l);
+long __fixxfsi (long double ld);
+long double __addxf3 (long double x1, long double x2);
+long double __subxf3 (long double x1, long double x2);
+long double __mulxf3 (long double x1, long double x2);
+long double __divxf3 (long double x1, long double x2);
+long double __negxf2 (long double x1);
+long __cmpxf2 (long double x1, long double x2);
+long __eqxf2 (long double x1, long double x2);
+long __nexf2 (long double x1, long double x2);
+long __ltxf2 (long double x1, long double x2);
+long __lexf2 (long double x1, long double x2);
+long __gtxf2 (long double x1, long double x2);
+long __gexf2 (long double x1, long double x2);
+#endif
+
+
+#ifdef L_unordsf2
 int
 __unordsf2(float a, float b)
 {
   union float_long fl;
 
   fl.f = a;
-  if (EXP(fl.l) == EXP(~0u) && (MANT(fl.l) & ~HIDDEN) != 0)
+  if (EXP(fl.l) == EXP(~0ul) && (MANT(fl.l) & ~HIDDEN) != 0)
     return 1;
   fl.f = b;
-  if (EXP(fl.l) == EXP(~0u) && (MANT(fl.l) & ~HIDDEN) != 0)
+  if (EXP(fl.l) == EXP(~0ul) && (MANT(fl.l) & ~HIDDEN) != 0)
     return 1;
   return 0;
 }
+#endif
 
+#ifdef L_unorddf2
 int
 __unorddf2(double a, double b)
 {
@@ -135,7 +169,9 @@ __unorddf2(double a, double b)
     return 1;
   return 0;
 }
+#endif
 
+#ifdef L_floatunsidf
 /* convert unsigned int to double */
 double
 __floatunsidf (unsigned long a1)
@@ -168,7 +204,9 @@ __floatunsidf (unsigned long a1)
 
   return dl.d;
 }
+#endif
 
+#ifdef L_floatsidf
 /* convert int to double */
 double
 __floatsidf (long a1)
@@ -214,7 +252,9 @@ __floatsidf (long a1)
 
   return dl.d;
 }
+#endif
 
+#ifdef L_floatunsisf
 /* convert unsigned int to float */
 float
 __floatunsisf (unsigned long l)
@@ -222,7 +262,9 @@ __floatunsisf (unsigned long l)
   double foo = __floatunsidf (l);
   return foo;
 }
+#endif
 
+#ifdef L_floatsisf
 /* convert int to float */
 float
 __floatsisf (long l)
@@ -230,15 +272,17 @@ __floatsisf (long l)
   double foo = __floatsidf (l);
   return foo;
 }
+#endif
 
+#ifdef L_extendsfdf2
 /* convert float to double */
 double
 __extendsfdf2 (float a1)
 {
-  register union float_long fl1;
-  register union double_long dl;
-  register long exp;
-  register long mant;
+  union float_long fl1;
+  union double_long dl;
+  long exp;
+  long mant;
 
   fl1.f = a1;
 
@@ -251,7 +295,7 @@ __extendsfdf2 (float a1)
 
   exp = EXP(fl1.l);
   mant = MANT (fl1.l) & ~HIDDEN;
-  if (exp == 0)
+  if (exp == 0) /* case of mant == 0 has already been catched above */
     {
       /* Denormal.  */
       exp = 1;
@@ -262,25 +306,28 @@ __extendsfdf2 (float a1)
 	}
       mant &= ~HIDDEN;
     }
-  exp = exp - EXCESS + EXCESSD;
   /* Handle inf and NaN */
-  if (exp == EXPMASK - EXCESS + EXCESSD)
+  if (exp == EXPFMASK)
     exp = EXPDMASK;
+  else
+    exp = exp - EXCESS + EXCESSD;
   dl.l.upper |= exp << 20;
   dl.l.upper |= mant >> 3;
   dl.l.lower = mant << 29;
 
   return dl.d;
 }
+#endif
 
+#ifdef L_truncdfsf2
 /* convert double to float */
 float
 __truncdfsf2 (double a1)
 {
-  register long exp;
-  register long mant;
-  register union float_long fl;
-  register union double_long dl1;
+  long exp;
+  long mant;
+  union float_long fl;
+  union double_long dl1;
   int sticky;
   int shift;
 
@@ -294,14 +341,14 @@ __truncdfsf2 (double a1)
 
   exp = EXPD (dl1) - EXCESSD + EXCESS;
 
-  sticky = dl1.l.lower & ((1 << 22) - 1);
+  sticky = dl1.l.lower & ((1L << 22) - 1);
   mant = MANTD (dl1);
   /* shift double mantissa 6 bits so we can round */
   sticky |= mant & ((1 << 6) - 1);
   mant >>= 6;
   if (exp == EXPDMASK - EXCESSD + EXCESS)
     {
-      exp = EXPMASK;
+      exp = EXPFMASK;
       mant = (mant >> 1) | (mant & 1) | (!!sticky);
     }
   else
@@ -339,9 +386,9 @@ __truncdfsf2 (double a1)
 	}
       /* shift down */
       mant >>= shift;
-      if (exp >= EXPMASK)
+      if (exp >= EXPFMASK)
 	{
-	  exp = EXPMASK;
+	  exp = EXPFMASK;
 	  mant = 0;
 	}
     }
@@ -352,14 +399,16 @@ __truncdfsf2 (double a1)
   fl.l = PACK (SIGND (dl1), exp, mant);
   return (fl.f);
 }
+#endif
 
+#ifdef L_fixdfsi
 /* convert double to int */
 long
 __fixdfsi (double a1)
 {
-  register union double_long dl1;
-  register long exp;
-  register long l;
+  union double_long dl1;
+  long exp;
+  long l;
 
   dl1.d = a1;
 
@@ -384,7 +433,9 @@ __fixdfsi (double a1)
 
   return (SIGND (dl1) ? -l : l);
 }
+#endif
 
+#ifdef L_fixsfsi
 /* convert float to int */
 long
 __fixsfsi (float a1)
@@ -392,8 +443,7 @@ __fixsfsi (float a1)
   double foo = a1;
   return __fixdfsi (foo);
 }
-
-#else /* EXTFLOAT */
+#endif
 
 /* We do not need these routines for coldfire, as it has no extended
    float format. */
@@ -403,16 +453,7 @@ __fixsfsi (float a1)
 
    We assume all numbers are normalized, don't do any rounding, etc.  */
 
-/* Prototypes for the above in case we use them.  */
-double __floatunsidf (unsigned long);
-double __floatsidf (long);
-float __floatsisf (long);
-double __extendsfdf2 (float);
-float __truncdfsf2 (double);
-long __fixdfsi (double);
-long __fixsfsi (float);
-int __cmpdf2 (double, double);
-
+#ifdef L_unordxf2
 int
 __unordxf2(long double a, long double b)
 {
@@ -428,14 +469,16 @@ __unordxf2(long double a, long double b)
     return 1;
   return 0;
 }
+#endif
 
+#ifdef L_extenddfxf2
 /* convert double to long double */
 long double
 __extenddfxf2 (double d)
 {
-  register union double_long dl;
-  register union long_double_long ldl;
-  register long exp;
+  union double_long dl;
+  union long_double_long ldl;
+  long exp;
 
   dl.d = d;
   /*printf ("dfxf in: %g\n", d);*/
@@ -448,7 +491,11 @@ __extenddfxf2 (double d)
       return ldl.ld;
     }
 
-  exp = EXPD (dl) - EXCESSD + EXCESSX;
+  exp = EXPD (dl);
+  if (exp == EXPDMASK)
+    exp = EXPXMASK;
+  else
+    exp = exp - EXCESSD + EXCESSX;
 
   dl.l.upper &= MANTDMASK;
 
@@ -488,26 +535,29 @@ __extenddfxf2 (double d)
   /*printf ("dfxf out: %s\n", dumpxf (ldl.ld));*/
   return ldl.ld;
 }
+#endif
 
+#ifdef L_truncxfdf2
 /* convert long double to double */
 double
 __truncxfdf2 (long double ld)
 {
-  register long exp;
-  register union double_long dl;
-  register union long_double_long ldl;
+  long exp;
+  union double_long dl;
+  union long_double_long ldl;
 
   ldl.ld = ld;
   /*printf ("xfdf in: %s\n", dumpxf (ld));*/
 
+  exp = EXPX (ldl);
   dl.l.upper = SIGNX (ldl);
-  if ((ldl.l.upper & ~SIGNBIT) == 0 && !ldl.l.middle && !ldl.l.lower)
+  if (exp == 0 && (ldl.l.middle & MANTXMASK) == 0 && !ldl.l.lower)
     {
       dl.l.lower = 0;
       return dl.d;
     }
 
-  exp = EXPX (ldl) - EXCESSX + EXCESSD;
+  exp = exp - EXCESSX + EXCESSD;
   /* Check for underflow and denormals. */
   if (exp <= 0)
     {
@@ -549,7 +599,9 @@ __truncxfdf2 (long double ld)
   /*printf ("xfdf out: %g\n", dl.d);*/
   return dl.d;
 }
+#endif
 
+#ifdef L_extendsfxf2
 /* convert a float to a long double */
 long double
 __extendsfxf2 (float f)
@@ -557,7 +609,9 @@ __extendsfxf2 (float f)
   long double foo = __extenddfxf2 (__extendsfdf2 (f));
   return foo;
 }
+#endif
 
+#ifdef L_truncxfsf2
 /* convert a long double to a float */
 float
 __truncxfsf2 (long double ld)
@@ -565,7 +619,9 @@ __truncxfsf2 (long double ld)
   float foo = __truncdfsf2 (__truncxfdf2 (ld));
   return foo;
 }
+#endif
 
+#ifdef L_floatsixf
 /* convert an int to a long double */
 long double
 __floatsixf (long l)
@@ -573,7 +629,9 @@ __floatsixf (long l)
   double foo = __floatsidf (l);
   return foo;
 }
+#endif
 
+#ifdef L_floatunsixf
 /* convert an unsigned int to a long double */
 long double
 __floatunsixf (unsigned long l)
@@ -581,7 +639,9 @@ __floatunsixf (unsigned long l)
   double foo = __floatunsidf (l);
   return foo;
 }
+#endif
 
+#ifdef L_fixxfsi
 /* convert a long double to an int */
 long
 __fixxfsi (long double a)
@@ -610,80 +670,6 @@ __fixxfsi (long double a)
 
   return SIGNX (ldl) ? -ldl.l.middle : ldl.l.middle;
 }
-
-/* The remaining provide crude math support by working in double precision.  */
-
-long double
-__addxf3 (long double x1, long double x2)
-{
-  return (double) x1 + (double) x2;
-}
-
-long double
-__subxf3 (long double x1, long double x2)
-{
-  return (double) x1 - (double) x2;
-}
-
-long double
-__mulxf3 (long double x1, long double x2)
-{
-  return (double) x1 * (double) x2;
-}
-
-long double
-__divxf3 (long double x1, long double x2)
-{
-  return (double) x1 / (double) x2;
-}
-
-long double
-__negxf2 (long double x1)
-{
-  return - (double) x1;
-}
-
-long
-__cmpxf2 (long double x1, long double x2)
-{
-  return __cmpdf2 ((double) x1, (double) x2);
-}
-
-long
-__eqxf2 (long double x1, long double x2)
-{
-  return __cmpdf2 ((double) x1, (double) x2);
-}
-
-long
-__nexf2 (long double x1, long double x2)
-{
-  return __cmpdf2 ((double) x1, (double) x2);
-}
-
-long
-__ltxf2 (long double x1, long double x2)
-{
-  return __cmpdf2 ((double) x1, (double) x2);
-}
-
-long
-__lexf2 (long double x1, long double x2)
-{
-  return __cmpdf2 ((double) x1, (double) x2);
-}
-
-long
-__gtxf2 (long double x1, long double x2)
-{
-  return __cmpdf2 ((double) x1, (double) x2);
-}
-
-long
-__gexf2 (long double x1, long double x2)
-{
-  return __cmpdf2 ((double) x1, (double) x2);
-}
+#endif
 
 #endif /* !__mcoldfire__ */
-#endif /* EXTFLOAT */
diff --git a/libgcc/config/m68k/lb1sf68-fast.S b/libgcc/config/m68k/lb1sf68-fast.S
new file mode 100644
index 00000000000..0c2b886d812
--- /dev/null
+++ b/libgcc/config/m68k/lb1sf68-fast.S
@@ -0,0 +1,219 @@
+/* libgcc routines for 68000 w/o floating-point hardware.
+   Copyright (C) 1994, 1996, 1997, 1998, 2008, 2009 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3, or (at your option) any
+later version.
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+#ifdef  L_mulsi3
+	.text
+	FUNC(__mulsi3)
+	.globl	SYM (__mulsi3)
+	.globl	SYM (__mulsi3_internal)
+#ifdef __ELF__
+	.hidden	SYM (__mulsi3_internal)
+#endif
+SYM (__mulsi3):
+SYM (__mulsi3_internal):
+	move.l  d2,-(sp)
+	movel   d0, a0          | d0a0 = x0:x1
+	movel   d1, a1		| d1a1 = y0:y1
+	swap	d0              | d0   = x1:x0
+	muluw   d1, d0          | d0 = y1*x0
+	swap	d1		| d1 = y1:y0
+	movel   a0, d2		| d2 = x0:x1
+	muluw   d2, d1          | d1 = x1*y0
+#ifndef __mcoldfire__
+	addw	d1, d0
+#else
+	addl	d1, d0
+#endif
+	swap	d0
+	clrw	d0
+	movel	a1,d1		| d1 = y0:y1
+	muluw	d2, d1		| d1 = x1*y1
+
+	move.l  (sp)+,d2
+	addl	d1, d0
+
+	rts
+#endif /* L_mulsi3 */
+
+#ifdef  L_udivsi3
+	.text
+	FUNC(__udivsi3)
+	.globl	SYM (__udivsi3)
+	.globl	SYM (__udivsi3_internal)
+#ifdef __ELF__
+	.hidden	SYM (__udivsi3_internal)
+#endif
+SYM (__udivsi3):
+SYM (__udivsi3_internal):
+#ifndef __mcoldfire__
+	move.l  d2,-(sp)
+	movel	d0, a0
+
+	cmpl	IMM (0x10000), d1 /* divisor >= 2 ^ 16 ?   */
+	jcc	udivsi3_fast_L3		/* then try next algorithm */
+	movel	d0, d2
+	clrw	d2
+	swap	d2
+	divu	d1, d2          /* high quotient in lower word */
+	movew	d2, d0		/* save high quotient */
+	swap	d0
+	movew	a0, d2		/* get low dividend + high rest */
+	divu	d1, d2		/* low quotient */
+	movew	d2, d0
+	jra	udivsi3_fast_L6
+
+udivsi3_fast_L3:	movel	d1, d2		/* use d2 as divisor backup */
+udivsi3_fast_L4:	lsrl	IMM (1), d1	/* shift divisor */
+	lsrl	IMM (1), d0	/* shift dividend */
+	cmpl	IMM (0x10000), d1 /* still divisor >= 2 ^ 16 ?  */
+	jcc	udivsi3_fast_L4
+	divu	d1, d0		/* now we have 16-bit divisor */
+	andl	IMM (0xffff), d0 /* mask out divisor, ignore remainder */
+
+/* Multiply the 16-bit tentative quotient with the 32-bit divisor.  Because of
+   the operand ranges, this might give a 33-bit product.  If this product is
+   greater than the dividend, the tentative quotient was too large. */
+	movel	d2, d1
+	mulu	d0, d1		/* low part, 32 bits */
+	swap	d2
+	mulu	d0, d2		/* high part, at most 17 bits */
+	swap	d2		/* align high part with low part */
+	tstw	d2		/* high part 17 bits? */
+	jne	udivsi3_fast_L5		/* if 17 bits, quotient was too large */
+	addl	d2, d1		/* add parts */
+	jcs	udivsi3_fast_L5		/* if sum is 33 bits, quotient was too large */
+	cmpl	a0, d1		/* compare the sum with the dividend */
+	jls	udivsi3_fast_L6		/* if sum > dividend, quotient was too large */
+udivsi3_fast_L5:	subql	IMM (1), d0	/* adjust quotient */
+
+udivsi3_fast_L6:
+	move.l  (sp)+,d2
+	rts
+
+#else /* __mcoldfire__ */
+
+/* ColdFire implementation of non-restoring division algorithm from
+   Hennessy & Patterson, Appendix A. */
+	moveml	d2-d4,sp@
+	clrl	d2		| clear p
+	moveq	IMM (31),d4
+udivsi3_fast_L1:	addl	d0,d0		| shift reg pair (p,a) one bit left
+	addxl	d2,d2
+	movl	d2,d3		| subtract b from p, store in tmp.
+	subl	d1,d3
+	jcs	udivsi3_fast_L2		| if no carry,
+	bset	IMM (0),d0	| set the low order bit of a to 1,
+	movl	d3,d2		| and store tmp in p.
+udivsi3_fast_L2:	subql	IMM (1),d4
+	jcc	udivsi3_fast_L1
+	moveml	sp@,d2-d4	| restore data registers
+	rts
+#endif /* __mcoldfire__ */
+
+#endif /* L_udivsi3 */
+
+#ifdef  L_divsi3
+	.text
+	FUNC(__divsi3)
+	.globl	SYM (__divsi3)
+	.globl	SYM (__divsi3_internal)
+#ifdef __ELF__
+	.hidden	SYM (__divsi3_internal)
+#endif
+SYM (__divsi3):
+SYM (__divsi3_internal):
+	move.l  d2,-(sp)
+	moveq	IMM (1), d2	/* sign of result stored in d2 (=1 or =-1) */
+	tstl	d1
+	jpl	divsi3_fast_L1
+	negl	d1
+#ifndef __mcoldfire__
+	negw	d2		/* change sign because divisor <0  */
+#else
+	negl	d2		/* change sign because divisor <0  */
+#endif
+divsi3_fast_L1:	tstl	d0		/* d0 = dividend */
+	jpl	divsi3_fast_L2
+	negl	d0
+#ifndef __mcoldfire__
+	negw	d2
+#else
+	negl	d2
+#endif
+
+divsi3_fast_L2:	movew	d2,a1		/* Called function MUST NOT clobber a1 */
+	PICCALL	SYM (__udivsi3_internal)	/* divide abs(dividend) by abs(divisor) */
+
+	movew	a1,d2
+	jpl	divsi3_fast_L3
+	negl	d0
+
+divsi3_fast_L3:
+	move.l  (sp)+,d2
+	rts
+#endif /* L_divsi3 */
+
+#ifdef  L_umodsi3
+	.text
+	FUNC(__umodsi3)
+	.globl	SYM (__umodsi3)
+SYM (__umodsi3):
+	move.l  d2,-(sp)
+	movel	d0, d2
+	movel	d1, a1		/* a1 MUST NOT be clobbered by calls*/
+	PICCALL	SYM (__udivsi3_internal)
+	movel	a1, d1		/* d1 = divisor */
+#ifndef __mcoldfire__
+	PICCALL	SYM (__mulsi3_internal)	/* d0 = (a/b)*b */
+#else
+	mulsl	d1,d0
+#endif
+	movel	d2, d1		/* d1 = dividend */
+	subl	d0, d1		/* d1 = a - (a/b)*b */
+	movel	d1, d0
+	move.l  (sp)+,d2
+	rts
+#endif /* L_umodsi3 */
+
+#ifdef  L_modsi3
+	.text
+	FUNC(__modsi3)
+	.globl	SYM (__modsi3)
+SYM (__modsi3):
+	move.l  d2,-(sp)
+	movel	d0, sp@-
+	movel	d1, sp@-
+	PICCALL	SYM (__divsi3_internal)
+	movel	sp@+, d1	/* d1 = divisor */
+#ifndef __mcoldfire__
+	PICCALL	SYM (__mulsi3_internal)	/* d0 = (a/b)*b */
+#else
+	mulsl	d1,d0
+#endif
+	movel	sp@+, d1	/* d1 = dividend */
+	subl	d0, d1		/* d1 = a - (a/b)*b */
+	movel	d1, d0
+	move.l  (sp)+,d2
+	rts
+#endif /* L_modsi3 */
diff --git a/libgcc/config/m68k/lb1sf68.S b/libgcc/config/m68k/lb1sf68.S
index bcbcaf327dc..da5bf56028f 100644
--- a/libgcc/config/m68k/lb1sf68.S
+++ b/libgcc/config/m68k/lb1sf68.S
@@ -52,17 +52,17 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #define SYM(x) CONCAT1 (__USER_LABEL_PREFIX__, x)
 
 /* Note that X is a function.  */
-	
+
 #ifdef __ELF__
 #define FUNC(x) .type SYM(x),function
 #else
-/* The .proc pseudo-op is accepted, but ignored, by GAS.  We could just	
+/* The .proc pseudo-op is accepted, but ignored, by GAS.  We could just
    define this to the empty string for non-ELF systems, but defining it
    to .proc means that the information is available to the assembler if
    the need arises.  */
 #define FUNC(x) .proc
 #endif
-		
+
 /* Use the right prefix for registers.  */
 
 #define REG(x) CONCAT1 (__REGISTER_PREFIX__, x)
@@ -90,6 +90,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #define sp REG (sp)
 #define pc REG (pc)
 
+#ifndef M68K_STRUCT_VALUE_REGNUM
+#define M68K_STRUCT_VALUE_REGNUM a1
+#endif
+
 /* Provide a few macros to allow for PIC code support.
  * With PIC, data is stored A5 relative so we've got to take a bit of special
  * care to ensure that all loads of global data is via A5.  PIC also requires
@@ -223,9 +227,44 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #endif /* __PIC__ */
 
 
+| The following exception types are supported:
+INEXACT_RESULT 		= 0x0001
+UNDERFLOW 		= 0x0002
+OVERFLOW 		= 0x0004
+DIVIDE_BY_ZERO 		= 0x0008
+INVALID_OPERATION 	= 0x0010
+
+| The allowed rounding modes are:
+UNKNOWN           = -1
+ROUND_TO_NEAREST  = 0 | round result to nearest representable value
+ROUND_TO_ZERO     = 1 | round result towards zero
+ROUND_TO_PLUS     = 2 | round result towards plus infinity
+ROUND_TO_MINUS    = 3 | round result towards minus infinity
+
+| The allowed values of format are:
+NIL          = 0
+SINGLE_FLOAT = 1
+DOUBLE_FLOAT = 2
+LONG_FLOAT   = 3
+
+| The allowed values for the last operation are:
+NOOP         = 0
+ADD          = 1
+MULTIPLY     = 2
+DIVIDE       = 3
+NEGATE       = 4
+COMPARE      = 5
+EXTENDSFDF   = 6
+TRUNCDFSF    = 7
+
+| return values from __cmpdf2/__cmpsf2/__cmpxf2
+GREATER =  1
+LESS    = -1
+EQUAL   =  0
+
 #ifdef L_floatex
 
-| This is an attempt at a decent floating point (single, double and 
+| This is an attempt at a decent floating point (single, double and
 | extended double) code for the GNU C compiler. It should be easy to
 | adapt to other compilers (but beware of the local labels!).
 
@@ -234,10 +273,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 | It is convenient to introduce the notation (s,e,f) for a floating point
 | number, where s=sign, e=exponent, f=fraction. We will call a floating
 | point number fpn to abbreviate, independently of the precision.
-| Let MAX_EXP be in each case the maximum exponent (255 for floats, 1023 
-| for doubles and 16383 for long doubles). We then have the following 
+| Let MAX_EXP be in each case the maximum exponent (255 for floats, 1023
+| for doubles and 16383 for long doubles). We then have the following
 | different cases:
-|  1. Normalized fpns have 0 < e < MAX_EXP. They correspond to 
+|  1. Normalized fpns have 0 < e < MAX_EXP. They correspond to
 |     (-1)^s x 1.f x 2^(e-bias-1).
 |  2. Denormalized fpns have e=0. They correspond to numbers of the form
 |     (-1)^s x 0.f x 2^(-bias).
@@ -252,8 +291,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 | This is the floating point condition code register (_fpCCR):
 |
 | struct {
-|   short _exception_bits;	
-|   short _trap_enable_bits;	
+|   short _exception_bits;
+|   short _trap_enable_bits;
 |   short _sticky_bits;
 |   short _rounding_mode;
 |   short _format;
@@ -261,10 +300,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 |   union {
 |     float sf;
 |     double df;
+|     long double xf;
 |   } _operand1;
 |   union {
 |     float sf;
 |     double df;
+|     long double xf;
 |   } _operand2;
 | } _fpCCR;
 
@@ -272,7 +313,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 	.even
 
 	.globl	SYM (_fpCCR)
-	
+
 SYM (_fpCCR):
 __exception_bits:
 	.word	0
@@ -289,9 +330,11 @@ __last_operation:
 __operand1:
 	.long	0
 	.long	0
+	.long	0
 __operand2:
 	.long 	0
 	.long	0
+	.long	0
 
 | Offsets:
 EBITS  = __exception_bits - SYM (_fpCCR)
@@ -303,42 +346,12 @@ LASTO  = __last_operation - SYM (_fpCCR)
 OPER1  = __operand1 - SYM (_fpCCR)
 OPER2  = __operand2 - SYM (_fpCCR)
 
-| The following exception types are supported:
-INEXACT_RESULT 		= 0x0001
-UNDERFLOW 		= 0x0002
-OVERFLOW 		= 0x0004
-DIVIDE_BY_ZERO 		= 0x0008
-INVALID_OPERATION 	= 0x0010
-
-| The allowed rounding modes are:
-UNKNOWN           = -1
-ROUND_TO_NEAREST  = 0 | round result to nearest representable value
-ROUND_TO_ZERO     = 1 | round result towards zero
-ROUND_TO_PLUS     = 2 | round result towards plus infinity
-ROUND_TO_MINUS    = 3 | round result towards minus infinity
-
-| The allowed values of format are:
-NIL          = 0
-SINGLE_FLOAT = 1
-DOUBLE_FLOAT = 2
-LONG_FLOAT   = 3
-
-| The allowed values for the last operation are:
-NOOP         = 0
-ADD          = 1
-MULTIPLY     = 2
-DIVIDE       = 3
-NEGATE       = 4
-COMPARE      = 5
-EXTENDSFDF   = 6
-TRUNCDFSF    = 7
-
 |=============================================================================
 |                           __clear_sticky_bits
 |=============================================================================
 
-| The sticky bits are normally not cleared (thus the name), whereas the 
-| exception type and exception value reflect the last computation. 
+| The sticky bits are normally not cleared (thus the name), whereas the
+| exception type and exception value reflect the last computation.
 | This routine is provided to clear them (you can also write to _fpCCR,
 | since it is globally visible).
 
@@ -348,13 +361,9 @@ TRUNCDFSF    = 7
 	.even
 
 | void __clear_sticky_bits(void);
-SYM (__clear_sticky_bit):		
+SYM (__clear_sticky_bit):
 	PICLEA	SYM (_fpCCR),a0
-#ifndef __mcoldfire__
-	movew	IMM (0),a0@(STICK)
-#else
 	clr.w	a0@(STICK)
-#endif
 	rts
 
 |=============================================================================
@@ -370,13 +379,13 @@ SYM (__clear_sticky_bit):
 | NOTE: it is NOT callable from C!
 | It expects the exception type in d7, the format (SINGLE_FLOAT,
 | DOUBLE_FLOAT or LONG_FLOAT) in d6, and the last operation code in d5.
-| It sets the corresponding exception and sticky bits, and the format. 
-| Depending on the format if fills the corresponding slots for the 
+| It sets the corresponding exception and sticky bits, and the format.
+| Depending on the format if fills the corresponding slots for the
 | operands which produced the exception (all this information is provided
 | so if you write your own exception handlers you have enough information
 | to deal with the problem).
-| Then checks to see if the corresponding exception is trap-enabled, 
-| in which case it pushes the address of _fpCCR and traps through 
+| Then checks to see if the corresponding exception is trap-enabled,
+| in which case it pushes the address of _fpCCR and traps through
 | trap FPTRAP (15 for the moment).
 
 FPTRAP = 15
@@ -396,19 +405,33 @@ $_exception_handler:
 
 | Now put the operands in place:
 #ifndef __mcoldfire__
-	cmpw	IMM (SINGLE_FLOAT),d6
+	subqw	IMM (DOUBLE_FLOAT),d6
 #else
-	cmpl	IMM (SINGLE_FLOAT),d6
+	subql	IMM (DOUBLE_FLOAT),d6
 #endif
-	beq	1f
+	beq	2f
+	bmi	3f
+	moveml a6@(8),d0-d5
+	moveml d0-d5,a0@(OPER1)
+	| for cmpxf2, return value is int!
+#ifndef __mcoldfire__
+	subqw	IMM (2),d6
+#else
+	subql	IMM (2),d6
+#endif
+	beq		4f
+	moveml	d0-d2,M68K_STRUCT_VALUE_REGNUM@			| write return value for long double
+	movel	M68K_STRUCT_VALUE_REGNUM,d0
+	bra	4f
+2:
 	movel	a6@(8),a0@(OPER1)
 	movel	a6@(12),a0@(OPER1+4)
 	movel	a6@(16),a0@(OPER2)
 	movel	a6@(20),a0@(OPER2+4)
-	bra	2f
-1:	movel	a6@(8),a0@(OPER1)
+	bra	4f
+3:	movel	a6@(8),a0@(OPER1)
 	movel	a6@(12),a0@(OPER2)
-2:
+4:
 | And check whether the exception is trap-enabled:
 #ifndef __mcoldfire__
 	andw	a0@(TRAPE),d7	| is exception trap-enabled?
@@ -418,25 +441,30 @@ $_exception_handler:
 	andl	d6,d7
 #endif
 	beq	1f		| no, exit
-	PICPEA	SYM (_fpCCR),a1	| yes, push address of _fpCCR
+	pea		(a0)	| yes, push address of _fpCCR
 	trap	IMM (FPTRAP)	| and trap
-#ifndef __mcoldfire__
-1:	moveml	sp@+,d2-d7	| restore data registers
-#else
-1:	moveml	sp@,d2-d7
+1:
+	moveml	sp@,d2-d7/a2-a5	| restore data registers
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6		| and return
 	rts
 #endif /* L_floatex */
 
+#ifdef __FASTCALL__
+
+#include "lb1sf68-fast.S"
+
+#else
+
 #ifdef  L_mulsi3
 	.text
 	FUNC(__mulsi3)
 	.globl	SYM (__mulsi3)
 	.globl	SYM (__mulsi3_internal)
+#ifdef __ELF__
 	.hidden	SYM (__mulsi3_internal)
+#endif
 SYM (__mulsi3):
 SYM (__mulsi3_internal):
 	movew	sp@(4), d0	/* x0 -> d0 */
@@ -462,7 +490,9 @@ SYM (__mulsi3_internal):
 	FUNC(__udivsi3)
 	.globl	SYM (__udivsi3)
 	.globl	SYM (__udivsi3_internal)
+#ifdef __ELF__
 	.hidden	SYM (__udivsi3_internal)
+#endif
 SYM (__udivsi3):
 SYM (__udivsi3_internal):
 #ifndef __mcoldfire__
@@ -522,11 +552,11 @@ L6:	movel	sp@+, d2
 	moveq	IMM (31),d4
 L1:	addl	d0,d0		| shift reg pair (p,a) one bit left
 	addxl	d2,d2
-	movl	d2,d3		| subtract b from p, store in tmp.
+	movel	d2,d3		| subtract b from p, store in tmp.
 	subl	d1,d3
 	jcs	L2		| if no carry,
 	bset	IMM (0),d0	| set the low order bit of a to 1,
-	movl	d3,d2		| and store tmp in p.
+	movel	d3,d2		| and store tmp in p.
 L2:	subql	IMM (1),d4
 	jcc	L1
 	moveml	sp@,d2-d4	| restore data registers
@@ -541,7 +571,9 @@ L2:	subql	IMM (1),d4
 	FUNC(__divsi3)
 	.globl	SYM (__divsi3)
 	.globl	SYM (__divsi3_internal)
+#ifdef __ELF__
 	.hidden	SYM (__divsi3_internal)
+#endif
 SYM (__divsi3):
 SYM (__divsi3_internal):
 	movel	d2, sp@-
@@ -629,13 +661,35 @@ SYM (__modsi3):
 	rts
 #endif /* L_modsi3 */
 
+#endif /* __FASTCALL__ */
 
 #ifdef  L_double
 
+|=============================================================================
+|=============================================================================
+|                         double precision routines
+|=============================================================================
+|=============================================================================
+
+| A double precision floating point number (double) has the format:
+|
+| struct _double {
+|  unsigned int sign      : 1;  /* sign bit */
+|  unsigned int exponent  : 11; /* exponent, shifted by 1022 */
+|  unsigned int fraction  : 52; /* fraction */
+| } double;
+|
+| Thus sizeof(double) = 8 (64 bits).
+|
+| All the routines are callable from C programs, and return the result
+| in the register pair d0-d1. They also preserve all registers except
+| d0-d1 and a0-a1.
+
 	.globl	SYM (_fpCCR)
 	.globl  $_exception_handler
 
 QUIET_NaN      = 0x7fffffff
+INFINITY       = 0x7ff00000
 
 D_MAX_EXP      = 0x07ff
 D_BIAS         = 1022
@@ -643,29 +697,6 @@ DBL_MAX_EXP    = D_MAX_EXP - D_BIAS
 DBL_MIN_EXP    = 1 - D_BIAS
 DBL_MANT_DIG   = 53
 
-INEXACT_RESULT 		= 0x0001
-UNDERFLOW 		= 0x0002
-OVERFLOW 		= 0x0004
-DIVIDE_BY_ZERO 		= 0x0008
-INVALID_OPERATION 	= 0x0010
-
-DOUBLE_FLOAT = 2
-
-NOOP         = 0
-ADD          = 1
-MULTIPLY     = 2
-DIVIDE       = 3
-NEGATE       = 4
-COMPARE      = 5
-EXTENDSFDF   = 6
-TRUNCDFSF    = 7
-
-UNKNOWN           = -1
-ROUND_TO_NEAREST  = 0 | round result to nearest representable value
-ROUND_TO_ZERO     = 1 | round result towards zero
-ROUND_TO_PLUS     = 2 | round result towards plus infinity
-ROUND_TO_MINUS    = 3 | round result towards minus infinity
-
 | Entry points:
 
 	.globl SYM (__adddf3)
@@ -675,12 +706,14 @@ ROUND_TO_MINUS    = 3 | round result towards minus infinity
 	.globl SYM (__negdf2)
 	.globl SYM (__cmpdf2)
 	.globl SYM (__cmpdf2_internal)
+#ifdef __ELF__
 	.hidden SYM (__cmpdf2_internal)
+#endif
 
 	.text
 	.even
 
-| These are common routines to return and signal exceptions.	
+| These are common routines to return and signal exceptions.
 
 Ld$den:
 | Return and signal a denormalized number
@@ -692,7 +725,7 @@ Ld$den:
 Ld$infty:
 Ld$overflow:
 | Return a properly signed INFINITY and set the exception flags
-	movel	IMM (0x7ff00000),d0
+	movel	IMM (INFINITY),d0
 	movel	IMM (0),d1
 	orl	d7,d0
 	movew	IMM (INEXACT_RESULT+OVERFLOW),d7
@@ -719,33 +752,13 @@ Ld$inop:
 
 Ld$div$0:
 | Return a properly signed INFINITY and set the exception flags
-	movel	IMM (0x7ff00000),d0
+	movel	IMM (INFINITY),d0
 	movel	IMM (0),d1
 	orl	d7,d0
 	movew	IMM (INEXACT_RESULT+DIVIDE_BY_ZERO),d7
 	moveq	IMM (DOUBLE_FLOAT),d6
 	PICJUMP	$_exception_handler
 
-|=============================================================================
-|=============================================================================
-|                         double precision routines
-|=============================================================================
-|=============================================================================
-
-| A double precision floating point number (double) has the format:
-|
-| struct _double {
-|  unsigned int sign      : 1;  /* sign bit */ 
-|  unsigned int exponent  : 11; /* exponent, shifted by 126 */
-|  unsigned int fraction  : 52; /* fraction */
-| } double;
-| 
-| Thus sizeof(double) = 8 (64 bits). 
-|
-| All the routines are callable from C programs, and return the result 
-| in the register pair d0-d1. They also preserve all registers except 
-| d0-d1 and a0-a1.
-
 |=============================================================================
 |                              __subdf3
 |=============================================================================
@@ -755,6 +768,7 @@ Ld$div$0:
 SYM (__subdf3):
 	bchg	IMM (31),sp@(12) | change sign of second operand
 				| and fall through, so we always add
+
 |=============================================================================
 |                              __adddf3
 |=============================================================================
@@ -762,34 +776,26 @@ SYM (__subdf3):
 | double __adddf3(double, double);
 	FUNC(__adddf3)
 SYM (__adddf3):
-#ifndef __mcoldfire__
-	link	a6,IMM (0)	| everything will be done in registers
-	moveml	d2-d7,sp@-	| save all data registers and a2 (but d0-d1)
-#else
-	link	a6,IMM (-24)
-	moveml	d2-d7,sp@
-#endif
-	movel	a6@(8),d0	| get first operand
-	movel	a6@(12),d1	| 
-	movel	a6@(16),d2	| get second operand
-	movel	a6@(20),d3	| 
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+	moveml	a6@(8),d0-d3	| get first operand into d0-d1, and second operand into d2-d3
 
-	movel	d0,d7		| get d0's sign bit in d7 '
+	movel	d0,d7		| get d0's sign bit in d7
 	addl	d1,d1		| check and clear sign bit of a, and gain one
 	addxl	d0,d0		| bit of extra precision
 	beq	Ladddf$b	| if zero return second operand
 
-	movel	d2,d6		| save sign in d6 
+	movel	d2,d6		| save sign in d6
 	addl	d3,d3		| get rid of sign bit and gain one bit of
 	addxl	d2,d2		| extra precision
 	beq	Ladddf$a	| if zero return first operand
 
-	andl	IMM (0x80000000),d7 | isolate a's sign bit '
-        swap	d6		| and also b's sign bit '
+	andl	IMM (0x80000000),d7 | isolate a's sign bit
+	swap	d6		| and also b's sign bit
 #ifndef __mcoldfire__
 	andw	IMM (0x8000),d6	|
-	orw	d6,d7		| and combine them into d7, so that a's sign '
-				| bit is in the high word and b's is in the '
+	orw	d6,d7		| and combine them into d7, so that a's sign
+				| bit is in the high word and b's is in the
 				| low word, so d6 is free to be used
 #else
 	andl	IMM (0x8000),d6
@@ -803,13 +809,13 @@ SYM (__adddf3):
 	movel	IMM (0x001fffff),d6 | mask for the fraction
 	movel	IMM (0x00200000),d7 | mask to put hidden bit back
 
-	movel	d0,d4		| 
+	movel	d0,d4		|
 	andl	d6,d0		| get fraction in d0
 	notl	d6		| make d6 into mask for the exponent
 	andl	d6,d4		| get exponent in d4
 	beq	Ladddf$a$den	| branch if a is denormalized
 	cmpl	d6,d4		| check for INFINITY or NaN
-	beq	Ladddf$nf       | 
+	beq	Ladddf$nf       |
 	orl	d7,d0		| and put hidden bit back
 Ladddf$1:
 	swap	d4		| shift right exponent so that it starts
@@ -818,7 +824,7 @@ Ladddf$1:
 #else
 	lsrl	IMM (5),d4	| in bit 0 and not bit 20
 #endif
-| Now we have a's exponent in d4 and fraction in d0-d1 '
+| Now we have a's exponent in d4 and fraction in d0-d1
 	movel	d2,d5		| save b to get exponent
 	andl	d6,d5		| get exponent in d5
 	beq	Ladddf$b$den	| branch if b is denormalized
@@ -835,25 +841,17 @@ Ladddf$2:
 	lsrl	IMM (5),d5	| in bit 0 and not bit 20
 #endif
 
-| Now we have b's exponent in d5 and fraction in d2-d3. '
+| Now we have b's exponent in d5 and fraction in d2-d3.
 
-| The situation now is as follows: the signs are combined in a0, the 
+| The situation now is as follows: the signs are combined in a0, the
 | numbers are in d0-d1 (a) and d2-d3 (b), and the exponents in d4 (a)
 | and d5 (b). To do the rounding correctly we need to keep all the
 | bits until the end, so we need to use d0-d1-d2-d3 for the first number
 | and d4-d5-d6-d7 for the second. To do this we store (temporarily) the
 | exponents in a2-a3.
 
-#ifndef __mcoldfire__
-	moveml	a2-a3,sp@-	| save the address registers
-#else
-	movel	a2,sp@-	
-	movel	a3,sp@-	
-	movel	a4,sp@-	
-#endif
-
 	movel	d4,a2		| save the exponents
-	movel	d5,a3		| 
+	movel	d5,a3		|
 
 	movel	IMM (0),d7	| and move the numbers around
 	movel	d7,d6		|
@@ -862,7 +860,7 @@ Ladddf$2:
 	movel	d7,d3		|
 	movel	d7,d2		|
 
-| Here we shift the numbers until the exponents are the same, and put 
+| Here we shift the numbers until the exponents are the same, and put
 | the largest exponent in a2.
 #ifndef __mcoldfire__
 	exg	d4,a2		| get exponents back
@@ -877,10 +875,10 @@ Ladddf$2:
 	movel	a4,a3
 	cmpl	d4,d5		| compare the exponents
 #endif
-	beq	Ladddf$3	| if equal don't shift '
+	beq	Ladddf$3	| if equal don't shift
 	bhi	9f		| branch if second exponent is higher
 
-| Here we have a's exponent larger than b's, so we have to shift b. We do 
+| Here we have a's exponent larger than b's, so we have to shift b. We do
 | this by using as counter d2:
 1:	movew	d4,d2		| move largest exponent to d2
 #ifndef __mcoldfire__
@@ -896,7 +894,7 @@ Ladddf$2:
 	movel	a3,d5
 	movel	a4,a3
 #endif
-| if difference is too large we don't shift (actually, we can just exit) '
+| if difference is too large we don't shift (actually, we can just exit)
 #ifndef __mcoldfire__
 	cmpw	IMM (DBL_MANT_DIG+2),d2
 #else
@@ -911,9 +909,9 @@ Ladddf$2:
 	bge	5f
 2:
 #ifndef __mcoldfire__
-	cmpw	IMM (16),d2	| if difference >= 16, shift by words	
+	cmpw	IMM (16),d2	| if difference >= 16, shift by words
 #else
-	cmpl	IMM (16),d2	| if difference >= 16, shift by words	
+	cmpl	IMM (16),d2	| if difference >= 16, shift by words
 #endif
 	bge	6f
 	bra	3f		| enter dbra loop
@@ -944,10 +942,10 @@ Ladddf$2:
 	dbra	d2,4b
 #else
 	subql	IMM (1),d2
-	bpl	4b	
+	bpl	4b
 #endif
 	movel	IMM (0),d2
-	movel	d2,d3	
+	movel	d2,d3
 	bra	Ladddf$4
 5:
 	movel	d6,d7
@@ -975,7 +973,7 @@ Ladddf$2:
 	subl	IMM (16),d2
 #endif
 	bra	3b
-	
+
 9:
 #ifndef __mcoldfire__
 	exg	d4,d5
@@ -995,7 +993,7 @@ Ladddf$2:
 	movel	a3,d5
 	movel	a4,a3
 #endif
-| if difference is too large we don't shift (actually, we can just exit) '
+| if difference is too large we don't shift (actually, we can just exit)
 #ifndef __mcoldfire__
 	cmpw	IMM (DBL_MANT_DIG+2),d6
 #else
@@ -1010,9 +1008,9 @@ Ladddf$2:
 	bge	5f
 2:
 #ifndef __mcoldfire__
-	cmpw	IMM (16),d6	| if difference >= 16, shift by words	
+	cmpw	IMM (16),d6	| if difference >= 16, shift by words
 #else
-	cmpl	IMM (16),d6	| if difference >= 16, shift by words	
+	cmpl	IMM (16),d6	| if difference >= 16, shift by words
 #endif
 	bge	6f
 	bra	3f		| enter dbra loop
@@ -1076,7 +1074,7 @@ Ladddf$2:
 	bra	3b
 Ladddf$3:
 #ifndef __mcoldfire__
-	exg	d4,a2	
+	exg	d4,a2
 	exg	d5,a3
 #else
 	movel	d4,a4
@@ -1086,13 +1084,13 @@ Ladddf$3:
 	movel	a3,d5
 	movel	a4,a3
 #endif
-Ladddf$4:	
+Ladddf$4:
 | Now we have the numbers in d0--d3 and d4--d7, the exponent in a2, and
-| the signs in a4.
+| the signs in a0.
 
 | Here we have to decide whether to add or subtract the numbers:
 #ifndef __mcoldfire__
-	exg	d7,a0		| get the signs 
+	exg	d7,a0		| get the signs
 	exg	d6,a3		| a3 is free to be used
 #else
 	movel	d7,a4
@@ -1103,11 +1101,11 @@ Ladddf$4:
 	movel	a4,a3
 #endif
 	movel	d7,d6		|
-	movew	IMM (0),d7	| get a's sign in d7 '
+	movew	IMM (0),d7	| get a's sign in d7
 	swap	d6              |
-	movew	IMM (0),d6	| and b's sign in d6 '
+	movew	IMM (0),d6	| and b's sign in d6
 	eorl	d7,d6		| compare the signs
-	bmi	Lsubdf$0	| if the signs are different we have 
+	bmi	Lsubdf$0	| if the signs are different we have
 				| to subtract
 #ifndef __mcoldfire__
 	exg	d7,a0		| else we add the numbers
@@ -1122,26 +1120,18 @@ Ladddf$4:
 #endif
 	addl	d7,d3		|
 	addxl	d6,d2		|
-	addxl	d5,d1		| 
+	addxl	d5,d1		|
 	addxl	d4,d0           |
 
 	movel	a2,d4		| return exponent to d4
-	movel	a0,d7		| 
+	movel	a0,d7		|
 	andl	IMM (0x80000000),d7 | d7 now has the sign
 
-#ifndef __mcoldfire__
-	moveml	sp@+,a2-a3	
-#else
-	movel	sp@+,a4	
-	movel	sp@+,a3	
-	movel	sp@+,a2	
-#endif
-
 | Before rounding normalize so bit #DBL_MANT_DIG is set (we will consider
 | the case of denormalized numbers in the rounding routine itself).
-| As in the addition (not in the subtraction!) we could have set 
+| As in the addition (not in the subtraction!) we could have set
 | one more bit we check this:
-	btst	IMM (DBL_MANT_DIG+1),d0	
+	btst	IMM (DBL_MANT_DIG+1-32),d0
 	beq	1f
 #ifndef __mcoldfire__
 	lsrl	IMM (1),d0
@@ -1166,12 +1156,12 @@ Ladddf$4:
 	addl	IMM (1),d4
 #endif
 1:
-	lea	pc@(Ladddf$5),a0 | to return from rounding routine
-	PICLEA	SYM (_fpCCR),a1	| check the rounding mode
+	PICLEA	SYM (_fpCCR),a0	| check the rounding mode
 #ifdef __mcoldfire__
 	clrl	d6
 #endif
-	movew	a1@(6),d6	| rounding mode in d6
+	movew	a0@(6),d6	| rounding mode in d6
+	lea	pc@(Ladddf$5),a0 | to return from rounding routine
 	beq	Lround$to$nearest
 #ifndef __mcoldfire__
 	cmpw	IMM (ROUND_TO_PLUS),d6
@@ -1184,18 +1174,18 @@ Ladddf$4:
 Ladddf$5:
 | Put back the exponent and check for overflow
 #ifndef __mcoldfire__
-	cmpw	IMM (0x7ff),d4	| is the exponent big?
+	cmpw	IMM (D_MAX_EXP),d4	| is the exponent big?
 #else
-	cmpl	IMM (0x7ff),d4	| is the exponent big?
+	cmpl	IMM (D_MAX_EXP),d4	| is the exponent big?
 #endif
 	bge	1f
-	bclr	IMM (DBL_MANT_DIG-1),d0
+	bclr	IMM (DBL_MANT_DIG-1-32),d0
 #ifndef __mcoldfire__
 	lslw	IMM (4),d4	| put exponent back into position
 #else
 	lsll	IMM (4),d4	| put exponent back into position
 #endif
-	swap	d0		| 
+	swap	d0		|
 #ifndef __mcoldfire__
 	orw	d4,d0		|
 #else
@@ -1233,23 +1223,16 @@ Lsubdf$0:
 	negxl	d2		|
 	negxl	d1              | and negate result
 	negxl	d0              |
-1:	
+1:
 	movel	a2,d4		| return exponent to d4
 	movel	a0,d7
 	andl	IMM (0x80000000),d7 | isolate sign bit
-#ifndef __mcoldfire__
-	moveml	sp@+,a2-a3	|
-#else
-	movel	sp@+,a4
-	movel	sp@+,a3
-	movel	sp@+,a2
-#endif
 
 | Before rounding normalize so bit #DBL_MANT_DIG is set (we will consider
 | the case of denormalized numbers in the rounding routine itself).
-| As in the addition (not in the subtraction!) we could have set 
+| As in the addition (not in the subtraction!) we could have set
 | one more bit we check this:
-	btst	IMM (DBL_MANT_DIG+1),d0	
+	btst	IMM (DBL_MANT_DIG+1-32),d0
 	beq	1f
 #ifndef __mcoldfire__
 	lsrl	IMM (1),d0
@@ -1274,12 +1257,12 @@ Lsubdf$0:
 	addl	IMM (1),d4
 #endif
 1:
-	lea	pc@(Lsubdf$1),a0 | to return from rounding routine
-	PICLEA	SYM (_fpCCR),a1	| check the rounding mode
+	PICLEA	SYM (_fpCCR),a0	| check the rounding mode
 #ifdef __mcoldfire__
 	clrl	d6
 #endif
-	movew	a1@(6),d6	| rounding mode in d6
+	movew	a0@(6),d6	| rounding mode in d6
+	lea	pc@(Lsubdf$1),a0 | to return from rounding routine
 	beq	Lround$to$nearest
 #ifndef __mcoldfire__
 	cmpw	IMM (ROUND_TO_PLUS),d6
@@ -1290,14 +1273,14 @@ Lsubdf$0:
 	blt	Lround$to$zero
 	bra	Lround$to$plus
 Lsubdf$1:
-| Put back the exponent and sign (we don't have overflow). '
-	bclr	IMM (DBL_MANT_DIG-1),d0	
+| Put back the exponent and sign (we don't have overflow).
+	bclr	IMM (DBL_MANT_DIG-1-32),d0
 #ifndef __mcoldfire__
 	lslw	IMM (4),d4	| put exponent back into position
 #else
 	lsll	IMM (4),d4	| put exponent back into position
 #endif
-	swap	d0		| 
+	swap	d0		|
 #ifndef __mcoldfire__
 	orw	d4,d0		|
 #else
@@ -1306,50 +1289,28 @@ Lsubdf$1:
 	swap	d0		|
 	bra	Ladddf$ret
 
-| If one of the numbers was too small (difference of exponents >= 
-| DBL_MANT_DIG+1) we return the other (and now we don't have to '
+| If one of the numbers was too small (difference of exponents >=
+| DBL_MANT_DIG+1) we return the other (and now we don't have to
 | check for finiteness or zero).
 Ladddf$a$small:
-#ifndef __mcoldfire__
-	moveml	sp@+,a2-a3	
-#else
-	movel	sp@+,a4
-	movel	sp@+,a3
-	movel	sp@+,a2
-#endif
 	movel	a6@(16),d0
 	movel	a6@(20),d1
 	PICLEA	SYM (_fpCCR),a0
-	movew	IMM (0),a0@
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7	| restore data registers
-#else
-	moveml	sp@,d2-d7
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5	| restore data registers
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6		| and return
 	rts
 
 Ladddf$b$small:
-#ifndef __mcoldfire__
-	moveml	sp@+,a2-a3	
-#else
-	movel	sp@+,a4	
-	movel	sp@+,a3	
-	movel	sp@+,a2	
-#endif
 	movel	a6@(8),d0
 	movel	a6@(12),d1
 	PICLEA	SYM (_fpCCR),a0
-	movew	IMM (0),a0@
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7	| restore data registers
-#else
-	moveml	sp@,d2-d7
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6		| and return
 	rts
 
@@ -1383,10 +1344,8 @@ Ladddf$a:
 	bclr	IMM (31),d0		|
 	cmpl	IMM (0x7ff00000),d0	|
 	bge	2f			|
-	movel	d0,d0           	| check for zero, since we don't  '
+	movel	d0,d0           	| check for zero, since we don't
 	bne	Ladddf$ret		| want to return -0 by mistake
-	movel	d1,d1			|
-	bne	Ladddf$ret		|
 	bclr	IMM (31),d7		|
 	bra	Ladddf$ret		|
 2:
@@ -1394,28 +1353,17 @@ Ladddf$a:
 	orl	d1,d0			|
 	bne	Ld$inop         	|
 	bra	Ld$infty		|
-	
+
 Ladddf$ret$1:
-#ifndef __mcoldfire__
-	moveml	sp@+,a2-a3	| restore regs and exit
-#else
-	movel	sp@+,a4
-	movel	sp@+,a3
-	movel	sp@+,a2
-#endif
 
 Ladddf$ret:
 | Normal exit.
 	PICLEA	SYM (_fpCCR),a0
-	movew	IMM (0),a0@
+	clrw	a0@
 	orl	d7,d0		| put sign bit back
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7
-#else
-	moveml	sp@,d2-d7
+	moveml	sp@,d2-d7/a2-a5
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6
 	rts
 
@@ -1439,25 +1387,25 @@ Ladddf$nf:
 | executed very often. We sacrifice speed for clarity here.
 	movel	a6@(8),d0	| get the numbers back (remember that we
 	movel	a6@(12),d1	| did some processing already)
-	movel	a6@(16),d2	| 
-	movel	a6@(20),d3	| 
-	movel	IMM (0x7ff00000),d4 | useful constant (INFINITY)
+	movel	a6@(16),d2	|
+	movel	a6@(20),d3	|
+	movel	IMM (INFINITY),d4 | useful constant (INFINITY)
 	movel	d0,d7		| save sign bits
-	movel	d2,d6		| 
+	movel	d2,d6		|
 	bclr	IMM (31),d0	| clear sign bits
-	bclr	IMM (31),d2	| 
+	bclr	IMM (31),d2	|
 | We know that one of them is either NaN of +/-INFINITY
 | Check for NaN (if either one is NaN return NaN)
 	cmpl	d4,d0		| check first a (d0)
 	bhi	Ld$inop		| if d0 > 0x7ff00000 or equal and
 	bne	2f
 	tstl	d1		| d1 > 0, a is NaN
-	bne	Ld$inop		| 
+	bne	Ld$inop		|
 2:	cmpl	d4,d2		| check now b (d1)
-	bhi	Ld$inop		| 
+	bhi	Ld$inop		|
 	bne	3f
-	tstl	d3		| 
-	bne	Ld$inop		| 
+	tstl	d3		|
+	bne	Ld$inop		|
 3:
 | Now comes the check for +/-INFINITY. We know that both are (maybe not
 | finite) numbers, but we have to check if both are infinite whether we
@@ -1474,8 +1422,8 @@ Ladddf$nf:
 	bne	1f		| if d0 <> d2 they are not equal
 	cmpl	d3,d1		| if d0 == d2 test d3 and d1
 	beq	Ld$inop		| if equal return NaN
-1:	
-	andl	IMM (0x80000000),d7 | get a's sign bit '
+1:
+	andl	IMM (0x80000000),d7 | get a's sign bit
 	cmpl	d4,d0		| test now for infinity
 	beq	Ld$infty	| if a is INFINITY return with this sign
 	bchg	IMM (31),d7	| else we know b is INFINITY and has
@@ -1488,34 +1436,26 @@ Ladddf$nf:
 | double __muldf3(double, double);
 	FUNC(__muldf3)
 SYM (__muldf3):
-#ifndef __mcoldfire__
-	link	a6,IMM (0)
-	moveml	d2-d7,sp@-
-#else
-	link	a6,IMM (-24)
-	moveml	d2-d7,sp@
-#endif
-	movel	a6@(8),d0		| get a into d0-d1
-	movel	a6@(12),d1		| 
-	movel	a6@(16),d2		| and b into d2-d3
-	movel	a6@(20),d3		|
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+	moveml	a6@(8),d0-d3	| get a into d0-d1, and b into d2-d3
 	movel	d0,d7			| d7 will hold the sign of the product
 	eorl	d2,d7			|
 	andl	IMM (0x80000000),d7	|
-	movel	d7,a0			| save sign bit into a0 
-	movel	IMM (0x7ff00000),d7	| useful constant (+INFINITY)
+	movel	d7,a0			| save sign bit into a0
+	movel	IMM (INFINITY),d7	| useful constant (+INFINITY)
 	movel	d7,d6			| another (mask for fraction)
 	notl	d6			|
-	bclr	IMM (31),d0		| get rid of a's sign bit '
-	movel	d0,d4			| 
-	orl	d1,d4			| 
+	bclr	IMM (31),d0		| get rid of a's sign bit
+	movel	d0,d4			|
+	orl	d1,d4			|
 	beq	Lmuldf$a$0		| branch if a is zero
 	movel	d0,d4			|
-	bclr	IMM (31),d2		| get rid of b's sign bit '
+	bclr	IMM (31),d2		| get rid of b's sign bit
 	movel	d2,d5			|
-	orl	d3,d5			| 
+	orl	d3,d5			|
 	beq	Lmuldf$b$0		| branch if b is zero
-	movel	d2,d5			| 
+	movel	d2,d5			|
 	cmpl	d7,d0			| is a big?
 	bhi	Lmuldf$inop		| if a is NaN return NaN
 	beq	Lmuldf$a$nf		| we still have to check d1 and b ...
@@ -1530,11 +1470,11 @@ SYM (__muldf3):
 	orl	IMM (0x00100000),d0	| and put hidden bit back
 	swap	d4			| I like exponents in the first byte
 #ifndef __mcoldfire__
-	lsrw	IMM (4),d4		| 
+	lsrw	IMM (4),d4		|
 #else
-	lsrl	IMM (4),d4		| 
+	lsrl	IMM (4),d4		|
 #endif
-Lmuldf$1:			
+Lmuldf$1:
 	andl	d7,d5			|
 	beq	Lmuldf$b$den		|
 	andl	d6,d2			|
@@ -1555,8 +1495,8 @@ Lmuldf$2:				|
 #endif
 
 | We are now ready to do the multiplication. The situation is as follows:
-| both a and b have bit 52 ( bit 20 of d0 and d2) set (even if they were 
-| denormalized to start with!), which means that in the product bit 104 
+| both a and b have bit 52 ( bit 20 of d0 and d2) set (even if they were
+| denormalized to start with!), which means that in the product bit 104
 | (which will correspond to bit 8 of the fourth long) is set.
 
 | Here we have to do the product.
@@ -1564,13 +1504,6 @@ Lmuldf$2:				|
 | enough to keep everything in them. So we use the address registers to keep
 | some intermediate data.
 
-#ifndef __mcoldfire__
-	moveml	a2-a3,sp@-	| save a2 and a3 for temporary use
-#else
-	movel	a2,sp@-
-	movel	a3,sp@-
-	movel	a4,sp@-
-#endif
 	movel	IMM (0),a2	| a2 is a null register
 	movel	d4,a3		| and a3 will preserve the exponent
 
@@ -1604,8 +1537,8 @@ Lmuldf$2:				|
 	movel	d3,d1           |
 	movel	d3,d0	        |
 
-| We use a1 as counter:	
-	movel	IMM (DBL_MANT_DIG-1),a1		
+| We use a1 as counter:
+	movel	IMM (DBL_MANT_DIG-1),a1
 #ifndef __mcoldfire__
 	exg	d7,a1
 #else
@@ -1641,7 +1574,7 @@ Lmuldf$2:				|
 	addxl	d7,d1		|
 	addxl	d7,d0		|
 #ifndef __mcoldfire__
-	exg	d7,a2		| 
+	exg	d7,a2		|
 #else
 	movel	d7,a4
 	movel	a2,d7
@@ -1660,16 +1593,9 @@ Lmuldf$2:				|
 #endif
 
 	movel	a3,d4		| restore exponent
-#ifndef __mcoldfire__
-	moveml	sp@+,a2-a3
-#else
-	movel	sp@+,a4
-	movel	sp@+,a3
-	movel	sp@+,a2
-#endif
 
-| Now we have the product in d0-d1-d2-d3, with bit 8 of d0 set. The 
-| first thing to do now is to normalize it so bit 8 becomes bit 
+| Now we have the product in d0-d1-d2-d3, with bit 8 of d0 set. The
+| first thing to do now is to normalize it so bit 8 becomes bit
 | DBL_MANT_DIG-32 (to do the rounding); later we will shift right.
 	swap	d0
 	swap	d1
@@ -1708,7 +1634,7 @@ Lmuldf$2:				|
 	orl	d7,d1
 	lsrl	IMM (3),d0
 #endif
-	
+
 | Now round, check for over- and underflow, and exit.
 	movel	a0,d7		| get sign bit back into d7
 	moveq	IMM (MULTIPLY),d5
@@ -1770,18 +1696,14 @@ Lmuldf$a$0:
 1:	cmpl	IMM (0x7ff00000),d2 | check for non-finiteness
 	bge	Ld$inop		| in case NaN or +/-INFINITY return NaN
 	PICLEA	SYM (_fpCCR),a0
-	movew	IMM (0),a0@
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7
-#else
-	moveml	sp@,d2-d7
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6
 	rts
 
-| If a number is denormalized we put an exponent of 1 but do not put the 
+| If a number is denormalized we put an exponent of 1 but do not put the
 | hidden bit back into the fraction; instead we shift left until bit 21
 | (the hidden bit) is set, adjusting the exponent accordingly. We do this
 | to ensure that the product of the fractions is close to 1.
@@ -1821,30 +1743,22 @@ Lmuldf$b$den:
 | double __divdf3(double, double);
 	FUNC(__divdf3)
 SYM (__divdf3):
-#ifndef __mcoldfire__
-	link	a6,IMM (0)
-	moveml	d2-d7,sp@-
-#else
-	link	a6,IMM (-24)
-	moveml	d2-d7,sp@
-#endif
-	movel	a6@(8),d0	| get a into d0-d1
-	movel	a6@(12),d1	| 
-	movel	a6@(16),d2	| and b into d2-d3
-	movel	a6@(20),d3	|
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+	moveml	a6@(8),d0-d3	| get a into d0-d1, and b into d2-d3
 	movel	d0,d7		| d7 will hold the sign of the result
 	eorl	d2,d7		|
 	andl	IMM (0x80000000),d7
 	movel	d7,a0		| save sign into a0
-	movel	IMM (0x7ff00000),d7 | useful constant (+INFINITY)
+	movel	IMM (INFINITY),d7 | useful constant (+INFINITY)
 	movel	d7,d6		| another (mask for fraction)
 	notl	d6		|
-	bclr	IMM (31),d0	| get rid of a's sign bit '
+	bclr	IMM (31),d0	| get rid of a's sign bit
 	movel	d0,d4		|
 	orl	d1,d4		|
 	beq	Ldivdf$a$0	| branch if a is zero
 	movel	d0,d4		|
-	bclr	IMM (31),d2	| get rid of b's sign bit '
+	bclr	IMM (31),d2	| get rid of b's sign bit
 	movel	d2,d5		|
 	orl	d3,d5		|
 	beq	Ldivdf$b$0	| branch if b is zero
@@ -1852,7 +1766,7 @@ SYM (__divdf3):
 	cmpl	d7,d0		| is a big?
 	bhi	Ldivdf$inop	| if a is NaN return NaN
 	beq	Ldivdf$a$nf	| if d0 == 0x7ff00000 we check d1
-	cmpl	d7,d2		| now compare b with INFINITY 
+	cmpl	d7,d2		| now compare b with INFINITY
 	bhi	Ldivdf$inop	| if b is NaN return NaN
 	beq	Ldivdf$b$nf	| if d2 == 0x7ff00000 we check d3
 | Here we have both numbers finite and nonzero (and with no sign bit).
@@ -1867,11 +1781,11 @@ SYM (__divdf3):
 	orl	IMM (0x00100000),d0 | and put hidden bit back
 	swap	d4		| I like exponents in the first byte
 #ifndef __mcoldfire__
-	lsrw	IMM (4),d4	| 
+	lsrw	IMM (4),d4	|
 #else
-	lsrl	IMM (4),d4	| 
+	lsrl	IMM (4),d4	|
 #endif
-Ldivdf$1:			| 
+Ldivdf$1:			|
 	andl	d7,d5		|
 	beq	Ldivdf$b$den	|
 	andl	d6,d2		|
@@ -1894,7 +1808,7 @@ Ldivdf$2:			|
 | We are now ready to do the division. We have prepared things in such a way
 | that the ratio of the fractions will be less than 2 but greater than 1/2.
 | At this point the registers in use are:
-| d0-d1	hold a (first operand, bit DBL_MANT_DIG-32=0, bit 
+| d0-d1	hold a (first operand, bit DBL_MANT_DIG-32=0, bit
 | DBL_MANT_DIG-1-32=1)
 | d2-d3	hold b (second operand, bit DBL_MANT_DIG-32=1)
 | d4	holds the difference of the exponents, corrected by the bias
@@ -1903,19 +1817,19 @@ Ldivdf$2:			|
 | To do the rounding correctly we need to keep information about the
 | nonsignificant bits. One way to do this would be to do the division
 | using four registers; another is to use two registers (as originally
-| I did), but use a sticky bit to preserve information about the 
+| I did), but use a sticky bit to preserve information about the
 | fractional part. Note that we can keep that info in a1, which is not
 | used.
 	movel	IMM (0),d6	| d6-d7 will hold the result
-	movel	d6,d7		| 
+	movel	d6,d7		|
 	movel	IMM (0),a1	| and a1 will hold the sticky bit
 
-	movel	IMM (DBL_MANT_DIG-32+1),d5	
-	
+	movel	IMM (DBL_MANT_DIG-32+1),d5
+
 1:	cmpl	d0,d2		| is a < b?
 	bhi	3f		| if b > a skip the following
 	beq	4f		| if d0==d2 check d1 and d3
-2:	subl	d3,d1		| 
+2:	subl	d3,d1		|
 	subxl	d2,d0		| a <-- a - b
 	bset	d5,d6		| set the corresponding bit in d6
 3:	addl	d1,d1		| shift a by 1
@@ -1926,7 +1840,7 @@ Ldivdf$2:			|
 	subql	IMM (1), d5
 	bpl	1b
 #endif
-	bra	5f			
+	bra	5f
 4:	cmpl	d1,d3		| here d0==d2, so check d1 and d3
 	bhi	3b		| if d1 > d2 skip the subtraction
 	bra	2b		| else go do it
@@ -1937,7 +1851,7 @@ Ldivdf$2:			|
 1:	cmpl	d0,d2		| is a < b?
 	bhi	3f		| if b > a skip the following
 	beq	4f		| if d0==d2 check d1 and d3
-2:	subl	d3,d1		| 
+2:	subl	d3,d1		|
 	subxl	d2,d0		| a <-- a - b
 	bset	d5,d7		| set the corresponding bit in d7
 3:	addl	d1,d1		| shift a by 1
@@ -1948,7 +1862,7 @@ Ldivdf$2:			|
 	subql	IMM (1), d5
 	bpl	1b
 #endif
-	bra	5f			
+	bra	5f
 4:	cmpl	d1,d3		| here d0==d2, so check d1 and d3
 	bhi	3b		| if d1 > d2 skip the subtraction
 	bra	2b		| else go do it
@@ -1968,12 +1882,12 @@ Ldivdf$2:			|
 #endif
 	movel	IMM (0),d2	| here no sticky bit was found
 	movel	d2,d3
-	bra	5f			
+	bra	5f
 3:	cmpl	d1,d3		| here d0==d2, so check d1 and d3
 	bhi	2b		| if d1 > d2 go back
 4:
 | Here put the sticky bit in d2-d3 (in the position which actually corresponds
-| to it; if you don't do this the algorithm loses in some cases). '
+| to it; if you don't do this the algorithm loses in some cases).
 	movel	IMM (0),d2
 	movel	d2,d3
 #ifndef __mcoldfire__
@@ -2045,38 +1959,34 @@ Ldivdf$a$0:
 | return a properly signed zero.
 	moveq	IMM (DIVIDE),d5
 	bclr	IMM (31),d2	|
-	movel	d2,d4		| 
-	orl	d3,d4		| 
+	movel	d2,d4		|
+	orl	d3,d4		|
 	beq	Ld$inop		| if b is also zero return NaN
-	cmpl	IMM (0x7ff00000),d2 | check for NaN
-	bhi	Ld$inop		| 
+	cmpl	IMM (INFINITY),d2 | check for NaN
+	bhi	Ld$inop		|
 	blt	1f		|
 	tstl	d3		|
 	bne	Ld$inop		|
 1:	movel	a0,d0		| else return signed zero
-	moveq	IMM(0),d1	| 
+	moveq	IMM(0),d1	|
 	PICLEA	SYM (_fpCCR),a0	| clear exception flags
-	movew	IMM (0),a0@	|
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7	| 
-#else
-	moveml	sp@,d2-d7	| 
+	clrw	a0@	|
+	moveml	sp@,d2-d7/a2-a5	|
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
-	unlk	a6		| 
-	rts			| 	
+	unlk	a6		|
+	rts			|
 
 Ldivdf$b$0:
 	moveq	IMM (DIVIDE),d5
 | If we got here a is not zero. Check if a is NaN; in that case return NaN,
-| else return +/-INFINITY. Remember that a is in d0 with the sign bit 
+| else return +/-INFINITY. Remember that a is in d0 with the sign bit
 | cleared already.
-	movel	a0,d7		| put a's sign bit back in d7 '
-	cmpl	IMM (0x7ff00000),d0 | compare d0 with INFINITY
+	movel	a0,d7		| put a's sign bit back in d7
+	cmpl	IMM (INFINITY),d0 | compare d0 with INFINITY
 	bhi	Ld$inop		| if larger it is NaN
-	tstl	d1		| 
-	bne	Ld$inop		| 
+	tstl	d1		|
+	bne	Ld$inop		|
 	bra	Ld$div$0	| else signal DIVIDE_BY_ZERO
 
 Ldivdf$b$nf:
@@ -2093,12 +2003,13 @@ Ldivdf$a$nf:
 	tstl	d1		|
 	bne	Ld$inop		| if d1 <> 0, a is NaN
 | If a is INFINITY we have to check b
-	cmpl	d7,d2		| compare b with INFINITY 
+	cmpl	d7,d2		| compare b with INFINITY
 	bge	Ld$inop		| if b is NaN or INFINITY return NaN
-	movl	a0,d7		| restore sign bit to d7
+	tstl	d3		|
+	bne	Ld$inop		|
 	bra	Ld$overflow	| else return overflow
 
-| If a number is denormalized we put an exponent of 1 but do not put the 
+| If a number is denormalized we put an exponent of 1 but do not put the
 | bit back into the fraction.
 Ldivdf$a$den:
 	movel	IMM (1),d4
@@ -2135,32 +2046,32 @@ Lround$exit:
 
 | First check for underlow in the exponent:
 #ifndef __mcoldfire__
-	cmpw	IMM (-DBL_MANT_DIG-1),d4		
+	cmpw	IMM (-DBL_MANT_DIG-1),d4
 #else
-	cmpl	IMM (-DBL_MANT_DIG-1),d4		
+	cmpl	IMM (-DBL_MANT_DIG-1),d4
 #endif
-	blt	Ld$underflow	
-| It could happen that the exponent is less than 1, in which case the 
-| number is denormalized. In this case we shift right and adjust the 
-| exponent until it becomes 1 or the fraction is zero (in the latter case 
+	blt	Ld$underflow
+| It could happen that the exponent is less than 1, in which case the
+| number is denormalized. In this case we shift right and adjust the
+| exponent until it becomes 1 or the fraction is zero (in the latter case
 | we signal underflow and return zero).
 	movel	d7,a0		|
 	movel	IMM (0),d6	| use d6-d7 to collect bits flushed right
 	movel	d6,d7		| use d6-d7 to collect bits flushed right
 #ifndef __mcoldfire__
-	cmpw	IMM (1),d4	| if the exponent is less than 1 we 
+	cmpw	IMM (1),d4	| if the exponent is less than 1 we
 #else
-	cmpl	IMM (1),d4	| if the exponent is less than 1 we 
+	cmpl	IMM (1),d4	| if the exponent is less than 1 we
 #endif
 	bge	2f		| have to shift right (denormalize)
 1:
 #ifndef __mcoldfire__
 	addw	IMM (1),d4	| adjust the exponent
-	lsrl	IMM (1),d0	| shift right once 
+	lsrl	IMM (1),d0	| shift right once
 	roxrl	IMM (1),d1	|
 	roxrl	IMM (1),d2	|
 	roxrl	IMM (1),d3	|
-	roxrl	IMM (1),d6	| 
+	roxrl	IMM (1),d6	|
 	roxrl	IMM (1),d7	|
 	cmpw	IMM (1),d4	| is the exponent 1 already?
 #else
@@ -2191,17 +2102,17 @@ Lround$exit:
 	beq	2f		| if not loop back
 	bra	1b              |
 	movel	a0,d7		| get back sign bit into d7
-	bra	Ld$underflow	| safety check, shouldn't execute '
-2:	orl	d6,d2		| this is a trick so we don't lose  '
+	bra	Ld$underflow	| safety check, shouldn't execute
+2:	orl	d6,d2		| this is a trick so we don't lose
 	orl	d7,d3		| the bits which were flushed right
 	movel	a0,d7		| get back sign bit into d7
 | Now call the rounding routine (which takes care of denormalized numbers):
-	lea	pc@(Lround$0),a0 | to return from rounding routine
-	PICLEA	SYM (_fpCCR),a1	| check the rounding mode
+	PICLEA	SYM (_fpCCR),a0	| check the rounding mode
 #ifdef __mcoldfire__
 	clrl	d6
 #endif
-	movew	a1@(6),d6	| rounding mode in d6
+	movew	a0@(6),d6	| rounding mode in d6
+	lea	pc@(Lround$0),a0 | to return from rounding routine
 	beq	Lround$to$nearest
 #ifndef __mcoldfire__
 	cmpw	IMM (ROUND_TO_PLUS),d6
@@ -2215,14 +2126,14 @@ Lround$0:
 | Here we have a correctly rounded result (either normalized or denormalized).
 
 | Here we should have either a normalized number or a denormalized one, and
-| the exponent is necessarily larger or equal to 1 (so we don't have to  '
-| check again for underflow!). We have to check for overflow or for a 
+| the exponent is necessarily larger or equal to 1 (so we don't have to
+| check again for underflow!). We have to check for overflow or for a
 | denormalized number (which also signals underflow).
 | Check for overflow (i.e., exponent >= 0x7ff).
 #ifndef __mcoldfire__
-	cmpw	IMM (0x07ff),d4
+	cmpw	IMM (D_MAX_EXP),d4
 #else
-	cmpl	IMM (0x07ff),d4
+	cmpl	IMM (D_MAX_EXP),d4
 #endif
 	bge	Ld$overflow
 | Now check for a denormalized number (exponent==0):
@@ -2238,22 +2149,18 @@ Lround$0:
 	bclr	IMM (DBL_MANT_DIG-32-1),d0
 	swap	d0		| and put back exponent
 #ifndef __mcoldfire__
-	orw	d4,d0		| 
+	orw	d4,d0		|
 #else
-	orl	d4,d0		| 
+	orl	d4,d0		|
 #endif
 	swap	d0		|
 	orl	d7,d0		| and sign also
 
 	PICLEA	SYM (_fpCCR),a0
-	movew	IMM (0),a0@
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7
-#else
-	moveml	sp@,d2-d7
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6
 	rts
 
@@ -2264,13 +2171,8 @@ Lround$0:
 | double __negdf2(double, double);
 	FUNC(__negdf2)
 SYM (__negdf2):
-#ifndef __mcoldfire__
-	link	a6,IMM (0)
-	moveml	d2-d7,sp@-
-#else
-	link	a6,IMM (-24)
-	moveml	d2-d7,sp@
-#endif
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
 	moveq	IMM (NEGATE),d5
 	movel	a6@(8),d0	| get number to negate in d0-d1
 	movel	a6@(12),d1	|
@@ -2287,16 +2189,12 @@ SYM (__negdf2):
 	bne	Ld$inop		|
 	movel	d0,d7		| else get sign and return INFINITY
 	andl	IMM (0x80000000),d7
-	bra	Ld$infty		
+	bra	Ld$infty
 1:	PICLEA	SYM (_fpCCR),a0
-	movew	IMM (0),a0@
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7
-#else
-	moveml	sp@,d2-d7
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6
 	rts
 2:	bclr	IMM (31),d0
@@ -2306,24 +2204,47 @@ SYM (__negdf2):
 |                              __cmpdf2
 |=============================================================================
 
-GREATER =  1
-LESS    = -1
-EQUAL   =  0
+| gcc expects the routines __eqdf2, __nedf2, __gtdf2, __gedf2,
+| __ledf2, __ltdf2 to all return the same value as a direct call to
+| __cmpdf2 would.  In this implementation, each of these routines
+| simply calls __cmpdf2.  It would be more efficient to give the
+| __cmpdf2 routine several names, but separating them out will make it
+| easier to write efficient versions of these routines someday.
+| If the operands recompare unordered unordered __gtdf2 and __gedf2 return -1.
+| The other routines return 1.
+
+	FUNC(__gtdf2)
+	.globl	SYM (__gtdf2)
+SYM (__gtdf2):
+	FUNC(__gedf2)
+	.globl	SYM (__gedf2)
+SYM (__gedf2):
+	lea	LESS,a0
+	jbra SYM(__cmpdf2_internal)
+
+	FUNC(__eqdf2)
+	.globl	SYM (__eqdf2)
+SYM (__eqdf2):
+	FUNC(__nedf2)
+	.globl	SYM (__nedf2)
+SYM (__nedf2):
+	FUNC(__ltdf2)
+	.globl	SYM (__ltdf2)
+SYM (__ltdf2):
+	FUNC(__ledf2)
+	.globl	SYM (__ledf2)
+SYM (__ledf2):
+
+| int __cmpdf2(double, double);
+	FUNC(__cmpdf2)
+SYM (__cmpdf2):
+	lea	GREATER,a0
 
 | int __cmpdf2_internal(double, double, int);
 SYM (__cmpdf2_internal):
-#ifndef __mcoldfire__
-	link	a6,IMM (0)
-	moveml	d2-d7,sp@- 	| save registers
-#else
-	link	a6,IMM (-24)
-	moveml	d2-d7,sp@
-#endif
-	moveq	IMM (COMPARE),d5
-	movel	a6@(8),d0	| get first operand
-	movel	a6@(12),d1	|
-	movel	a6@(16),d2	| get second operand
-	movel	a6@(20),d3	|
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+	moveml	a6@(8),d0-d3	| get first operand into d0-d1, and second operand into d2-d3
 | First check if a and/or b are (+/-) zero and in that case clear
 | the sign bit.
 	movel	d0,d6		| copy signs into d6 (a) and d7(b)
@@ -2331,14 +2252,14 @@ SYM (__cmpdf2_internal):
 	movel	d2,d7		|
 	bclr	IMM (31),d2	|
 	cmpl	IMM (0x7ff00000),d0 | check for a == NaN
-	bhi	Lcmpd$inop		| if d0 > 0x7ff00000, a is NaN
+	bhi	Lcmpdf$inop		| if d0 > 0x7ff00000, a is NaN
 	beq	Lcmpdf$a$nf	| if equal can be INFINITY, so check d1
 	movel	d0,d4		| copy into d4 to test for zero
 	orl	d1,d4		|
 	beq	Lcmpdf$a$0	|
 Lcmpdf$0:
 	cmpl	IMM (0x7ff00000),d2 | check for b == NaN
-	bhi	Lcmpd$inop		| if d2 > 0x7ff00000, b is NaN
+	bhi	Lcmpdf$inop		| if d2 > 0x7ff00000, b is NaN
 	beq	Lcmpdf$b$nf	| if equal can be INFINITY, so check d3
 	movel	d2,d4		|
 	orl	d3,d4		|
@@ -2379,39 +2300,27 @@ Lcmpdf$1:
 	bne	Lcmpdf$a$gt$b	| |b| < |a|
 | If we got here a == b.
 	movel	IMM (EQUAL),d0
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7 	| put back the registers
-#else
-	moveml	sp@,d2-d7
+	moveml	sp@,d2-d7/a2-a5 	| put back the registers
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6
 	rts
 Lcmpdf$a$gt$b:
 	movel	IMM (GREATER),d0
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7 	| put back the registers
-#else
-	moveml	sp@,d2-d7
+	moveml	sp@,d2-d7/a2-a5 	| put back the registers
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6
 	rts
 Lcmpdf$b$gt$a:
 	movel	IMM (LESS),d0
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7 	| put back the registers
-#else
-	moveml	sp@,d2-d7
+	moveml	sp@,d2-d7/a2-a5 	| put back the registers
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6
 	rts
 
-Lcmpdf$a$0:	
+Lcmpdf$a$0:
 	bclr	IMM (31),d6
 	bra	Lcmpdf$0
 Lcmpdf$b$0:
@@ -2420,39 +2329,27 @@ Lcmpdf$b$0:
 
 Lcmpdf$a$nf:
 	tstl	d1
-	bne	Ld$inop
+	bne	Lcmpdf$inop
 	bra	Lcmpdf$0
 
 Lcmpdf$b$nf:
 	tstl	d3
-	bne	Ld$inop
+	bne	Lcmpdf$inop
 	bra	Lcmpdf$1
 
-Lcmpd$inop:
-	movl	a6@(24),d0
+Lcmpdf$inop:
+	movel	a0,d0
+	moveq	IMM (COMPARE),d5
 	moveq	IMM (INEXACT_RESULT+INVALID_OPERATION),d7
 	moveq	IMM (DOUBLE_FLOAT),d6
 	PICJUMP	$_exception_handler
 
-| int __cmpdf2(double, double);
-	FUNC(__cmpdf2)
-SYM (__cmpdf2):
-	link	a6,IMM (0)
-	pea	1
-	movl	a6@(20),sp@-
-	movl	a6@(16),sp@-
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpdf2_internal)
-	unlk	a6
-	rts
-
 |=============================================================================
 |                           rounding routines
 |=============================================================================
 
 | The rounding routines expect the number to be normalized in registers
-| d0-d1-d2-d3, with the exponent in register d4. They assume that the 
+| d0-d1-d2-d3, with the exponent in register d4. They assume that the
 | exponent is larger or equal to 1. They return a properly normalized number
 | if possible, and a denormalized number otherwise. The exponent is returned
 | in d4.
@@ -2465,15 +2362,15 @@ Lround$to$nearest:
 | Check for denormalized numbers:
 1:	btst	IMM (DBL_MANT_DIG-32),d0
 	bne	2f		| if set the number is normalized
-| Normalize shifting left until bit #DBL_MANT_DIG-32 is set or the exponent 
-| is one (remember that a denormalized number corresponds to an 
+| Normalize shifting left until bit #DBL_MANT_DIG-32 is set or the exponent
+| is one (remember that a denormalized number corresponds to an
 | exponent of -D_BIAS+1).
 #ifndef __mcoldfire__
 	cmpw	IMM (1),d4	| remember that the exponent is at least one
 #else
 	cmpl	IMM (1),d4	| remember that the exponent is at least one
 #endif
- 	beq	2f		| an exponent of one means denormalized
+	beq	2f		| an exponent of one means denormalized
 	addl	d3,d3		| else shift and adjust the exponent
 	addxl	d2,d2		|
 	addxl	d1,d1		|
@@ -2487,20 +2384,20 @@ Lround$to$nearest:
 2:
 | Now round: we do it as follows: after the shifting we can write the
 | fraction part as f + delta, where 1 < f < 2^25, and 0 <= delta <= 2.
-| If delta < 1, do nothing. If delta > 1, add 1 to f. 
-| If delta == 1, we make sure the rounded number will be even (odd?) 
+| If delta < 1, do nothing. If delta > 1, add 1 to f.
+| If delta == 1, we make sure the rounded number will be even (odd?)
 | (after shifting).
 	btst	IMM (0),d1	| is delta < 1?
 	beq	2f		| if so, do not do anything
 	orl	d2,d3		| is delta == 1?
 	bne	1f		| if so round to even
-	movel	d1,d3		| 
+	movel	d1,d3		|
 	andl	IMM (2),d3	| bit 1 is the last significant bit
 	movel	IMM (0),d2	|
 	addl	d3,d1		|
 	addxl	d2,d0		|
-	bra	2f		| 
-1:	movel	IMM (1),d3	| else add 1 
+	bra	2f		|
+1:	movel	IMM (1),d3	| else add 1
 	movel	IMM (0),d2	|
 	addl	d3,d1		|
 	addxl	d2,d0
@@ -2508,7 +2405,7 @@ Lround$to$nearest:
 2:
 #ifndef __mcoldfire__
 	lsrl	IMM (1),d0
-	roxrl	IMM (1),d1		
+	roxrl	IMM (1),d1
 #else
 	lsrl	IMM (1),d1
 	btst	IMM (0),d0
@@ -2519,7 +2416,7 @@ Lround$to$nearest:
 
 | Now check again bit #DBL_MANT_DIG-32 (rounding could have produced a
 | 'fraction overflow' ...).
-	btst	IMM (DBL_MANT_DIG-32),d0	
+	btst	IMM (DBL_MANT_DIG-32),d0
 	beq	1f
 #ifndef __mcoldfire__
 	lsrl	IMM (1),d0
@@ -2534,7 +2431,7 @@ Lround$to$nearest:
 	addl	IMM (1),d4
 #endif
 1:
-| If bit #DBL_MANT_DIG-32-1 is clear we have a denormalized number, so we 
+| If bit #DBL_MANT_DIG-32-1 is clear we have a denormalized number, so we
 | have to put the exponent to zero and return a denormalized number.
 	btst	IMM (DBL_MANT_DIG-32-1),d0
 	beq	1f
@@ -2550,6 +2447,26 @@ Lround$to$minus:
 
 #ifdef  L_float
 
+|=============================================================================
+|=============================================================================
+|                         single precision routines
+|=============================================================================
+|=============================================================================
+
+| A single precision floating point number (float) has the format:
+|
+| struct _float {
+|  unsigned int sign      : 1;  /* sign bit */
+|  unsigned int exponent  : 8;  /* exponent, shifted by 126 */
+|  unsigned int fraction  : 23; /* fraction */
+| } float;
+|
+| Thus sizeof(float) = 4 (32 bits).
+|
+| All the routines are callable from C programs, and return the result
+| in the single register d0. They also preserve all registers except
+| d0-d1 and a0-a1.
+
 	.globl	SYM (_fpCCR)
 	.globl  $_exception_handler
 
@@ -2563,29 +2480,6 @@ FLT_MAX_EXP    = F_MAX_EXP - F_BIAS
 FLT_MIN_EXP    = 1 - F_BIAS
 FLT_MANT_DIG   = 24
 
-INEXACT_RESULT 		= 0x0001
-UNDERFLOW 		= 0x0002
-OVERFLOW 		= 0x0004
-DIVIDE_BY_ZERO 		= 0x0008
-INVALID_OPERATION 	= 0x0010
-
-SINGLE_FLOAT = 1
-
-NOOP         = 0
-ADD          = 1
-MULTIPLY     = 2
-DIVIDE       = 3
-NEGATE       = 4
-COMPARE      = 5
-EXTENDSFDF   = 6
-TRUNCDFSF    = 7
-
-UNKNOWN           = -1
-ROUND_TO_NEAREST  = 0 | round result to nearest representable value
-ROUND_TO_ZERO     = 1 | round result towards zero
-ROUND_TO_PLUS     = 2 | round result towards plus infinity
-ROUND_TO_MINUS    = 3 | round result towards minus infinity
-
 | Entry points:
 
 	.globl SYM (__addsf3)
@@ -2595,9 +2489,11 @@ ROUND_TO_MINUS    = 3 | round result towards minus infinity
 	.globl SYM (__negsf2)
 	.globl SYM (__cmpsf2)
 	.globl SYM (__cmpsf2_internal)
+#ifdef __ELF__
 	.hidden SYM (__cmpsf2_internal)
+#endif
 
-| These are common routines to return and signal exceptions.	
+| These are common routines to return and signal exceptions.
 
 	.text
 	.even
@@ -2641,26 +2537,6 @@ Lf$div$0:
 	moveq	IMM (SINGLE_FLOAT),d6
 	PICJUMP	$_exception_handler
 
-|=============================================================================
-|=============================================================================
-|                         single precision routines
-|=============================================================================
-|=============================================================================
-
-| A single precision floating point number (float) has the format:
-|
-| struct _float {
-|  unsigned int sign      : 1;  /* sign bit */ 
-|  unsigned int exponent  : 8;  /* exponent, shifted by 126 */
-|  unsigned int fraction  : 23; /* fraction */
-| } float;
-| 
-| Thus sizeof(float) = 4 (32 bits). 
-|
-| All the routines are callable from C programs, and return the result 
-| in the single register d0. They also preserve all registers except 
-| d0-d1 and a0-a1.
-
 |=============================================================================
 |                              __subsf3
 |=============================================================================
@@ -2668,8 +2544,14 @@ Lf$div$0:
 | float __subsf3(float, float);
 	FUNC(__subsf3)
 SYM (__subsf3):
+#ifdef __FASTCALL__
+	bchg	IMM (31),d1   	| change sign of second operand
+				| and fall through
+#else
 	bchg	IMM (31),sp@(8)	| change sign of second operand
 				| and fall through
+#endif
+
 |=============================================================================
 |                              __addsf3
 |=============================================================================
@@ -2677,19 +2559,18 @@ SYM (__subsf3):
 | float __addsf3(float, float);
 	FUNC(__addsf3)
 SYM (__addsf3):
-#ifndef __mcoldfire__
-	link	a6,IMM (0)	| everything will be done in registers
-	moveml	d2-d7,sp@-	| save all data registers but d0-d1
-#else
-	link	a6,IMM (-24)
-	moveml	d2-d7,sp@
-#endif
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+#ifndef __FASTCALL__
 	movel	a6@(8),d0	| get first operand
 	movel	a6@(12),d1	| get second operand
-	movel	d0,a0		| get d0's sign bit '
+#endif
+	movel	d0,a2		| store first operand
+	movel	d1,a3		| store second operand
+	movel	d0,a0		| get d0's sign bit
 	addl	d0,d0		| check and clear sign bit of a
 	beq	Laddsf$b	| if zero return second operand
-	movel	d1,a1		| save b's sign bit '
+	movel	d1,a1		| save b's sign bit
 	addl	d1,d1		| get rid of sign bit
 	beq	Laddsf$a	| if zero return first operand
 
@@ -2708,9 +2589,9 @@ SYM (__addsf3):
 	swap	d6		| put exponent into first word
 	orl	d5,d0		| and put hidden bit back
 Laddsf$1:
-| Now we have a's exponent in d6 (second byte) and the mantissa in d0. '
+| Now we have a's exponent in d6 (second byte) and the mantissa in d0.
 	movel	d1,d7		| get exponent in d7
-	andl	d4,d7		| 
+	andl	d4,d7		|
 	beq	Laddsf$b$den	| branch if b is denormalized
 	cmpl	d4,d7		| check for INFINITY or NaN
 	beq	Laddsf$nf
@@ -2719,9 +2600,9 @@ Laddsf$1:
 	andl	d4,d1		| get fraction in d1
 	orl	d5,d1		| and put hidden bit back
 Laddsf$2:
-| Now we have b's exponent in d7 (second byte) and the mantissa in d1. '
+| Now we have b's exponent in d7 (second byte) and the mantissa in d1.
 
-| Note that the hidden bit corresponds to bit #FLT_MANT_DIG-1, and we 
+| Note that the hidden bit corresponds to bit #FLT_MANT_DIG-1, and we
 | shifted right once, so bit #FLT_MANT_DIG is set (so we have one extra
 | bit).
 
@@ -2732,14 +2613,14 @@ Laddsf$2:
 
 | Here we shift the numbers in registers d0 and d1 so the exponents are the
 | same, and put the largest exponent in d6. Note that we are using two
-| registers for each number (see the discussion by D. Knuth in "Seminumerical 
+| registers for each number (see the discussion by D. Knuth in "Seminumerical
 | Algorithms").
 #ifndef __mcoldfire__
 	cmpw	d6,d7		| compare exponents
 #else
 	cmpl	d6,d7		| compare exponents
 #endif
-	beq	Laddsf$3	| if equal don't shift '
+	beq	Laddsf$3	| if equal don't shift
 	bhi	5f		| branch if second exponent largest
 1:
 	subl	d6,d7		| keep the largest exponent
@@ -2749,11 +2630,11 @@ Laddsf$2:
 #else
 	lsrl	IMM (8),d7	| put difference in lower byte
 #endif
-| if difference is too large we don't shift (actually, we can just exit) '
+| if difference is too large we don't shift (actually, we can just exit)
 #ifndef __mcoldfire__
-	cmpw	IMM (FLT_MANT_DIG+2),d7		
+	cmpw	IMM (FLT_MANT_DIG+2),d7
 #else
-	cmpl	IMM (FLT_MANT_DIG+2),d7		
+	cmpl	IMM (FLT_MANT_DIG+2),d7
 #endif
 	bge	Laddsf$b$small
 #ifndef __mcoldfire__
@@ -2810,11 +2691,11 @@ Laddsf$2:
 #else
 	lsrl	IMM (8),d7	| put difference in lower byte
 #endif
-| if difference is too large we don't shift (and exit!) '
+| if difference is too large we don't shift (and exit!)
 #ifndef __mcoldfire__
-	cmpw	IMM (FLT_MANT_DIG+2),d7		
+	cmpw	IMM (FLT_MANT_DIG+2),d7
 #else
-	cmpl	IMM (FLT_MANT_DIG+2),d7		
+	cmpl	IMM (FLT_MANT_DIG+2),d7
 #endif
 	bge	Laddsf$a$small
 #ifndef __mcoldfire__
@@ -2874,7 +2755,7 @@ Laddsf$3:
 	movel	d4,a1
 #endif
 	eorl	d6,d7		| combine sign bits
-	bmi	Lsubsf$0	| if negative a and b have opposite 
+	bmi	Lsubsf$0	| if negative a and b have opposite
 				| sign so we actually subtract the
 				| numbers
 
@@ -2891,7 +2772,7 @@ Laddsf$3:
 | Here we do the addition.
 	addl	d3,d1
 	addxl	d2,d0
-| Note: now we have d2, d3, d4 and d5 to play with! 
+| Note: now we have d2, d3, d4 and d5 to play with!
 
 | Put the exponent, in the first byte, in d2, to use the "standard" rounding
 | routines:
@@ -2904,9 +2785,9 @@ Laddsf$3:
 
 | Before rounding normalize so bit #FLT_MANT_DIG is set (we will consider
 | the case of denormalized numbers in the rounding routine itself).
-| As in the addition (not in the subtraction!) we could have set 
+| As in the addition (not in the subtraction!) we could have set
 | one more bit we check this:
-	btst	IMM (FLT_MANT_DIG+1),d0	
+	btst	IMM (FLT_MANT_DIG+1),d0
 	beq	1f
 #ifndef __mcoldfire__
 	lsrl	IMM (1),d0
@@ -2920,12 +2801,12 @@ Laddsf$3:
 #endif
 	addl	IMM (1),d2
 1:
-	lea	pc@(Laddsf$4),a0 | to return from rounding routine
-	PICLEA	SYM (_fpCCR),a1	| check the rounding mode
+	PICLEA	SYM (_fpCCR),a0	| check the rounding mode
 #ifdef __mcoldfire__
 	clrl	d6
 #endif
-	movew	a1@(6),d6	| rounding mode in d6
+	movew	a0@(6),d6	| ROUND rounding mode in d6
+	lea	pc@(Laddsf$4),a0 | to return from rounding routine
 	beq	Lround$to$nearest
 #ifndef __mcoldfire__
 	cmpw	IMM (ROUND_TO_PLUS),d6
@@ -2938,11 +2819,11 @@ Laddsf$3:
 Laddsf$4:
 | Put back the exponent, but check for overflow.
 #ifndef __mcoldfire__
-	cmpw	IMM (0xff),d2
+	cmpw	IMM (F_MAX_EXP),d2
 #else
-	cmpl	IMM (0xff),d2
+	cmpl	IMM (F_MAX_EXP),d2
 #endif
-	bge	1f
+	bhi	1f
 	bclr	IMM (FLT_MANT_DIG-1),d0
 #ifndef __mcoldfire__
 	lslw	IMM (7),d2
@@ -2985,12 +2866,12 @@ Lsubsf$0:
 | Note that we do not have to normalize, since in the subtraction bit
 | #FLT_MANT_DIG+1 is never set, and denormalized numbers are handled by
 | the rounding routines themselves.
-	lea	pc@(Lsubsf$1),a0 | to return from rounding routine
-	PICLEA	SYM (_fpCCR),a1	| check the rounding mode
+	PICLEA	SYM (_fpCCR),a0	| check the rounding mode
 #ifdef __mcoldfire__
 	clrl	d6
 #endif
-	movew	a1@(6),d6	| rounding mode in d6
+	movew	a0@(6),d6	| rounding mode in d6
+	lea	pc@(Lsubsf$1),a0 | to return from rounding routine
 	beq	Lround$to$nearest
 #ifndef __mcoldfire__
 	cmpw	IMM (ROUND_TO_PLUS),d6
@@ -3001,7 +2882,7 @@ Lsubsf$0:
 	blt	Lround$to$zero
 	bra	Lround$to$plus
 Lsubsf$1:
-| Put back the exponent (we can't have overflow!). '
+| Put back the exponent (we can't have overflow!).
 	bclr	IMM (FLT_MANT_DIG-1),d0
 #ifndef __mcoldfire__
 	lslw	IMM (7),d2
@@ -3012,36 +2893,28 @@ Lsubsf$1:
 	orl	d2,d0
 	bra	Laddsf$ret
 
-| If one of the numbers was too small (difference of exponents >= 
-| FLT_MANT_DIG+2) we return the other (and now we don't have to '
+| If one of the numbers was too small (difference of exponents >=
+| FLT_MANT_DIG+2) we return the other (and now we don't have to
 | check for finiteness or zero).
 Laddsf$a$small:
-	movel	a6@(12),d0
+	movel	a3,d0
 	PICLEA	SYM (_fpCCR),a0
-	movew	IMM (0),a0@
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7	| restore data registers
-#else
-	moveml	sp@,d2-d7
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
-	unlk	a6		| and return
-	rts
+	unlk	a6
+	rts		| and return
 
 Laddsf$b$small:
-	movel	a6@(8),d0
+	movel	a2,d0
 	PICLEA	SYM (_fpCCR),a0
-	movew	IMM (0),a0@
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7	| restore data registers
-#else
-	moveml	sp@,d2-d7
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
-	unlk	a6		| and return
-	rts
+	unlk	a6
+	rts		| and return
 
 | If the numbers are denormalized remember to put exponent equal to 1.
 
@@ -3057,12 +2930,12 @@ Laddsf$b$den:
 				| (this was not executed after the jump)
 	bra	Laddsf$2
 
-| The rest is mainly code for the different results which can be 
+| The rest is mainly code for the different results which can be
 | returned (checking always for +/-INFINITY and NaN).
 
 Laddsf$b:
 | Return b (if a is zero).
-	movel	a6@(12),d0
+	movel	a3,d0
 	cmpl	IMM (0x80000000),d0	| Check if b is -0
 	bne	1f
 	movel	a0,d7
@@ -3071,7 +2944,7 @@ Laddsf$b:
 	bra	Laddsf$ret
 Laddsf$a:
 | Return a (if b is zero).
-	movel	a6@(8),d0
+	movel	a2,d0
 1:
 	moveq	IMM (ADD),d5
 | We have to check for NaN and +/-infty.
@@ -3080,7 +2953,7 @@ Laddsf$a:
 	bclr	IMM (31),d0		| clear sign
 	cmpl	IMM (INFINITY),d0	| check for infty or NaN
 	bge	2f
-	movel	d0,d0		| check for zero (we do this because we don't '
+	movel	d0,d0		| check for zero (we do this because we don't
 	bne	Laddsf$ret	| want to return -0 by mistake
 	bclr	IMM (31),d7	| if zero be sure to clear sign
 	bra	Laddsf$ret	| if everything OK just return
@@ -3094,27 +2967,23 @@ Laddsf$ret:
 | Normal exit (a and b nonzero, result is not NaN nor +/-infty).
 | We have to clear the exception flags (just the exception type).
 	PICLEA	SYM (_fpCCR),a0
-	movew	IMM (0),a0@
+	clrw	a0@
 	orl	d7,d0		| put sign bit
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7	| restore data registers
-#else
-	moveml	sp@,d2-d7
+	moveml	sp@,d2-d7/a2-a5	| restore data registers
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
-	unlk	a6		| and return
-	rts
+	unlk	a6
+	rts		| and return
 
 Laddsf$ret$den:
-| Return a denormalized number (for addition we don't signal underflow) '
+| Return a denormalized number (for addition we don't signal underflow)
 	lsrl	IMM (1),d0	| remember to shift right back once
 	bra	Laddsf$ret	| and return
 
-| Note: when adding two floats of the same sign if either one is 
-| NaN we return NaN without regard to whether the other is finite or 
-| not. When subtracting them (i.e., when adding two numbers of 
-| opposite signs) things are more complicated: if both are INFINITY 
+| Note: when adding two floats of the same sign if either one is
+| NaN we return NaN without regard to whether the other is finite or
+| not. When subtracting them (i.e., when adding two numbers of
+| opposite signs) things are more complicated: if both are INFINITY
 | we return NaN, if only one is INFINITY and the other is NaN we return
 | NaN, but if it is finite we return INFINITY with the corresponding sign.
 
@@ -3122,21 +2991,21 @@ Laddsf$nf:
 	moveq	IMM (ADD),d5
 | This could be faster but it is not worth the effort, since it is not
 | executed very often. We sacrifice speed for clarity here.
-	movel	a6@(8),d0	| get the numbers back (remember that we
-	movel	a6@(12),d1	| did some processing already)
+	movel	a2,d0	| get the numbers back (remember that we
+	movel	a3,d1	| did some processing already)
 	movel	IMM (INFINITY),d4 | useful constant (INFINITY)
 	movel	d0,d2		| save sign bits
 	movel	d0,d7		| into d7 as well as we may need the sign
-				| bit before jumping to LfSinfty
+				| bit before jumping to Lf$infty
 	movel	d1,d3
 	bclr	IMM (31),d0	| clear sign bits
 	bclr	IMM (31),d1
 | We know that one of them is either NaN of +/-INFINITY
 | Check for NaN (if either one is NaN return NaN)
 	cmpl	d4,d0		| check first a (d0)
-	bhi	Lf$inop		
+	bhi	Lf$inop
 	cmpl	d4,d1		| check now b (d1)
-	bhi	Lf$inop		
+	bhi	Lf$inop
 | Now comes the check for +/-INFINITY. We know that both are (maybe not
 | finite) numbers, but we have to check if both are infinite whether we
 | are adding or subtracting them.
@@ -3151,7 +3020,7 @@ Laddsf$nf:
 	cmpl	d1,d0		| are both infinite?
 	beq	Lf$inop		| if so return NaN
 
-	andl	IMM (0x80000000),d7 | get a's sign bit '
+	andl	IMM (0x80000000),d7 | get a's sign bit
 	cmpl	d4,d0		| test now for infinity
 	beq	Lf$infty	| if a is INFINITY return with this sign
 	bchg	IMM (31),d7	| else we know b is INFINITY and has
@@ -3164,15 +3033,14 @@ Laddsf$nf:
 | float __mulsf3(float, float);
 	FUNC(__mulsf3)
 SYM (__mulsf3):
-#ifndef __mcoldfire__
-	link	a6,IMM (0)
-	moveml	d2-d7,sp@-
-#else
-	link	a6,IMM (-24)
-	moveml	d2-d7,sp@
-#endif
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+#ifndef __FASTCALL__
 	movel	a6@(8),d0	| get a into d0
 	movel	a6@(12),d1	| and b into d1
+#endif
+	movel	d0,a2		| store a into a0
+	movel	d1,a3		| store b into a1
 	movel	d0,d7		| d7 will hold the sign of the product
 	eorl	d1,d7		|
 	andl	IMM (0x80000000),d7
@@ -3180,10 +3048,10 @@ SYM (__mulsf3):
 	movel	d6,d5			| another (mask for fraction)
 	notl	d5			|
 	movel	IMM (0x00800000),d4	| this is to put hidden bit back
-	bclr	IMM (31),d0		| get rid of a's sign bit '
+	bclr	IMM (31),d0		| get rid of a's sign bit
 	movel	d0,d2			|
 	beq	Lmulsf$a$0		| branch if a is zero
-	bclr	IMM (31),d1		| get rid of b's sign bit '
+	bclr	IMM (31),d1		| get rid of b's sign bit
 	movel	d1,d3		|
 	beq	Lmulsf$b$0	| branch if b is zero
 	cmpl	d6,d0		| is a big?
@@ -3200,9 +3068,9 @@ SYM (__mulsf3):
 	orl	d4,d0		| and put hidden bit back
 	swap	d2		| I like exponents in the first byte
 #ifndef __mcoldfire__
-	lsrw	IMM (7),d2	| 
+	lsrw	IMM (7),d2	|
 #else
-	lsrl	IMM (7),d2	| 
+	lsrl	IMM (7),d2	|
 #endif
 Lmulsf$1:			| number
 	andl	d6,d3		|
@@ -3225,10 +3093,10 @@ Lmulsf$2:			|
 #endif
 
 | We are now ready to do the multiplication. The situation is as follows:
-| both a and b have bit FLT_MANT_DIG-1 set (even if they were 
-| denormalized to start with!), which means that in the product 
-| bit 2*(FLT_MANT_DIG-1) (that is, bit 2*FLT_MANT_DIG-2-32 of the 
-| high long) is set. 
+| both a and b have bit FLT_MANT_DIG-1 set (even if they were
+| denormalized to start with!), which means that in the product
+| bit 2*(FLT_MANT_DIG-1) (that is, bit 2*FLT_MANT_DIG-2-32 of the
+| high long) is set.
 
 | To do the multiplication let us move the number a little bit around ...
 	movel	d1,d6		| second operand in d6
@@ -3238,11 +3106,11 @@ Lmulsf$2:			|
 	movel	d4,d0
 
 | now bit FLT_MANT_DIG-1 becomes bit 31:
-	lsll	IMM (31-FLT_MANT_DIG+1),d6		
+	lsll	IMM (31-FLT_MANT_DIG+1),d6
 
 | Start the loop (we loop #FLT_MANT_DIG times):
-	moveq	IMM (FLT_MANT_DIG-1),d3	
-1:	addl	d1,d1		| shift sum 
+	moveq	IMM (FLT_MANT_DIG-1),d3
+1:	addl	d1,d1		| shift sum
 	addxl	d0,d0
 	lsll	IMM (1),d6	| get bit bn
 	bcc	2f		| if not set skip sum
@@ -3257,7 +3125,7 @@ Lmulsf$2:			|
 #endif
 
 | Now we have the product in d0-d1, with bit (FLT_MANT_DIG - 1) + FLT_MANT_DIG
-| (mod 32) of d0 set. The first thing to do now is to normalize it so bit 
+| (mod 32) of d0 set. The first thing to do now is to normalize it so bit
 | FLT_MANT_DIG is set (to do the rounding).
 #ifndef __mcoldfire__
 	rorl	IMM (6),d1
@@ -3285,7 +3153,7 @@ Lmulsf$2:			|
 #endif
 
 	moveq	IMM (MULTIPLY),d5
-	
+
 	btst	IMM (FLT_MANT_DIG+1),d0
 	beq	Lround$exit
 #ifndef __mcoldfire__
@@ -3318,31 +3186,27 @@ Lmulsf$inf:
 	bhi	Lf$inop		| if so return NaN
 	bra	Lf$overflow	| else return +/-INFINITY
 
-| If either number is zero return zero, unless the other is +/-INFINITY, 
+| If either number is zero return zero, unless the other is +/-INFINITY,
 | or NaN, in which case we return NaN.
 Lmulsf$b$0:
 | Here d1 (==b) is zero.
-	movel	a6@(8),d1	| get a again to check for non-finiteness
+	movel	a2,d1		| get a again to check for non-finiteness
 	bra	1f
 Lmulsf$a$0:
-	movel	a6@(12),d1	| get b again to check for non-finiteness
-1:	bclr	IMM (31),d1	| clear sign bit 
+	movel	a3,d1	| get b again to check for non-finiteness
+1:	bclr	IMM (31),d1	| clear sign bit
 	cmpl	IMM (INFINITY),d1 | and check for a large exponent
 	bge	Lf$inop		| if b is +/-INFINITY or NaN return NaN
 	movel	d7,d0		| else return signed zero
 	PICLEA	SYM (_fpCCR),a0	|
-	movew	IMM (0),a0@	| 
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7	| 
-#else
-	moveml	sp@,d2-d7
+	clrw	a0@	|
+	moveml	sp@,d2-d7/a2-a5
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
-	unlk	a6		| 
-	rts			| 
+	unlk	a6		|
+	rts			|
 
-| If a number is denormalized we put an exponent of 1 but do not put the 
+| If a number is denormalized we put an exponent of 1 but do not put the
 | hidden bit back into the fraction; instead we shift left until bit 23
 | (the hidden bit) is set, adjusting the exponent accordingly. We do this
 | to ensure that the product of the fractions is close to 1.
@@ -3379,32 +3243,29 @@ Lmulsf$b$den:
 | float __divsf3(float, float);
 	FUNC(__divsf3)
 SYM (__divsf3):
-#ifndef __mcoldfire__
-	link	a6,IMM (0)
-	moveml	d2-d7,sp@-
-#else
-	link	a6,IMM (-24)
-	moveml	d2-d7,sp@
-#endif
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+#ifndef __FASTCALL
 	movel	a6@(8),d0		| get a into d0
 	movel	a6@(12),d1		| and b into d1
+#endif
 	movel	d0,d7			| d7 will hold the sign of the result
 	eorl	d1,d7			|
-	andl	IMM (0x80000000),d7	| 
+	andl	IMM (0x80000000),d7	|
 	movel	IMM (INFINITY),d6	| useful constant (+INFINITY)
 	movel	d6,d5			| another (mask for fraction)
 	notl	d5			|
 	movel	IMM (0x00800000),d4	| this is to put hidden bit back
-	bclr	IMM (31),d0		| get rid of a's sign bit '
+	bclr	IMM (31),d0		| get rid of a's sign bit
 	movel	d0,d2			|
 	beq	Ldivsf$a$0		| branch if a is zero
-	bclr	IMM (31),d1		| get rid of b's sign bit '
+	bclr	IMM (31),d1		| get rid of b's sign bit
 	movel	d1,d3			|
 	beq	Ldivsf$b$0		| branch if b is zero
 	cmpl	d6,d0			| is a big?
 	bhi	Ldivsf$inop		| if a is NaN return NaN
 	beq	Ldivsf$inf		| if a is INFINITY we have to check b
-	cmpl	d6,d1			| now compare b with INFINITY 
+	cmpl	d6,d1			| now compare b with INFINITY
 	bhi	Ldivsf$inop		| if b is NaN return NaN
 	beq	Ldivsf$underflow
 | Here we have both numbers finite and nonzero (and with no sign bit).
@@ -3417,11 +3278,11 @@ SYM (__divsf3):
 	orl	d4,d0		| and put hidden bit back
 	swap	d2		| I like exponents in the first byte
 #ifndef __mcoldfire__
-	lsrw	IMM (7),d2	| 
+	lsrw	IMM (7),d2	|
 #else
-	lsrl	IMM (7),d2	| 
+	lsrl	IMM (7),d2	|
 #endif
-Ldivsf$1:			| 
+Ldivsf$1:			|
 	andl	d6,d3		|
 	beq	Ldivsf$b$den	|
 	andl	d5,d1		|
@@ -3440,7 +3301,7 @@ Ldivsf$2:			|
 	subl	d3,d2		| subtract exponents
  	addl	IMM (F_BIAS),d2	| and add bias
 #endif
- 
+
 | We are now ready to do the division. We have prepared things in such a way
 | that the ratio of the fractions will be less than 2 but greater than 1/2.
 | At this point the registers in use are:
@@ -3450,7 +3311,7 @@ Ldivsf$2:			|
 | d7	holds the sign of the ratio
 | d4, d5, d6 hold some constants
 	movel	d7,a0		| d6-d7 will hold the ratio of the fractions
-	movel	IMM (0),d6	| 
+	movel	IMM (0),d6	|
 	movel	d6,d7
 
 	moveq	IMM (FLT_MANT_DIG+1),d3
@@ -3493,10 +3354,10 @@ Ldivsf$2:			|
 	movel	d6,d0		| put the ratio in d0-d1
 	movel	a0,d7		| get sign back
 
-| Because of the normalization we did before we are guaranteed that 
+| Because of the normalization we did before we are guaranteed that
 | d0 is smaller than 2^26 but larger than 2^24. Thus bit 26 is not set,
 | bit 25 could be set, and if it is not set then bit 24 is necessarily set.
-	btst	IMM (FLT_MANT_DIG+1),d0		
+	btst	IMM (FLT_MANT_DIG+1),d0
 	beq	1f              | if it is not set, then bit 24 is set
 	lsrl	IMM (1),d0	|
 #ifndef __mcoldfire__
@@ -3529,24 +3390,20 @@ Ldivsf$a$0:
 	andl	IMM (0x7fffffff),d1	| clear sign bit and test b
 	beq	Lf$inop			| if b is also zero return NaN
 	cmpl	IMM (INFINITY),d1	| check for NaN
-	bhi	Lf$inop			| 
+	bhi	Lf$inop			|
 	movel	d7,d0			| else return signed zero
 	PICLEA	SYM (_fpCCR),a0		|
-	movew	IMM (0),a0@		|
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7		| 
-#else
-	moveml	sp@,d2-d7		| 
+	clrw	a0@		|
+	moveml	sp@,d2-d7/a2-a5		|
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
-	unlk	a6			| 
-	rts				| 
-	
+	unlk	a6			|
+	rts				|
+
 Ldivsf$b$0:
 	moveq	IMM (DIVIDE),d5
 | If we got here a is not zero. Check if a is NaN; in that case return NaN,
-| else return +/-INFINITY. Remember that a is in d0 with the sign bit 
+| else return +/-INFINITY. Remember that a is in d0 with the sign bit
 | cleared already.
 	cmpl	IMM (INFINITY),d0	| compare d0 with INFINITY
 	bhi	Lf$inop			| if larger it is NaN
@@ -3555,11 +3412,11 @@ Ldivsf$b$0:
 Ldivsf$inf:
 	moveq	IMM (DIVIDE),d5
 | If a is INFINITY we have to check b
-	cmpl	IMM (INFINITY),d1	| compare b with INFINITY 
+	cmpl	IMM (INFINITY),d1	| compare b with INFINITY
 	bge	Lf$inop			| if b is NaN or INFINITY return NaN
 	bra	Lf$overflow		| else return overflow
 
-| If a number is denormalized we put an exponent of 1 but do not put the 
+| If a number is denormalized we put an exponent of 1 but do not put the
 | bit back into the fraction.
 Ldivsf$a$den:
 	movel	IMM (1),d2
@@ -3588,30 +3445,30 @@ Ldivsf$b$den:
 	bra	1b
 
 Lround$exit:
-| This is a common exit point for __mulsf3 and __divsf3. 
+| This is a common exit point for __mulsf3 and __divsf3.
 
 | First check for underlow in the exponent:
 #ifndef __mcoldfire__
-	cmpw	IMM (-FLT_MANT_DIG-1),d2		
+	cmpw	IMM (-FLT_MANT_DIG-1),d2
 #else
-	cmpl	IMM (-FLT_MANT_DIG-1),d2		
+	cmpl	IMM (-FLT_MANT_DIG-1),d2
 #endif
-	blt	Lf$underflow	
-| It could happen that the exponent is less than 1, in which case the 
-| number is denormalized. In this case we shift right and adjust the 
-| exponent until it becomes 1 or the fraction is zero (in the latter case 
+	blt	Lf$underflow
+| It could happen that the exponent is less than 1, in which case the
+| number is denormalized. In this case we shift right and adjust the
+| exponent until it becomes 1 or the fraction is zero (in the latter case
 | we signal underflow and return zero).
 	movel	IMM (0),d6	| d6 is used temporarily
 #ifndef __mcoldfire__
-	cmpw	IMM (1),d2	| if the exponent is less than 1 we 
+	cmpw	IMM (1),d2	| if the exponent is less than 1 we
 #else
-	cmpl	IMM (1),d2	| if the exponent is less than 1 we 
+	cmpl	IMM (1),d2	| if the exponent is less than 1 we
 #endif
 	bge	2f		| have to shift right (denormalize)
 1:
 #ifndef __mcoldfire__
 	addw	IMM (1),d2	| adjust the exponent
-	lsrl	IMM (1),d0	| shift right once 
+	lsrl	IMM (1),d0	| shift right once
 	roxrl	IMM (1),d1	|
 	roxrl	IMM (1),d6	| d6 collect bits we would lose otherwise
 	cmpw	IMM (1),d2	| is the exponent 1 already?
@@ -3630,16 +3487,16 @@ Lround$exit:
 #endif
 	beq	2f		| if not loop back
 	bra	1b              |
-	bra	Lf$underflow	| safety check, shouldn't execute '
-2:	orl	d6,d1		| this is a trick so we don't lose  '
+	bra	Lf$underflow	| safety check, shouldn't execute
+2:	orl	d6,d1		| this is a trick so we don't lose
 				| the extra bits which were flushed right
 | Now call the rounding routine (which takes care of denormalized numbers):
-	lea	pc@(Lround$0),a0 | to return from rounding routine
-	PICLEA	SYM (_fpCCR),a1	| check the rounding mode
+	PICLEA	SYM (_fpCCR),a0	| check the rounding mode
 #ifdef __mcoldfire__
 	clrl	d6
 #endif
-	movew	a1@(6),d6	| rounding mode in d6
+	movew	a0@(6),d6	| rounding mode in d6
+	lea	pc@(Lround$0),a0 | to return from rounding routine
 	beq	Lround$to$nearest
 #ifndef __mcoldfire__
 	cmpw	IMM (ROUND_TO_PLUS),d6
@@ -3653,14 +3510,14 @@ Lround$0:
 | Here we have a correctly rounded result (either normalized or denormalized).
 
 | Here we should have either a normalized number or a denormalized one, and
-| the exponent is necessarily larger or equal to 1 (so we don't have to  '
-| check again for underflow!). We have to check for overflow or for a 
+| the exponent is necessarily larger or equal to 1 (so we don't have to
+| check again for underflow!). We have to check for overflow or for a
 | denormalized number (which also signals underflow).
 | Check for overflow (i.e., exponent >= 255).
 #ifndef __mcoldfire__
-	cmpw	IMM (0x00ff),d2
+	cmpw	IMM (F_MAX_EXP),d2
 #else
-	cmpl	IMM (0x00ff),d2
+	cmpl	IMM (F_MAX_EXP),d2
 #endif
 	bge	Lf$overflow
 | Now check for a denormalized number (exponent==0).
@@ -3676,7 +3533,7 @@ Lround$0:
 	bclr	IMM (FLT_MANT_DIG-1),d0
 	swap	d0		| and put back exponent
 #ifndef __mcoldfire__
-	orw	d2,d0		| 
+	orw	d2,d0		|
 #else
 	orl	d2,d0
 #endif
@@ -3684,14 +3541,10 @@ Lround$0:
 	orl	d7,d0		| and sign also
 
 	PICLEA	SYM (_fpCCR),a0
-	movew	IMM (0),a0@
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7
-#else
-	moveml	sp@,d2-d7
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6
 	rts
 
@@ -3699,21 +3552,18 @@ Lround$0:
 |                             __negsf2
 |=============================================================================
 
-| This is trivial and could be shorter if we didn't bother checking for NaN '
+| This is trivial and could be shorter if we didn't bother checking for NaN
 | and +/-INFINITY.
 
 | float __negsf2(float);
 	FUNC(__negsf2)
 SYM (__negsf2):
-#ifndef __mcoldfire__
-	link	a6,IMM (0)
-	moveml	d2-d7,sp@-
-#else
-	link	a6,IMM (-24)
-	moveml	d2-d7,sp@
-#endif
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
 	moveq	IMM (NEGATE),d5
+#ifndef __FASTCALL__
 	movel	a6@(8),d0	| get number to negate in d0
+#endif
 	bchg	IMM (31),d0	| negate
 	movel	d0,d1		| make a positive copy
 	bclr	IMM (31),d1	|
@@ -3724,16 +3574,12 @@ SYM (__negsf2):
 	bhi	Lf$inop		| if larger (fraction not zero) is NaN
 	movel	d0,d7		| else get sign and return INFINITY
 	andl	IMM (0x80000000),d7
-	bra	Lf$infty		
+	bra	Lf$infty
 1:	PICLEA	SYM (_fpCCR),a0
-	movew	IMM (0),a0@
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7
-#else
-	moveml	sp@,d2-d7
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6
 	rts
 2:	bclr	IMM (31),d0
@@ -3743,22 +3589,45 @@ SYM (__negsf2):
 |                             __cmpsf2
 |=============================================================================
 
-GREATER =  1
-LESS    = -1
-EQUAL   =  0
+| The comments above about __eqdf2, et. al., also apply to __eqsf2,
+| et. al., except that the latter call __cmpsf2 rather than __cmpdf2.
+
+	FUNC(__gtsf2)
+	.globl	SYM (__gtsf2)
+SYM (__gtsf2):
+	FUNC(__gesf2)
+	.globl	SYM (__gesf2)
+SYM (__gesf2):
+	lea	LESS,a0
+	jbra	SYM (__cmpsf2_internal)
+
+SYM (__cmpsf2):
+	FUNC(__eqsf2)
+	.globl	SYM (__eqsf2)
+SYM (__eqsf2):
+	FUNC(__nesf2)
+	.globl	SYM (__nesf2)
+SYM (__nesf2):
+	FUNC(__ltsf2)
+	.globl	SYM (__ltsf2)
+SYM (__ltsf2):
+	FUNC(__lesf2)
+	.globl	SYM (__lesf2)
+SYM (__lesf2):
+
+| int __cmpsf2(float, float);
+	FUNC(__cmpsf2)
+	lea	GREATER,a0
 
 | int __cmpsf2_internal(float, float, int);
 SYM (__cmpsf2_internal):
-#ifndef __mcoldfire__
-	link	a6,IMM (0)
-	moveml	d2-d7,sp@- 	| save registers
-#else
-	link	a6,IMM (-24)
-	moveml	d2-d7,sp@
-#endif
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
 	moveq	IMM (COMPARE),d5
+#ifndef __FASTCALL__
 	movel	a6@(8),d0	| get first operand
 	movel	a6@(12),d1	| get second operand
+#endif
 | Check if either is NaN, and in that case return garbage and signal
 | INVALID_OPERATION. Check also if either is zero, and clear the signs
 | if necessary.
@@ -3766,13 +3635,13 @@ SYM (__cmpsf2_internal):
 	andl	IMM (0x7fffffff),d0
 	beq	Lcmpsf$a$0
 	cmpl	IMM (0x7f800000),d0
-	bhi	Lcmpf$inop
+	bhi	Lcmpsf$inop
 Lcmpsf$1:
 	movel	d1,d7
 	andl	IMM (0x7fffffff),d1
 	beq	Lcmpsf$b$0
 	cmpl	IMM (0x7f800000),d1
-	bhi	Lcmpf$inop
+	bhi	Lcmpsf$inop
 Lcmpsf$2:
 | Check the signs
 	eorl	d6,d7
@@ -3801,66 +3670,43 @@ Lcmpsf$2:
 	bne	Lcmpsf$a$gt$b	| |b| < |a|
 | If we got here a == b.
 	movel	IMM (EQUAL),d0
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7 	| put back the registers
-#else
-	moveml	sp@,d2-d7
-#endif
+	moveml	sp@,d2-d7/a2-a5 	| put back the registers
 	unlk	a6
 	rts
 Lcmpsf$a$gt$b:
 	movel	IMM (GREATER),d0
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7 	| put back the registers
-#else
-	moveml	sp@,d2-d7
+	moveml	sp@,d2-d7/a2-a5 	| put back the registers
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6
 	rts
 Lcmpsf$b$gt$a:
 	movel	IMM (LESS),d0
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7 	| put back the registers
-#else
-	moveml	sp@,d2-d7
+	moveml	sp@,d2-d7/a2-a5 	| put back the registers
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6
 	rts
 
-Lcmpsf$a$0:	
+Lcmpsf$a$0:
 	bclr	IMM (31),d6
 	bra	Lcmpsf$1
 Lcmpsf$b$0:
 	bclr	IMM (31),d7
 	bra	Lcmpsf$2
 
-Lcmpf$inop:
-	movl	a6@(16),d0
+Lcmpsf$inop:
+	movel	a0,d0
 	moveq	IMM (INEXACT_RESULT+INVALID_OPERATION),d7
 	moveq	IMM (SINGLE_FLOAT),d6
 	PICJUMP	$_exception_handler
 
-| int __cmpsf2(float, float);
-	FUNC(__cmpsf2)
-SYM (__cmpsf2):
-	link	a6,IMM (0)
-	pea	1
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL SYM (__cmpsf2_internal)
-	unlk	a6
-	rts
-
 |=============================================================================
 |                           rounding routines
 |=============================================================================
 
 | The rounding routines expect the number to be normalized in registers
-| d0-d1, with the exponent in register d2. They assume that the 
+| d0-d1, with the exponent in register d2. They assume that the
 | exponent is larger or equal to 1. They return a properly normalized number
 | if possible, and a denormalized number otherwise. The exponent is returned
 | in d2.
@@ -3873,8 +3719,8 @@ Lround$to$nearest:
 | Check for denormalized numbers:
 1:	btst	IMM (FLT_MANT_DIG),d0
 	bne	2f		| if set the number is normalized
-| Normalize shifting left until bit #FLT_MANT_DIG is set or the exponent 
-| is one (remember that a denormalized number corresponds to an 
+| Normalize shifting left until bit #FLT_MANT_DIG is set or the exponent
+| is one (remember that a denormalized number corresponds to an
 | exponent of -F_BIAS+1).
 #ifndef __mcoldfire__
 	cmpw	IMM (1),d2	| remember that the exponent is at least one
@@ -3893,24 +3739,24 @@ Lround$to$nearest:
 2:
 | Now round: we do it as follows: after the shifting we can write the
 | fraction part as f + delta, where 1 < f < 2^25, and 0 <= delta <= 2.
-| If delta < 1, do nothing. If delta > 1, add 1 to f. 
-| If delta == 1, we make sure the rounded number will be even (odd?) 
+| If delta < 1, do nothing. If delta > 1, add 1 to f.
+| If delta == 1, we make sure the rounded number will be even (odd?)
 | (after shifting).
 	btst	IMM (0),d0	| is delta < 1?
 	beq	2f		| if so, do not do anything
 	tstl	d1		| is delta == 1?
 	bne	1f		| if so round to even
-	movel	d0,d1		| 
+	movel	d0,d1		|
 	andl	IMM (2),d1	| bit 1 is the last significant bit
-	addl	d1,d0		| 
-	bra	2f		| 
-1:	movel	IMM (1),d1	| else add 1 
+	addl	d1,d0		|
+	bra	2f		|
+1:	movel	IMM (1),d1	| else add 1
 	addl	d1,d0		|
 | Shift right once (because we used bit #FLT_MANT_DIG!).
-2:	lsrl	IMM (1),d0		
+2:	lsrl	IMM (1),d0
 | Now check again bit #FLT_MANT_DIG (rounding could have produced a
 | 'fraction overflow' ...).
-	btst	IMM (FLT_MANT_DIG),d0	
+	btst	IMM (FLT_MANT_DIG),d0
 	beq	1f
 	lsrl	IMM (1),d0
 #ifndef __mcoldfire__
@@ -3919,7 +3765,7 @@ Lround$to$nearest:
 	addql	IMM (1),d2
 #endif
 1:
-| If bit #FLT_MANT_DIG-1 is clear we have a denormalized number, so we 
+| If bit #FLT_MANT_DIG-1 is clear we have a denormalized number, so we
 | have to put the exponent to zero and return a denormalized number.
 	btst	IMM (FLT_MANT_DIG-1),d0
 	beq	1f
@@ -3933,199 +3779,270 @@ Lround$to$minus:
 	jmp	a0@
 #endif /* L_float */
 
-| gcc expects the routines __eqdf2, __nedf2, __gtdf2, __gedf2,
-| __ledf2, __ltdf2 to all return the same value as a direct call to
-| __cmpdf2 would.  In this implementation, each of these routines
-| simply calls __cmpdf2.  It would be more efficient to give the
-| __cmpdf2 routine several names, but separating them out will make it
-| easier to write efficient versions of these routines someday.
-| If the operands recompare unordered unordered __gtdf2 and __gedf2 return -1.
-| The other routines return 1.
+/* We do not need these routines for coldfire, as it has no extended
+   float format. */
+#if !defined (__mcoldfire__)
 
-#ifdef  L_eqdf2
-	.text
-	FUNC(__eqdf2)
-	.globl	SYM (__eqdf2)
-SYM (__eqdf2):
-	link	a6,IMM (0)
-	pea	1
-	movl	a6@(20),sp@-
-	movl	a6@(16),sp@-
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpdf2_internal)
-	unlk	a6
-	rts
-#endif /* L_eqdf2 */
+#ifdef  L_long_double
 
-#ifdef  L_nedf2
-	.text
-	FUNC(__nedf2)
-	.globl	SYM (__nedf2)
-SYM (__nedf2):
-	link	a6,IMM (0)
-	pea	1
-	movl	a6@(20),sp@-
-	movl	a6@(16),sp@-
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpdf2_internal)
-	unlk	a6
-	rts
-#endif /* L_nedf2 */
+| A long double precision floating point number (long double) has the format:
+|
+| struct _long_double {
+|  unsigned int sign      : 1;  /* sign bit */
+|  unsigned int exponent  : 15; /* exponent, shifted by 16383 */
+|  unsigned int empty     : 16;
+|  unsigned int fraction  : 64; /* fraction */
+| } double;
+|
+| Thus sizeof(long double) = 12 (96 bits).
+|
+| All the routines are callable from C programs, and return the result
+| in the register pair d0-d1. They also preserve all registers except
+| d0-d1 and a0-a1.
 
-#ifdef  L_gtdf2
-	.text
-	FUNC(__gtdf2)
-	.globl	SYM (__gtdf2)
-SYM (__gtdf2):
-	link	a6,IMM (0)
-	pea	-1
-	movl	a6@(20),sp@-
-	movl	a6@(16),sp@-
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpdf2_internal)
-	unlk	a6
-	rts
-#endif /* L_gtdf2 */
+	.globl	SYM (_fpCCR)
+	.globl  $_exception_handler
 
-#ifdef  L_gedf2
-	.text
-	FUNC(__gedf2)
-	.globl	SYM (__gedf2)
-SYM (__gedf2):
-	link	a6,IMM (0)
-	pea	-1
-	movl	a6@(20),sp@-
-	movl	a6@(16),sp@-
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpdf2_internal)
-	unlk	a6
-	rts
-#endif /* L_gedf2 */
+QUIET_NaN      = 0xffffffff
+INFINITY       = 0x7fff0000
 
-#ifdef  L_ltdf2
-	.text
-	FUNC(__ltdf2)
-	.globl	SYM (__ltdf2)
-SYM (__ltdf2):
-	link	a6,IMM (0)
-	pea	1
-	movl	a6@(20),sp@-
-	movl	a6@(16),sp@-
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpdf2_internal)
-	unlk	a6
-	rts
-#endif /* L_ltdf2 */
+X_MAX_EXP      = 0x7fff
+X_BIAS         = 16383
+LDBL_MAX_EXP   = X_MAX_EXP - X_BIAS
+LDBL_MIN_EXP   = 1 - X_BIAS
+LDBL_MANT_DIG  = 64
 
-#ifdef  L_ledf2
-	.text
-	FUNC(__ledf2)
-	.globl	SYM (__ledf2)
-SYM (__ledf2):
-	link	a6,IMM (0)
-	pea	1
-	movl	a6@(20),sp@-
-	movl	a6@(16),sp@-
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpdf2_internal)
-	unlk	a6
-	rts
-#endif /* L_ledf2 */
+| Entry points:
 
-| The comments above about __eqdf2, et. al., also apply to __eqsf2,
-| et. al., except that the latter call __cmpsf2 rather than __cmpdf2.
+	.globl SYM (__negxf2)
+	.globl SYM (__cmpxf2)
+| __addxf3, __subxf3, __mulxf3, and __divxf3 are implemented elsewhere
 
-#ifdef  L_eqsf2
 	.text
-	FUNC(__eqsf2)
-	.globl	SYM (__eqsf2)
-SYM (__eqsf2):
-	link	a6,IMM (0)
-	pea	1
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpsf2_internal)
-	unlk	a6
-	rts
-#endif /* L_eqsf2 */
+	.even
 
-#ifdef  L_nesf2
-	.text
-	FUNC(__nesf2)
-	.globl	SYM (__nesf2)
-SYM (__nesf2):
-	link	a6,IMM (0)
-	pea	1
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpsf2_internal)
-	unlk	a6
-	rts
-#endif /* L_nesf2 */
+| These are common routines to return and signal exceptions.
 
-#ifdef  L_gtsf2
-	.text
-	FUNC(__gtsf2)
-	.globl	SYM (__gtsf2)
-SYM (__gtsf2):
-	link	a6,IMM (0)
-	pea	-1
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpsf2_internal)
-	unlk	a6
-	rts
-#endif /* L_gtsf2 */
+Lx$infty:
+Lx$overflow:
+| Return a properly signed INFINITY and set the exception flags
+	movel	IMM (INFINITY),d0
+	movel	IMM (0),d1
+	movel	IMM (0),d2
+	orl	d7,d0
+	movew	IMM (INEXACT_RESULT+OVERFLOW),d7
+	moveq	IMM (LONG_FLOAT),d6
+	PICJUMP	$_exception_handler
 
-#ifdef  L_gesf2
-	.text
-	FUNC(__gesf2)
-	.globl	SYM (__gesf2)
-SYM (__gesf2):
-	link	a6,IMM (0)
-	pea	-1
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpsf2_internal)
-	unlk	a6
-	rts
-#endif /* L_gesf2 */
+Lx$inop:
+| Return a quiet NaN and set the exception flags
+	movel	IMM (QUIET_NaN),d0
+	movel	d0,d1
+	movel	d0,d2
+	movew	IMM (INEXACT_RESULT+INVALID_OPERATION),d7
+	moveq	IMM (LONG_FLOAT),d6
+	PICJUMP	$_exception_handler
 
-#ifdef  L_ltsf2
-	.text
-	FUNC(__ltsf2)
-	.globl	SYM (__ltsf2)
-SYM (__ltsf2):
-	link	a6,IMM (0)
-	pea	1
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpsf2_internal)
+|=============================================================================
+|                              __negxf2
+|=============================================================================
+
+| long double __negxf2(long double, long double);
+	FUNC(__negxf2)
+SYM (__negxf2):
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+	moveq	IMM (NEGATE),d5
+	moveml	a6@(8),d0-d2	| get number to negate in d0-d2
+	bchg	IMM (31),d0	| negate
+	movel	d0,d6		| make a positive copy (for the tests)
+	andl	IMM(0x7fff0000),d6	|
+	movel	d6,d4		| check for zero
+	orl	d1,d4		|
+	orl	d2,d4		|
+	beq	2f		| if zero (either sign) return +zero
+	cmpl	IMM (0x7fff0000),d6 | compare to +INFINITY
+	blt	1f		| if finite, return
+	tstl	d1		| if fraction not zero is NaN
+	bne	Lx$inop		|
+	tstl	d2		| if fraction not zero is NaN
+	bne	Lx$inop		|
+	movel	d0,d7		| else get sign and return INFINITY
+	andl	IMM (0x80000000),d7
+	bra	Lx$infty
+1:	PICLEA	SYM (_fpCCR),a0
+	clrw	a0@
+	moveml	d0-d2,M68K_STRUCT_VALUE_REGNUM@
+	movel	M68K_STRUCT_VALUE_REGNUM,d0
+	moveml	sp@,d2-d7/a2-a5
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
 	unlk	a6
 	rts
-#endif /* L_ltsf2 */
+2:	bclr	IMM (31),d0
+	bra	1b
 
-#ifdef  L_lesf2
-	.text
-	FUNC(__lesf2)
-	.globl	SYM (__lesf2)
-SYM (__lesf2):
-	link	a6,IMM (0)
-	pea	1
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpsf2_internal)
+|=============================================================================
+|                              __cmpxf2
+|=============================================================================
+
+GREATER =  1
+LESS    = -1
+EQUAL   =  0
+
+| The comments above about __eqdf2, et. al., also apply to __eqxf2,
+| et. al., except that the latter call __cmpxf2 rather than __cmpdf2.
+
+	FUNC(__gtxf2)
+	.globl	SYM (__gtxf2)
+SYM (__gtxf2):
+	FUNC(__gexf2)
+	.globl	SYM (__gexf2)
+SYM (__gexf2):
+	lea LESS,a0
+	jbra SYM(__cmpxf2_internal)
+
+	FUNC(__eqxf2)
+	.globl	SYM (__eqxf2)
+SYM (__eqxf2):
+	FUNC(__nexf2)
+	.globl	SYM (__nexf2)
+SYM (__nexf2):
+	FUNC(__ltxf2)
+	.globl	SYM (__ltxf2)
+SYM (__ltxf2):
+	FUNC(__lexf2)
+	.globl	SYM (__lexf2)
+SYM (__lexf2):
+
+| int __cmpxf2(long double, long double);
+	FUNC(__cmpxf2)
+SYM (__cmpxf2):
+	lea	GREATER,a0
+
+| int __cmpxf2_internal(long double, long double, int);
+SYM (__cmpxf2_internal):
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+	movel	a6@(8),d0	| get first operand
+	movel	a6@(12),d1	|
+	movel	a6@(16),a2
+	movel	a6@(20),d2	| get second operand
+	movel	a6@(24),d3	|
+	movel	a6@(28),a3
+| First check if a and/or b are (+/-) zero and in that case clear
+| the sign bit.
+	movel	d0,d6		| copy signs into d6 (a) and d7(b)
+	andl	IMM (0x7fff0000),d0	| and clear signs in d0 and d2
+	movel	d2,d7		|
+	andl	IMM (0x7fff0000),d2
+	cmpl	IMM (0x7fff0000),d0 | check for a == NaN
+	beq	Lcmpxf$a$nf	| if equal can be INFINITY, so check d1
+	movel	a2,d4		| copy into d4 to test for zero
+	orl	d0,d4		|
+	orl	d1,d4		|
+	beq	Lcmpxf$a$0	|
+Lcmpxf$0:
+	cmpl	IMM (0x7fff0000),d2 | check for b == NaN
+	bhi	Lcmpxf$inop		| if d2 > 0x7ff00000, b is NaN
+	beq	Lcmpxf$b$nf	| if equal can be INFINITY, so check d3
+	movel	a3,d4		|
+	orl	d2,d4		|
+	orl	d3,d4		|
+	beq	Lcmpxf$b$0	|
+Lcmpxf$1:
+| Check the signs
+	eorl	d6,d7
+	bpl	1f
+| If the signs are not equal check if a >= 0
+	tstl	d6
+	bpl	Lcmpxf$a$gt$b	| if (a >= 0 && b < 0) => a > b
+	bmi	Lcmpxf$b$gt$a	| if (a < 0 && b >= 0) => a < b
+1:
+| If the signs are equal check for < 0
+	tstl	d6
+	bpl	1f
+| If both are negative exchange them
+#ifndef __mcoldfire__
+	exg	d0,d2
+	exg	d1,d3
+	exg	a2,a3
+#else
+	movel	d0,d7
+	movel	d2,d0
+	movel	d7,d2
+	movel	d1,d7
+	movel	d3,d1
+	movel	d7,d3
+	movel	a2,d7
+	movel	a3,a2
+	movel	d7,a3
+#endif
+1:
+| Now that they are positive we just compare them as longs (does this also
+| work for denormalized numbers?).
+	cmpl	d0,d2
+	bhi	Lcmpxf$b$gt$a	| |b| > |a|
+	bne	Lcmpxf$a$gt$b	| |b| < |a|
+| If we got here d0 == d2, so we compare d1 and d3.
+	cmpl	d1,d3
+	bhi	Lcmpxf$b$gt$a	| |b| > |a|
+	bne	Lcmpxf$a$gt$b	| |b| < |a|
+| If we got here d1 == d3, so we compare a2 and a3.
+	movel	a3,d3
+	cmpl	a2,d3
+	bhi	Lcmpxf$b$gt$a	| |b| > |a|
+	bne	Lcmpxf$a$gt$b	| |b| < |a|
+| If we got here a == b.
+	movel	IMM (EQUAL),d0
+	bra 1f
+Lcmpxf$a$gt$b:
+	movel	IMM (GREATER),d0
+	bra 1f
+Lcmpxf$b$gt$a:
+	movel	IMM (LESS),d0
+1:
+	moveml	sp@,d2-d7/a2-a5 	| put back the registers
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
 	unlk	a6
 	rts
-#endif /* L_lesf2 */
 
-#if defined (__ELF__) && defined (__linux__)
+Lcmpxf$a$0:
+	bclr	IMM (31),d6
+	bra	Lcmpxf$0
+Lcmpxf$b$0:
+	bclr	IMM (31),d7
+	bra	Lcmpxf$1
+
+Lcmpxf$a$nf:
+	tstl	d1
+	bne	Lcmpxf$inop
+	movel a2,d4
+	bne	Lcmpxf$inop
+	bra	Lcmpxf$0
+
+Lcmpxf$b$nf:
+	tstl	d3
+	bne	Lcmpxf$inop
+	movel a3,d4
+	bne	Lcmpxf$inop
+	bra	Lcmpxf$1
+
+Lcmpxf$inop:
+	movel	a0,d0
+	moveq	IMM (COMPARE),d5
+	moveq	IMM (INEXACT_RESULT+INVALID_OPERATION),d7
+	| this functions returns an int, not a long double
+	moveq	IMM (LONG_FLOAT+1),d6
+	PICJUMP	$_exception_handler
+
+#endif /* _long_double */
+
+#endif /* __mcoldfire__ */
+
+
+#if defined (__ELF__)
 	/* Make stack non-executable for ELF linux targets.  */
 	.section	.note.GNU-stack,"",@progbits
 #endif
diff --git a/libgcc/config/m68k/lb1sf68.pc.S b/libgcc/config/m68k/lb1sf68.pc.S
new file mode 100644
index 00000000000..e50c4f8e2d1
--- /dev/null
+++ b/libgcc/config/m68k/lb1sf68.pc.S
@@ -0,0 +1,4858 @@
+/* libgcc routines for 68000 w/o floating-point hardware.
+   Copyright (C) 1994-2023 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3, or (at your option) any
+later version.
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+/* Use this one for any 680x0; assumes no floating point hardware.
+   The trailing " '" appearing on some lines is for ANSI preprocessors.  Yuk.
+   Some of this code comes from MINIX, via the folks at ericsson.
+   D. V. Henkel-Wallace (gumby@cygnus.com) Fete Bastille, 1992
+*/
+
+/* These are predefined by new versions of GNU cpp.  */
+
+#ifndef __USER_LABEL_PREFIX__
+#define __USER_LABEL_PREFIX__ _
+#endif
+
+#ifndef __REGISTER_PREFIX__
+#define __REGISTER_PREFIX__
+#endif
+
+#ifndef __IMMEDIATE_PREFIX__
+#define __IMMEDIATE_PREFIX__ #
+#endif
+
+/* ANSI concatenation macros.  */
+
+#define CONCAT1(a, b) CONCAT2(a, b)
+#define CONCAT2(a, b) a ## b
+
+/* Use the right prefix for global labels.  */
+
+#define SYM(x) CONCAT1 (__USER_LABEL_PREFIX__, x)
+
+/* Note that X is a function.  */
+
+#ifdef __ELF__
+#define FUNC(x) .type SYM(x),function
+#else
+/* The .proc pseudo-op is accepted, but ignored, by GAS.  We could just
+   define this to the empty string for non-ELF systems, but defining it
+   to .proc means that the information is available to the assembler if
+   the need arises.  */
+#define FUNC(x) .proc
+#endif
+
+/* Use the right prefix for registers.  */
+
+#define REG(x) CONCAT1 (__REGISTER_PREFIX__, x)
+
+/* Use the right prefix for immediate values.  */
+
+#define IMM(x) CONCAT1 (__IMMEDIATE_PREFIX__, x)
+
+#define d0 REG (d0)
+#define d1 REG (d1)
+#define d2 REG (d2)
+#define d3 REG (d3)
+#define d4 REG (d4)
+#define d5 REG (d5)
+#define d6 REG (d6)
+#define d7 REG (d7)
+#define a0 REG (a0)
+#define a1 REG (a1)
+#define a2 REG (a2)
+#define a3 REG (a3)
+#define a4 REG (a4)
+#define a5 REG (a5)
+#define a6 REG (a6)
+#define fp REG (fp)
+#define sp REG (sp)
+#define pc REG (pc)
+
+/* Provide a few macros to allow for PIC code support.
+ * With PIC, data is stored A5 relative so we've got to take a bit of special
+ * care to ensure that all loads of global data is via A5.  PIC also requires
+ * jumps and subroutine calls to be PC relative rather than absolute.  We cheat
+ * a little on this and in the PIC case, we use short offset branches and
+ * hope that the final object code is within range (which it should be).
+ */
+#ifndef __PIC__
+
+	/* Non PIC (absolute/relocatable) versions */
+
+	.macro PICCALL addr
+	jbsr	\addr
+	.endm
+
+	.macro PICJUMP addr
+	jmp	\addr
+	.endm
+
+	.macro PICLEA sym, reg
+	lea	\sym, \reg
+	.endm
+
+	.macro PICPEA sym, areg
+	pea	\sym
+	.endm
+
+#else /* __PIC__ */
+
+# if defined (__uClinux__)
+
+	/* Versions for uClinux */
+
+#  if defined(__ID_SHARED_LIBRARY__)
+
+	/* -mid-shared-library versions  */
+
+	.macro PICLEA sym, reg
+	movel	a5@(_current_shared_library_a5_offset_), \reg
+	movel	\sym@GOT(\reg), \reg
+	.endm
+
+	.macro PICPEA sym, areg
+	movel	a5@(_current_shared_library_a5_offset_), \areg
+	movel	\sym@GOT(\areg), sp@-
+	.endm
+
+	.macro PICCALL addr
+	PICLEA	\addr,a0
+	jsr	a0@
+	.endm
+
+	.macro PICJUMP addr
+	PICLEA	\addr,a0
+	jmp	a0@
+	.endm
+
+#  else /* !__ID_SHARED_LIBRARY__ */
+
+	/* Versions for -msep-data */
+
+	.macro PICLEA sym, reg
+	movel	\sym@GOT(a5), \reg
+	.endm
+
+	.macro PICPEA sym, areg
+	movel	\sym@GOT(a5), sp@-
+	.endm
+
+	.macro PICCALL addr
+#if defined (__mcoldfire__) && !defined (__mcfisab__) && !defined (__mcfisac__)
+	lea	\addr-.-8,a0
+	jsr	pc@(a0)
+#else
+	jbsr	\addr
+#endif
+	.endm
+
+	.macro PICJUMP addr
+	/* ISA C has no bra.l instruction, and since this assembly file
+	   gets assembled into multiple object files, we avoid the
+	   bra instruction entirely.  */
+#if defined (__mcoldfire__) && !defined (__mcfisab__)
+	lea	\addr-.-8,a0
+	jmp	pc@(a0)
+#else
+	bra	\addr
+#endif
+	.endm
+
+#  endif
+
+# else /* !__uClinux__ */
+
+	/* Versions for Linux */
+
+	.macro PICLEA sym, reg
+	movel	#_GLOBAL_OFFSET_TABLE_@GOTPC, \reg
+	lea	(-6, pc, \reg), \reg
+	movel	\sym@GOT(\reg), \reg
+	.endm
+
+	.macro PICPEA sym, areg
+	movel	#_GLOBAL_OFFSET_TABLE_@GOTPC, \areg
+	lea	(-6, pc, \areg), \areg
+	movel	\sym@GOT(\areg), sp@-
+	.endm
+
+	.macro PICCALL addr
+#if defined (__mcoldfire__) && !defined (__mcfisab__) && !defined (__mcfisac__)
+	lea	\addr-.-8,a0
+	jsr	pc@(a0)
+#else
+	jbsr	\addr
+#endif
+	.endm
+
+	.macro PICJUMP addr
+	/* ISA C has no bra.l instruction, and since this assembly file
+	   gets assembled into multiple object files, we avoid the
+	   bra instruction entirely.  */
+#if defined (__mcoldfire__) && !defined (__mcfisab__)
+	lea	\addr-.-8,a0
+	jmp	pc@(a0)
+#else
+	bra	\addr
+#endif
+	.endm
+
+# endif
+#endif /* __PIC__ */
+
+
+| The following exception types are supported:
+INEXACT_RESULT 		= 0x0001
+UNDERFLOW 		= 0x0002
+OVERFLOW 		= 0x0004
+DIVIDE_BY_ZERO 		= 0x0008
+INVALID_OPERATION 	= 0x0010
+
+| The allowed rounding modes are:
+UNKNOWN           = -1
+ROUND_TO_NEAREST  = 0 | round result to nearest representable value
+ROUND_TO_ZERO     = 1 | round result towards zero
+ROUND_TO_PLUS     = 2 | round result towards plus infinity
+ROUND_TO_MINUS    = 3 | round result towards minus infinity
+
+| The allowed values of format are:
+NIL          = 0
+SINGLE_FLOAT = 1
+DOUBLE_FLOAT = 2
+LONG_FLOAT   = 3
+
+| The allowed values for the last operation are:
+NOOP         = 0
+ADD          = 1
+MULTIPLY     = 2
+DIVIDE       = 3
+NEGATE       = 4
+COMPARE      = 5
+EXTENDSFDF   = 6
+TRUNCDFSF    = 7
+
+| return values from __cmpdf2/__cmpsf2/__cmpxf2
+GREATER =  1
+LESS    = -1
+EQUAL   =  0
+
+#ifdef L_floatex
+
+| This is an attempt at a decent floating point (single, double and
+| extended double) code for the GNU C compiler. It should be easy to
+| adapt to other compilers (but beware of the local labels!).
+
+| Starting date: 21 October, 1990
+
+| It is convenient to introduce the notation (s,e,f) for a floating point
+| number, where s=sign, e=exponent, f=fraction. We will call a floating
+| point number fpn to abbreviate, independently of the precision.
+| Let MAX_EXP be in each case the maximum exponent (255 for floats, 1023
+| for doubles and 16383 for long doubles). We then have the following
+| different cases:
+|  1. Normalized fpns have 0 < e < MAX_EXP. They correspond to
+|     (-1)^s x 1.f x 2^(e-bias-1).
+|  2. Denormalized fpns have e=0. They correspond to numbers of the form
+|     (-1)^s x 0.f x 2^(-bias).
+|  3. +/-INFINITY have e=MAX_EXP, f=0.
+|  4. Quiet NaN (Not a Number) have all bits set.
+|  5. Signaling NaN (Not a Number) have s=0, e=MAX_EXP, f=1.
+
+|=============================================================================
+|                                  exceptions
+|=============================================================================
+
+| This is the floating point condition code register (_fpCCR):
+|
+| struct {
+|   short _exception_bits;
+|   short _trap_enable_bits;
+|   short _sticky_bits;
+|   short _rounding_mode;
+|   short _format;
+|   short _last_operation;
+|   union {
+|     float sf;
+|     double df;
+|     long double xf;
+|   } _operand1;
+|   union {
+|     float sf;
+|     double df;
+|     long double xf;
+|   } _operand2;
+| } _fpCCR;
+
+	.data
+	.even
+
+	.globl	SYM (_fpCCR)
+
+SYM (_fpCCR):
+__exception_bits:
+	.word	0
+__trap_enable_bits:
+	.word	0
+__sticky_bits:
+	.word	0
+__rounding_mode:
+	.word	ROUND_TO_NEAREST
+__format:
+	.word	NIL
+__last_operation:
+	.word	NOOP
+__operand1:
+	.long	0
+	.long	0
+	.long	0
+__operand2:
+	.long 	0
+	.long	0
+	.long	0
+
+| Offsets:
+EBITS  = __exception_bits - SYM (_fpCCR)
+TRAPE  = __trap_enable_bits - SYM (_fpCCR)
+STICK  = __sticky_bits - SYM (_fpCCR)
+ROUND  = __rounding_mode - SYM (_fpCCR)
+FORMT  = __format - SYM (_fpCCR)
+LASTO  = __last_operation - SYM (_fpCCR)
+OPER1  = __operand1 - SYM (_fpCCR)
+OPER2  = __operand2 - SYM (_fpCCR)
+
+|=============================================================================
+|                           __clear_sticky_bits
+|=============================================================================
+
+| The sticky bits are normally not cleared (thus the name), whereas the
+| exception type and exception value reflect the last computation.
+| This routine is provided to clear them (you can also write to _fpCCR,
+| since it is globally visible).
+
+	.globl  SYM (__clear_sticky_bit)
+
+	.text
+	.even
+
+| void __clear_sticky_bits(void);
+SYM (__clear_sticky_bit):
+	PICLEA	SYM (_fpCCR),a0
+	clr.w	a0@(STICK)
+	rts
+
+|=============================================================================
+|                           $_exception_handler
+|=============================================================================
+
+	.globl  $_exception_handler
+
+	.text
+	.even
+
+| This is the common exit point if an exception occurs.
+| NOTE: it is NOT callable from C!
+| It expects the exception type in d7, the format (SINGLE_FLOAT,
+| DOUBLE_FLOAT or LONG_FLOAT) in d6, and the last operation code in d5.
+| It sets the corresponding exception and sticky bits, and the format.
+| Depending on the format if fills the corresponding slots for the
+| operands which produced the exception (all this information is provided
+| so if you write your own exception handlers you have enough information
+| to deal with the problem).
+| Then checks to see if the corresponding exception is trap-enabled,
+| in which case it pushes the address of _fpCCR and traps through
+| trap FPTRAP (15 for the moment).
+
+FPTRAP = 15
+
+$_exception_handler:
+	PICLEA	SYM (_fpCCR),a0
+	movew	d7,a0@(EBITS)	| set __exception_bits
+#ifndef __mcoldfire__
+	orw	d7,a0@(STICK)	| and __sticky_bits
+#else
+	movew	a0@(STICK),d4
+	orl	d7,d4
+	movew	d4,a0@(STICK)
+#endif
+	movew	d6,a0@(FORMT)	| and __format
+	movew	d5,a0@(LASTO)	| and __last_operation
+
+| Now put the operands in place:
+#ifndef __mcoldfire__
+	subqw	IMM (DOUBLE_FLOAT),d6
+#else
+	subql	IMM (DOUBLE_FLOAT),d6
+#endif
+	beq	2f
+	bmi	3f
+	moveml a6@(8),d0-d5
+	moveml d0-d5,a0@(OPER1)
+	| for cmpxf2, return value is int!
+#ifndef __mcoldfire__
+	subqw	IMM (2),d6
+#else
+	subql	IMM (2),d6
+#endif
+	beq		4f
+	moveml	d0-d2,a1@			| write return value for long double
+	movel	a1,d0
+	bra	4f
+2:
+	movel	a6@(8),a0@(OPER1)
+	movel	a6@(12),a0@(OPER1+4)
+	movel	a6@(16),a0@(OPER2)
+	movel	a6@(20),a0@(OPER2+4)
+	bra	4f
+3:	movel	a6@(8),a0@(OPER1)
+	movel	a6@(12),a0@(OPER2)
+4:
+| And check whether the exception is trap-enabled:
+#ifndef __mcoldfire__
+	andw	a0@(TRAPE),d7	| is exception trap-enabled?
+#else
+	clrl	d6
+	movew	a0@(TRAPE),d6
+	andl	d6,d7
+#endif
+	beq	1f		| no, exit
+	pea		(a0)	| yes, push address of _fpCCR
+	trap	IMM (FPTRAP)	| and trap
+1:
+	moveml	sp@,d2-d7/a2-a5	| restore data registers
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6		| and return
+	rts
+#endif /* L_floatex */
+
+#ifdef __FASTCALL__
+
+#include "lb1sf68-fast.asm"
+
+#else
+
+#ifdef  L_mulsi3
+	.text
+	FUNC(__mulsi3)
+	.globl	SYM (__mulsi3)
+	.globl	SYM (__mulsi3_internal)
+#ifdef __ELF__
+	.hidden	SYM (__mulsi3_internal)
+#endif
+SYM (__mulsi3):
+SYM (__mulsi3_internal):
+	movew	sp@(4), d0	/* x0 -> d0 */
+	muluw	sp@(10), d0	/* x0*y1 */
+	movew	sp@(6), d1	/* x1 -> d1 */
+	muluw	sp@(8), d1	/* x1*y0 */
+#ifndef __mcoldfire__
+	addw	d1, d0
+#else
+	addl	d1, d0
+#endif
+	swap	d0
+	clrw	d0
+	movew	sp@(6), d1	/* x1 -> d1 */
+	muluw	sp@(10), d1	/* x1*y1 */
+	addl	d1, d0
+
+	rts
+#endif /* L_mulsi3 */
+
+#ifdef  L_udivsi3
+	.text
+	FUNC(__udivsi3)
+	.globl	SYM (__udivsi3)
+	.globl	SYM (__udivsi3_internal)
+#ifdef __ELF__
+	.hidden	SYM (__udivsi3_internal)
+#endif
+SYM (__udivsi3):
+SYM (__udivsi3_internal):
+#ifndef __mcoldfire__
+	movel	d2, sp@-
+	movel	sp@(12), d1	/* d1 = divisor */
+	movel	sp@(8), d0	/* d0 = dividend */
+
+	cmpl	IMM (0x10000), d1 /* divisor >= 2 ^ 16 ?   */
+	jcc	L3		/* then try next algorithm */
+	movel	d0, d2
+	clrw	d2
+	swap	d2
+	divu	d1, d2          /* high quotient in lower word */
+	movew	d2, d0		/* save high quotient */
+	swap	d0
+	movew	sp@(10), d2	/* get low dividend + high rest */
+	divu	d1, d2		/* low quotient */
+	movew	d2, d0
+	jra	L6
+
+L3:	movel	d1, d2		/* use d2 as divisor backup */
+L4:	lsrl	IMM (1), d1	/* shift divisor */
+	lsrl	IMM (1), d0	/* shift dividend */
+	cmpl	IMM (0x10000), d1 /* still divisor >= 2 ^ 16 ?  */
+	jcc	L4
+	divu	d1, d0		/* now we have 16-bit divisor */
+	andl	IMM (0xffff), d0 /* mask out divisor, ignore remainder */
+
+/* Multiply the 16-bit tentative quotient with the 32-bit divisor.  Because of
+   the operand ranges, this might give a 33-bit product.  If this product is
+   greater than the dividend, the tentative quotient was too large. */
+	movel	d2, d1
+	mulu	d0, d1		/* low part, 32 bits */
+	swap	d2
+	mulu	d0, d2		/* high part, at most 17 bits */
+	swap	d2		/* align high part with low part */
+	tstw	d2		/* high part 17 bits? */
+	jne	L5		/* if 17 bits, quotient was too large */
+	addl	d2, d1		/* add parts */
+	jcs	L5		/* if sum is 33 bits, quotient was too large */
+	cmpl	sp@(8), d1	/* compare the sum with the dividend */
+	jls	L6		/* if sum > dividend, quotient was too large */
+L5:	subql	IMM (1), d0	/* adjust quotient */
+
+L6:	movel	sp@+, d2
+	rts
+
+#else /* __mcoldfire__ */
+
+/* ColdFire implementation of non-restoring division algorithm from
+   Hennessy & Patterson, Appendix A. */
+	link	a6,IMM (-12)
+	moveml	d2-d4,sp@
+	movel	a6@(8),d0
+	movel	a6@(12),d1
+	clrl	d2		| clear p
+	moveq	IMM (31),d4
+L1:	addl	d0,d0		| shift reg pair (p,a) one bit left
+	addxl	d2,d2
+	movel	d2,d3		| subtract b from p, store in tmp.
+	subl	d1,d3
+	jcs	L2		| if no carry,
+	bset	IMM (0),d0	| set the low order bit of a to 1,
+	movel	d3,d2		| and store tmp in p.
+L2:	subql	IMM (1),d4
+	jcc	L1
+	moveml	sp@,d2-d4	| restore data registers
+	unlk	a6		| and return
+	rts
+#endif /* __mcoldfire__ */
+
+#endif /* L_udivsi3 */
+
+#ifdef  L_divsi3
+	.text
+	FUNC(__divsi3)
+	.globl	SYM (__divsi3)
+	.globl	SYM (__divsi3_internal)
+#ifdef __ELF__
+	.hidden	SYM (__divsi3_internal)
+#endif
+SYM (__divsi3):
+SYM (__divsi3_internal):
+	movel	d2, sp@-
+
+	moveq	IMM (1), d2	/* sign of result stored in d2 (=1 or =-1) */
+	movel	sp@(12), d1	/* d1 = divisor */
+	jpl	L1
+	negl	d1
+#ifndef __mcoldfire__
+	negb	d2		/* change sign because divisor <0  */
+#else
+	negl	d2		/* change sign because divisor <0  */
+#endif
+L1:	movel	sp@(8), d0	/* d0 = dividend */
+	jpl	L2
+	negl	d0
+#ifndef __mcoldfire__
+	negb	d2
+#else
+	negl	d2
+#endif
+
+L2:	movel	d1, sp@-
+	movel	d0, sp@-
+	PICCALL	SYM (__udivsi3_internal)	/* divide abs(dividend) by abs(divisor) */
+	addql	IMM (8), sp
+
+	tstb	d2
+	jpl	L3
+	negl	d0
+
+L3:	movel	sp@+, d2
+	rts
+#endif /* L_divsi3 */
+
+#ifdef  L_umodsi3
+	.text
+	FUNC(__umodsi3)
+	.globl	SYM (__umodsi3)
+SYM (__umodsi3):
+	movel	sp@(8), d1	/* d1 = divisor */
+	movel	sp@(4), d0	/* d0 = dividend */
+	movel	d1, sp@-
+	movel	d0, sp@-
+	PICCALL	SYM (__udivsi3_internal)
+	addql	IMM (8), sp
+	movel	sp@(8), d1	/* d1 = divisor */
+#ifndef __mcoldfire__
+	movel	d1, sp@-
+	movel	d0, sp@-
+	PICCALL	SYM (__mulsi3_internal)	/* d0 = (a/b)*b */
+	addql	IMM (8), sp
+#else
+	mulsl	d1,d0
+#endif
+	movel	sp@(4), d1	/* d1 = dividend */
+	subl	d0, d1		/* d1 = a - (a/b)*b */
+	movel	d1, d0
+	rts
+#endif /* L_umodsi3 */
+
+#ifdef  L_modsi3
+	.text
+	FUNC(__modsi3)
+	.globl	SYM (__modsi3)
+SYM (__modsi3):
+	movel	sp@(8), d1	/* d1 = divisor */
+	movel	sp@(4), d0	/* d0 = dividend */
+	movel	d1, sp@-
+	movel	d0, sp@-
+	PICCALL	SYM (__divsi3_internal)
+	addql	IMM (8), sp
+	movel	sp@(8), d1	/* d1 = divisor */
+#ifndef __mcoldfire__
+	movel	d1, sp@-
+	movel	d0, sp@-
+	PICCALL	SYM (__mulsi3_internal)	/* d0 = (a/b)*b */
+	addql	IMM (8), sp
+#else
+	mulsl	d1,d0
+#endif
+	movel	sp@(4), d1	/* d1 = dividend */
+	subl	d0, d1		/* d1 = a - (a/b)*b */
+	movel	d1, d0
+	rts
+#endif /* L_modsi3 */
+
+#endif /* __FASTCALL__ */
+
+#ifdef  L_double
+
+|=============================================================================
+|=============================================================================
+|                         double precision routines
+|=============================================================================
+|=============================================================================
+
+| A double precision floating point number (double) has the format:
+|
+| struct _double {
+|  unsigned int sign      : 1;  /* sign bit */
+|  unsigned int exponent  : 11; /* exponent, shifted by 1022 */
+|  unsigned int fraction  : 52; /* fraction */
+| } double;
+|
+| Thus sizeof(double) = 8 (64 bits).
+|
+| All the routines are callable from C programs, and return the result
+| in the register pair d0-d1. They also preserve all registers except
+| d0-d1 and a0-a1.
+
+	.globl	SYM (_fpCCR)
+	.globl  $_exception_handler
+
+QUIET_NaN      = 0xffffffff
+INFINITY       = 0x7ff00000
+
+D_MAX_EXP      = 0x07ff
+D_BIAS         = 1022
+DBL_MAX_EXP    = D_MAX_EXP - D_BIAS
+DBL_MIN_EXP    = 1 - D_BIAS
+DBL_MANT_DIG   = 53
+
+| Entry points:
+
+	.globl SYM (__adddf3)
+	.globl SYM (__subdf3)
+	.globl SYM (__muldf3)
+	.globl SYM (__divdf3)
+	.globl SYM (__negdf2)
+	.globl SYM (__cmpdf2)
+
+	.text
+	.even
+
+| These are common routines to return and signal exceptions.
+
+Ld$den:
+| Return and signal a denormalized number
+	orl	d7,d0
+	movew	IMM (INEXACT_RESULT+UNDERFLOW),d7
+	moveq	IMM (DOUBLE_FLOAT),d6
+	PICJUMP	$_exception_handler
+
+Ld$infty:
+Ld$overflow:
+| Return a properly signed INFINITY and set the exception flags
+	movel	IMM (INFINITY),d0
+	movel	IMM (0),d1
+	orl	d7,d0
+	movew	IMM (INEXACT_RESULT+OVERFLOW),d7
+	moveq	IMM (DOUBLE_FLOAT),d6
+	PICJUMP	$_exception_handler
+
+Ld$underflow:
+| Return 0 and set the exception flags
+	movel	IMM (0),d0
+	movel	d0,d1
+	movew	IMM (INEXACT_RESULT+UNDERFLOW),d7
+	moveq	IMM (DOUBLE_FLOAT),d6
+	PICJUMP	$_exception_handler
+
+Ld$inop:
+| Return a quiet NaN and set the exception flags
+	movel	IMM (QUIET_NaN),d0
+	movel	d0,d1
+	movew	IMM (INEXACT_RESULT+INVALID_OPERATION),d7
+	moveq	IMM (DOUBLE_FLOAT),d6
+	PICJUMP	$_exception_handler
+
+Ld$div$0:
+| Return a properly signed INFINITY and set the exception flags
+	movel	IMM (INFINITY),d0
+	movel	IMM (0),d1
+	orl	d7,d0
+	movew	IMM (INEXACT_RESULT+DIVIDE_BY_ZERO),d7
+	moveq	IMM (DOUBLE_FLOAT),d6
+	PICJUMP	$_exception_handler
+
+|=============================================================================
+|                              __subdf3
+|=============================================================================
+
+| double __subdf3(double, double);
+	FUNC(__subdf3)
+SYM (__subdf3):
+	bchg	IMM (31),sp@(12) | change sign of second operand
+				| and fall through, so we always add
+
+|=============================================================================
+|                              __adddf3
+|=============================================================================
+
+| double __adddf3(double, double);
+	FUNC(__adddf3)
+SYM (__adddf3):
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+	moveml	a6@(8),d0-d3	| get first operand into d0-d1, and second operand into d2-d3
+
+	movel	d0,d7		| get d0's sign bit in d7
+	addl	d1,d1		| check and clear sign bit of a, and gain one
+	addxl	d0,d0		| bit of extra precision
+	beq	Ladddf$b	| if zero return second operand
+
+	movel	d2,d6		| save sign in d6
+	addl	d3,d3		| get rid of sign bit and gain one bit of
+	addxl	d2,d2		| extra precision
+	beq	Ladddf$a	| if zero return first operand
+
+	andl	IMM (0x80000000),d7 | isolate a's sign bit
+    swap	d6		| and also b's sign bit
+#ifndef __mcoldfire__
+	andw	IMM (0x8000),d6	|
+	orw	d6,d7		| and combine them into d7, so that a's sign
+				| bit is in the high word and b's is in the
+				| low word, so d6 is free to be used
+#else
+	andl	IMM (0x8000),d6
+	orl	d6,d7
+#endif
+	movel	d7,a0		| now save d7 into a0, so d7 is free to
+                                | be used also
+
+| Get the exponents and check for denormalized and/or infinity.
+
+	movel	IMM (0x001fffff),d6 | mask for the fraction
+	movel	IMM (0x00200000),d7 | mask to put hidden bit back
+
+	movel	d0,d4		|
+	andl	d6,d0		| get fraction in d0
+	notl	d6		| make d6 into mask for the exponent
+	andl	d6,d4		| get exponent in d4
+	beq	Ladddf$a$den	| branch if a is denormalized
+	cmpl	d6,d4		| check for INFINITY or NaN
+	beq	Ladddf$nf       |
+	orl	d7,d0		| and put hidden bit back
+Ladddf$1:
+	swap	d4		| shift right exponent so that it starts
+#ifndef __mcoldfire__
+	lsrw	IMM (5),d4	| in bit 0 and not bit 20
+#else
+	lsrl	IMM (5),d4	| in bit 0 and not bit 20
+#endif
+| Now we have a's exponent in d4 and fraction in d0-d1
+	movel	d2,d5		| save b to get exponent
+	andl	d6,d5		| get exponent in d5
+	beq	Ladddf$b$den	| branch if b is denormalized
+	cmpl	d6,d5		| check for INFINITY or NaN
+	beq	Ladddf$nf
+	notl	d6		| make d6 into mask for the fraction again
+	andl	d6,d2		| and get fraction in d2
+	orl	d7,d2		| and put hidden bit back
+Ladddf$2:
+	swap	d5		| shift right exponent so that it starts
+#ifndef __mcoldfire__
+	lsrw	IMM (5),d5	| in bit 0 and not bit 20
+#else
+	lsrl	IMM (5),d5	| in bit 0 and not bit 20
+#endif
+
+| Now we have b's exponent in d5 and fraction in d2-d3.
+
+| The situation now is as follows: the signs are combined in a0, the
+| numbers are in d0-d1 (a) and d2-d3 (b), and the exponents in d4 (a)
+| and d5 (b). To do the rounding correctly we need to keep all the
+| bits until the end, so we need to use d0-d1-d2-d3 for the first number
+| and d4-d5-d6-d7 for the second. To do this we store (temporarily) the
+| exponents in a2-a3.
+
+	movel	d4,a2		| save the exponents
+	movel	d5,a3		|
+
+	movel	IMM (0),d7	| and move the numbers around
+	movel	d7,d6		|
+	movel	d3,d5		|
+	movel	d2,d4		|
+	movel	d7,d3		|
+	movel	d7,d2		|
+
+| Here we shift the numbers until the exponents are the same, and put
+| the largest exponent in a2.
+#ifndef __mcoldfire__
+	exg	d4,a2		| get exponents back
+	exg	d5,a3		|
+	cmpw	d4,d5		| compare the exponents
+#else
+	movel	d4,a4		| get exponents back
+	movel	a2,d4
+	movel	a4,a2
+	movel	d5,a4
+	movel	a3,d5
+	movel	a4,a3
+	cmpl	d4,d5		| compare the exponents
+#endif
+	beq	Ladddf$3	| if equal don't shift
+	bhi	9f		| branch if second exponent is higher
+
+| Here we have a's exponent larger than b's, so we have to shift b. We do
+| this by using as counter d2:
+1:	movew	d4,d2		| move largest exponent to d2
+#ifndef __mcoldfire__
+	subw	d5,d2		| and subtract second exponent
+	exg	d4,a2		| get back the longs we saved
+	exg	d5,a3		|
+#else
+	subl	d5,d2		| and subtract second exponent
+	movel	d4,a4		| get back the longs we saved
+	movel	a2,d4
+	movel	a4,a2
+	movel	d5,a4
+	movel	a3,d5
+	movel	a4,a3
+#endif
+| if difference is too large we don't shift (actually, we can just exit)
+#ifndef __mcoldfire__
+	cmpw	IMM (DBL_MANT_DIG+2),d2
+#else
+	cmpl	IMM (DBL_MANT_DIG+2),d2
+#endif
+	bge	Ladddf$b$small
+#ifndef __mcoldfire__
+	cmpw	IMM (32),d2	| if difference >= 32, shift by longs
+#else
+	cmpl	IMM (32),d2	| if difference >= 32, shift by longs
+#endif
+	bge	5f
+2:
+#ifndef __mcoldfire__
+	cmpw	IMM (16),d2	| if difference >= 16, shift by words
+#else
+	cmpl	IMM (16),d2	| if difference >= 16, shift by words
+#endif
+	bge	6f
+	bra	3f		| enter dbra loop
+
+4:
+#ifndef __mcoldfire__
+	lsrl	IMM (1),d4
+	roxrl	IMM (1),d5
+	roxrl	IMM (1),d6
+	roxrl	IMM (1),d7
+#else
+	lsrl	IMM (1),d7
+	btst	IMM (0),d6
+	beq	10f
+	bset	IMM (31),d7
+10:	lsrl	IMM (1),d6
+	btst	IMM (0),d5
+	beq	11f
+	bset	IMM (31),d6
+11:	lsrl	IMM (1),d5
+	btst	IMM (0),d4
+	beq	12f
+	bset	IMM (31),d5
+12:	lsrl	IMM (1),d4
+#endif
+3:
+#ifndef __mcoldfire__
+	dbra	d2,4b
+#else
+	subql	IMM (1),d2
+	bpl	4b
+#endif
+	movel	IMM (0),d2
+	movel	d2,d3
+	bra	Ladddf$4
+5:
+	movel	d6,d7
+	movel	d5,d6
+	movel	d4,d5
+	movel	IMM (0),d4
+#ifndef __mcoldfire__
+	subw	IMM (32),d2
+#else
+	subl	IMM (32),d2
+#endif
+	bra	2b
+6:
+	movew	d6,d7
+	swap	d7
+	movew	d5,d6
+	swap	d6
+	movew	d4,d5
+	swap	d5
+	movew	IMM (0),d4
+	swap	d4
+#ifndef __mcoldfire__
+	subw	IMM (16),d2
+#else
+	subl	IMM (16),d2
+#endif
+	bra	3b
+
+9:
+#ifndef __mcoldfire__
+	exg	d4,d5
+	movew	d4,d6
+	subw	d5,d6		| keep d5 (largest exponent) in d4
+	exg	d4,a2
+	exg	d5,a3
+#else
+	movel	d5,d6
+	movel	d4,d5
+	movel	d6,d4
+	subl	d5,d6
+	movel	d4,a4
+	movel	a2,d4
+	movel	a4,a2
+	movel	d5,a4
+	movel	a3,d5
+	movel	a4,a3
+#endif
+| if difference is too large we don't shift (actually, we can just exit)
+#ifndef __mcoldfire__
+	cmpw	IMM (DBL_MANT_DIG+2),d6
+#else
+	cmpl	IMM (DBL_MANT_DIG+2),d6
+#endif
+	bge	Ladddf$a$small
+#ifndef __mcoldfire__
+	cmpw	IMM (32),d6	| if difference >= 32, shift by longs
+#else
+	cmpl	IMM (32),d6	| if difference >= 32, shift by longs
+#endif
+	bge	5f
+2:
+#ifndef __mcoldfire__
+	cmpw	IMM (16),d6	| if difference >= 16, shift by words
+#else
+	cmpl	IMM (16),d6	| if difference >= 16, shift by words
+#endif
+	bge	6f
+	bra	3f		| enter dbra loop
+
+4:
+#ifndef __mcoldfire__
+	lsrl	IMM (1),d0
+	roxrl	IMM (1),d1
+	roxrl	IMM (1),d2
+	roxrl	IMM (1),d3
+#else
+	lsrl	IMM (1),d3
+	btst	IMM (0),d2
+	beq	10f
+	bset	IMM (31),d3
+10:	lsrl	IMM (1),d2
+	btst	IMM (0),d1
+	beq	11f
+	bset	IMM (31),d2
+11:	lsrl	IMM (1),d1
+	btst	IMM (0),d0
+	beq	12f
+	bset	IMM (31),d1
+12:	lsrl	IMM (1),d0
+#endif
+3:
+#ifndef __mcoldfire__
+	dbra	d6,4b
+#else
+	subql	IMM (1),d6
+	bpl	4b
+#endif
+	movel	IMM (0),d7
+	movel	d7,d6
+	bra	Ladddf$4
+5:
+	movel	d2,d3
+	movel	d1,d2
+	movel	d0,d1
+	movel	IMM (0),d0
+#ifndef __mcoldfire__
+	subw	IMM (32),d6
+#else
+	subl	IMM (32),d6
+#endif
+	bra	2b
+6:
+	movew	d2,d3
+	swap	d3
+	movew	d1,d2
+	swap	d2
+	movew	d0,d1
+	swap	d1
+	movew	IMM (0),d0
+	swap	d0
+#ifndef __mcoldfire__
+	subw	IMM (16),d6
+#else
+	subl	IMM (16),d6
+#endif
+	bra	3b
+Ladddf$3:
+#ifndef __mcoldfire__
+	exg	d4,a2
+	exg	d5,a3
+#else
+	movel	d4,a4
+	movel	a2,d4
+	movel	a4,a2
+	movel	d5,a4
+	movel	a3,d5
+	movel	a4,a3
+#endif
+Ladddf$4:
+| Now we have the numbers in d0--d3 and d4--d7, the exponent in a2, and
+| the signs in a0.
+
+| Here we have to decide whether to add or subtract the numbers:
+#ifndef __mcoldfire__
+	exg	d7,a0		| get the signs
+	exg	d6,a3		| a3 is free to be used
+#else
+	movel	d7,a4
+	movel	a0,d7
+	movel	a4,a0
+	movel	d6,a4
+	movel	a3,d6
+	movel	a4,a3
+#endif
+	movel	d7,d6		|
+	movew	IMM (0),d7	| get a's sign in d7
+	swap	d6              |
+	movew	IMM (0),d6	| and b's sign in d6
+	eorl	d7,d6		| compare the signs
+	bmi	Lsubdf$0	| if the signs are different we have
+				| to subtract
+#ifndef __mcoldfire__
+	exg	d7,a0		| else we add the numbers
+	exg	d6,a3		|
+#else
+	movel	d7,a4
+	movel	a0,d7
+	movel	a4,a0
+	movel	d6,a4
+	movel	a3,d6
+	movel	a4,a3
+#endif
+	addl	d7,d3		|
+	addxl	d6,d2		|
+	addxl	d5,d1		|
+	addxl	d4,d0           |
+
+	movel	a2,d4		| return exponent to d4
+	movel	a0,d7		|
+	andl	IMM (0x80000000),d7 | d7 now has the sign
+
+| Before rounding normalize so bit #DBL_MANT_DIG is set (we will consider
+| the case of denormalized numbers in the rounding routine itself).
+| As in the addition (not in the subtraction!) we could have set
+| one more bit we check this:
+	btst	IMM (DBL_MANT_DIG+1-32),d0
+	beq	1f
+#ifndef __mcoldfire__
+	lsrl	IMM (1),d0
+	roxrl	IMM (1),d1
+	roxrl	IMM (1),d2
+	roxrl	IMM (1),d3
+	addw	IMM (1),d4
+#else
+	lsrl	IMM (1),d3
+	btst	IMM (0),d2
+	beq	10f
+	bset	IMM (31),d3
+10:	lsrl	IMM (1),d2
+	btst	IMM (0),d1
+	beq	11f
+	bset	IMM (31),d2
+11:	lsrl	IMM (1),d1
+	btst	IMM (0),d0
+	beq	12f
+	bset	IMM (31),d1
+12:	lsrl	IMM (1),d0
+	addl	IMM (1),d4
+#endif
+1:
+	PICLEA	SYM (_fpCCR),a0	| check the rounding mode
+#ifdef __mcoldfire__
+	clrl	d6
+#endif
+	movew	a0@(6),d6	| rounding mode in d6
+	lea	pc@(Ladddf$5),a0 | to return from rounding routine
+	beq	Lround$to$nearest
+#ifndef __mcoldfire__
+	cmpw	IMM (ROUND_TO_PLUS),d6
+#else
+	cmpl	IMM (ROUND_TO_PLUS),d6
+#endif
+	bhi	Lround$to$minus
+	blt	Lround$to$zero
+	bra	Lround$to$plus
+Ladddf$5:
+| Put back the exponent and check for overflow
+#ifndef __mcoldfire__
+	cmpw	IMM (D_MAX_EXP),d4	| is the exponent big?
+#else
+	cmpl	IMM (D_MAX_EXP),d4	| is the exponent big?
+#endif
+	bge	1f
+	bclr	IMM (DBL_MANT_DIG-1-32),d0
+#ifndef __mcoldfire__
+	lslw	IMM (4),d4	| put exponent back into position
+#else
+	lsll	IMM (4),d4	| put exponent back into position
+#endif
+	swap	d0		|
+#ifndef __mcoldfire__
+	orw	d4,d0		|
+#else
+	orl	d4,d0		|
+#endif
+	swap	d0		|
+	bra	Ladddf$ret
+1:
+	moveq	IMM (ADD),d5
+	bra	Ld$overflow
+
+Lsubdf$0:
+| Here we do the subtraction.
+#ifndef __mcoldfire__
+	exg	d7,a0		| put sign back in a0
+	exg	d6,a3		|
+#else
+	movel	d7,a4
+	movel	a0,d7
+	movel	a4,a0
+	movel	d6,a4
+	movel	a3,d6
+	movel	a4,a3
+#endif
+	subl	d7,d3		|
+	subxl	d6,d2		|
+	subxl	d5,d1		|
+	subxl	d4,d0		|
+	beq	Ladddf$ret$1	| if zero just exit
+	bpl	1f		| if positive skip the following
+	movel	a0,d7		|
+	bchg	IMM (31),d7	| change sign bit in d7
+	movel	d7,a0		|
+	negl	d3		|
+	negxl	d2		|
+	negxl	d1              | and negate result
+	negxl	d0              |
+1:
+	movel	a2,d4		| return exponent to d4
+	movel	a0,d7
+	andl	IMM (0x80000000),d7 | isolate sign bit
+
+| Before rounding normalize so bit #DBL_MANT_DIG is set (we will consider
+| the case of denormalized numbers in the rounding routine itself).
+| As in the addition (not in the subtraction!) we could have set
+| one more bit we check this:
+	btst	IMM (DBL_MANT_DIG+1-32),d0
+	beq	1f
+#ifndef __mcoldfire__
+	lsrl	IMM (1),d0
+	roxrl	IMM (1),d1
+	roxrl	IMM (1),d2
+	roxrl	IMM (1),d3
+	addw	IMM (1),d4
+#else
+	lsrl	IMM (1),d3
+	btst	IMM (0),d2
+	beq	10f
+	bset	IMM (31),d3
+10:	lsrl	IMM (1),d2
+	btst	IMM (0),d1
+	beq	11f
+	bset	IMM (31),d2
+11:	lsrl	IMM (1),d1
+	btst	IMM (0),d0
+	beq	12f
+	bset	IMM (31),d1
+12:	lsrl	IMM (1),d0
+	addl	IMM (1),d4
+#endif
+1:
+	PICLEA	SYM (_fpCCR),a0	| check the rounding mode
+#ifdef __mcoldfire__
+	clrl	d6
+#endif
+	movew	a0@(6),d6	| rounding mode in d6
+	lea	pc@(Lsubdf$1),a0 | to return from rounding routine
+	beq	Lround$to$nearest
+#ifndef __mcoldfire__
+	cmpw	IMM (ROUND_TO_PLUS),d6
+#else
+	cmpl	IMM (ROUND_TO_PLUS),d6
+#endif
+	bhi	Lround$to$minus
+	blt	Lround$to$zero
+	bra	Lround$to$plus
+Lsubdf$1:
+| Put back the exponent and sign (we don't have overflow).
+	bclr	IMM (DBL_MANT_DIG-1-32),d0
+#ifndef __mcoldfire__
+	lslw	IMM (4),d4	| put exponent back into position
+#else
+	lsll	IMM (4),d4	| put exponent back into position
+#endif
+	swap	d0		|
+#ifndef __mcoldfire__
+	orw	d4,d0		|
+#else
+	orl	d4,d0		|
+#endif
+	swap	d0		|
+	bra	Ladddf$ret
+
+| If one of the numbers was too small (difference of exponents >=
+| DBL_MANT_DIG+1) we return the other (and now we don't have to
+| check for finiteness or zero).
+Ladddf$a$small:
+	movel	a6@(16),d0
+	movel	a6@(20),d1
+	PICLEA	SYM (_fpCCR),a0
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6		| and return
+	rts
+
+Ladddf$b$small:
+	movel	a6@(8),d0
+	movel	a6@(12),d1
+	PICLEA	SYM (_fpCCR),a0
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6		| and return
+	rts
+
+Ladddf$a$den:
+	movel	d7,d4		| d7 contains 0x00200000
+	bra	Ladddf$1
+
+Ladddf$b$den:
+	movel	d7,d5           | d7 contains 0x00200000
+	notl	d6
+	bra	Ladddf$2
+
+Ladddf$b:
+| Return b (if a is zero)
+	movel	d2,d0
+	movel	d3,d1
+	bne	1f			| Check if b is -0
+	cmpl	IMM (0x80000000),d0
+	bne	1f
+	andl	IMM (0x80000000),d7	| Use the sign of a
+	clrl	d0
+	bra	Ladddf$ret
+Ladddf$a:
+	movel	a6@(8),d0
+	movel	a6@(12),d1
+1:
+	moveq	IMM (ADD),d5
+| Check for NaN and +/-INFINITY.
+	movel	d0,d7         		|
+	andl	IMM (0x80000000),d7	|
+	bclr	IMM (31),d0		|
+	cmpl	IMM (0x7ff00000),d0	|
+	bge	2f			|
+	movel	d0,d0           	| check for zero, since we don't
+	bne	Ladddf$ret		| want to return -0 by mistake
+	bclr	IMM (31),d7		|
+	bra	Ladddf$ret		|
+2:
+	andl	IMM (0x000fffff),d0	| check for NaN (nonzero fraction)
+	orl	d1,d0			|
+	bne	Ld$inop         	|
+	bra	Ld$infty		|
+
+Ladddf$ret$1:
+
+Ladddf$ret:
+| Normal exit.
+	PICLEA	SYM (_fpCCR),a0
+	clrw	a0@
+	orl	d7,d0		| put sign bit back
+	moveml	sp@,d2-d7/a2-a5
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6
+	rts
+
+Ladddf$ret$den:
+| Return a denormalized number.
+#ifndef __mcoldfire__
+	lsrl	IMM (1),d0	| shift right once more
+	roxrl	IMM (1),d1	|
+#else
+	lsrl	IMM (1),d1
+	btst	IMM (0),d0
+	beq	10f
+	bset	IMM (31),d1
+10:	lsrl	IMM (1),d0
+#endif
+	bra	Ladddf$ret
+
+Ladddf$nf:
+	moveq	IMM (ADD),d5
+| This could be faster but it is not worth the effort, since it is not
+| executed very often. We sacrifice speed for clarity here.
+	movel	a6@(8),d0	| get the numbers back (remember that we
+	movel	a6@(12),d1	| did some processing already)
+	movel	a6@(16),d2	|
+	movel	a6@(20),d3	|
+	movel	IMM (INFINITY),d4 | useful constant (INFINITY)
+	movel	d0,d7		| save sign bits
+	movel	d2,d6		|
+	bclr	IMM (31),d0	| clear sign bits
+	bclr	IMM (31),d2	|
+| We know that one of them is either NaN of +/-INFINITY
+| Check for NaN (if either one is NaN return NaN)
+	cmpl	d4,d0		| check first a (d0)
+	bhi	Ld$inop		| if d0 > 0x7ff00000 or equal and
+	bne	2f
+	tstl	d1		| d1 > 0, a is NaN
+	bne	Ld$inop		|
+2:	cmpl	d4,d2		| check now b (d1)
+	bhi	Ld$inop		|
+	bne	3f
+	tstl	d3		|
+	bne	Ld$inop		|
+3:
+| Now comes the check for +/-INFINITY. We know that both are (maybe not
+| finite) numbers, but we have to check if both are infinite whether we
+| are adding or subtracting them.
+	eorl	d7,d6		| to check sign bits
+	bmi	1f
+	andl	IMM (0x80000000),d7 | get (common) sign bit
+	bra	Ld$infty
+1:
+| We know one (or both) are infinite, so we test for equality between the
+| two numbers (if they are equal they have to be infinite both, so we
+| return NaN).
+	cmpl	d2,d0		| are both infinite?
+	bne	1f		| if d0 <> d2 they are not equal
+	cmpl	d3,d1		| if d0 == d2 test d3 and d1
+	beq	Ld$inop		| if equal return NaN
+1:
+	andl	IMM (0x80000000),d7 | get a's sign bit
+	cmpl	d4,d0		| test now for infinity
+	beq	Ld$infty	| if a is INFINITY return with this sign
+	bchg	IMM (31),d7	| else we know b is INFINITY and has
+	bra	Ld$infty	| the opposite sign
+
+|=============================================================================
+|                              __muldf3
+|=============================================================================
+
+| double __muldf3(double, double);
+	FUNC(__muldf3)
+SYM (__muldf3):
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+	moveml	a6@(8),d0-d3	| get a into d0-d1, and b into d2-d3
+	movel	d0,d7			| d7 will hold the sign of the product
+	eorl	d2,d7			|
+	andl	IMM (0x80000000),d7	|
+	movel	d7,a0			| save sign bit into a0
+	movel	IMM (INFINITY),d7	| useful constant (+INFINITY)
+	movel	d7,d6			| another (mask for fraction)
+	notl	d6			|
+	bclr	IMM (31),d0		| get rid of a's sign bit
+	movel	d0,d4			|
+	orl	d1,d4			|
+	beq	Lmuldf$a$0		| branch if a is zero
+	movel	d0,d4			|
+	bclr	IMM (31),d2		| get rid of b's sign bit
+	movel	d2,d5			|
+	orl	d3,d5			|
+	beq	Lmuldf$b$0		| branch if b is zero
+	movel	d2,d5			|
+	cmpl	d7,d0			| is a big?
+	bhi	Lmuldf$inop		| if a is NaN return NaN
+	beq	Lmuldf$a$nf		| we still have to check d1 and b ...
+	cmpl	d7,d2			| now compare b with INFINITY
+	bhi	Lmuldf$inop		| is b NaN?
+	beq	Lmuldf$b$nf 		| we still have to check d3 ...
+| Here we have both numbers finite and nonzero (and with no sign bit).
+| Now we get the exponents into d4 and d5.
+	andl	d7,d4			| isolate exponent in d4
+	beq	Lmuldf$a$den		| if exponent zero, have denormalized
+	andl	d6,d0			| isolate fraction
+	orl	IMM (0x00100000),d0	| and put hidden bit back
+	swap	d4			| I like exponents in the first byte
+#ifndef __mcoldfire__
+	lsrw	IMM (4),d4		|
+#else
+	lsrl	IMM (4),d4		|
+#endif
+Lmuldf$1:
+	andl	d7,d5			|
+	beq	Lmuldf$b$den		|
+	andl	d6,d2			|
+	orl	IMM (0x00100000),d2	| and put hidden bit back
+	swap	d5			|
+#ifndef __mcoldfire__
+	lsrw	IMM (4),d5		|
+#else
+	lsrl	IMM (4),d5		|
+#endif
+Lmuldf$2:				|
+#ifndef __mcoldfire__
+	addw	d5,d4			| add exponents
+	subw	IMM (D_BIAS+1),d4	| and subtract bias (plus one)
+#else
+	addl	d5,d4			| add exponents
+	subl	IMM (D_BIAS+1),d4	| and subtract bias (plus one)
+#endif
+
+| We are now ready to do the multiplication. The situation is as follows:
+| both a and b have bit 52 ( bit 20 of d0 and d2) set (even if they were
+| denormalized to start with!), which means that in the product bit 104
+| (which will correspond to bit 8 of the fourth long) is set.
+
+| Here we have to do the product.
+| To do it we have to juggle the registers back and forth, as there are not
+| enough to keep everything in them. So we use the address registers to keep
+| some intermediate data.
+
+	movel	IMM (0),a2	| a2 is a null register
+	movel	d4,a3		| and a3 will preserve the exponent
+
+| First, shift d2-d3 so bit 20 becomes bit 31:
+#ifndef __mcoldfire__
+	rorl	IMM (5),d2	| rotate d2 5 places right
+	swap	d2		| and swap it
+	rorl	IMM (5),d3	| do the same thing with d3
+	swap	d3		|
+	movew	d3,d6		| get the rightmost 11 bits of d3
+	andw	IMM (0x07ff),d6	|
+	orw	d6,d2		| and put them into d2
+	andw	IMM (0xf800),d3	| clear those bits in d3
+#else
+	moveq	IMM (11),d7	| left shift d2 11 bits
+	lsll	d7,d2
+	movel	d3,d6		| get a copy of d3
+	lsll	d7,d3		| left shift d3 11 bits
+	andl	IMM (0xffe00000),d6 | get the top 11 bits of d3
+	moveq	IMM (21),d7	| right shift them 21 bits
+	lsrl	d7,d6
+	orl	d6,d2		| stick them at the end of d2
+#endif
+
+	movel	d2,d6		| move b into d6-d7
+	movel	d3,d7           | move a into d4-d5
+	movel	d0,d4           | and clear d0-d1-d2-d3 (to put result)
+	movel	d1,d5           |
+	movel	IMM (0),d3	|
+	movel	d3,d2           |
+	movel	d3,d1           |
+	movel	d3,d0	        |
+
+| We use a1 as counter:
+	movel	IMM (DBL_MANT_DIG-1),a1
+#ifndef __mcoldfire__
+	exg	d7,a1
+#else
+	movel	d7,a4
+	movel	a1,d7
+	movel	a4,a1
+#endif
+
+1:
+#ifndef __mcoldfire__
+	exg	d7,a1		| put counter back in a1
+#else
+	movel	d7,a4
+	movel	a1,d7
+	movel	a4,a1
+#endif
+	addl	d3,d3		| shift sum once left
+	addxl	d2,d2           |
+	addxl	d1,d1           |
+	addxl	d0,d0           |
+	addl	d7,d7		|
+	addxl	d6,d6		|
+	bcc	2f		| if bit clear skip the following
+#ifndef __mcoldfire__
+	exg	d7,a2		|
+#else
+	movel	d7,a4
+	movel	a2,d7
+	movel	a4,a2
+#endif
+	addl	d5,d3		| else add a to the sum
+	addxl	d4,d2		|
+	addxl	d7,d1		|
+	addxl	d7,d0		|
+#ifndef __mcoldfire__
+	exg	d7,a2		|
+#else
+	movel	d7,a4
+	movel	a2,d7
+	movel	a4,a2
+#endif
+2:
+#ifndef __mcoldfire__
+	exg	d7,a1		| put counter in d7
+	dbf	d7,1b		| decrement and branch
+#else
+	movel	d7,a4
+	movel	a1,d7
+	movel	a4,a1
+	subql	IMM (1),d7
+	bpl	1b
+#endif
+
+	movel	a3,d4		| restore exponent
+
+| Now we have the product in d0-d1-d2-d3, with bit 8 of d0 set. The
+| first thing to do now is to normalize it so bit 8 becomes bit
+| DBL_MANT_DIG-32 (to do the rounding); later we will shift right.
+	swap	d0
+	swap	d1
+	movew	d1,d0
+	swap	d2
+	movew	d2,d1
+	swap	d3
+	movew	d3,d2
+	movew	IMM (0),d3
+#ifndef __mcoldfire__
+	lsrl	IMM (1),d0
+	roxrl	IMM (1),d1
+	roxrl	IMM (1),d2
+	roxrl	IMM (1),d3
+	lsrl	IMM (1),d0
+	roxrl	IMM (1),d1
+	roxrl	IMM (1),d2
+	roxrl	IMM (1),d3
+	lsrl	IMM (1),d0
+	roxrl	IMM (1),d1
+	roxrl	IMM (1),d2
+	roxrl	IMM (1),d3
+#else
+	moveq	IMM (29),d6
+	lsrl	IMM (3),d3
+	movel	d2,d7
+	lsll	d6,d7
+	orl	d7,d3
+	lsrl	IMM (3),d2
+	movel	d1,d7
+	lsll	d6,d7
+	orl	d7,d2
+	lsrl	IMM (3),d1
+	movel	d0,d7
+	lsll	d6,d7
+	orl	d7,d1
+	lsrl	IMM (3),d0
+#endif
+
+| Now round, check for over- and underflow, and exit.
+	movel	a0,d7		| get sign bit back into d7
+	moveq	IMM (MULTIPLY),d5
+
+	btst	IMM (DBL_MANT_DIG+1-32),d0
+	beq	Lround$exit
+#ifndef __mcoldfire__
+	lsrl	IMM (1),d0
+	roxrl	IMM (1),d1
+	addw	IMM (1),d4
+#else
+	lsrl	IMM (1),d1
+	btst	IMM (0),d0
+	beq	10f
+	bset	IMM (31),d1
+10:	lsrl	IMM (1),d0
+	addl	IMM (1),d4
+#endif
+	bra	Lround$exit
+
+Lmuldf$inop:
+	moveq	IMM (MULTIPLY),d5
+	bra	Ld$inop
+
+Lmuldf$b$nf:
+	moveq	IMM (MULTIPLY),d5
+	movel	a0,d7		| get sign bit back into d7
+	tstl	d3		| we know d2 == 0x7ff00000, so check d3
+	bne	Ld$inop		| if d3 <> 0 b is NaN
+	bra	Ld$overflow	| else we have overflow (since a is finite)
+
+Lmuldf$a$nf:
+	moveq	IMM (MULTIPLY),d5
+	movel	a0,d7		| get sign bit back into d7
+	tstl	d1		| we know d0 == 0x7ff00000, so check d1
+	bne	Ld$inop		| if d1 <> 0 a is NaN
+	bra	Ld$overflow	| else signal overflow
+
+| If either number is zero return zero, unless the other is +/-INFINITY or
+| NaN, in which case we return NaN.
+Lmuldf$b$0:
+	moveq	IMM (MULTIPLY),d5
+#ifndef __mcoldfire__
+	exg	d2,d0		| put b (==0) into d0-d1
+	exg	d3,d1		| and a (with sign bit cleared) into d2-d3
+	movel	a0,d0		| set result sign
+#else
+	movel	d0,d2		| put a into d2-d3
+	movel	d1,d3
+	movel	a0,d0		| put result zero into d0-d1
+	movq	IMM(0),d1
+#endif
+	bra	1f
+Lmuldf$a$0:
+	movel	a0,d0		| set result sign
+	movel	a6@(16),d2	| put b into d2-d3 again
+	movel	a6@(20),d3	|
+	bclr	IMM (31),d2	| clear sign bit
+1:	cmpl	IMM (0x7ff00000),d2 | check for non-finiteness
+	bge	Ld$inop		| in case NaN or +/-INFINITY return NaN
+	PICLEA	SYM (_fpCCR),a0
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6
+	rts
+
+| If a number is denormalized we put an exponent of 1 but do not put the
+| hidden bit back into the fraction; instead we shift left until bit 21
+| (the hidden bit) is set, adjusting the exponent accordingly. We do this
+| to ensure that the product of the fractions is close to 1.
+Lmuldf$a$den:
+	movel	IMM (1),d4
+	andl	d6,d0
+1:	addl	d1,d1           | shift a left until bit 20 is set
+	addxl	d0,d0		|
+#ifndef __mcoldfire__
+	subw	IMM (1),d4	| and adjust exponent
+#else
+	subl	IMM (1),d4	| and adjust exponent
+#endif
+	btst	IMM (20),d0	|
+	bne	Lmuldf$1        |
+	bra	1b
+
+Lmuldf$b$den:
+	movel	IMM (1),d5
+	andl	d6,d2
+1:	addl	d3,d3		| shift b left until bit 20 is set
+	addxl	d2,d2		|
+#ifndef __mcoldfire__
+	subw	IMM (1),d5	| and adjust exponent
+#else
+	subql	IMM (1),d5	| and adjust exponent
+#endif
+	btst	IMM (20),d2	|
+	bne	Lmuldf$2	|
+	bra	1b
+
+
+|=============================================================================
+|                              __divdf3
+|=============================================================================
+
+| double __divdf3(double, double);
+	FUNC(__divdf3)
+SYM (__divdf3):
+	link	a6,IMM (-40	| everything will be done in registers)
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+	moveml	a6@(8),d0-d3	| get a into d0-d1, and b into d2-d3
+	movel	d0,d7		| d7 will hold the sign of the result
+	eorl	d2,d7		|
+	andl	IMM (0x80000000),d7
+	movel	d7,a0		| save sign into a0
+	movel	IMM (INFINITY),d7 | useful constant (+INFINITY)
+	movel	d7,d6		| another (mask for fraction)
+	notl	d6		|
+	bclr	IMM (31),d0	| get rid of a's sign bit
+	movel	d0,d4		|
+	orl	d1,d4		|
+	beq	Ldivdf$a$0	| branch if a is zero
+	movel	d0,d4		|
+	bclr	IMM (31),d2	| get rid of b's sign bit
+	movel	d2,d5		|
+	orl	d3,d5		|
+	beq	Ldivdf$b$0	| branch if b is zero
+	movel	d2,d5
+	cmpl	d7,d0		| is a big?
+	bhi	Ldivdf$inop	| if a is NaN return NaN
+	beq	Ldivdf$a$nf	| if d0 == 0x7ff00000 we check d1
+	cmpl	d7,d2		| now compare b with INFINITY
+	bhi	Ldivdf$inop	| if b is NaN return NaN
+	beq	Ldivdf$b$nf	| if d2 == 0x7ff00000 we check d3
+| Here we have both numbers finite and nonzero (and with no sign bit).
+| Now we get the exponents into d4 and d5 and normalize the numbers to
+| ensure that the ratio of the fractions is around 1. We do this by
+| making sure that both numbers have bit #DBL_MANT_DIG-32-1 (hidden bit)
+| set, even if they were denormalized to start with.
+| Thus, the result will satisfy: 2 > result > 1/2.
+	andl	d7,d4		| and isolate exponent in d4
+	beq	Ldivdf$a$den	| if exponent is zero we have a denormalized
+	andl	d6,d0		| and isolate fraction
+	orl	IMM (0x00100000),d0 | and put hidden bit back
+	swap	d4		| I like exponents in the first byte
+#ifndef __mcoldfire__
+	lsrw	IMM (4),d4	|
+#else
+	lsrl	IMM (4),d4	|
+#endif
+Ldivdf$1:			|
+	andl	d7,d5		|
+	beq	Ldivdf$b$den	|
+	andl	d6,d2		|
+	orl	IMM (0x00100000),d2
+	swap	d5		|
+#ifndef __mcoldfire__
+	lsrw	IMM (4),d5	|
+#else
+	lsrl	IMM (4),d5	|
+#endif
+Ldivdf$2:			|
+#ifndef __mcoldfire__
+	subw	d5,d4		| subtract exponents
+	addw	IMM (D_BIAS),d4	| and add bias
+#else
+	subl	d5,d4		| subtract exponents
+	addl	IMM (D_BIAS),d4	| and add bias
+#endif
+
+| We are now ready to do the division. We have prepared things in such a way
+| that the ratio of the fractions will be less than 2 but greater than 1/2.
+| At this point the registers in use are:
+| d0-d1	hold a (first operand, bit DBL_MANT_DIG-32=0, bit
+| DBL_MANT_DIG-1-32=1)
+| d2-d3	hold b (second operand, bit DBL_MANT_DIG-32=1)
+| d4	holds the difference of the exponents, corrected by the bias
+| a0	holds the sign of the ratio
+
+| To do the rounding correctly we need to keep information about the
+| nonsignificant bits. One way to do this would be to do the division
+| using four registers; another is to use two registers (as originally
+| I did), but use a sticky bit to preserve information about the
+| fractional part. Note that we can keep that info in a1, which is not
+| used.
+	movel	IMM (0),d6	| d6-d7 will hold the result
+	movel	d6,d7		|
+	movel	IMM (0),a1	| and a1 will hold the sticky bit
+
+	movel	IMM (DBL_MANT_DIG-32+1),d5
+
+1:	cmpl	d0,d2		| is a < b?
+	bhi	3f		| if b > a skip the following
+	beq	4f		| if d0==d2 check d1 and d3
+2:	subl	d3,d1		|
+	subxl	d2,d0		| a <-- a - b
+	bset	d5,d6		| set the corresponding bit in d6
+3:	addl	d1,d1		| shift a by 1
+	addxl	d0,d0		|
+#ifndef __mcoldfire__
+	dbra	d5,1b		| and branch back
+#else
+	subql	IMM (1), d5
+	bpl	1b
+#endif
+	bra	5f
+4:	cmpl	d1,d3		| here d0==d2, so check d1 and d3
+	bhi	3b		| if d1 > d2 skip the subtraction
+	bra	2b		| else go do it
+5:
+| Here we have to start setting the bits in the second long.
+	movel	IMM (31),d5	| again d5 is counter
+
+1:	cmpl	d0,d2		| is a < b?
+	bhi	3f		| if b > a skip the following
+	beq	4f		| if d0==d2 check d1 and d3
+2:	subl	d3,d1		|
+	subxl	d2,d0		| a <-- a - b
+	bset	d5,d7		| set the corresponding bit in d7
+3:	addl	d1,d1		| shift a by 1
+	addxl	d0,d0		|
+#ifndef __mcoldfire__
+	dbra	d5,1b		| and branch back
+#else
+	subql	IMM (1), d5
+	bpl	1b
+#endif
+	bra	5f
+4:	cmpl	d1,d3		| here d0==d2, so check d1 and d3
+	bhi	3b		| if d1 > d2 skip the subtraction
+	bra	2b		| else go do it
+5:
+| Now go ahead checking until we hit a one, which we store in d2.
+	movel	IMM (DBL_MANT_DIG),d5
+1:	cmpl	d2,d0		| is a < b?
+	bhi	4f		| if b < a, exit
+	beq	3f		| if d0==d2 check d1 and d3
+2:	addl	d1,d1		| shift a by 1
+	addxl	d0,d0		|
+#ifndef __mcoldfire__
+	dbra	d5,1b		| and branch back
+#else
+	subql	IMM (1), d5
+	bpl	1b
+#endif
+	movel	IMM (0),d2	| here no sticky bit was found
+	movel	d2,d3
+	bra	5f
+3:	cmpl	d1,d3		| here d0==d2, so check d1 and d3
+	bhi	2b		| if d1 > d2 go back
+4:
+| Here put the sticky bit in d2-d3 (in the position which actually corresponds
+| to it; if you don't do this the algorithm loses in some cases).
+	movel	IMM (0),d2
+	movel	d2,d3
+#ifndef __mcoldfire__
+	subw	IMM (DBL_MANT_DIG),d5
+	addw	IMM (63),d5
+	cmpw	IMM (31),d5
+#else
+	subl	IMM (DBL_MANT_DIG),d5
+	addl	IMM (63),d5
+	cmpl	IMM (31),d5
+#endif
+	bhi	2f
+1:	bset	d5,d3
+	bra	5f
+#ifndef __mcoldfire__
+	subw	IMM (32),d5
+#else
+	subl	IMM (32),d5
+#endif
+2:	bset	d5,d2
+5:
+| Finally we are finished! Move the longs in the address registers to
+| their final destination:
+	movel	d6,d0
+	movel	d7,d1
+	movel	IMM (0),d3
+
+| Here we have finished the division, with the result in d0-d1-d2-d3, with
+| 2^21 <= d6 < 2^23. Thus bit 23 is not set, but bit 22 could be set.
+| If it is not, then definitely bit 21 is set. Normalize so bit 22 is
+| not set:
+	btst	IMM (DBL_MANT_DIG-32+1),d0
+	beq	1f
+#ifndef __mcoldfire__
+	lsrl	IMM (1),d0
+	roxrl	IMM (1),d1
+	roxrl	IMM (1),d2
+	roxrl	IMM (1),d3
+	addw	IMM (1),d4
+#else
+	lsrl	IMM (1),d3
+	btst	IMM (0),d2
+	beq	10f
+	bset	IMM (31),d3
+10:	lsrl	IMM (1),d2
+	btst	IMM (0),d1
+	beq	11f
+	bset	IMM (31),d2
+11:	lsrl	IMM (1),d1
+	btst	IMM (0),d0
+	beq	12f
+	bset	IMM (31),d1
+12:	lsrl	IMM (1),d0
+	addl	IMM (1),d4
+#endif
+1:
+| Now round, check for over- and underflow, and exit.
+	movel	a0,d7		| restore sign bit to d7
+	moveq	IMM (DIVIDE),d5
+	bra	Lround$exit
+
+Ldivdf$inop:
+	moveq	IMM (DIVIDE),d5
+	bra	Ld$inop
+
+Ldivdf$a$0:
+| If a is zero check to see whether b is zero also. In that case return
+| NaN; then check if b is NaN, and return NaN also in that case. Else
+| return a properly signed zero.
+	moveq	IMM (DIVIDE),d5
+	bclr	IMM (31),d2	|
+	movel	d2,d4		|
+	orl	d3,d4		|
+	beq	Ld$inop		| if b is also zero return NaN
+	cmpl	IMM (INFINITY),d2 | check for NaN
+	bhi	Ld$inop		|
+	blt	1f		|
+	tstl	d3		|
+	bne	Ld$inop		|
+1:	movel	a0,d0		| else return signed zero
+	moveq	IMM(0),d1	|
+	PICLEA	SYM (_fpCCR),a0	| clear exception flags
+	clrw	a0@	|
+	moveml	sp@,d2-d7/a2-a5	|
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6		|
+	rts			|
+
+Ldivdf$b$0:
+	moveq	IMM (DIVIDE),d5
+| If we got here a is not zero. Check if a is NaN; in that case return NaN,
+| else return +/-INFINITY. Remember that a is in d0 with the sign bit
+| cleared already.
+	movel	a0,d7		| put a's sign bit back in d7
+	cmpl	IMM (INFINITY),d0 | compare d0 with INFINITY
+	bhi	Ld$inop		| if larger it is NaN
+	tstl	d1		|
+	bne	Ld$inop		|
+	bra	Ld$div$0	| else signal DIVIDE_BY_ZERO
+
+Ldivdf$b$nf:
+	moveq	IMM (DIVIDE),d5
+| If d2 == 0x7ff00000 we have to check d3.
+	tstl	d3		|
+	bne	Ld$inop		| if d3 <> 0, b is NaN
+	bra	Ld$underflow	| else b is +/-INFINITY, so signal underflow
+
+Ldivdf$a$nf:
+	moveq	IMM (DIVIDE),d5
+| If d0 == 0x7ff00000 we have to check d1.
+	tstl	d1		|
+	bne	Ld$inop		| if d1 <> 0, a is NaN
+| If a is INFINITY we have to check b
+	cmpl	d7,d2		| compare b with INFINITY
+	bge	Ld$inop		| if b is NaN or INFINITY return NaN
+	tstl	d3		|
+	bne	Ld$inop		|
+	bra	Ld$overflow	| else return overflow
+
+| If a number is denormalized we put an exponent of 1 but do not put the
+| bit back into the fraction.
+Ldivdf$a$den:
+	movel	IMM (1),d4
+	andl	d6,d0
+1:	addl	d1,d1		| shift a left until bit 20 is set
+	addxl	d0,d0
+#ifndef __mcoldfire__
+	subw	IMM (1),d4	| and adjust exponent
+#else
+	subl	IMM (1),d4	| and adjust exponent
+#endif
+	btst	IMM (DBL_MANT_DIG-32-1),d0
+	bne	Ldivdf$1
+	bra	1b
+
+Ldivdf$b$den:
+	movel	IMM (1),d5
+	andl	d6,d2
+1:	addl	d3,d3		| shift b left until bit 20 is set
+	addxl	d2,d2
+#ifndef __mcoldfire__
+	subw	IMM (1),d5	| and adjust exponent
+#else
+	subql	IMM (1),d5	| and adjust exponent
+#endif
+	btst	IMM (DBL_MANT_DIG-32-1),d2
+	bne	Ldivdf$2
+	bra	1b
+
+Lround$exit:
+| This is a common exit point for __muldf3 and __divdf3. When they enter
+| this point the sign of the result is in d7, the result in d0-d1, normalized
+| so that 2^21 <= d0 < 2^22, and the exponent is in the lower byte of d4.
+
+| First check for underlow in the exponent:
+#ifndef __mcoldfire__
+	cmpw	IMM (-DBL_MANT_DIG-1),d4
+#else
+	cmpl	IMM (-DBL_MANT_DIG-1),d4
+#endif
+	blt	Ld$underflow
+| It could happen that the exponent is less than 1, in which case the
+| number is denormalized. In this case we shift right and adjust the
+| exponent until it becomes 1 or the fraction is zero (in the latter case
+| we signal underflow and return zero).
+	movel	d7,a0		|
+	movel	IMM (0),d6	| use d6-d7 to collect bits flushed right
+	movel	d6,d7		| use d6-d7 to collect bits flushed right
+#ifndef __mcoldfire__
+	cmpw	IMM (1),d4	| if the exponent is less than 1 we
+#else
+	cmpl	IMM (1),d4	| if the exponent is less than 1 we
+#endif
+	bge	2f		| have to shift right (denormalize)
+1:
+#ifndef __mcoldfire__
+	addw	IMM (1),d4	| adjust the exponent
+	lsrl	IMM (1),d0	| shift right once
+	roxrl	IMM (1),d1	|
+	roxrl	IMM (1),d2	|
+	roxrl	IMM (1),d3	|
+	roxrl	IMM (1),d6	|
+	roxrl	IMM (1),d7	|
+	cmpw	IMM (1),d4	| is the exponent 1 already?
+#else
+	addl	IMM (1),d4	| adjust the exponent
+	lsrl	IMM (1),d7
+	btst	IMM (0),d6
+	beq	13f
+	bset	IMM (31),d7
+13:	lsrl	IMM (1),d6
+	btst	IMM (0),d3
+	beq	14f
+	bset	IMM (31),d6
+14:	lsrl	IMM (1),d3
+	btst	IMM (0),d2
+	beq	10f
+	bset	IMM (31),d3
+10:	lsrl	IMM (1),d2
+	btst	IMM (0),d1
+	beq	11f
+	bset	IMM (31),d2
+11:	lsrl	IMM (1),d1
+	btst	IMM (0),d0
+	beq	12f
+	bset	IMM (31),d1
+12:	lsrl	IMM (1),d0
+	cmpl	IMM (1),d4	| is the exponent 1 already?
+#endif
+	beq	2f		| if not loop back
+	bra	1b              |
+	bra	Ld$underflow	| safety check, shouldn't execute
+2:	orl	d6,d2		| this is a trick so we don't lose
+	orl	d7,d3		| the bits which were flushed right
+	movel	a0,d7		| get back sign bit into d7
+| Now call the rounding routine (which takes care of denormalized numbers):
+	PICLEA	SYM (_fpCCR),a0	| check the rounding mode
+#ifdef __mcoldfire__
+	clrl	d6
+#endif
+	movew	a0@(6),d6	| rounding mode in d6
+	lea	pc@(Lround$0),a0 | to return from rounding routine
+	beq	Lround$to$nearest
+#ifndef __mcoldfire__
+	cmpw	IMM (ROUND_TO_PLUS),d6
+#else
+	cmpl	IMM (ROUND_TO_PLUS),d6
+#endif
+	bhi	Lround$to$minus
+	blt	Lround$to$zero
+	bra	Lround$to$plus
+Lround$0:
+| Here we have a correctly rounded result (either normalized or denormalized).
+
+| Here we should have either a normalized number or a denormalized one, and
+| the exponent is necessarily larger or equal to 1 (so we don't have to
+| check again for underflow!). We have to check for overflow or for a
+| denormalized number (which also signals underflow).
+| Check for overflow (i.e., exponent >= 0x7ff).
+#ifndef __mcoldfire__
+	cmpw	IMM (D_MAX_EXP),d4
+#else
+	cmpl	IMM (D_MAX_EXP),d4
+#endif
+	bge	Ld$overflow
+| Now check for a denormalized number (exponent==0):
+	movew	d4,d4
+	beq	Ld$den
+1:
+| Put back the exponents and sign and return.
+#ifndef __mcoldfire__
+	lslw	IMM (4),d4	| exponent back to fourth byte
+#else
+	lsll	IMM (4),d4	| exponent back to fourth byte
+#endif
+	bclr	IMM (DBL_MANT_DIG-32-1),d0
+	swap	d0		| and put back exponent
+#ifndef __mcoldfire__
+	orw	d4,d0		|
+#else
+	orl	d4,d0		|
+#endif
+	swap	d0		|
+	orl	d7,d0		| and sign also
+
+	PICLEA	SYM (_fpCCR),a0
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6
+	rts
+
+|=============================================================================
+|                              __negdf2
+|=============================================================================
+
+| double __negdf2(double, double);
+	FUNC(__negdf2)
+SYM (__negdf2):
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+	moveq	IMM (NEGATE),d5
+	movel	a6@(8),d0	| get number to negate in d0-d1
+	movel	a6@(12),d1	|
+	bchg	IMM (31),d0	| negate
+	movel	d0,d2		| make a positive copy (for the tests)
+	bclr	IMM (31),d2	|
+	movel	d2,d4		| check for zero
+	orl	d1,d4		|
+	beq	2f		| if zero (either sign) return +zero
+	cmpl	IMM (0x7ff00000),d2 | compare to +INFINITY
+	blt	1f		| if finite, return
+	bhi	Ld$inop		| if larger (fraction not zero) is NaN
+	tstl	d1		| if d2 == 0x7ff00000 check d1
+	bne	Ld$inop		|
+	movel	d0,d7		| else get sign and return INFINITY
+	andl	IMM (0x80000000),d7
+	bra	Ld$infty
+1:	PICLEA	SYM (_fpCCR),a0
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6
+	rts
+2:	bclr	IMM (31),d0
+	bra	1b
+
+|=============================================================================
+|                              __cmpdf2
+|=============================================================================
+
+| gcc expects the routines __eqdf2, __nedf2, __gtdf2, __gedf2,
+| __ledf2, __ltdf2 to all return the same value as a direct call to
+| __cmpdf2 would.  In this implementation, each of these routines
+| simply calls __cmpdf2.  It would be more efficient to give the
+| __cmpdf2 routine several names, but separating them out will make it
+| easier to write efficient versions of these routines someday.
+| If the operands recompare unordered unordered __gtdf2 and __gedf2 return -1.
+| The other routines return 1.
+
+	FUNC(__gtdf2)
+	.globl	SYM (__gtdf2)
+SYM (__gtdf2):
+	FUNC(__gedf2)
+	.globl	SYM (__gedf2)
+SYM (__gedf2):
+	lea	LESS,a0
+	jbra SYM(__cmpdf2_internal)
+
+	FUNC(__eqdf2)
+	.globl	SYM (__eqdf2)
+SYM (__eqdf2):
+	FUNC(__nedf2)
+	.globl	SYM (__nedf2)
+SYM (__nedf2):
+	FUNC(__ltdf2)
+	.globl	SYM (__ltdf2)
+SYM (__ltdf2):
+	FUNC(__ledf2)
+	.globl	SYM (__ledf2)
+SYM (__ledf2):
+
+| int __cmpdf2(double, double);
+	FUNC(__cmpdf2)
+SYM (__cmpdf2):
+	lea	GREATER,a0
+
+| int __cmpdf2_internal(double, double, int);
+SYM (__cmpdf2_internal):
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+	moveml	a6@(8),d0-d3	| get first operand into d0-d1, and second operand into d2-d3
+| First check if a and/or b are (+/-) zero and in that case clear
+| the sign bit.
+	movel	d0,d6		| copy signs into d6 (a) and d7(b)
+	bclr	IMM (31),d0	| and clear signs in d0 and d2
+	movel	d2,d7		|
+	bclr	IMM (31),d2	|
+	cmpl	IMM (0x7ff00000),d0 | check for a == NaN
+	bhi	Lcmpdf$inop		| if d0 > 0x7ff00000, a is NaN
+	beq	Lcmpdf$a$nf	| if equal can be INFINITY, so check d1
+	movel	d0,d4		| copy into d4 to test for zero
+	orl	d1,d4		|
+	beq	Lcmpdf$a$0	|
+Lcmpdf$0:
+	cmpl	IMM (0x7ff00000),d2 | check for b == NaN
+	bhi	Lcmpdf$inop		| if d2 > 0x7ff00000, b is NaN
+	beq	Lcmpdf$b$nf	| if equal can be INFINITY, so check d3
+	movel	d2,d4		|
+	orl	d3,d4		|
+	beq	Lcmpdf$b$0	|
+Lcmpdf$1:
+| Check the signs
+	eorl	d6,d7
+	bpl	1f
+| If the signs are not equal check if a >= 0
+	tstl	d6
+	bpl	Lcmpdf$a$gt$b	| if (a >= 0 && b < 0) => a > b
+	bmi	Lcmpdf$b$gt$a	| if (a < 0 && b >= 0) => a < b
+1:
+| If the signs are equal check for < 0
+	tstl	d6
+	bpl	1f
+| If both are negative exchange them
+#ifndef __mcoldfire__
+	exg	d0,d2
+	exg	d1,d3
+#else
+	movel	d0,d7
+	movel	d2,d0
+	movel	d7,d2
+	movel	d1,d7
+	movel	d3,d1
+	movel	d7,d3
+#endif
+1:
+| Now that they are positive we just compare them as longs (does this also
+| work for denormalized numbers?).
+	cmpl	d0,d2
+	bhi	Lcmpdf$b$gt$a	| |b| > |a|
+	bne	Lcmpdf$a$gt$b	| |b| < |a|
+| If we got here d0 == d2, so we compare d1 and d3.
+	cmpl	d1,d3
+	bhi	Lcmpdf$b$gt$a	| |b| > |a|
+	bne	Lcmpdf$a$gt$b	| |b| < |a|
+| If we got here a == b.
+	movel	IMM (EQUAL),d0
+	moveml	sp@,d2-d7/a2-a5 	| put back the registers
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6
+	rts
+Lcmpdf$a$gt$b:
+	movel	IMM (GREATER),d0
+	moveml	sp@,d2-d7/a2-a5 	| put back the registers
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6
+	rts
+Lcmpdf$b$gt$a:
+	movel	IMM (LESS),d0
+	moveml	sp@,d2-d7/a2-a5 	| put back the registers
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6
+	rts
+
+Lcmpdf$a$0:
+	bclr	IMM (31),d6
+	bra	Lcmpdf$0
+Lcmpdf$b$0:
+	bclr	IMM (31),d7
+	bra	Lcmpdf$1
+
+Lcmpdf$a$nf:
+	tstl	d1
+	bne	Lcmpdf$inop
+	bra	Lcmpdf$0
+
+Lcmpdf$b$nf:
+	tstl	d3
+	bne	Lcmpdf$inop
+	bra	Lcmpdf$1
+
+Lcmpdf$inop:
+	movel	a0,d0
+	moveq	IMM (COMPARE),d5
+	moveq	IMM (INEXACT_RESULT+INVALID_OPERATION),d7
+	moveq	IMM (DOUBLE_FLOAT),d6
+	PICJUMP	$_exception_handler
+
+|=============================================================================
+|                           rounding routines
+|=============================================================================
+
+| The rounding routines expect the number to be normalized in registers
+| d0-d1-d2-d3, with the exponent in register d4. They assume that the
+| exponent is larger or equal to 1. They return a properly normalized number
+| if possible, and a denormalized number otherwise. The exponent is returned
+| in d4.
+
+Lround$to$nearest:
+| We now normalize as suggested by D. Knuth ("Seminumerical Algorithms"):
+| Here we assume that the exponent is not too small (this should be checked
+| before entering the rounding routine), but the number could be denormalized.
+
+| Check for denormalized numbers:
+1:	btst	IMM (DBL_MANT_DIG-32),d0
+	bne	2f		| if set the number is normalized
+| Normalize shifting left until bit #DBL_MANT_DIG-32 is set or the exponent
+| is one (remember that a denormalized number corresponds to an
+| exponent of -D_BIAS+1).
+#ifndef __mcoldfire__
+	cmpw	IMM (1),d4	| remember that the exponent is at least one
+#else
+	cmpl	IMM (1),d4	| remember that the exponent is at least one
+#endif
+	beq	2f		| an exponent of one means denormalized
+	addl	d3,d3		| else shift and adjust the exponent
+	addxl	d2,d2		|
+	addxl	d1,d1		|
+	addxl	d0,d0		|
+#ifndef __mcoldfire__
+	dbra	d4,1b		|
+#else
+	subql	IMM (1), d4
+	bpl	1b
+#endif
+2:
+| Now round: we do it as follows: after the shifting we can write the
+| fraction part as f + delta, where 1 < f < 2^25, and 0 <= delta <= 2.
+| If delta < 1, do nothing. If delta > 1, add 1 to f.
+| If delta == 1, we make sure the rounded number will be even (odd?)
+| (after shifting).
+	btst	IMM (0),d1	| is delta < 1?
+	beq	2f		| if so, do not do anything
+	orl	d2,d3		| is delta == 1?
+	bne	1f		| if so round to even
+	movel	d1,d3		|
+	andl	IMM (2),d3	| bit 1 is the last significant bit
+	movel	IMM (0),d2	|
+	addl	d3,d1		|
+	addxl	d2,d0		|
+	bra	2f		|
+1:	movel	IMM (1),d3	| else add 1
+	movel	IMM (0),d2	|
+	addl	d3,d1		|
+	addxl	d2,d0
+| Shift right once (because we used bit #DBL_MANT_DIG-32!).
+2:
+#ifndef __mcoldfire__
+	lsrl	IMM (1),d0
+	roxrl	IMM (1),d1
+#else
+	lsrl	IMM (1),d1
+	btst	IMM (0),d0
+	beq	10f
+	bset	IMM (31),d1
+10:	lsrl	IMM (1),d0
+#endif
+
+| Now check again bit #DBL_MANT_DIG-32 (rounding could have produced a
+| 'fraction overflow' ...).
+	btst	IMM (DBL_MANT_DIG-32),d0
+	beq	1f
+#ifndef __mcoldfire__
+	lsrl	IMM (1),d0
+	roxrl	IMM (1),d1
+	addw	IMM (1),d4
+#else
+	lsrl	IMM (1),d1
+	btst	IMM (0),d0
+	beq	10f
+	bset	IMM (31),d1
+10:	lsrl	IMM (1),d0
+	addl	IMM (1),d4
+#endif
+1:
+| If bit #DBL_MANT_DIG-32-1 is clear we have a denormalized number, so we
+| have to put the exponent to zero and return a denormalized number.
+	btst	IMM (DBL_MANT_DIG-32-1),d0
+	beq	1f
+	jmp	a0@
+1:	movel	IMM (0),d4
+	jmp	a0@
+
+Lround$to$zero:
+Lround$to$plus:
+Lround$to$minus:
+	jmp	a0@
+#endif /* L_double */
+
+#ifdef  L_float
+
+|=============================================================================
+|=============================================================================
+|                         single precision routines
+|=============================================================================
+|=============================================================================
+
+| A single precision floating point number (float) has the format:
+|
+| struct _float {
+|  unsigned int sign      : 1;  /* sign bit */
+|  unsigned int exponent  : 8;  /* exponent, shifted by 126 */
+|  unsigned int fraction  : 23; /* fraction */
+| } float;
+|
+| Thus sizeof(float) = 4 (32 bits).
+|
+| All the routines are callable from C programs, and return the result
+| in the single register d0. They also preserve all registers except
+| d0-d1 and a0-a1.
+
+	.globl	SYM (_fpCCR)
+	.globl  $_exception_handler
+
+QUIET_NaN    = 0xffffffff
+SIGNL_NaN    = 0x7f800001
+INFINITY     = 0x7f800000
+
+F_MAX_EXP      = 0xff
+F_BIAS         = 126
+FLT_MAX_EXP    = F_MAX_EXP - F_BIAS
+FLT_MIN_EXP    = 1 - F_BIAS
+FLT_MANT_DIG   = 24
+
+| Entry points:
+
+	.globl SYM (__addsf3)
+	.globl SYM (__subsf3)
+	.globl SYM (__mulsf3)
+	.globl SYM (__divsf3)
+	.globl SYM (__negsf2)
+	.globl SYM (__cmpsf2)
+
+| These are common routines to return and signal exceptions.
+
+	.text
+	.even
+
+Lf$den:
+| Return and signal a denormalized number
+	orl	d7,d0
+	moveq	IMM (INEXACT_RESULT+UNDERFLOW),d7
+	moveq	IMM (SINGLE_FLOAT),d6
+	PICJUMP	$_exception_handler
+
+Lf$infty:
+Lf$overflow:
+| Return a properly signed INFINITY and set the exception flags
+	movel	IMM (INFINITY),d0
+	orl	d7,d0
+	moveq	IMM (INEXACT_RESULT+OVERFLOW),d7
+	moveq	IMM (SINGLE_FLOAT),d6
+	PICJUMP	$_exception_handler
+
+Lf$underflow:
+| Return 0 and set the exception flags
+	moveq	IMM (0),d0
+	moveq	IMM (INEXACT_RESULT+UNDERFLOW),d7
+	moveq	IMM (SINGLE_FLOAT),d6
+	PICJUMP	$_exception_handler
+
+Lf$inop:
+| Return a quiet NaN and set the exception flags
+	movel	IMM (QUIET_NaN),d0
+	moveq	IMM (INEXACT_RESULT+INVALID_OPERATION),d7
+	moveq	IMM (SINGLE_FLOAT),d6
+	PICJUMP	$_exception_handler
+
+Lf$div$0:
+| Return a properly signed INFINITY and set the exception flags
+	movel	IMM (INFINITY),d0
+	orl	d7,d0
+	moveq	IMM (INEXACT_RESULT+DIVIDE_BY_ZERO),d7
+	moveq	IMM (SINGLE_FLOAT),d6
+	PICJUMP	$_exception_handler
+
+|=============================================================================
+|                              __subsf3
+|=============================================================================
+
+| float __subsf3(float, float);
+	FUNC(__subsf3)
+SYM (__subsf3):
+#ifdef __FASTCALL__
+	bchg	IMM (31),d1   	| change sign of second operand
+				| and fall through
+#else
+	bchg	IMM (31),sp@(8)	| change sign of second operand
+				| and fall through
+#endif
+
+|=============================================================================
+|                              __addsf3
+|=============================================================================
+
+| float __addsf3(float, float);
+	FUNC(__addsf3)
+SYM (__addsf3):
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+#ifndef __FASTCALL__
+	movel	a6@(8),d0	| get first operand
+	movel	a6@(12),d1	| get second operand
+#endif
+	movel	d0,a2		| store first operand
+	movel	d1,a3		| store second operand
+	movel	d0,a0		| get d0's sign bit
+	addl	d0,d0		| check and clear sign bit of a
+	beq	Laddsf$b	| if zero return second operand
+	movel	d1,a1		| save b's sign bit
+	addl	d1,d1		| get rid of sign bit
+	beq	Laddsf$a	| if zero return first operand
+
+| Get the exponents and check for denormalized and/or infinity.
+
+	movel	IMM (0x00ffffff),d4	| mask to get fraction
+	movel	IMM (0x01000000),d5	| mask to put hidden bit back
+
+	movel	d0,d6		| save a to get exponent
+	andl	d4,d0		| get fraction in d0
+	notl 	d4		| make d4 into a mask for the exponent
+	andl	d4,d6		| get exponent in d6
+	beq	Laddsf$a$den	| branch if a is denormalized
+	cmpl	d4,d6		| check for INFINITY or NaN
+	beq	Laddsf$nf
+	swap	d6		| put exponent into first word
+	orl	d5,d0		| and put hidden bit back
+Laddsf$1:
+| Now we have a's exponent in d6 (second byte) and the mantissa in d0.
+	movel	d1,d7		| get exponent in d7
+	andl	d4,d7		|
+	beq	Laddsf$b$den	| branch if b is denormalized
+	cmpl	d4,d7		| check for INFINITY or NaN
+	beq	Laddsf$nf
+	swap	d7		| put exponent into first word
+	notl 	d4		| make d4 into a mask for the fraction
+	andl	d4,d1		| get fraction in d1
+	orl	d5,d1		| and put hidden bit back
+Laddsf$2:
+| Now we have b's exponent in d7 (second byte) and the mantissa in d1.
+
+| Note that the hidden bit corresponds to bit #FLT_MANT_DIG-1, and we
+| shifted right once, so bit #FLT_MANT_DIG is set (so we have one extra
+| bit).
+
+	movel	d1,d2		| move b to d2, since we want to use
+				| two registers to do the sum
+	movel	IMM (0),d1	| and clear the new ones
+	movel	d1,d3		|
+
+| Here we shift the numbers in registers d0 and d1 so the exponents are the
+| same, and put the largest exponent in d6. Note that we are using two
+| registers for each number (see the discussion by D. Knuth in "Seminumerical
+| Algorithms").
+#ifndef __mcoldfire__
+	cmpw	d6,d7		| compare exponents
+#else
+	cmpl	d6,d7		| compare exponents
+#endif
+	beq	Laddsf$3	| if equal don't shift
+	bhi	5f		| branch if second exponent largest
+1:
+	subl	d6,d7		| keep the largest exponent
+	negl	d7
+#ifndef __mcoldfire__
+	lsrw	IMM (8),d7	| put difference in lower byte
+#else
+	lsrl	IMM (8),d7	| put difference in lower byte
+#endif
+| if difference is too large we don't shift (actually, we can just exit)
+#ifndef __mcoldfire__
+	cmpw	IMM (FLT_MANT_DIG+2),d7
+#else
+	cmpl	IMM (FLT_MANT_DIG+2),d7
+#endif
+	bge	Laddsf$b$small
+#ifndef __mcoldfire__
+	cmpw	IMM (16),d7	| if difference >= 16 swap
+#else
+	cmpl	IMM (16),d7	| if difference >= 16 swap
+#endif
+	bge	4f
+2:
+#ifndef __mcoldfire__
+	subw	IMM (1),d7
+#else
+	subql	IMM (1), d7
+#endif
+3:
+#ifndef __mcoldfire__
+	lsrl	IMM (1),d2	| shift right second operand
+	roxrl	IMM (1),d3
+	dbra	d7,3b
+#else
+	lsrl	IMM (1),d3
+	btst	IMM (0),d2
+	beq	10f
+	bset	IMM (31),d3
+10:	lsrl	IMM (1),d2
+	subql	IMM (1), d7
+	bpl	3b
+#endif
+	bra	Laddsf$3
+4:
+	movew	d2,d3
+	swap	d3
+	movew	d3,d2
+	swap	d2
+#ifndef __mcoldfire__
+	subw	IMM (16),d7
+#else
+	subl	IMM (16),d7
+#endif
+	bne	2b		| if still more bits, go back to normal case
+	bra	Laddsf$3
+5:
+#ifndef __mcoldfire__
+	exg	d6,d7		| exchange the exponents
+#else
+	eorl	d6,d7
+	eorl	d7,d6
+	eorl	d6,d7
+#endif
+	subl	d6,d7		| keep the largest exponent
+	negl	d7		|
+#ifndef __mcoldfire__
+	lsrw	IMM (8),d7	| put difference in lower byte
+#else
+	lsrl	IMM (8),d7	| put difference in lower byte
+#endif
+| if difference is too large we don't shift (and exit!)
+#ifndef __mcoldfire__
+	cmpw	IMM (FLT_MANT_DIG+2),d7
+#else
+	cmpl	IMM (FLT_MANT_DIG+2),d7
+#endif
+	bge	Laddsf$a$small
+#ifndef __mcoldfire__
+	cmpw	IMM (16),d7	| if difference >= 16 swap
+#else
+	cmpl	IMM (16),d7	| if difference >= 16 swap
+#endif
+	bge	8f
+6:
+#ifndef __mcoldfire__
+	subw	IMM (1),d7
+#else
+	subl	IMM (1),d7
+#endif
+7:
+#ifndef __mcoldfire__
+	lsrl	IMM (1),d0	| shift right first operand
+	roxrl	IMM (1),d1
+	dbra	d7,7b
+#else
+	lsrl	IMM (1),d1
+	btst	IMM (0),d0
+	beq	10f
+	bset	IMM (31),d1
+10:	lsrl	IMM (1),d0
+	subql	IMM (1),d7
+	bpl	7b
+#endif
+	bra	Laddsf$3
+8:
+	movew	d0,d1
+	swap	d1
+	movew	d1,d0
+	swap	d0
+#ifndef __mcoldfire__
+	subw	IMM (16),d7
+#else
+	subl	IMM (16),d7
+#endif
+	bne	6b		| if still more bits, go back to normal case
+				| otherwise we fall through
+
+| Now we have a in d0-d1, b in d2-d3, and the largest exponent in d6 (the
+| signs are stored in a0 and a1).
+
+Laddsf$3:
+| Here we have to decide whether to add or subtract the numbers
+#ifndef __mcoldfire__
+	exg	d6,a0		| get signs back
+	exg	d7,a1		| and save the exponents
+#else
+	movel	d6,d4
+	movel	a0,d6
+	movel	d4,a0
+	movel	d7,d4
+	movel	a1,d7
+	movel	d4,a1
+#endif
+	eorl	d6,d7		| combine sign bits
+	bmi	Lsubsf$0	| if negative a and b have opposite
+				| sign so we actually subtract the
+				| numbers
+
+| Here we have both positive or both negative
+#ifndef __mcoldfire__
+	exg	d6,a0		| now we have the exponent in d6
+#else
+	movel	d6,d4
+	movel	a0,d6
+	movel	d4,a0
+#endif
+	movel	a0,d7		| and sign in d7
+	andl	IMM (0x80000000),d7
+| Here we do the addition.
+	addl	d3,d1
+	addxl	d2,d0
+| Note: now we have d2, d3, d4 and d5 to play with!
+
+| Put the exponent, in the first byte, in d2, to use the "standard" rounding
+| routines:
+	movel	d6,d2
+#ifndef __mcoldfire__
+	lsrw	IMM (8),d2
+#else
+	lsrl	IMM (8),d2
+#endif
+
+| Before rounding normalize so bit #FLT_MANT_DIG is set (we will consider
+| the case of denormalized numbers in the rounding routine itself).
+| As in the addition (not in the subtraction!) we could have set
+| one more bit we check this:
+	btst	IMM (FLT_MANT_DIG+1),d0
+	beq	1f
+#ifndef __mcoldfire__
+	lsrl	IMM (1),d0
+	roxrl	IMM (1),d1
+#else
+	lsrl	IMM (1),d1
+	btst	IMM (0),d0
+	beq	10f
+	bset	IMM (31),d1
+10:	lsrl	IMM (1),d0
+#endif
+	addl	IMM (1),d2
+1:
+	PICLEA	SYM (_fpCCR),a0	| check the rounding mode
+#ifdef __mcoldfire__
+	clrl	d6
+#endif
+	movew	a0@(6),d6	| ROUND rounding mode in d6
+	lea	pc@(Laddsf$4),a0 | to return from rounding routine
+	beq	Lround$to$nearest
+#ifndef __mcoldfire__
+	cmpw	IMM (ROUND_TO_PLUS),d6
+#else
+	cmpl	IMM (ROUND_TO_PLUS),d6
+#endif
+	bhi	Lround$to$minus
+	blt	Lround$to$zero
+	bra	Lround$to$plus
+Laddsf$4:
+| Put back the exponent, but check for overflow.
+#ifndef __mcoldfire__
+	cmpw	IMM (F_MAX_EXP),d2
+#else
+	cmpl	IMM (F_MAX_EXP),d2
+#endif
+	bhi	1f
+	bclr	IMM (FLT_MANT_DIG-1),d0
+#ifndef __mcoldfire__
+	lslw	IMM (7),d2
+#else
+	lsll	IMM (7),d2
+#endif
+	swap	d2
+	orl	d2,d0
+	bra	Laddsf$ret
+1:
+	moveq	IMM (ADD),d5
+	bra	Lf$overflow
+
+Lsubsf$0:
+| We are here if a > 0 and b < 0 (sign bits cleared).
+| Here we do the subtraction.
+	movel	d6,d7		| put sign in d7
+	andl	IMM (0x80000000),d7
+
+	subl	d3,d1		| result in d0-d1
+	subxl	d2,d0		|
+	beq	Laddsf$ret	| if zero just exit
+	bpl	1f		| if positive skip the following
+	bchg	IMM (31),d7	| change sign bit in d7
+	negl	d1
+	negxl	d0
+1:
+#ifndef __mcoldfire__
+	exg	d2,a0		| now we have the exponent in d2
+	lsrw	IMM (8),d2	| put it in the first byte
+#else
+	movel	d2,d4
+	movel	a0,d2
+	movel	d4,a0
+	lsrl	IMM (8),d2	| put it in the first byte
+#endif
+
+| Now d0-d1 is positive and the sign bit is in d7.
+
+| Note that we do not have to normalize, since in the subtraction bit
+| #FLT_MANT_DIG+1 is never set, and denormalized numbers are handled by
+| the rounding routines themselves.
+	PICLEA	SYM (_fpCCR),a0	| check the rounding mode
+#ifdef __mcoldfire__
+	clrl	d6
+#endif
+	movew	a0@(6),d6	| rounding mode in d6
+	lea	pc@(Lsubsf$1),a0 | to return from rounding routine
+	beq	Lround$to$nearest
+#ifndef __mcoldfire__
+	cmpw	IMM (ROUND_TO_PLUS),d6
+#else
+	cmpl	IMM (ROUND_TO_PLUS),d6
+#endif
+	bhi	Lround$to$minus
+	blt	Lround$to$zero
+	bra	Lround$to$plus
+Lsubsf$1:
+| Put back the exponent (we can't have overflow!).
+	bclr	IMM (FLT_MANT_DIG-1),d0
+#ifndef __mcoldfire__
+	lslw	IMM (7),d2
+#else
+	lsll	IMM (7),d2
+#endif
+	swap	d2
+	orl	d2,d0
+	bra	Laddsf$ret
+
+| If one of the numbers was too small (difference of exponents >=
+| FLT_MANT_DIG+2) we return the other (and now we don't have to
+| check for finiteness or zero).
+Laddsf$a$small:
+	movel	a3,d0
+	PICLEA	SYM (_fpCCR),a0
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6
+	rts		| and return
+
+Laddsf$b$small:
+	movel	a2,d0
+	PICLEA	SYM (_fpCCR),a0
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6
+	rts		| and return
+
+| If the numbers are denormalized remember to put exponent equal to 1.
+
+Laddsf$a$den:
+	movel	d5,d6		| d5 contains 0x01000000
+	swap	d6
+	bra	Laddsf$1
+
+Laddsf$b$den:
+	movel	d5,d7
+	swap	d7
+	notl 	d4		| make d4 into a mask for the fraction
+				| (this was not executed after the jump)
+	bra	Laddsf$2
+
+| The rest is mainly code for the different results which can be
+| returned (checking always for +/-INFINITY and NaN).
+
+Laddsf$b:
+| Return b (if a is zero).
+	movel	a3,d0
+	cmpl	IMM (0x80000000),d0	| Check if b is -0
+	bne	1f
+	movel	a0,d7
+	andl	IMM (0x80000000),d7	| Use the sign of a
+	clrl	d0
+	bra	Laddsf$ret
+Laddsf$a:
+| Return a (if b is zero).
+	movel	a2,d0
+1:
+	moveq	IMM (ADD),d5
+| We have to check for NaN and +/-infty.
+	movel	d0,d7
+	andl	IMM (0x80000000),d7	| put sign in d7
+	bclr	IMM (31),d0		| clear sign
+	cmpl	IMM (INFINITY),d0	| check for infty or NaN
+	bge	2f
+	movel	d0,d0		| check for zero (we do this because we don't
+	bne	Laddsf$ret	| want to return -0 by mistake
+	bclr	IMM (31),d7	| if zero be sure to clear sign
+	bra	Laddsf$ret	| if everything OK just return
+2:
+| The value to be returned is either +/-infty or NaN
+	andl	IMM (0x007fffff),d0	| check for NaN
+	bne	Lf$inop			| if mantissa not zero is NaN
+	bra	Lf$infty
+
+Laddsf$ret:
+| Normal exit (a and b nonzero, result is not NaN nor +/-infty).
+| We have to clear the exception flags (just the exception type).
+	PICLEA	SYM (_fpCCR),a0
+	clrw	a0@
+	orl	d7,d0		| put sign bit
+	moveml	sp@,d2-d7/a2-a5	| restore data registers
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6
+	rts		| and return
+
+Laddsf$ret$den:
+| Return a denormalized number (for addition we don't signal underflow)
+	lsrl	IMM (1),d0	| remember to shift right back once
+	bra	Laddsf$ret	| and return
+
+| Note: when adding two floats of the same sign if either one is
+| NaN we return NaN without regard to whether the other is finite or
+| not. When subtracting them (i.e., when adding two numbers of
+| opposite signs) things are more complicated: if both are INFINITY
+| we return NaN, if only one is INFINITY and the other is NaN we return
+| NaN, but if it is finite we return INFINITY with the corresponding sign.
+
+Laddsf$nf:
+	moveq	IMM (ADD),d5
+| This could be faster but it is not worth the effort, since it is not
+| executed very often. We sacrifice speed for clarity here.
+	movel	a2,d0	| get the numbers back (remember that we
+	movel	a3,d1	| did some processing already)
+	movel	IMM (INFINITY),d4 | useful constant (INFINITY)
+	movel	d0,d2		| save sign bits
+	movel	d0,d7		| into d7 as well as we may need the sign
+				| bit before jumping to Lf$infty
+	movel	d1,d3
+	bclr	IMM (31),d0	| clear sign bits
+	bclr	IMM (31),d1
+| We know that one of them is either NaN of +/-INFINITY
+| Check for NaN (if either one is NaN return NaN)
+	cmpl	d4,d0		| check first a (d0)
+	bhi	Lf$inop
+	cmpl	d4,d1		| check now b (d1)
+	bhi	Lf$inop
+| Now comes the check for +/-INFINITY. We know that both are (maybe not
+| finite) numbers, but we have to check if both are infinite whether we
+| are adding or subtracting them.
+	eorl	d3,d2		| to check sign bits
+	bmi	1f
+	andl	IMM (0x80000000),d7	| get (common) sign bit
+	bra	Lf$infty
+1:
+| We know one (or both) are infinite, so we test for equality between the
+| two numbers (if they are equal they have to be infinite both, so we
+| return NaN).
+	cmpl	d1,d0		| are both infinite?
+	beq	Lf$inop		| if so return NaN
+
+	andl	IMM (0x80000000),d7 | get a's sign bit
+	cmpl	d4,d0		| test now for infinity
+	beq	Lf$infty	| if a is INFINITY return with this sign
+	bchg	IMM (31),d7	| else we know b is INFINITY and has
+	bra	Lf$infty	| the opposite sign
+
+|=============================================================================
+|                             __mulsf3
+|=============================================================================
+
+| float __mulsf3(float, float);
+	FUNC(__mulsf3)
+SYM (__mulsf3):
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+#ifndef __FASTCALL__
+	movel	a6@(8),d0	| get a into d0
+	movel	a6@(12),d1	| and b into d1
+#endif
+	movel	d0,a2		| store a into a0
+	movel	d1,a3		| store b into a1
+	movel	d0,d7		| d7 will hold the sign of the product
+	eorl	d1,d7		|
+	andl	IMM (0x80000000),d7
+	movel	IMM (INFINITY),d6	| useful constant (+INFINITY)
+	movel	d6,d5			| another (mask for fraction)
+	notl	d5			|
+	movel	IMM (0x00800000),d4	| this is to put hidden bit back
+	bclr	IMM (31),d0		| get rid of a's sign bit
+	movel	d0,d2			|
+	beq	Lmulsf$a$0		| branch if a is zero
+	bclr	IMM (31),d1		| get rid of b's sign bit
+	movel	d1,d3		|
+	beq	Lmulsf$b$0	| branch if b is zero
+	cmpl	d6,d0		| is a big?
+	bhi	Lmulsf$inop	| if a is NaN return NaN
+	beq	Lmulsf$inf	| if a is INFINITY we have to check b
+	cmpl	d6,d1		| now compare b with INFINITY
+	bhi	Lmulsf$inop	| is b NaN?
+	beq	Lmulsf$overflow | is b INFINITY?
+| Here we have both numbers finite and nonzero (and with no sign bit).
+| Now we get the exponents into d2 and d3.
+	andl	d6,d2		| and isolate exponent in d2
+	beq	Lmulsf$a$den	| if exponent is zero we have a denormalized
+	andl	d5,d0		| and isolate fraction
+	orl	d4,d0		| and put hidden bit back
+	swap	d2		| I like exponents in the first byte
+#ifndef __mcoldfire__
+	lsrw	IMM (7),d2	|
+#else
+	lsrl	IMM (7),d2	|
+#endif
+Lmulsf$1:			| number
+	andl	d6,d3		|
+	beq	Lmulsf$b$den	|
+	andl	d5,d1		|
+	orl	d4,d1		|
+	swap	d3		|
+#ifndef __mcoldfire__
+	lsrw	IMM (7),d3	|
+#else
+	lsrl	IMM (7),d3	|
+#endif
+Lmulsf$2:			|
+#ifndef __mcoldfire__
+	addw	d3,d2		| add exponents
+	subw	IMM (F_BIAS+1),d2 | and subtract bias (plus one)
+#else
+	addl	d3,d2		| add exponents
+	subl	IMM (F_BIAS+1),d2 | and subtract bias (plus one)
+#endif
+
+| We are now ready to do the multiplication. The situation is as follows:
+| both a and b have bit FLT_MANT_DIG-1 set (even if they were
+| denormalized to start with!), which means that in the product
+| bit 2*(FLT_MANT_DIG-1) (that is, bit 2*FLT_MANT_DIG-2-32 of the
+| high long) is set.
+
+| To do the multiplication let us move the number a little bit around ...
+	movel	d1,d6		| second operand in d6
+	movel	d0,d5		| first operand in d4-d5
+	movel	IMM (0),d4
+	movel	d4,d1		| the sums will go in d0-d1
+	movel	d4,d0
+
+| now bit FLT_MANT_DIG-1 becomes bit 31:
+	lsll	IMM (31-FLT_MANT_DIG+1),d6
+
+| Start the loop (we loop #FLT_MANT_DIG times):
+	moveq	IMM (FLT_MANT_DIG-1),d3
+1:	addl	d1,d1		| shift sum
+	addxl	d0,d0
+	lsll	IMM (1),d6	| get bit bn
+	bcc	2f		| if not set skip sum
+	addl	d5,d1		| add a
+	addxl	d4,d0
+2:
+#ifndef __mcoldfire__
+	dbf	d3,1b		| loop back
+#else
+	subql	IMM (1),d3
+	bpl	1b
+#endif
+
+| Now we have the product in d0-d1, with bit (FLT_MANT_DIG - 1) + FLT_MANT_DIG
+| (mod 32) of d0 set. The first thing to do now is to normalize it so bit
+| FLT_MANT_DIG is set (to do the rounding).
+#ifndef __mcoldfire__
+	rorl	IMM (6),d1
+	swap	d1
+	movew	d1,d3
+	andw	IMM (0x03ff),d3
+	andw	IMM (0xfd00),d1
+#else
+	movel	d1,d3
+	lsll	IMM (8),d1
+	addl	d1,d1
+	addl	d1,d1
+	moveq	IMM (22),d5
+	lsrl	d5,d3
+	orl	d3,d1
+	andl	IMM (0xfffffd00),d1
+#endif
+	lsll	IMM (8),d0
+	addl	d0,d0
+	addl	d0,d0
+#ifndef __mcoldfire__
+	orw	d3,d0
+#else
+	orl	d3,d0
+#endif
+
+	moveq	IMM (MULTIPLY),d5
+
+	btst	IMM (FLT_MANT_DIG+1),d0
+	beq	Lround$exit
+#ifndef __mcoldfire__
+	lsrl	IMM (1),d0
+	roxrl	IMM (1),d1
+	addw	IMM (1),d2
+#else
+	lsrl	IMM (1),d1
+	btst	IMM (0),d0
+	beq	10f
+	bset	IMM (31),d1
+10:	lsrl	IMM (1),d0
+	addql	IMM (1),d2
+#endif
+	bra	Lround$exit
+
+Lmulsf$inop:
+	moveq	IMM (MULTIPLY),d5
+	bra	Lf$inop
+
+Lmulsf$overflow:
+	moveq	IMM (MULTIPLY),d5
+	bra	Lf$overflow
+
+Lmulsf$inf:
+	moveq	IMM (MULTIPLY),d5
+| If either is NaN return NaN; else both are (maybe infinite) numbers, so
+| return INFINITY with the correct sign (which is in d7).
+	cmpl	d6,d1		| is b NaN?
+	bhi	Lf$inop		| if so return NaN
+	bra	Lf$overflow	| else return +/-INFINITY
+
+| If either number is zero return zero, unless the other is +/-INFINITY,
+| or NaN, in which case we return NaN.
+Lmulsf$b$0:
+| Here d1 (==b) is zero.
+	movel	a2,d1		| get a again to check for non-finiteness
+	bra	1f
+Lmulsf$a$0:
+	movel	a3,d1	| get b again to check for non-finiteness
+1:	bclr	IMM (31),d1	| clear sign bit
+	cmpl	IMM (INFINITY),d1 | and check for a large exponent
+	bge	Lf$inop		| if b is +/-INFINITY or NaN return NaN
+	movel	d7,d0		| else return signed zero
+	PICLEA	SYM (_fpCCR),a0	|
+	clrw	a0@	|
+	moveml	sp@,d2-d7/a2-a5
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6		|
+	rts			|
+
+| If a number is denormalized we put an exponent of 1 but do not put the
+| hidden bit back into the fraction; instead we shift left until bit 23
+| (the hidden bit) is set, adjusting the exponent accordingly. We do this
+| to ensure that the product of the fractions is close to 1.
+Lmulsf$a$den:
+	movel	IMM (1),d2
+	andl	d5,d0
+1:	addl	d0,d0		| shift a left (until bit 23 is set)
+#ifndef __mcoldfire__
+	subw	IMM (1),d2	| and adjust exponent
+#else
+	subql	IMM (1),d2	| and adjust exponent
+#endif
+	btst	IMM (FLT_MANT_DIG-1),d0
+	bne	Lmulsf$1	|
+	bra	1b		| else loop back
+
+Lmulsf$b$den:
+	movel	IMM (1),d3
+	andl	d5,d1
+1:	addl	d1,d1		| shift b left until bit 23 is set
+#ifndef __mcoldfire__
+	subw	IMM (1),d3	| and adjust exponent
+#else
+	subql	IMM (1),d3	| and adjust exponent
+#endif
+	btst	IMM (FLT_MANT_DIG-1),d1
+	bne	Lmulsf$2	|
+	bra	1b		| else loop back
+
+|=============================================================================
+|                             __divsf3
+|=============================================================================
+
+| float __divsf3(float, float);
+	FUNC(__divsf3)
+SYM (__divsf3):
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+#ifndef __FASTCALL
+	movel	a6@(8),d0		| get a into d0
+	movel	a6@(12),d1		| and b into d1
+#endif
+	movel	d0,d7			| d7 will hold the sign of the result
+	eorl	d1,d7			|
+	andl	IMM (0x80000000),d7	|
+	movel	IMM (INFINITY),d6	| useful constant (+INFINITY)
+	movel	d6,d5			| another (mask for fraction)
+	notl	d5			|
+	movel	IMM (0x00800000),d4	| this is to put hidden bit back
+	bclr	IMM (31),d0		| get rid of a's sign bit
+	movel	d0,d2			|
+	beq	Ldivsf$a$0		| branch if a is zero
+	bclr	IMM (31),d1		| get rid of b's sign bit
+	movel	d1,d3			|
+	beq	Ldivsf$b$0		| branch if b is zero
+	cmpl	d6,d0			| is a big?
+	bhi	Ldivsf$inop		| if a is NaN return NaN
+	beq	Ldivsf$inf		| if a is INFINITY we have to check b
+	cmpl	d6,d1			| now compare b with INFINITY
+	bhi	Ldivsf$inop		| if b is NaN return NaN
+	beq	Ldivsf$underflow
+| Here we have both numbers finite and nonzero (and with no sign bit).
+| Now we get the exponents into d2 and d3 and normalize the numbers to
+| ensure that the ratio of the fractions is close to 1. We do this by
+| making sure that bit #FLT_MANT_DIG-1 (hidden bit) is set.
+	andl	d6,d2		| and isolate exponent in d2
+	beq	Ldivsf$a$den	| if exponent is zero we have a denormalized
+	andl	d5,d0		| and isolate fraction
+	orl	d4,d0		| and put hidden bit back
+	swap	d2		| I like exponents in the first byte
+#ifndef __mcoldfire__
+	lsrw	IMM (7),d2	|
+#else
+	lsrl	IMM (7),d2	|
+#endif
+Ldivsf$1:			|
+	andl	d6,d3		|
+	beq	Ldivsf$b$den	|
+	andl	d5,d1		|
+	orl	d4,d1		|
+	swap	d3		|
+#ifndef __mcoldfire__
+	lsrw	IMM (7),d3	|
+#else
+	lsrl	IMM (7),d3	|
+#endif
+Ldivsf$2:			|
+#ifndef __mcoldfire__
+	subw	d3,d2		| subtract exponents
+ 	addw	IMM (F_BIAS),d2	| and add bias
+#else
+	subl	d3,d2		| subtract exponents
+ 	addl	IMM (F_BIAS),d2	| and add bias
+#endif
+
+| We are now ready to do the division. We have prepared things in such a way
+| that the ratio of the fractions will be less than 2 but greater than 1/2.
+| At this point the registers in use are:
+| d0	holds a (first operand, bit FLT_MANT_DIG=0, bit FLT_MANT_DIG-1=1)
+| d1	holds b (second operand, bit FLT_MANT_DIG=1)
+| d2	holds the difference of the exponents, corrected by the bias
+| d7	holds the sign of the ratio
+| d4, d5, d6 hold some constants
+	movel	d7,a0		| d6-d7 will hold the ratio of the fractions
+	movel	IMM (0),d6	|
+	movel	d6,d7
+
+	moveq	IMM (FLT_MANT_DIG+1),d3
+1:	cmpl	d0,d1		| is a < b?
+	bhi	2f		|
+	bset	d3,d6		| set a bit in d6
+	subl	d1,d0		| if a >= b  a <-- a-b
+	beq	3f		| if a is zero, exit
+2:	addl	d0,d0		| multiply a by 2
+#ifndef __mcoldfire__
+	dbra	d3,1b
+#else
+	subql	IMM (1),d3
+	bpl	1b
+#endif
+
+| Now we keep going to set the sticky bit ...
+	moveq	IMM (FLT_MANT_DIG),d3
+1:	cmpl	d0,d1
+	ble	2f
+	addl	d0,d0
+#ifndef __mcoldfire__
+	dbra	d3,1b
+#else
+	subql	IMM(1),d3
+	bpl	1b
+#endif
+	movel	IMM (0),d1
+	bra	3f
+2:	movel	IMM (0),d1
+#ifndef __mcoldfire__
+	subw	IMM (FLT_MANT_DIG),d3
+	addw	IMM (31),d3
+#else
+	subl	IMM (FLT_MANT_DIG),d3
+	addl	IMM (31),d3
+#endif
+	bset	d3,d1
+3:
+	movel	d6,d0		| put the ratio in d0-d1
+	movel	a0,d7		| get sign back
+
+| Because of the normalization we did before we are guaranteed that
+| d0 is smaller than 2^26 but larger than 2^24. Thus bit 26 is not set,
+| bit 25 could be set, and if it is not set then bit 24 is necessarily set.
+	btst	IMM (FLT_MANT_DIG+1),d0
+	beq	1f              | if it is not set, then bit 24 is set
+	lsrl	IMM (1),d0	|
+#ifndef __mcoldfire__
+	addw	IMM (1),d2	|
+#else
+	addl	IMM (1),d2	|
+#endif
+1:
+| Now round, check for over- and underflow, and exit.
+	moveq	IMM (DIVIDE),d5
+	bra	Lround$exit
+
+Ldivsf$inop:
+	moveq	IMM (DIVIDE),d5
+	bra	Lf$inop
+
+Ldivsf$overflow:
+	moveq	IMM (DIVIDE),d5
+	bra	Lf$overflow
+
+Ldivsf$underflow:
+	moveq	IMM (DIVIDE),d5
+	bra	Lf$underflow
+
+Ldivsf$a$0:
+	moveq	IMM (DIVIDE),d5
+| If a is zero check to see whether b is zero also. In that case return
+| NaN; then check if b is NaN, and return NaN also in that case. Else
+| return a properly signed zero.
+	andl	IMM (0x7fffffff),d1	| clear sign bit and test b
+	beq	Lf$inop			| if b is also zero return NaN
+	cmpl	IMM (INFINITY),d1	| check for NaN
+	bhi	Lf$inop			|
+	movel	d7,d0			| else return signed zero
+	PICLEA	SYM (_fpCCR),a0		|
+	clrw	a0@		|
+	moveml	sp@,d2-d7/a2-a5		|
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6			|
+	rts				|
+
+Ldivsf$b$0:
+	moveq	IMM (DIVIDE),d5
+| If we got here a is not zero. Check if a is NaN; in that case return NaN,
+| else return +/-INFINITY. Remember that a is in d0 with the sign bit
+| cleared already.
+	cmpl	IMM (INFINITY),d0	| compare d0 with INFINITY
+	bhi	Lf$inop			| if larger it is NaN
+	bra	Lf$div$0		| else signal DIVIDE_BY_ZERO
+
+Ldivsf$inf:
+	moveq	IMM (DIVIDE),d5
+| If a is INFINITY we have to check b
+	cmpl	IMM (INFINITY),d1	| compare b with INFINITY
+	bge	Lf$inop			| if b is NaN or INFINITY return NaN
+	bra	Lf$overflow		| else return overflow
+
+| If a number is denormalized we put an exponent of 1 but do not put the
+| bit back into the fraction.
+Ldivsf$a$den:
+	movel	IMM (1),d2
+	andl	d5,d0
+1:	addl	d0,d0		| shift a left until bit FLT_MANT_DIG-1 is set
+#ifndef __mcoldfire__
+	subw	IMM (1),d2	| and adjust exponent
+#else
+	subl	IMM (1),d2	| and adjust exponent
+#endif
+	btst	IMM (FLT_MANT_DIG-1),d0
+	bne	Ldivsf$1
+	bra	1b
+
+Ldivsf$b$den:
+	movel	IMM (1),d3
+	andl	d5,d1
+1:	addl	d1,d1		| shift b left until bit FLT_MANT_DIG is set
+#ifndef __mcoldfire__
+	subw	IMM (1),d3	| and adjust exponent
+#else
+	subl	IMM (1),d3	| and adjust exponent
+#endif
+	btst	IMM (FLT_MANT_DIG-1),d1
+	bne	Ldivsf$2
+	bra	1b
+
+Lround$exit:
+| This is a common exit point for __mulsf3 and __divsf3.
+
+| First check for underlow in the exponent:
+#ifndef __mcoldfire__
+	cmpw	IMM (-FLT_MANT_DIG-1),d2
+#else
+	cmpl	IMM (-FLT_MANT_DIG-1),d2
+#endif
+	blt	Lf$underflow
+| It could happen that the exponent is less than 1, in which case the
+| number is denormalized. In this case we shift right and adjust the
+| exponent until it becomes 1 or the fraction is zero (in the latter case
+| we signal underflow and return zero).
+	movel	IMM (0),d6	| d6 is used temporarily
+#ifndef __mcoldfire__
+	cmpw	IMM (1),d2	| if the exponent is less than 1 we
+#else
+	cmpl	IMM (1),d2	| if the exponent is less than 1 we
+#endif
+	bge	2f		| have to shift right (denormalize)
+1:
+#ifndef __mcoldfire__
+	addw	IMM (1),d2	| adjust the exponent
+	lsrl	IMM (1),d0	| shift right once
+	roxrl	IMM (1),d1	|
+	roxrl	IMM (1),d6	| d6 collect bits we would lose otherwise
+	cmpw	IMM (1),d2	| is the exponent 1 already?
+#else
+	addql	IMM (1),d2	| adjust the exponent
+	lsrl	IMM (1),d6
+	btst	IMM (0),d1
+	beq	11f
+	bset	IMM (31),d6
+11:	lsrl	IMM (1),d1
+	btst	IMM (0),d0
+	beq	10f
+	bset	IMM (31),d1
+10:	lsrl	IMM (1),d0
+	cmpl	IMM (1),d2	| is the exponent 1 already?
+#endif
+	beq	2f		| if not loop back
+	bra	1b              |
+	bra	Lf$underflow	| safety check, shouldn't execute
+2:	orl	d6,d1		| this is a trick so we don't lose
+				| the extra bits which were flushed right
+| Now call the rounding routine (which takes care of denormalized numbers):
+	PICLEA	SYM (_fpCCR),a0	| check the rounding mode
+#ifdef __mcoldfire__
+	clrl	d6
+#endif
+	movew	a0@(6),d6	| rounding mode in d6
+	lea	pc@(Lround$0),a0 | to return from rounding routine
+	beq	Lround$to$nearest
+#ifndef __mcoldfire__
+	cmpw	IMM (ROUND_TO_PLUS),d6
+#else
+	cmpl	IMM (ROUND_TO_PLUS),d6
+#endif
+	bhi	Lround$to$minus
+	blt	Lround$to$zero
+	bra	Lround$to$plus
+Lround$0:
+| Here we have a correctly rounded result (either normalized or denormalized).
+
+| Here we should have either a normalized number or a denormalized one, and
+| the exponent is necessarily larger or equal to 1 (so we don't have to
+| check again for underflow!). We have to check for overflow or for a
+| denormalized number (which also signals underflow).
+| Check for overflow (i.e., exponent >= 255).
+#ifndef __mcoldfire__
+	cmpw	IMM (F_MAX_EXP),d2
+#else
+	cmpl	IMM (F_MAX_EXP),d2
+#endif
+	bge	Lf$overflow
+| Now check for a denormalized number (exponent==0).
+	movew	d2,d2
+	beq	Lf$den
+1:
+| Put back the exponents and sign and return.
+#ifndef __mcoldfire__
+	lslw	IMM (7),d2	| exponent back to fourth byte
+#else
+	lsll	IMM (7),d2	| exponent back to fourth byte
+#endif
+	bclr	IMM (FLT_MANT_DIG-1),d0
+	swap	d0		| and put back exponent
+#ifndef __mcoldfire__
+	orw	d2,d0		|
+#else
+	orl	d2,d0
+#endif
+	swap	d0		|
+	orl	d7,d0		| and sign also
+
+	PICLEA	SYM (_fpCCR),a0
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6
+	rts
+
+|=============================================================================
+|                             __negsf2
+|=============================================================================
+
+| This is trivial and could be shorter if we didn't bother checking for NaN
+| and +/-INFINITY.
+
+| float __negsf2(float);
+	FUNC(__negsf2)
+SYM (__negsf2):
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+	moveq	IMM (NEGATE),d5
+#ifndef __FASTCALL__
+	movel	a6@(8),d0	| get number to negate in d0
+#endif
+	bchg	IMM (31),d0	| negate
+	movel	d0,d1		| make a positive copy
+	bclr	IMM (31),d1	|
+	tstl	d1		| check for zero
+	beq	2f		| if zero (either sign) return +zero
+	cmpl	IMM (INFINITY),d1 | compare to +INFINITY
+	blt	1f		|
+	bhi	Lf$inop		| if larger (fraction not zero) is NaN
+	movel	d0,d7		| else get sign and return INFINITY
+	andl	IMM (0x80000000),d7
+	bra	Lf$infty
+1:	PICLEA	SYM (_fpCCR),a0
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6
+	rts
+2:	bclr	IMM (31),d0
+	bra	1b
+
+|=============================================================================
+|                             __cmpsf2
+|=============================================================================
+
+| The comments above about __eqdf2, et. al., also apply to __eqsf2,
+| et. al., except that the latter call __cmpsf2 rather than __cmpdf2.
+
+	FUNC(__gtsf2)
+	.globl	SYM (__gtsf2)
+SYM (__gtsf2):
+	FUNC(__gesf2)
+	.globl	SYM (__gesf2)
+SYM (__gesf2):
+	lea	LESS,a0
+	jbra	SYM (__cmpsf2_internal)
+
+SYM (__cmpsf2):
+	FUNC(__eqsf2)
+	.globl	SYM (__eqsf2)
+SYM (__eqsf2):
+	FUNC(__nesf2)
+	.globl	SYM (__nesf2)
+SYM (__nesf2):
+	FUNC(__ltsf2)
+	.globl	SYM (__ltsf2)
+SYM (__ltsf2):
+	FUNC(__lesf2)
+	.globl	SYM (__lesf2)
+SYM (__lesf2):
+
+| int __cmpsf2(float, float);
+	FUNC(__cmpsf2)
+	lea	GREATER,a0
+
+| int __cmpsf2_internal(float, float, int);
+SYM (__cmpsf2_internal):
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+	moveq	IMM (COMPARE),d5
+#ifndef __FASTCALL__
+	movel	a6@(8),d0	| get first operand
+	movel	a6@(12),d1	| get second operand
+#endif
+| Check if either is NaN, and in that case return garbage and signal
+| INVALID_OPERATION. Check also if either is zero, and clear the signs
+| if necessary.
+	movel	d0,d6
+	andl	IMM (0x7fffffff),d0
+	beq	Lcmpsf$a$0
+	cmpl	IMM (0x7f800000),d0
+	bhi	Lcmpf$inop
+Lcmpsf$1:
+	movel	d1,d7
+	andl	IMM (0x7fffffff),d1
+	beq	Lcmpsf$b$0
+	cmpl	IMM (0x7f800000),d1
+	bhi	Lcmpf$inop
+Lcmpsf$2:
+| Check the signs
+	eorl	d6,d7
+	bpl	1f
+| If the signs are not equal check if a >= 0
+	tstl	d6
+	bpl	Lcmpsf$a$gt$b	| if (a >= 0 && b < 0) => a > b
+	bmi	Lcmpsf$b$gt$a	| if (a < 0 && b >= 0) => a < b
+1:
+| If the signs are equal check for < 0
+	tstl	d6
+	bpl	1f
+| If both are negative exchange them
+#ifndef __mcoldfire__
+	exg	d0,d1
+#else
+	movel	d0,d7
+	movel	d1,d0
+	movel	d7,d1
+#endif
+1:
+| Now that they are positive we just compare them as longs (does this also
+| work for denormalized numbers?).
+	cmpl	d0,d1
+	bhi	Lcmpsf$b$gt$a	| |b| > |a|
+	bne	Lcmpsf$a$gt$b	| |b| < |a|
+| If we got here a == b.
+	movel	IMM (EQUAL),d0
+	moveml	sp@,d2-d7/a2-a5 	| put back the registers
+	unlk	a6
+	rts
+Lcmpsf$a$gt$b:
+	movel	IMM (GREATER),d0
+	moveml	sp@,d2-d7/a2-a5 	| put back the registers
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6
+	rts
+Lcmpsf$b$gt$a:
+	movel	IMM (LESS),d0
+	moveml	sp@,d2-d7/a2-a5 	| put back the registers
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6
+	rts
+
+Lcmpsf$a$0:
+	bclr	IMM (31),d6
+	bra	Lcmpsf$1
+Lcmpsf$b$0:
+	bclr	IMM (31),d7
+	bra	Lcmpsf$2
+
+Lcmpf$inop:
+	movel	a0,d0
+	moveq	IMM (INEXACT_RESULT+INVALID_OPERATION),d7
+	moveq	IMM (SINGLE_FLOAT),d6
+	PICJUMP	$_exception_handler
+
+|=============================================================================
+|                           rounding routines
+|=============================================================================
+
+| The rounding routines expect the number to be normalized in registers
+| d0-d1, with the exponent in register d2. They assume that the
+| exponent is larger or equal to 1. They return a properly normalized number
+| if possible, and a denormalized number otherwise. The exponent is returned
+| in d2.
+
+Lround$to$nearest:
+| We now normalize as suggested by D. Knuth ("Seminumerical Algorithms"):
+| Here we assume that the exponent is not too small (this should be checked
+| before entering the rounding routine), but the number could be denormalized.
+
+| Check for denormalized numbers:
+1:	btst	IMM (FLT_MANT_DIG),d0
+	bne	2f		| if set the number is normalized
+| Normalize shifting left until bit #FLT_MANT_DIG is set or the exponent
+| is one (remember that a denormalized number corresponds to an
+| exponent of -F_BIAS+1).
+#ifndef __mcoldfire__
+	cmpw	IMM (1),d2	| remember that the exponent is at least one
+#else
+	cmpl	IMM (1),d2	| remember that the exponent is at least one
+#endif
+ 	beq	2f		| an exponent of one means denormalized
+	addl	d1,d1		| else shift and adjust the exponent
+	addxl	d0,d0		|
+#ifndef __mcoldfire__
+	dbra	d2,1b		|
+#else
+	subql	IMM (1),d2
+	bpl	1b
+#endif
+2:
+| Now round: we do it as follows: after the shifting we can write the
+| fraction part as f + delta, where 1 < f < 2^25, and 0 <= delta <= 2.
+| If delta < 1, do nothing. If delta > 1, add 1 to f.
+| If delta == 1, we make sure the rounded number will be even (odd?)
+| (after shifting).
+	btst	IMM (0),d0	| is delta < 1?
+	beq	2f		| if so, do not do anything
+	tstl	d1		| is delta == 1?
+	bne	1f		| if so round to even
+	movel	d0,d1		|
+	andl	IMM (2),d1	| bit 1 is the last significant bit
+	addl	d1,d0		|
+	bra	2f		|
+1:	movel	IMM (1),d1	| else add 1
+	addl	d1,d0		|
+| Shift right once (because we used bit #FLT_MANT_DIG!).
+2:	lsrl	IMM (1),d0
+| Now check again bit #FLT_MANT_DIG (rounding could have produced a
+| 'fraction overflow' ...).
+	btst	IMM (FLT_MANT_DIG),d0
+	beq	1f
+	lsrl	IMM (1),d0
+#ifndef __mcoldfire__
+	addw	IMM (1),d2
+#else
+	addql	IMM (1),d2
+#endif
+1:
+| If bit #FLT_MANT_DIG-1 is clear we have a denormalized number, so we
+| have to put the exponent to zero and return a denormalized number.
+	btst	IMM (FLT_MANT_DIG-1),d0
+	beq	1f
+	jmp	a0@
+1:	movel	IMM (0),d2
+	jmp	a0@
+
+Lround$to$zero:
+Lround$to$plus:
+Lround$to$minus:
+	jmp	a0@
+#endif /* L_float */
+
+/* We do not need these routines for coldfire, as it has no extended
+   float format. */
+#if !defined (__mcoldfire__)
+
+#ifdef  L_long_double
+
+| A long double precision floating point number (long double) has the format:
+|
+| struct _long_double {
+|  unsigned int sign      : 1;  /* sign bit */
+|  unsigned int exponent  : 15; /* exponent, shifted by 16383 */
+|  unsigned int empty     : 16;
+|  unsigned int fraction  : 64; /* fraction */
+| } double;
+|
+| Thus sizeof(long double) = 12 (96 bits).
+|
+| All the routines are callable from C programs, and return the result
+| in the register pair d0-d1. They also preserve all registers except
+| d0-d1 and a0-a1.
+
+	.globl	SYM (_fpCCR)
+	.globl  $_exception_handler
+
+QUIET_NaN      = 0xffffffff
+INFINITY       = 0x7fff0000
+
+X_MAX_EXP      = 0x7fff
+X_BIAS         = 16383
+LDBL_MAX_EXP   = X_MAX_EXP - X_BIAS
+LDBL_MIN_EXP   = 1 - X_BIAS
+LDBL_MANT_DIG  = 64
+
+| Entry points:
+
+	.globl SYM (__addxf3)
+	.globl SYM (__subxf3)
+	.globl SYM (__mulxf3)
+	.globl SYM (__divxf3)
+	.globl SYM (__negxf2)
+	.globl SYM (__cmpxf2)
+
+	.text
+	.even
+
+| These are common routines to return and signal exceptions.
+
+Lx$den:
+| Return and signal a denormalized number
+	orl	d7,d0
+	movew	IMM (INEXACT_RESULT+UNDERFLOW),d7
+	moveq	IMM (DOUBLE_FLOAT),d6
+	PICJUMP	$_exception_handler
+
+Lx$infty:
+Lx$overflow:
+| Return a properly signed INFINITY and set the exception flags
+	movel	IMM (INFINITY),d0
+	movel	IMM (0),d1
+	movel	IMM (0),d2
+	orl	d7,d0
+	movew	IMM (INEXACT_RESULT+OVERFLOW),d7
+	moveq	IMM (LONG_FLOAT),d6
+	PICJUMP	$_exception_handler
+
+Lx$underflow:
+| Return 0 and set the exception flags
+	movel	IMM (0),d0
+	movel	d0,d1
+	movel	d0,d2
+	movew	IMM (INEXACT_RESULT+UNDERFLOW),d7
+	moveq	IMM (LONG_FLOAT),d6
+	PICJUMP	$_exception_handler
+
+Lx$inop:
+| Return a quiet NaN and set the exception flags
+	movel	IMM (QUIET_NaN),d0
+	movel	d0,d1
+	movel	d0,d2
+	movew	IMM (INEXACT_RESULT+INVALID_OPERATION),d7
+	moveq	IMM (LONG_FLOAT),d6
+	PICJUMP	$_exception_handler
+
+Lx$div$0:
+| Return a properly signed INFINITY and set the exception flags
+	movel	IMM (INFINITY),d0
+	movel	IMM (0),d1
+	movel	IMM (0),d2
+	orl	d7,d0
+	movew	IMM (INEXACT_RESULT+DIVIDE_BY_ZERO),d7
+	moveq	IMM (LONG_FLOAT),d6
+	PICJUMP	$_exception_handler
+
+|=============================================================================
+|                              __subxf3
+|=============================================================================
+
+| long double __subxf3(long double, long double);
+	FUNC(__subxf3)
+SYM (__subxf3):
+	bchg	IMM (31),sp@(16) | change sign of second operand
+				| and fall through, so we always add
+
+|=============================================================================
+|                              __addxf3
+|=============================================================================
+
+| long double __addxf3(long double, long double);
+	FUNC(__addxf3)
+SYM (__addxf3):
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+	pea.l      xxadd6(pc)
+	bra     _xxentry
+
+xxadd1:
+	eor.l      d3,d0
+	bmi        xxadd28
+xxadd2:
+	move.l     d3,d0
+	move.l     d4,d1
+	move.l     d5,d2
+xxadd3:
+	tst.w      d0
+	bpl        xxadd29
+	lsr.l      IMM(1),d1
+	roxr.l     IMM(1),d2
+	addq.w     IMM(1),d0
+	bra.s      xxadd3
+xxadd4:
+	eor.l      d0,d3
+	bpl.s      xxadd3
+xxadd5:
+	moveq	IMM (ADD),d5
+	bra        Lx$inop
+
+	bra.s      xxadd5
+	bra.s      xxadd5
+	bra.s      xxadd5
+	bra.s      xxadd4
+	bra.s      xxadd3
+	bra.s      xxadd3
+	bra.s      xxadd2
+	bra.s      xxadd1
+	bra.s      xxadd2
+	bra.s      xxadd2
+	bra.s      xxadd3
+xxadd6:
+	move.l     d0,d6
+	eor.l      d3,d6
+	move.w     d0,d6
+	sub.w      d3,d6
+	bgt.s      xxadd8
+	neg.w      d6
+	bne.s      xxadd7
+	cmp.l      d4,d1
+	bhi.s      xxadd8
+	bne.s      xxadd7
+	cmp.l      d2,d5
+	bls.s      xxadd8
+xxadd7:
+	move.l     d3,d0
+	exg        d4,d1
+	exg        d5,d2
+xxadd8:
+	moveq.l    IMM(0),d3
+	cmpi.w     IMM(9),d6
+	bls.s      xxadd13
+	cmpi.w     IMM(65),d6
+	bls.s      xxadd9
+	moveq.l    IMM(0),d5
+	moveq.l    IMM(0),d4
+	moveq.l    IMM(1),d3
+	bra.s      xxadd15
+xxadd9:
+	cmpi.w     IMM(33),d6
+	bls.s      xxadd10
+	or.l       d5,d3
+	move.l     d4,d5
+	moveq.l    IMM(0),d4
+	subi.w     IMM(32),d6
+xxadd10:
+	cmpi.w     IMM(17),d6
+	bls.s      xxadd11
+	or.w       d5,d3
+	move.w     d4,d5
+	clr.w      d4
+	swap       d4
+	swap       d5
+	subi.w     IMM(16),d6
+xxadd11:
+	cmpi.w     IMM(9),d6
+	bls.s      xxadd12
+	or.b       d5,d3
+	move.b     d4,d5
+	ror.l      IMM(8),d5
+	lsr.l      IMM(8),d4
+	subq.w     IMM(8),d6
+xxadd12:
+	tst.l      d3
+	beq.s      xxadd13
+	move.w     IMM(0x0FFF),d3
+xxadd13:
+	subq.w     IMM(1),d6
+	bmi.s      xxadd15
+xxadd14:
+	lsr.l      IMM(1),d4
+	roxr.l     IMM(1),d5
+	roxr.w     IMM(1),d3
+	dbf        d6,xxadd14
+xxadd15:
+	tst.l      d6
+	bmi.s      xxadd20
+	add.l      d5,d2
+	addx.l     d4,d1
+	bcc.s      xxadd16
+	roxr.l     IMM(1),d1
+	roxr.l     IMM(1),d2
+	roxr.w     IMM(1),d3
+	addq.w     IMM(1),d0
+xxadd16:
+	cmpi.w     IMM(0x8000),d3
+	bhi.s      xxadd17
+	bne        xxadd27
+	btst       IMM(0),d2
+	beq        xxadd27
+xxadd17:
+	addq.l     IMM(1),d2
+	bcc        xxadd27
+	addq.l     IMM(1),d1
+	bcc        xxadd27
+	bset       IMM(31),d1
+	addq.w     IMM(1),d0
+	bra        xxadd27
+
+xxadd20:
+	sub.l      d5,d2
+	subx.l     d4,d1
+	bmi.s      xxadd21
+	beq        xxadd28
+	subq.w     IMM(1),d0
+	add.l      d2,d2
+	addx.l     d1,d1
+	add.w      d3,d3
+	bcc.s      xxadd21
+	subq.l     IMM(1),d2
+	bcc.s      xxadd21
+	subq.l     IMM(1),d1
+xxadd21:
+	cmpi.w     IMM(0x8000),d3
+	bhi.s      xxadd22
+	bne.s      xxadd25
+	btst       IMM(0),d2
+	bne.s      xxadd22
+	tst.l      d2
+	bne.s      xxadd25
+	cmp.l      IMM(0x80000000),d1
+	bne.s      xxadd25
+xxadd22:
+	subq.l     IMM(1),d2
+	bcc.s      xxadd25
+	subq.l     IMM(1),d1
+	bmi.s      xxadd27
+	beq.s      xxadd28
+	moveq.l    IMM(-1),d2
+	moveq.l    IMM(-1),d1
+	subq.w     IMM(1),d0
+	btst       IMM(14),d3
+	beq.s      xxadd27
+	moveq.l    IMM(-2),d2
+	bra.s      xxadd27
+
+xxadd25:
+	tst.l      d1
+	bmi.s      xxadd27
+xxadd26:
+	subq.w     IMM(1),d0
+	add.l      d2,d2
+	addx.l     d1,d1
+	bpl.s      xxadd26
+xxadd27:
+	cmpi.w     IMM(0x7FFF),d0
+	bcs.s      xxadd29
+	cmpi.w     IMM(0xC000),d0
+	bhi.w      _xxunder
+	bra.w      Lx$overflow
+
+xxadd28:
+	clr.l      d0
+	clr.l      d1
+	clr.l      d2
+	bra.s      xxadd30
+xxadd29:
+	add.l      d0,d0
+	roxr.w     IMM(1),d0
+xxadd30:
+
+
+Laddxf$retnorm:
+	swap       d0
+	clr.w      d0
+	PICLEA	SYM (_fpCCR),a0
+	clrw	a0@
+	moveml	d0-d2,a1@
+	movel	a1,d0
+	moveml	sp@,d2-d7/a2-a5
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6
+	rts
+
+
+_xxentry:
+	movem.l    20(a6),d3-d5
+	clr.w      d3
+	swap       d3
+	move.w     IMM(X_MAX_EXP),d6
+	ext.l      d3
+	and.w      d6,d3
+	cmp.w      d6,d3
+	beq.s      _xxentry5
+	tst.l      d4
+	bmi.s      _xxentry3
+	bne.s      _xxentry2
+	tst.l      d5
+	bne.s      _xxentry2
+	subq.l     IMM(2),(a7)
+	bra.s      _xxentry3
+_xxentry2:
+	subq.w     IMM(1),d3
+	add.l      d5,d5
+	addx.l     d4,d4
+	bpl.s      _xxentry2
+_xxentry3:
+	movem.l    8(a6),d0-d2
+	swap       d0
+	ext.l      d0
+	and.w      d6,d0
+	cmp.w      d6,d0
+	beq.s      _xxentry6
+	tst.l      d1
+	bpl.s      _xxentry4
+	rts
+_xxentry4:
+	bne.s      _norm012_1
+	tst.l      d2
+	bne.s      _norm012_1
+	subq.l     IMM(6),(a7)
+	rts
+_xxentry5:
+	tst.l      d4
+	bne.s      _xxentry7
+	tst.l      d5
+	bne.s      _xxentry7
+	subq.l     IMM(4),(a7)
+	bra.s      _xxentry3
+_xxentry6:
+	tst.l      d1
+	bne.s      _xxentry8
+	tst.l      d2
+	bne.s      _xxentry8
+	subi.l     IMM(12),(a7)
+	rts
+_xxentry7:
+_xxentry8:
+	subi.l     IMM(18),(a7)
+	rts
+
+
+
+_norm012:
+	tst.l      d1
+	bmi.s      _norm012_2
+_norm012_1:
+	subq.w     IMM(1),d0
+	add.l      d2,d2
+	addx.l     d1,d1
+	bpl.s      _norm012_1
+_norm012_2:
+	rts
+
+
+_xxunder:
+	cmpi.w     IMM(0xFF80),d0
+	bgt        _xxunder1
+	bra        Lx$underflow
+	
+_xxunder1:
+	moveq.l    IMM(0),d3
+	moveq.l    IMM(0),d4
+_xxunder2:
+	lsr.l      IMM(1),d1
+	roxr.l     IMM(1),d2
+	roxr.l     IMM(1),d3
+	roxr.l     IMM(1),d4
+	addq.w     IMM(1),d0
+	bne.s      _xxunder2
+	add.l      d0,d0
+	roxr.w     IMM(1),d0
+	bclr       IMM(31),d3
+	beq.s      _xxunder6
+	tst.l      d3
+	beq.s      _xxunder6
+	addq.l     IMM(1),d2
+	bcc.s      _xxunder6
+	addq.l     IMM(1),d1
+_xxunder6:
+	bra        Laddxf$retnorm
+
+|=============================================================================
+|                              __mulxf3
+|=============================================================================
+
+| long double __mulxf3(long double, long double);
+	FUNC(__mulxf3)
+SYM (__mulxf3):
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+
+	pea.l      xxmul4(pc)
+	bra.w      _xxentry
+
+xxmul1:
+	eor.l      d3,d0
+	andi.l     IMM(0x80000000),d0
+	moveq      IMM(0),d1
+	moveq      IMM(0),d2
+	swap       d0
+	bra        Lmulxf$retnorm
+xxmul2:
+	moveq	IMM (MULTIPLY),d5
+	bra        Lx$inop
+xxmul3:
+	eor.l      d3,d0
+	swap       d0
+	or.w       d6,d0
+	moveq      IMM(0),d1
+	moveq      IMM(0),d2
+	bra        Lmulxf$retnorm
+
+	move.l     d7,d0
+	clr.w      d0
+	moveq	IMM (MULTIPLY),d5
+	bra     Lx$overflow
+
+	bra.s      xxmul2
+	bra.s      xxmul2
+	bra.s      xxmul2
+	bra.s      xxmul3
+	bra.s      xxmul2
+	bra.s      xxmul3
+	bra.s      xxmul2
+	bra.s      xxmul1
+	bra.s      xxmul1
+	bra.s      xxmul3
+	bra.s      xxmul1
+xxmul4:
+	move.l     d0,d7
+	eor.l      d3,d7
+	move.w     d0,d7
+	add.w      d3,d7
+	subi.w     IMM(0x3FFE),d7
+	move.l     d7,-(a7)
+	moveq.l    IMM(0),d0
+	move.w     d2,d6
+	mulu.w     d4,d6
+	move.w     d1,d3
+	mulu.w     d4,d3
+	move.w     d1,d7
+	mulu.w     d5,d7
+	add.l      d7,d6
+	addx.l     d0,d3
+	swap       d1
+	swap       d2
+	swap       d4
+	swap       d5
+	move.w     d2,d7
+	mulu.w     d5,d7
+	add.l      d7,d6
+	addx.l     d0,d3
+	move.w     d6,-(a7)
+	move.w     d3,d6
+	clr.w      d3
+	swap       d3
+	swap       d6
+	move.l     d2,d7
+	swap       d7
+	mulu.w     d4,d7
+	add.l      d7,d6
+	addx.l     d0,d3
+	move.l     d4,d7
+	swap       d7
+	mulu.w     d2,d7
+	add.l      d7,d6
+	addx.l     d0,d3
+	move.l     d1,d7
+	swap       d7
+	mulu.w     d5,d7
+	add.l      d7,d6
+	addx.l     d0,d3
+	move.l     d5,d7
+	swap       d7
+	mulu.w     d1,d7
+	add.l      d7,d6
+	addx.l     d0,d3
+	move.l     d1,d7
+	swap       d7
+	mulu.w     d4,d7
+	add.l      d7,d3
+	move.l     d4,d7
+	swap       d7
+	mulu.w     d1,d7
+	add.l      d7,d3
+	addx.l     d0,d0
+	move.w     d6,-(a7)
+	move.w     d3,d6
+	move.w     d0,d3
+	swap       d3
+	swap       d6
+	moveq.l    IMM(0),d0
+	move.w     d2,d7
+	mulu.w     d4,d7
+	add.l      d7,d6
+	addx.l     d0,d3
+	move.w     d1,d7
+	mulu.w     d5,d7
+	add.l      d7,d6
+	addx.l     d0,d3
+	move.w     d1,d7
+	mulu.w     d4,d7
+	add.l      d7,d3
+	move.l     (a7)+,d4
+	move.l     (a7)+,d1
+	move.l     d4,d7
+	tst.l      d3
+	bmi.s      xxmul5
+	add.l      d7,d7
+xxmul5:
+
+xxmul11:
+	cmpi.l     IMM(0x80000000),d7
+	bhi.s      xxmul12
+	cmpi.l     IMM(0x7FFE0001),d7
+	bls.s      xxmul14
+	bsr.s      xxmul9
+	cmpi.l     IMM(0x80000000),d4
+	bhi.s      xxmul12
+	bne.s      xxmul14
+	tst.l      d7
+	bne.s      xxmul12
+	btst       IMM(0),d6
+	beq.s      xxmul14
+xxmul12:
+	tst.l      d3
+	bmi.s      xxmul13
+	add.l      d4,d4
+	addx.l     d6,d6
+	addx.l     d3,d3
+	subq.w     IMM(1),d1
+xxmul13:
+	addq.l     IMM(1),d6
+	addx.l     d0,d3
+	bne.s      xxmul15
+	bset       IMM(31),d3
+	addq.w     IMM(1),d1
+	bra.s      xxmul15
+xxmul14:
+	tst.l      d3
+	bmi.s      xxmul15
+	add.l      d4,d4
+	addx.l     d6,d6
+	addx.l     d3,d3
+	subq.w     IMM(1),d1
+xxmul15:
+	cmpi.w     IMM(0x7FFF),d1
+	bcs.s      xxmul16
+	moveq	IMM (MULTIPLY),d5
+	bra     Lx$overflow
+xxmul16:
+	add.l      d1,d1
+	roxr.w     IMM(1),d1
+	move.w     d1,d0
+	move.l     d6,d2
+	move.l     d3,d1
+
+Lmulxf$retnorm:
+	swap       d0
+	clr.w      d0
+	PICLEA	SYM (_fpCCR),a0
+	clrw	a0@
+	moveml	d0-d2,a1@
+	movel	a1,d0
+	moveml	sp@,d2-d7/a2-a5
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6
+	rts
+
+xxmul9:
+	move.l     d1,-(a7)
+	move.l     d2,d1
+	swap       d1
+	mulu.w     d5,d1
+	move.l     d5,d7
+	swap       d7
+	mulu.w     d2,d7
+	moveq.l    IMM(0),d0
+	add.l      d1,d7
+	addx.w     d0,d0
+	swap       d0
+	swap       d7
+	move.w     d7,d0
+	clr.w      d7
+	swap       d2
+	swap       d5
+	move.w     d2,d1
+	mulu.w     d5,d1
+	moveq.l    IMM(0),d2
+	add.l      d1,d7
+	addx.l     d0,d4
+	addx.l     d2,d6
+	addx.l     d2,d3
+	moveq.l    IMM(0),d0
+	move.l     (a7)+,d1
+	tst.l      d3
+	bmi.s      xxmul10
+	add.l      d7,d7
+	addx.l     d4,d4
+	addx.l     d6,d6
+	addx.l     d3,d3
+	subq.w     IMM(1),d1
+xxmul10:
+	rts
+
+|=============================================================================
+|                              __divxf3
+|=============================================================================
+
+| long double __divxf3(long double, long double);
+	FUNC(__divxf3)
+SYM (__divxf3):
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+
+	pea.l      xxdiv5(pc)
+	bra.w      _xxentry
+
+__xxdiv:
+	movem.l    d3-d7/a2-a3,-(a7)
+	pea.l      xxdiv5(pc)
+	bra.w      _xxentry
+
+xxdiv1:
+	moveq	IMM (DIVIDE),d5
+	bra     Lx$inop
+
+xxdiv2:
+	eor.l      d3,d0
+	swap       d0
+	andi.w     IMM(0x8000),d0
+	moveq      IMM(0),d1
+	moveq      IMM(0),d2
+	bra        Ldivxf$retnorm
+
+xxdiv3:
+	moveq	IMM (DIVIDE),d5
+	bra     Lx$div$0
+
+xxdiv4:
+	eor.l      d3,d0
+	swap       d0
+	or.w       d6,d0
+	moveq      IMM(0),d1
+	moveq      IMM(0),d2
+	bra        Ldivxf$retnorm
+
+	bra.s      xxdiv1
+	bra.s      xxdiv1
+	bra.s      xxdiv1
+	bra.s      xxdiv1
+	bra.s      xxdiv4
+	bra.s      xxdiv4
+	bra.s      xxdiv2
+	bra.s      xxdiv1
+	bra.s      xxdiv2
+	bra.s      xxdiv2
+	bra.s      xxdiv3
+xxdiv5:
+	suba.l     a3,a3
+	move.l     d0,d7
+	eor.l      d3,d7
+	move.w     d0,d7
+	sub.w      d3,d7
+	addi.w     IMM(0x3FFE),d7
+	cmp.l      d1,d4
+	bhi.s      xxdiv7
+	bne.s      xxdiv6
+	cmp.l      d2,d5
+	bhi.s      xxdiv7
+xxdiv6:
+	addq.w     IMM(1),d7
+	lsr.l      IMM(1),d1
+	roxr.l     IMM(1),d2
+	bcc.s      xxdiv7
+	movea.w    IMM(0x8000),a3
+xxdiv7:
+	move.l     d7,-(a7)
+	moveq.l    IMM(2),d6
+xxdiv8:
+	movea.l    d6,a2
+	move.l     d4,d6
+	swap       d6
+	move.l     d1,d7
+	divu.w     d6,d7
+	bvc.s      xxdiv9
+	move.l     d4,d7
+	clr.w      d7
+	sub.l      d7,d1
+	swap       d7
+	add.l      d7,d1
+	moveq.l    IMM(-1),d7
+	bra.s      xxdiv10
+xxdiv9:
+	move.l     d7,d1
+	clr.w      d1
+	swap       d1
+xxdiv10:
+	move.l     d5,d6
+	swap       d6
+	mulu.w     d7,d6
+	moveq.l    IMM(0),d0
+	sub.l      d6,d2
+	subx.l     d0,d1
+	swap       d1
+	swap       d2
+	move.w     d1,d0
+	move.w     d2,d1
+	move.w     a3,d2
+	suba.l     a3,a3
+	move.w     d4,d3
+	mulu.w     d7,d3
+	move.w     d5,d6
+	mulu.w     d7,d6
+	move.w     d7,-(a7)
+	moveq.l    IMM(0),d7
+	sub.l      d6,d2
+	subx.l     d3,d1
+	subx.w     d7,d0
+	bpl.s      xxdiv12
+xxdiv11:
+	subq.w     IMM(1),(a7)
+	add.l      d5,d2
+	addx.l     d4,d1
+	addx.w     d7,d0
+	bcc.s      xxdiv11
+xxdiv12:
+	move.l     a2,d6
+	dbf        d6,xxdiv8
+	move.l     d4,d6
+	swap       d6
+	move.l     d1,d7
+	divu.w     d6,d7
+	bvc.s      xxdiv13
+	move.l     d4,d7
+	clr.w      d7
+	sub.l      d7,d1
+	swap       d7
+	add.l      d7,d1
+	moveq.l    IMM(-1),d7
+	swap       d1
+	bra.s      xxdiv14
+xxdiv13:
+	move.l     d7,d1
+	clr.w      d1
+xxdiv14:
+	swap       d2
+	move.w     d1,d0
+	move.w     d2,d1
+	clr.w      d2
+	move.w     d4,d3
+	mulu.w     d7,d3
+	moveq.l    IMM(0),d6
+	sub.l      d3,d1
+	subx.w     d6,d0
+	bpl.s      xxdiv16
+xxdiv15:
+	subq.w     IMM(1),d7
+	add.l      d4,d1
+	addx.w     d6,d0
+	bcc.s      xxdiv15
+xxdiv16:
+	swap       d7
+	move.w     (a7)+,d7
+	swap       d7
+	move.l     d4,d6
+	lsr.l      IMM(1),d6
+	sub.l      d1,d6
+	bhi        xxdiv27
+	swap       d6
+	addq.w     IMM(1),d6
+	bmi        xxdiv26
+xxdiv17:
+
+xxdiv22:
+	move.l     d2,-(a7)
+	move.l     d1,-(a7)
+	move.l     d5,d3
+	swap       d3
+	mulu.w     d7,d3
+	move.w     d3,d0
+	clr.w      d3
+	swap       d3
+	swap       d0
+	clr.w      d0
+	move.w     d5,d2
+	mulu.w     d7,d2
+	moveq.l    IMM(0),d1
+	add.l      d2,d0
+	addx.l     d1,d3
+	move.l     (a7)+,d1
+	move.l     (a7)+,d2
+	sub.l      d0,d2
+	subx.l     d3,d1
+	bcc.s      xxdiv23
+	subq.w     IMM(1),d7
+	add.l      d5,d2
+	addx.l     d4,d1
+xxdiv23:
+
+xxdiv24:
+	lsr.l      IMM(1),d4
+	roxr.l     IMM(1),d5
+	sub.l      d2,d5
+	subx.l     d1,d4
+	bmi.s      xxdiv26
+	bne.s      xxdiv27
+	btst       IMM(0),d7
+	beq.s      xxdiv27
+
+xxdiv26:
+	move.l     (a7)+,d6
+	swap       d6
+	addq.l     IMM(1),d7
+	bcc.s      xxdiv28
+	addq.l     IMM(1),d6
+	bra.s      xxdiv28
+xxdiv27:
+	move.l     (a7)+,d6
+	swap       d6
+xxdiv28:
+	move.l     (a7)+,d0
+	cmpi.w     IMM(0x7FFE),d0
+	bls.s      xxdiv29
+	move.l     d6,d1
+	move.l     d7,d2
+	moveq	IMM (DIVIDE),d5
+	bra     Lx$overflow
+
+xxdiv29:
+	add.l      d0,d0
+	roxr.w     IMM(1),d0
+	move.l     d7,d2
+	move.l     d6,d1
+
+Ldivxf$retnorm:
+	swap       d0
+	clr.w      d0
+	PICLEA	SYM (_fpCCR),a0
+	clrw	a0@
+	moveml	d0-d2,a1@
+	movel	a1,d0
+	moveml	sp@,d2-d7/a2-a5
+	unlk	a6
+	rts
+
+|=============================================================================
+|                              __negxf2
+|=============================================================================
+
+| long double __negxf2(long double, long double);
+	FUNC(__negxf2)
+SYM (__negxf2):
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+	moveq	IMM (NEGATE),d5
+	moveml	a6@(8),d0-d2	| get number to negate in d0-d2
+	bchg	IMM (31),d0	| negate
+	movel	d0,d6		| make a positive copy (for the tests)
+	andl	IMM(0x7fff0000),d6	|
+	movel	d6,d4		| check for zero
+	orl	d1,d4		|
+	orl	d2,d4		|
+	beq	2f		| if zero (either sign) return +zero
+	cmpl	IMM (0x7fff0000),d6 | compare to +INFINITY
+	blt	1f		| if finite, return
+	tstl	d1		| if fraction not zero is NaN
+	bne	Lx$inop		|
+	tstl	d2		| if fraction not zero is NaN
+	bne	Lx$inop		|
+	movel	d0,d7		| else get sign and return INFINITY
+	andl	IMM (0x80000000),d7
+	bra	Lx$infty
+1:	PICLEA	SYM (_fpCCR),a0
+	clrw	a0@
+	moveml	d0-d2,a1@
+	movel	a1,d0
+	moveml	sp@,d2-d7/a2-a5
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6
+	rts
+2:	bclr	IMM (31),d0
+	bra	1b
+
+|=============================================================================
+|                              __cmpxf2
+|=============================================================================
+
+GREATER =  1
+LESS    = -1
+EQUAL   =  0
+
+| The comments above about __eqdf2, et. al., also apply to __eqxf2,
+| et. al., except that the latter call __cmpxf2 rather than __cmpdf2.
+
+	FUNC(__gtxf2)
+	.globl	SYM (__gtxf2)
+SYM (__gtxf2):
+	FUNC(__gexf2)
+	.globl	SYM (__gexf2)
+SYM (__gexf2):
+	lea LESS,a0
+	jbra SYM(__cmpxf2_internal)
+
+	FUNC(__eqxf2)
+	.globl	SYM (__eqxf2)
+SYM (__eqxf2):
+	FUNC(__nexf2)
+	.globl	SYM (__nexf2)
+SYM (__nexf2):
+	FUNC(__ltxf2)
+	.globl	SYM (__ltxf2)
+SYM (__ltxf2):
+	FUNC(__lexf2)
+	.globl	SYM (__lexf2)
+SYM (__lexf2):
+
+| int __cmpxf2(long double, long double);
+	FUNC(__cmpxf2)
+SYM (__cmpxf2):
+	lea	GREATER,a0
+
+| int __cmpxf2_internal(long double, long double, int);
+SYM (__cmpxf2_internal):
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+	movel	a6@(8),d0	| get first operand
+	movel	a6@(12),d1	|
+	movel	a6@(16),a2
+	movel	a6@(20),d2	| get second operand
+	movel	a6@(24),d3	|
+	movel	a6@(28),a3
+| First check if a and/or b are (+/-) zero and in that case clear
+| the sign bit.
+	movel	d0,d6		| copy signs into d6 (a) and d7(b)
+	andl	IMM (0x7fff0000),d0	| and clear signs in d0 and d2
+	movel	d2,d7		|
+	andl	IMM (0x7fff0000),d2
+	cmpl	IMM (0x7fff0000),d0 | check for a == NaN
+	beq	Lcmpxf$a$nf	| if equal can be INFINITY, so check d1
+	movel	a2,d4		| copy into d4 to test for zero
+	orl	d0,d4		|
+	orl	d1,d4		|
+	beq	Lcmpxf$a$0	|
+Lcmpxf$0:
+	cmpl	IMM (0x7fff0000),d2 | check for b == NaN
+	bhi	Lcmpxf$inop		| if d2 > 0x7ff00000, b is NaN
+	beq	Lcmpxf$b$nf	| if equal can be INFINITY, so check d3
+	movel	a3,d4		|
+	orl	d2,d4		|
+	orl	d3,d4		|
+	beq	Lcmpxf$b$0	|
+Lcmpxf$1:
+| Check the signs
+	eorl	d6,d7
+	bpl	1f
+| If the signs are not equal check if a >= 0
+	tstl	d6
+	bpl	Lcmpxf$a$gt$b	| if (a >= 0 && b < 0) => a > b
+	bmi	Lcmpxf$b$gt$a	| if (a < 0 && b >= 0) => a < b
+1:
+| If the signs are equal check for < 0
+	tstl	d6
+	bpl	1f
+| If both are negative exchange them
+#ifndef __mcoldfire__
+	exg	d0,d2
+	exg	d1,d3
+	exg	a2,a3
+#else
+	movel	d0,d7
+	movel	d2,d0
+	movel	d7,d2
+	movel	d1,d7
+	movel	d3,d1
+	movel	d7,d3
+	movel	a2,d7
+	movel	a3,a2
+	movel	d7,a3
+#endif
+1:
+| Now that they are positive we just compare them as longs (does this also
+| work for denormalized numbers?).
+	cmpl	d0,d2
+	bhi	Lcmpxf$b$gt$a	| |b| > |a|
+	bne	Lcmpxf$a$gt$b	| |b| < |a|
+| If we got here d0 == d2, so we compare d1 and d3.
+	cmpl	d1,d3
+	bhi	Lcmpxf$b$gt$a	| |b| > |a|
+	bne	Lcmpxf$a$gt$b	| |b| < |a|
+| If we got here d1 == d3, so we compare a2 and a3.
+	movel	a3,d3
+	cmpl	a2,d3
+	bhi	Lcmpxf$b$gt$a	| |b| > |a|
+	bne	Lcmpxf$a$gt$b	| |b| < |a|
+| If we got here a == b.
+	movel	IMM (EQUAL),d0
+	bra 1f
+Lcmpxf$a$gt$b:
+	movel	IMM (GREATER),d0
+	bra 1f
+Lcmpxf$b$gt$a:
+	movel	IMM (LESS),d0
+1:
+	moveml	sp@,d2-d7/a2-a5 	| put back the registers
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
+	unlk	a6
+	rts
+
+Lcmpxf$a$0:
+	bclr	IMM (31),d6
+	bra	Lcmpxf$0
+Lcmpxf$b$0:
+	bclr	IMM (31),d7
+	bra	Lcmpxf$1
+
+Lcmpxf$a$nf:
+	tstl	d1
+	bne	Lcmpxf$inop
+	movel a2,d4
+	bne	Lcmpxf$inop
+	bra	Lcmpxf$0
+
+Lcmpxf$b$nf:
+	tstl	d3
+	bne	Lcmpxf$inop
+	movel a3,d4
+	bne	Lcmpxf$inop
+	bra	Lcmpxf$1
+
+Lcmpxf$inop:
+	movel	a0,d0
+	moveq	IMM (COMPARE),d5
+	moveq	IMM (INEXACT_RESULT+INVALID_OPERATION),d7
+	| this functions returns an int, not a long double
+	moveq	IMM (LONG_FLOAT+1),d6
+	PICJUMP	$_exception_handler
+
+|=============================================================================
+|                           rounding routines
+|=============================================================================
+
+| The rounding routines expect the number to be normalized in registers
+| d0-d1-d2-d3, with the exponent in register d4. They assume that the
+| exponent is larger or equal to 1. They return a properly normalized number
+| if possible, and a denormalized number otherwise. The exponent is returned
+| in d4.
+
+Lround$to$nearest:
+Lround$to$zero:
+Lround$to$plus:
+Lround$to$minus:
+	jmp	a0@
+
+#endif /* _long_double */
+
+#endif /* __mcoldfire__ */
+
+
+#if defined (__ELF__) && defined (__linux__)
+	/* Make stack non-executable for ELF linux targets.  */
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libgcc/config/m68k/mint-atomic.c b/libgcc/config/m68k/mint-atomic.c
new file mode 100644
index 00000000000..e46ef7f8055
--- /dev/null
+++ b/libgcc/config/m68k/mint-atomic.c
@@ -0,0 +1,233 @@
+/* Linux-specific atomic operations for m68k Linux.
+   Copyright (C) 2011-2017 Free Software Foundation, Inc.
+   Based on code contributed by CodeSourcery for ARM EABI Linux.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+/* Coldfire dropped the CAS instruction from the base M68K ISA.
+
+   GCC automatically issues a asm memory barrier when it encounters
+   a __sync_synchronize builtin.  Thus, we do not need to define this
+   builtin.
+
+   We implement byte, short and int versions of each atomic operation
+   using the kernel helper defined below.  There is no support for
+   64-bit operations yet.  */
+
+#include <stdbool.h>
+
+#ifndef __NR_atomic_cmpxchg_32
+#define __NR_atomic_cmpxchg_32  335
+#endif
+
+typedef unsigned int uint32_t __attribute__ ((mode (SI)));
+
+/* Kernel helper for compare-and-exchange a 32-bit value.  */
+static inline uint32_t
+__kernel_cmpxchg (volatile uint32_t *mem, uint32_t oldval, uint32_t newval)
+{
+#ifdef __linux__
+  register uint32_t *a0 asm("a0") = mem;
+  register uint32_t d2 asm("d2") = oldval;
+  register uint32_t d1 asm("d1") = newval;
+  register uint32_t d0 asm("d0") = __NR_atomic_cmpxchg_32;
+
+  asm volatile ("trap #0"
+		: "=r"(d0), "=r"(d1), "=r"(a0)
+		: "r"(d0), "r"(d1), "r"(d2), "r"(a0)
+		: "memory", "a1");
+
+  return d0;
+#else
+  volatile uint32_t *memp = (volatile uint32_t *)mem;
+  uint32_t memval = *memp;
+  if (memval == oldval)
+    *memp = newval;
+  return memval;
+#endif
+}
+
+#ifdef __ELF__
+#define HIDDEN __attribute__ ((visibility ("hidden")))
+#else
+#define HIDDEN
+#endif
+
+/* Big endian masks  */
+#define INVERT_MASK_1 24
+#define INVERT_MASK_2 16
+
+#define MASK_1 0xffu
+#define MASK_2 0xffffu
+
+#define NAME_oldval(OP, WIDTH) __sync_fetch_and_##OP##_##WIDTH
+#define NAME_newval(OP, WIDTH) __sync_##OP##_and_fetch_##WIDTH
+
+#define WORD_SYNC_OP(OP, PFX_OP, INF_OP, RETURN)			\
+  uint32_t HIDDEN							\
+  NAME##_##RETURN (OP, 4) (volatile void *ptr, uint32_t val)			\
+  {									\
+    volatile uint32_t *uptr = (volatile uint32_t *)ptr; \
+    uint32_t oldval, newval, cmpval = *uptr;				\
+									\
+    do {								\
+      oldval = cmpval;							\
+      newval = PFX_OP (oldval INF_OP val);				\
+      cmpval = __kernel_cmpxchg (uptr, oldval, newval);			\
+    } while (__builtin_expect (oldval != cmpval, 0));			\
+									\
+    return RETURN;							\
+  }
+
+#define SUBWORD_SYNC_OP(OP, PFX_OP, INF_OP, TYPE, RTYPE, WIDTH, RETURN)	\
+  RTYPE HIDDEN								\
+  NAME##_##RETURN (OP, WIDTH) (volatile void *ptr, TYPE sval)			\
+  {									\
+    uint32_t *wordptr = (uint32_t *) ((unsigned long) ptr & ~3);	\
+    uint32_t mask, shift, oldval, newval, cmpval, wval;		\
+									\
+    shift = (((unsigned long) ptr & 3) << 3) ^ INVERT_MASK_##WIDTH;	\
+    mask = MASK_##WIDTH << shift;					\
+    wval = (sval & MASK_##WIDTH) << shift;				\
+									\
+    cmpval = *wordptr;							\
+    do {								\
+      oldval = cmpval;							\
+      newval = PFX_OP (oldval INF_OP wval);				\
+      newval = (newval & mask) | (oldval & ~mask);			\
+      cmpval = __kernel_cmpxchg (wordptr, oldval, newval);		\
+    } while (__builtin_expect (oldval != cmpval, 0));			\
+									\
+    return (RETURN >> shift) & MASK_##WIDTH;				\
+  }
+
+WORD_SYNC_OP (add,   , +, oldval)
+WORD_SYNC_OP (sub,   , -, oldval)
+WORD_SYNC_OP (or,    , |, oldval)
+WORD_SYNC_OP (and,   , &, oldval)
+WORD_SYNC_OP (xor,   , ^, oldval)
+WORD_SYNC_OP (nand, ~, &, oldval)
+
+#ifdef __MSHORT__
+#define SHORTINT unsigned int
+#else
+#define SHORTINT unsigned short
+#endif
+
+SUBWORD_SYNC_OP (add,   , +, SHORTINT, SHORTINT, 2, oldval)
+SUBWORD_SYNC_OP (sub,   , -, SHORTINT, SHORTINT, 2, oldval)
+SUBWORD_SYNC_OP (or,    , |, SHORTINT, SHORTINT, 2, oldval)
+SUBWORD_SYNC_OP (and,   , &, SHORTINT, SHORTINT, 2, oldval)
+SUBWORD_SYNC_OP (xor,   , ^, SHORTINT, SHORTINT, 2, oldval)
+SUBWORD_SYNC_OP (nand, ~, &, SHORTINT, SHORTINT, 2, oldval)
+
+SUBWORD_SYNC_OP (add,   , +, unsigned char, unsigned char, 1, oldval)
+SUBWORD_SYNC_OP (sub,   , -, unsigned char, unsigned char, 1, oldval)
+SUBWORD_SYNC_OP (or,    , |, unsigned char, unsigned char, 1, oldval)
+SUBWORD_SYNC_OP (and,   , &, unsigned char, unsigned char, 1, oldval)
+SUBWORD_SYNC_OP (xor,   , ^, unsigned char, unsigned char, 1, oldval)
+SUBWORD_SYNC_OP (nand, ~, &, unsigned char, unsigned char, 1, oldval)
+
+WORD_SYNC_OP (add,   , +, newval)
+WORD_SYNC_OP (sub,   , -, newval)
+WORD_SYNC_OP (or,    , |, newval)
+WORD_SYNC_OP (and,   , &, newval)
+WORD_SYNC_OP (xor,   , ^, newval)
+WORD_SYNC_OP (nand, ~, &, newval)
+
+SUBWORD_SYNC_OP (add,   , +, SHORTINT, SHORTINT, 2, newval)
+SUBWORD_SYNC_OP (sub,   , -, SHORTINT, SHORTINT, 2, newval)
+SUBWORD_SYNC_OP (or,    , |, SHORTINT, SHORTINT, 2, newval)
+SUBWORD_SYNC_OP (and,   , &, SHORTINT, SHORTINT, 2, newval)
+SUBWORD_SYNC_OP (xor,   , ^, SHORTINT, SHORTINT, 2, newval)
+SUBWORD_SYNC_OP (nand, ~, &, SHORTINT, SHORTINT, 2, newval)
+
+SUBWORD_SYNC_OP (add,   , +, unsigned char, unsigned char, 1, newval)
+SUBWORD_SYNC_OP (sub,   , -, unsigned char, unsigned char, 1, newval)
+SUBWORD_SYNC_OP (or,    , |, unsigned char, unsigned char, 1, newval)
+SUBWORD_SYNC_OP (and,   , &, unsigned char, unsigned char, 1, newval)
+SUBWORD_SYNC_OP (xor,   , ^, unsigned char, unsigned char, 1, newval)
+SUBWORD_SYNC_OP (nand, ~, &, unsigned char, unsigned char, 1, newval)
+
+uint32_t HIDDEN
+__sync_val_compare_and_swap_4 (volatile void *ptr, uint32_t oldval, uint32_t newval)
+{
+  return __kernel_cmpxchg ((volatile uint32_t *) ptr, oldval, newval);
+}
+
+bool HIDDEN
+__sync_bool_compare_and_swap_4 (volatile void *ptr, uint32_t oldval,
+				uint32_t newval)
+{
+  return __kernel_cmpxchg ((volatile uint32_t *) ptr, oldval, newval) == oldval;
+}
+
+#define SUBWORD_VAL_CAS(TYPE, WIDTH)					\
+  TYPE HIDDEN								\
+  __sync_val_compare_and_swap_##WIDTH (volatile void *ptr, TYPE soldval,		\
+				       TYPE snewval)			\
+  {									\
+    uint32_t *wordptr = (uint32_t *)((unsigned long) ptr & ~3);		\
+    uint32_t mask, shift, woldval, wnewval;				\
+    uint32_t oldval, newval, cmpval;					\
+									\
+    shift = (((unsigned long) ptr & 3) << 3) ^ INVERT_MASK_##WIDTH;	\
+    mask = MASK_##WIDTH << shift;					\
+    woldval = (soldval & MASK_##WIDTH) << shift;			\
+    wnewval = (snewval & MASK_##WIDTH) << shift;			\
+    cmpval = *wordptr;							\
+									\
+    do {								\
+      oldval = cmpval;							\
+      if ((oldval & mask) != woldval)					\
+	break;								\
+      newval = (oldval & ~mask) | wnewval;				\
+      cmpval = __kernel_cmpxchg (wordptr, oldval, newval);		\
+    } while (__builtin_expect (oldval != cmpval, 0));			\
+									\
+    return (oldval >> shift) & MASK_##WIDTH;				\
+  }
+
+SUBWORD_VAL_CAS (SHORTINT, 2)
+SUBWORD_VAL_CAS (unsigned char,  1)
+
+#define SUBWORD_BOOL_CAS(TYPE, WIDTH)					\
+  bool HIDDEN								\
+  __sync_bool_compare_and_swap_##WIDTH (volatile void *ptr, TYPE oldval,		\
+					TYPE newval)			\
+  {									\
+    return (__sync_val_compare_and_swap_##WIDTH (ptr, oldval, newval)	\
+	    == oldval);							\
+  }
+
+SUBWORD_BOOL_CAS (SHORTINT, 2)
+SUBWORD_BOOL_CAS (unsigned char,  1)
+
+#undef NAME_oldval
+#define NAME_oldval(OP, WIDTH) __sync_lock_##OP##_##WIDTH
+#define COMMA ,
+
+#pragma GCC diagnostic ignored "-Wunused-value"
+
+WORD_SYNC_OP (test_and_set, , COMMA, oldval)
+SUBWORD_SYNC_OP (test_and_set, , COMMA, unsigned char, unsigned char, 1, oldval)
+SUBWORD_SYNC_OP (test_and_set, , COMMA, SHORTINT, SHORTINT, 2, oldval)
diff --git a/libgcc/config/m68k/mulxf3.c b/libgcc/config/m68k/mulxf3.c
new file mode 100644
index 00000000000..51e5fb9d5a8
--- /dev/null
+++ b/libgcc/config/m68k/mulxf3.c
@@ -0,0 +1 @@
+#include "soft-fp/mulxf3.c"
diff --git a/libgcc/config/m68k/sfp-exceptions.c b/libgcc/config/m68k/sfp-exceptions.c
new file mode 100644
index 00000000000..3bd77a70b7c
--- /dev/null
+++ b/libgcc/config/m68k/sfp-exceptions.c
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2012-2023 Free Software Foundation, Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 3, or (at your option) any
+ * later version.
+ * 
+ * This file is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * Under Section 7 of GPL version 3, you are granted additional
+ * permissions described in the GCC Runtime Library Exception, version
+ * 3.1, as published by the Free Software Foundation.
+ *
+ * You should have received a copy of the GNU General Public License and
+ * a copy of the GCC Runtime Library Exception along with this program;
+ * see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _SOFT_FLOAT
+#include "sfp-machine.h"
+
+void
+__sfp_handle_exceptions (int _fex __attribute__ ((unused)))
+{
+  /* does nothing currently. The DFmode functions eventually do a trap #15 */
+}
+#endif
diff --git a/libgcc/config/m68k/sfp-machine.h b/libgcc/config/m68k/sfp-machine.h
new file mode 100644
index 00000000000..9376f62c74f
--- /dev/null
+++ b/libgcc/config/m68k/sfp-machine.h
@@ -0,0 +1,193 @@
+#define _FP_W_TYPE_SIZE		32
+#define _FP_W_TYPE		unsigned long
+#define _FP_WS_TYPE		signed long
+#define _FP_I_TYPE		long
+
+/* The type of the result of a floating point comparison.  This must
+   match `__libgcc_cmp_return__' in GCC for the target.  */
+typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));
+#define CMPtype __gcc_CMPtype
+
+#if 0 /* does not work, because all inputs/outputs must be in data registers */
+
+#define __FP_FRAC_ADD_4(r3,r2,r1,r0,x3,x2,x1,x0,y3,y2,y1,y0)	\
+  __asm__ ("addl %11,%3\n\t"				\
+	   "addxl %9,%2\n\t"				\
+	   "addxl %7,%1\n\t"				\
+	   "addxl %5,%0"				\
+	   : "=d" ((USItype) (r3)),				\
+	     "=&d" ((USItype) (r2)),				\
+	     "=&d" ((USItype) (r1)),				\
+	     "=&d" ((USItype) (r0))				\
+	   : "%0" ((USItype) (x3)),				\
+	     "g" ((USItype) (y3)),				\
+	     "%1" ((USItype) (x2)),				\
+	     "g" ((USItype) (y2)),				\
+	     "%2" ((USItype) (x1)),				\
+	     "g" ((USItype) (y1)),				\
+	     "%3" ((USItype) (x0)),				\
+	     "g" ((USItype) (y0)))
+#define __FP_FRAC_ADD_3(r2,r1,r0,x2,x1,x0,y2,y1,y0)		\
+  __asm__ ("addl %8,%2\n\t"				\
+	   "addxl %6,%1\n\t"				\
+	   "addxl %4,%0"				\
+	   : "=d" ((USItype) (r2)),				\
+	     "=&d" ((USItype) (r1)),				\
+	     "=&d" ((USItype) (r0))				\
+	   : "%0" ((USItype) (x2)),				\
+	     "g" ((USItype) (y2)),				\
+	     "%1" ((USItype) (x1)),				\
+	     "g" ((USItype) (y1)),				\
+	     "%2" ((USItype) (x0)),				\
+	     "g" ((USItype) (y0)))
+#define __FP_FRAC_SUB_4(r3,r2,r1,r0,x3,x2,x1,x0,y3,y2,y1,y0)	\
+  __asm__ ("subl %11,%3\n\t"				\
+	   "subxl %9,%2\n\t"				\
+	   "subxl %7,%1\n\t"				\
+	   "subxl %5,%0"				\
+	   : "=d" ((USItype) (r3)),				\
+	     "=&d" ((USItype) (r2)),				\
+	     "=&d" ((USItype) (r1)),				\
+	     "=&d" ((USItype) (r0))				\
+	   : "0" ((USItype) (x3)),				\
+	     "g" ((USItype) (y3)),				\
+	     "1" ((USItype) (x2)),				\
+	     "g" ((USItype) (y2)),				\
+	     "2" ((USItype) (x1)),				\
+	     "g" ((USItype) (y1)),				\
+	     "3" ((USItype) (x0)),				\
+	     "g" ((USItype) (y0)))
+#define __FP_FRAC_SUB_3(r2,r1,r0,x2,x1,x0,y2,y1,y0)		\
+  __asm__ ("subl %8,%2\n\t"				\
+	   "subxl %6,%1\n\t"				\
+	   "subxl %4,%0"				\
+	   : "=d" ((USItype) (r2)),				\
+	     "=&d" ((USItype) (r1)),				\
+	     "=&d" ((USItype) (r0))				\
+	   : "0" ((USItype) (x2)),				\
+	     "g" ((USItype) (y2)),				\
+	     "1" ((USItype) (x1)),				\
+	     "g" ((USItype) (y1)),				\
+	     "2" ((USItype) (x0)),				\
+	     "g" ((USItype) (y0)))
+#endif
+#define __FP_FRAC_ADDI_4(x3,x2,x1,x0,i)				\
+  do { \
+    long zero; \
+  	__asm__ ("moveq #0,%4\n\t" \
+       "addl %5,%3\n\t"				\
+	   "addxl %4,%2\n\t"				\
+	   "addxl %4,%1\n\t"				\
+	   "addxl %4,%0"				\
+	   : "+d" ((USItype) (x3)),				\
+	     "+&d" ((USItype) (x2)),				\
+	     "+&d" ((USItype) (x1)),				\
+	     "+&d" ((USItype) (x0)),				\
+	     "=d"(zero) \
+	   : "g" ((USItype) (i))); \
+	} while(0)
+
+#define _FP_MUL_MEAT_S(R,X,Y)	_FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_D(R,X,Y)	_FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_E(R,X,Y)	_FP_MUL_MEAT_4_wide(_FP_WFRACBITS_E,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_Q(R,X,Y)	_FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)
+
+#define _FP_DIV_MEAT_S(R,X,Y)   _FP_DIV_MEAT_1_loop(S,R,X,Y)
+#define _FP_DIV_MEAT_D(R,X,Y)   _FP_DIV_MEAT_2_udiv(D,R,X,Y)
+#define _FP_DIV_MEAT_E(R,X,Y)   _FP_DIV_MEAT_4_udiv(E,R,X,Y)
+#define _FP_DIV_MEAT_Q(R,X,Y)   _FP_DIV_MEAT_4_udiv(Q,R,X,Y)
+
+#define _FP_NANFRAC_H		_FP_QNANBIT_H
+#define _FP_NANFRAC_B		_FP_QNANBIT_B
+#define _FP_NANFRAC_S		_FP_QNANBIT_S
+#define _FP_NANFRAC_D		_FP_QNANBIT_D, 0
+/* Even if XFmode is 12byte,  we have to pad it to
+   16byte since soft-fp emulation is done in 16byte.  */
+#define _FP_NANFRAC_E		_FP_QNANBIT_E, 0, 0, 0
+#define _FP_NANFRAC_Q		_FP_QNANBIT_Q, 0, 0, 0
+
+#ifndef _SOFT_FLOAT
+#define FP_EX_SHIFT 0
+
+#define _FP_DECL_EX \
+  unsigned short _fcw __attribute__ ((unused)) = FP_RND_NEAREST;
+
+#define FP_RND_NEAREST		0
+#define FP_RND_ZERO		0x010
+#define FP_RND_PINF		0x020
+#define FP_RND_MINF		0x030
+
+#define FP_RND_MASK		0x030
+
+#define FP_INIT_ROUNDMODE
+
+#endif
+
+#define _FP_KEEPNANFRACP	1
+#define _FP_QNANNEGATEDP 0
+
+#define _FP_NANSIGN_H		0
+#define _FP_NANSIGN_B		0
+#define _FP_NANSIGN_S		0
+#define _FP_NANSIGN_D		0
+#define _FP_NANSIGN_E		0
+#define _FP_NANSIGN_Q		0
+
+/* Here is something Intel misdesigned: the specs don't define
+   the case where we have two NaNs with same mantissas, but
+   different sign. Different operations pick up different NaNs.  */
+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)			\
+  do {								\
+    if (_FP_FRAC_GT_##wc(X, Y)					\
+	|| (_FP_FRAC_EQ_##wc(X,Y) && (OP == '+' || OP == '*')))	\
+      {								\
+	R##_s = X##_s;						\
+	_FP_FRAC_COPY_##wc(R,X);				\
+      }								\
+    else							\
+      {								\
+	R##_s = Y##_s;						\
+	_FP_FRAC_COPY_##wc(R,Y);				\
+      }								\
+    R##_c = FP_CLS_NAN;						\
+  } while (0)
+
+#ifndef _SOFT_FLOAT
+/*
+ * these are arbitrary, but we choose
+ * the same values as co-processor would use
+ */
+#define FP_EX_INVALID		0x4000
+#define FP_EX_OVERFLOW		0x1000
+#define FP_EX_DIVZERO		0x0400
+#define FP_EX_UNDERFLOW		0x0800
+#define FP_EX_INEXACT		0x0200
+#define FP_EX_ALL \
+	(FP_EX_INVALID | FP_EX_DENORM | FP_EX_DIVZERO | FP_EX_OVERFLOW \
+	 | FP_EX_UNDERFLOW | FP_EX_INEXACT)
+
+void __sfp_handle_exceptions (int);
+
+#define FP_HANDLE_EXCEPTIONS			\
+  do {						\
+    if (__builtin_expect (_fex, 0))		\
+      __sfp_handle_exceptions (_fex);		\
+  } while (0)
+
+#define FP_TRAPPING_EXCEPTIONS ((_fcw >> FP_EX_SHIFT) & FP_EX_ALL)
+
+#define FP_ROUNDMODE		(_fcw & FP_RND_MASK)
+#endif
+
+#define _FP_TININESS_AFTER_ROUNDING 1
+
+#define	__LITTLE_ENDIAN	1234
+#define	__BIG_ENDIAN	4321
+
+#define __BYTE_ORDER __BIG_ENDIAN
+
+/* Define ALIASNAME as a strong alias for NAME.  */
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+# define _strong_alias(name, aliasname) \
+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));
+
diff --git a/libgcc/config/m68k/subxf3.c b/libgcc/config/m68k/subxf3.c
new file mode 100644
index 00000000000..e0d005769ad
--- /dev/null
+++ b/libgcc/config/m68k/subxf3.c
@@ -0,0 +1,45 @@
+/* Software floating-point emulation.
+   Return a - b
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp/soft-fp.h"
+#ifdef LIBGCC_HAS_XF_MODE
+#include "soft-fp/extended.h"
+
+long double
+__subxf3 (long double a, long double b)
+{
+	(void)a;
+	__asm__ __volatile__(
+		"bchg #7,%0\n\t"
+		"jmp %1"
+	:
+	: "m"(b), "m"(__addxf3)
+	: "cc", "memory");
+	__builtin_unreachable();
+}
+#endif
diff --git a/libgcc/config/m68k/t-floatlib b/libgcc/config/m68k/t-floatlib
index 1ee8782d9fd..50a9ad20070 100644
--- a/libgcc/config/m68k/t-floatlib
+++ b/libgcc/config/m68k/t-floatlib
@@ -1,11 +1,31 @@
 LIB1ASMSRC = m68k/lb1sf68.S
 LIB1ASMFUNCS = _mulsi3 _udivsi3 _divsi3 _umodsi3 _modsi3 \
-   _double _float _floatex \
-   _eqdf2 _nedf2 _gtdf2 _gedf2 _ltdf2 _ledf2 \
-   _eqsf2 _nesf2 _gtsf2 _gesf2 _ltsf2 _lesf2
+	_double _long_double _float _floatex
 
-LIB2ADD = $(srcdir)/config/m68k/fpgnulib.c xfgnulib.c
-
-xfgnulib.c: $(srcdir)/config/m68k/fpgnulib.c
-	echo '#define EXTFLOAT' > xfgnulib.c
-	cat $< >> xfgnulib.c
+LIB2ADD = \
+	$(srcdir)/config/m68k/unordsf2.c \
+	$(srcdir)/config/m68k/unorddf2.c \
+	$(srcdir)/config/m68k/floatunsidf.c \
+	$(srcdir)/config/m68k/floatsidf.c \
+	$(srcdir)/config/m68k/floatunsisf.c \
+	$(srcdir)/config/m68k/floatsisf.c \
+	$(srcdir)/config/m68k/extendsfdf2.c \
+	$(srcdir)/config/m68k/truncdfsf2.c \
+	$(srcdir)/config/m68k/fixdfsi.c \
+	$(srcdir)/config/m68k/fixsfsi.c \
+	\
+	$(srcdir)/config/m68k/unordxf2.c \
+	$(srcdir)/config/m68k/extenddfxf2.c \
+	$(srcdir)/config/m68k/extendsfxf2.c \
+	$(srcdir)/config/m68k/truncxfdf2.c \
+	$(srcdir)/config/m68k/truncxfsf2.c \
+	$(srcdir)/config/m68k/floatsixf.c \
+	$(srcdir)/config/m68k/floatunsixf.c \
+	$(srcdir)/config/m68k/fixxfsi.c \
+	\
+	$(srcdir)/config/m68k/addxf3.c \
+	$(srcdir)/config/m68k/subxf3.c \
+	$(srcdir)/config/m68k/mulxf3.c \
+	$(srcdir)/config/m68k/divxf3.c \
+	$(srcdir)/config/m68k/sfp-exceptions.c \
+	$(empty)
diff --git a/libgcc/config/m68k/t-mint b/libgcc/config/m68k/t-mint
new file mode 100644
index 00000000000..c768fc121b0
--- /dev/null
+++ b/libgcc/config/m68k/t-mint
@@ -0,0 +1 @@
+LIB2ADD_ST = $(srcdir)/config/m68k/mint-atomic.c
diff --git a/libgcc/config/m68k/truncdfsf2.c b/libgcc/config/m68k/truncdfsf2.c
new file mode 100644
index 00000000000..75017b4f0a8
--- /dev/null
+++ b/libgcc/config/m68k/truncdfsf2.c
@@ -0,0 +1,2 @@
+#define L_truncdfsf2
+#include "fpgnulib.c"
diff --git a/libgcc/config/m68k/truncxfdf2.c b/libgcc/config/m68k/truncxfdf2.c
new file mode 100644
index 00000000000..67db750e2d0
--- /dev/null
+++ b/libgcc/config/m68k/truncxfdf2.c
@@ -0,0 +1,2 @@
+#define L_truncxfdf2
+#include "fpgnulib.c"
diff --git a/libgcc/config/m68k/truncxfsf2.c b/libgcc/config/m68k/truncxfsf2.c
new file mode 100644
index 00000000000..1320019a454
--- /dev/null
+++ b/libgcc/config/m68k/truncxfsf2.c
@@ -0,0 +1,2 @@
+#define L_truncxfsf2
+#include "fpgnulib.c"
diff --git a/libgcc/config/m68k/unorddf2.c b/libgcc/config/m68k/unorddf2.c
new file mode 100644
index 00000000000..32f668b2aa7
--- /dev/null
+++ b/libgcc/config/m68k/unorddf2.c
@@ -0,0 +1,2 @@
+#define L_unorddf2
+#include "fpgnulib.c"
diff --git a/libgcc/config/m68k/unordsf2.c b/libgcc/config/m68k/unordsf2.c
new file mode 100644
index 00000000000..0471d9a121e
--- /dev/null
+++ b/libgcc/config/m68k/unordsf2.c
@@ -0,0 +1,2 @@
+#define L_unordsf2
+#include "fpgnulib.c"
diff --git a/libgcc/config/m68k/unordxf2.c b/libgcc/config/m68k/unordxf2.c
new file mode 100644
index 00000000000..a1c11bee483
--- /dev/null
+++ b/libgcc/config/m68k/unordxf2.c
@@ -0,0 +1,2 @@
+#define L_unordxf2
+#include "fpgnulib.c"
diff --git a/libgcc/crtstuff.c b/libgcc/crtstuff.c
index b9767cd1eee..d5a3850d688 100644
--- a/libgcc/crtstuff.c
+++ b/libgcc/crtstuff.c
@@ -198,7 +198,12 @@ extern void _ITM_deregisterTMCloneTable (void *) TARGET_ATTRIBUTE_WEAK;
 
 /*  Declare a pointer to void function type.  */
 typedef void (*func_ptr) (void);
+#ifdef HAS_INIT_SECTION
 #define STATIC static
+#else
+/* Define global arrays because they are referred by __main.o.  */
+#define STATIC
+#endif
 
 #else  /* OBJECT_FORMAT_ELF */
 
@@ -252,6 +257,7 @@ STATIC func_ptr __DTOR_LIST__[1]
   = { (func_ptr) (-1) };
 #else
 STATIC func_ptr __DTOR_LIST__[1]
+  __attribute__((__used__))
   __attribute__((section(".dtors"), aligned(__alignof__(func_ptr))))
   = { (func_ptr) (-1) };
 #endif /* __DTOR_LIST__ alternatives */
@@ -260,7 +266,9 @@ STATIC func_ptr __DTOR_LIST__[1]
 #ifdef USE_EH_FRAME_REGISTRY
 /* Stick a label at the beginning of the frame unwind info so we can register
    and deregister it with the exception handling library code.  */
+
 STATIC EH_FRAME_SECTION_CONST char __EH_FRAME_BEGIN__[]
+     __attribute__((__used__))
      __attribute__((section(__LIBGCC_EH_FRAME_SECTION_NAME__),
 		    aligned(__alignof__ (void *))))
      = { };
@@ -594,6 +602,8 @@ __do_global_ctors_1(void)
 }
 #endif /* USE_EH_FRAME_REGISTRY || USE_TM_CLONE_REGISTRY */
 
+#elif defined(__MINT__) && defined(__ELF__)
+/* already done in libgcc2.c */
 #else /* ! __LIBGCC_INIT_SECTION_ASM_OP__ && ! HAS_INIT_SECTION */
 #error "What are you doing with crtstuff.c, then?"
 #endif
@@ -621,6 +631,7 @@ STATIC func_ptr __CTOR_END__[1]
   = { (func_ptr) 0 };
 #else
 STATIC func_ptr __CTOR_END__[1]
+  __attribute__((__used__))
   __attribute__((section(".ctors"), aligned(__alignof__(func_ptr))))
   = { (func_ptr) 0 };
 #endif
@@ -753,6 +764,8 @@ __do_global_ctors (void)
     (*p) ();
 }
 
+#elif defined(__MINT__) && defined(__ELF__)
+/* already done in libgcc2.c */
 #else /* ! __LIBGCC_INIT_SECTION_ASM_OP__ && ! HAS_INIT_SECTION */
 #error "What are you doing with crtstuff.c, then?"
 #endif
diff --git a/libgcc/emutls.c b/libgcc/emutls.c
index ee410923f43..81412af08d3 100644
--- a/libgcc/emutls.c
+++ b/libgcc/emutls.c
@@ -66,9 +66,9 @@ struct __emutls_array
 #pragma GCC diagnostic ignored "-Wbuiltin-declaration-mismatch"
 
 EMUTLS_ATTR
-void *__emutls_get_address (struct __emutls_object *);
+void *__emutls_get_address (void *);
 EMUTLS_ATTR
-void __emutls_register_common (struct __emutls_object *, word, word, void *);
+void __emutls_register_common (void *, word, word, void *);
 
 #ifdef __GTHREADS
 #ifdef __GTHREAD_MUTEX_INIT
@@ -145,8 +145,9 @@ emutls_alloc (struct __emutls_object *obj)
    implementation here, causes the decl. attributes to be discarded.  */
 
 EMUTLS_ATTR void *
-__emutls_get_address (struct __emutls_object *obj)
+__emutls_get_address (void *_obj)
 {
+  struct __emutls_object *obj = (struct __emutls_object *)_obj;
   if (! __gthread_active_p ())
     {
       if (__builtin_expect (obj->loc.ptr == NULL, 0))
@@ -209,9 +210,10 @@ __emutls_get_address (struct __emutls_object *obj)
 }
 
 EMUTLS_ATTR void
-__emutls_register_common (struct __emutls_object *obj,
+__emutls_register_common (void *_obj,
 			  word size, word align, void *templ)
 {
+  struct __emutls_object *obj = (struct __emutls_object *)_obj;
   if (obj->size < size)
     {
       obj->size = size;
diff --git a/libgcc/gthr-posix.h b/libgcc/gthr-posix.h
index eeb84f32d8f..7afb7f2c457 100644
--- a/libgcc/gthr-posix.h
+++ b/libgcc/gthr-posix.h
@@ -103,7 +103,7 @@ typedef struct timespec __gthread_time_t;
 # define __GTHREAD_COND_INIT_FUNCTION __gthread_cond_init_function
 #endif
 
-#if SUPPORTS_WEAK && GTHREAD_USE_WEAK
+#if SUPPORTS_WEAK && GTHREAD_USE_WEAK && !defined(__MINGW32__)
 # ifndef __gthrw_pragma
 #  define __gthrw_pragma(pragma)
 # endif
diff --git a/libgcc/libgcc2.c b/libgcc/libgcc2.c
index 92cb79dc8f8..1fdc82648eb 100644
--- a/libgcc/libgcc2.c
+++ b/libgcc/libgcc2.c
@@ -3189,6 +3189,9 @@ SYMBOL__MAIN (void)
 
    Long term no port should use those extensions.  But many still do.  */
 #if !defined(__LIBGCC_INIT_SECTION_ASM_OP__)
+#if defined(__MINT__) && defined(__ELF__)
+/* nothing; we use the definitions from crtstuff.c now */
+#else
 #if defined (TARGET_ASM_CONSTRUCTOR) || defined (USE_COLLECT2)
 func_ptr __CTOR_LIST__[2] = {0, 0};
 func_ptr __DTOR_LIST__[2] = {0, 0};
@@ -3196,6 +3199,7 @@ func_ptr __DTOR_LIST__[2] = {0, 0};
 func_ptr __CTOR_LIST__[2];
 func_ptr __DTOR_LIST__[2];
 #endif
+#endif
 #endif /* no __LIBGCC_INIT_SECTION_ASM_OP__ */
 #endif /* L_ctors */
 #endif /* LIBGCC2_UNITS_PER_WORD <= MIN_UNITS_PER_WORD */
diff --git a/libgcc/soft-fp/addxf3.c b/libgcc/soft-fp/addxf3.c
new file mode 100644
index 00000000000..bde96b06081
--- /dev/null
+++ b/libgcc/soft-fp/addxf3.c
@@ -0,0 +1,51 @@
+/* Software floating-point emulation.
+   Return a + b
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#ifdef LIBGCC_HAS_XF_MODE
+#include "extended.h"
+
+XFtype
+__addxf3 (XFtype a, XFtype b)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  FP_DECL_E (B);
+  FP_DECL_E (R);
+  XFtype r;
+
+  FP_INIT_ROUNDMODE;
+  FP_UNPACK_SEMIRAW_E (A, a);
+  FP_UNPACK_SEMIRAW_E (B, b);
+  FP_ADD_E (R, A, B);
+  FP_PACK_SEMIRAW_E (r, R);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
+#endif
diff --git a/libgcc/soft-fp/brain.h b/libgcc/soft-fp/brain.h
index c8563ef8897..0d4b89eeede 100644
--- a/libgcc/soft-fp/brain.h
+++ b/libgcc/soft-fp/brain.h
@@ -164,6 +164,7 @@ union _FP_UNION_B
 /* BFmode arithmetic is not implemented.  */
 
 #define _FP_FRAC_HIGH_B(X)	_FP_FRAC_HIGH_1 (X)
+#define _FP_FRAC_ZEROHIGH_B(X)
 #define _FP_FRAC_HIGH_RAW_B(X)	_FP_FRAC_HIGH_1 (X)
 #define _FP_FRAC_HIGH_DW_B(X)	_FP_FRAC_HIGH_1 (X)
 
diff --git a/libgcc/soft-fp/divxf3.c b/libgcc/soft-fp/divxf3.c
new file mode 100644
index 00000000000..9eb45e27365
--- /dev/null
+++ b/libgcc/soft-fp/divxf3.c
@@ -0,0 +1,51 @@
+/* Software floating-point emulation.
+   Return a / b
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#ifdef LIBGCC_HAS_XF_MODE
+#include "extended.h"
+
+XFtype
+__divxf3 (XFtype a, XFtype b)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  FP_DECL_E (B);
+  FP_DECL_E (R);
+  XFtype r;
+
+  FP_INIT_ROUNDMODE;
+  FP_UNPACK_E (A, a);
+  FP_UNPACK_E (B, b);
+  FP_DIV_E (R, A, B);
+  FP_PACK_E (r, R);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
+#endif
diff --git a/libgcc/soft-fp/double.h b/libgcc/soft-fp/double.h
index 497ab92ccf8..cdf3d20703d 100644
--- a/libgcc/soft-fp/double.h
+++ b/libgcc/soft-fp/double.h
@@ -186,6 +186,7 @@ union _FP_UNION_D
 # define FP_FROM_INT_D(X, r, rs, rt)	_FP_FROM_INT (D, 2, X, (r), (rs), rt)
 
 # define _FP_FRAC_HIGH_D(X)	_FP_FRAC_HIGH_2 (X)
+# define _FP_FRAC_ZEROHIGH_D(X)
 # define _FP_FRAC_HIGH_RAW_D(X)	_FP_FRAC_HIGH_2 (X)
 
 # define _FP_FRAC_HIGH_DW_D(X)	_FP_FRAC_HIGH_4 (X)
@@ -310,6 +311,7 @@ union _FP_UNION_D
 # define FP_FROM_INT_D(X, r, rs, rt)	_FP_FROM_INT (D, 1, X, (r), (rs), rt)
 
 # define _FP_FRAC_HIGH_D(X)	_FP_FRAC_HIGH_1 (X)
+# define _FP_FRAC_ZEROHIGH_D(X)
 # define _FP_FRAC_HIGH_RAW_D(X)	_FP_FRAC_HIGH_1 (X)
 
 # define _FP_FRAC_HIGH_DW_D(X)	_FP_FRAC_HIGH_2 (X)
diff --git a/libgcc/soft-fp/eqxf2.c b/libgcc/soft-fp/eqxf2.c
new file mode 100644
index 00000000000..f5d86407a6d
--- /dev/null
+++ b/libgcc/soft-fp/eqxf2.c
@@ -0,0 +1,49 @@
+/* Software floating-point emulation.
+   Return 0 iff a == b, 1 otherwise
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "extended.h"
+
+CMPtype
+__eqxf2 (XFtype a, XFtype b)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  FP_DECL_E (B);
+  CMPtype r;
+
+  FP_INIT_EXCEPTIONS;
+  FP_UNPACK_RAW_E (A, a);
+  FP_UNPACK_RAW_E (B, b);
+  FP_CMP_EQ_E (r, A, B, 1);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
+
+strong_alias (__eqxf2, __nexf2);
diff --git a/libgcc/soft-fp/extenddfxf2.c b/libgcc/soft-fp/extenddfxf2.c
new file mode 100644
index 00000000000..053ee08a8ca
--- /dev/null
+++ b/libgcc/soft-fp/extenddfxf2.c
@@ -0,0 +1,53 @@
+/* Software floating-point emulation.
+   Return a converted to IEEE quad
+   Copyright (C) 2007-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define FP_NO_EXACT_UNDERFLOW
+#include "soft-fp.h"
+#include "double.h"
+#include "extended.h"
+
+XFtype
+__extenddfxf2 (DFtype a)
+{
+  FP_DECL_EX;
+  FP_DECL_D (A);
+  FP_DECL_E (R);
+  XFtype r;
+
+  FP_INIT_TRAPPING_EXCEPTIONS;
+  FP_UNPACK_RAW_D (A, a);
+#if _FP_W_TYPE_SIZE < 64
+  FP_EXTEND (E, D, 4, 2, R, A);
+#else
+  FP_EXTEND (E, D, 2, 1, R, A);
+#endif
+  FP_PACK_RAW_E (r, R);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/libgcc/soft-fp/extended.h b/libgcc/soft-fp/extended.h
index 14e306d58c3..7c80924a933 100644
--- a/libgcc/soft-fp/extended.h
+++ b/libgcc/soft-fp/extended.h
@@ -75,10 +75,9 @@ union _FP_UNION_E
   struct _FP_STRUCT_LAYOUT
   {
 # if __BYTE_ORDER == __BIG_ENDIAN
-    unsigned long pad1 : _FP_W_TYPE_SIZE;
-    unsigned long pad2 : (_FP_W_TYPE_SIZE - 1 - _FP_EXPBITS_E);
     unsigned long sign : 1;
     unsigned long exp : _FP_EXPBITS_E;
+    unsigned long pad2 : (_FP_W_TYPE_SIZE - 1 - _FP_EXPBITS_E);
     unsigned long frac1 : _FP_W_TYPE_SIZE;
     unsigned long frac0 : _FP_W_TYPE_SIZE;
 # else
@@ -301,9 +300,10 @@ union _FP_UNION_E
 # define FP_FROM_INT_E(X, r, rs, rt)	_FP_FROM_INT (E, 4, X, (r), (rs), rt)
 
 # define _FP_FRAC_HIGH_E(X)	(X##_f[2])
+# define _FP_FRAC_ZEROHIGH_E(X)	(X##_f[3] = 0)
 # define _FP_FRAC_HIGH_RAW_E(X)	(X##_f[1])
 
-# define _FP_FRAC_HIGH_DW_E(X)	(X##_f[4])
+# define _FP_FRAC_HIGH_DW_E(X)	_FP_FRAC_HIGH_4(X)
 
 #else   /* not _FP_W_TYPE_SIZE < 64 */
 union _FP_UNION_E
@@ -312,9 +312,9 @@ union _FP_UNION_E
   struct _FP_STRUCT_LAYOUT
   {
 # if __BYTE_ORDER == __BIG_ENDIAN
-    _FP_W_TYPE pad  : (_FP_W_TYPE_SIZE - 1 - _FP_EXPBITS_E);
     unsigned sign   : 1;
     unsigned exp    : _FP_EXPBITS_E;
+    _FP_W_TYPE pad  : (_FP_W_TYPE_SIZE - 1 - _FP_EXPBITS_E);
     _FP_W_TYPE frac : _FP_W_TYPE_SIZE;
 # else
     _FP_W_TYPE frac : _FP_W_TYPE_SIZE;
@@ -507,6 +507,7 @@ union _FP_UNION_E
 # define FP_FROM_INT_E(X, r, rs, rt)	_FP_FROM_INT (E, 2, X, (r), (rs), rt)
 
 # define _FP_FRAC_HIGH_E(X)	(X##_f1)
+# define _FP_FRAC_ZEROHIGH_E(X)
 # define _FP_FRAC_HIGH_RAW_E(X)	(X##_f0)
 
 # define _FP_FRAC_HIGH_DW_E(X)	(X##_f[2])
diff --git a/libgcc/soft-fp/extendsfxf2.c b/libgcc/soft-fp/extendsfxf2.c
new file mode 100644
index 00000000000..d9ae418f3ef
--- /dev/null
+++ b/libgcc/soft-fp/extendsfxf2.c
@@ -0,0 +1,53 @@
+/* Software floating-point emulation.
+   Return a converted to IEEE quad
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define FP_NO_EXACT_UNDERFLOW
+#include "soft-fp.h"
+#include "single.h"
+#include "extended.h"
+
+XFtype
+__extendsfxf2 (SFtype a)
+{
+  FP_DECL_EX;
+  FP_DECL_S (A);
+  FP_DECL_E (R);
+  XFtype r;
+
+  FP_INIT_EXCEPTIONS;
+  FP_UNPACK_RAW_S (A, a);
+#if _FP_W_TYPE_SIZE < 64
+  FP_EXTEND (E, S, 4, 1, R, A);
+#else
+  FP_EXTEND (E, S, 2, 1, R, A);
+#endif
+  FP_PACK_RAW_E (r, R);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/libgcc/soft-fp/extendxftf2.c b/libgcc/soft-fp/extendxftf2.c
index 4d56b1d9d08..fb6efd5ab0a 100644
--- a/libgcc/soft-fp/extendxftf2.c
+++ b/libgcc/soft-fp/extendxftf2.c
@@ -26,6 +26,7 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
+#define FP_NO_EXACT_UNDERFLOW
 #include "soft-fp.h"
 #include "extended.h"
 #include "quad.h"
diff --git a/libgcc/soft-fp/fixunsxfdi.c b/libgcc/soft-fp/fixunsxfdi.c
new file mode 100644
index 00000000000..7826eb586c1
--- /dev/null
+++ b/libgcc/soft-fp/fixunsxfdi.c
@@ -0,0 +1,45 @@
+/* Software floating-point emulation.
+   Convert a to 64bit unsigned integer
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "extended.h"
+
+UDItype
+__fixunsxfdi (XFtype a)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  UDItype r;
+
+  FP_INIT_EXCEPTIONS;
+  FP_UNPACK_RAW_E (A, a);
+  FP_TO_INT_E (r, A, DI_BITS, 0);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/libgcc/soft-fp/fixunsxfsi.c b/libgcc/soft-fp/fixunsxfsi.c
new file mode 100644
index 00000000000..2197c15af56
--- /dev/null
+++ b/libgcc/soft-fp/fixunsxfsi.c
@@ -0,0 +1,45 @@
+/* Software floating-point emulation.
+   Convert a to 32bit unsigned integer
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "extended.h"
+
+USItype
+__fixunsxfsi (XFtype a)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  USItype r;
+
+  FP_INIT_EXCEPTIONS;
+  FP_UNPACK_RAW_E (A, a);
+  FP_TO_INT_E (r, A, SI_BITS, 0);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/libgcc/soft-fp/fixxfdi.c b/libgcc/soft-fp/fixxfdi.c
new file mode 100644
index 00000000000..191b2cc9640
--- /dev/null
+++ b/libgcc/soft-fp/fixxfdi.c
@@ -0,0 +1,45 @@
+/* Software floating-point emulation.
+   Convert a to 64bit signed integer
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "extended.h"
+
+DItype
+__fixxfdi (XFtype a)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  UDItype r;
+
+  FP_INIT_EXCEPTIONS;
+  FP_UNPACK_RAW_E (A, a);
+  FP_TO_INT_E (r, A, DI_BITS, 1);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/libgcc/soft-fp/fixxfsi.c b/libgcc/soft-fp/fixxfsi.c
new file mode 100644
index 00000000000..d7b194e5094
--- /dev/null
+++ b/libgcc/soft-fp/fixxfsi.c
@@ -0,0 +1,45 @@
+/* Software floating-point emulation.
+   Convert a to 32bit signed integer
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "extended.h"
+
+SItype
+__fixxfsi (XFtype a)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  USItype r;
+
+  FP_INIT_EXCEPTIONS;
+  FP_UNPACK_RAW_E (A, a);
+  FP_TO_INT_E (r, A, SI_BITS, 1);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/libgcc/soft-fp/floatdixf.c b/libgcc/soft-fp/floatdixf.c
new file mode 100644
index 00000000000..1ffc2b36e84
--- /dev/null
+++ b/libgcc/soft-fp/floatdixf.c
@@ -0,0 +1,46 @@
+/* Software floating-point emulation.
+   Convert a 64bit signed integer to IEEE double
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define FP_NO_EXCEPTIONS
+#include "soft-fp.h"
+#include "extended.h"
+
+XFtype
+__floatdixf (DItype i)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  XFtype a;
+
+  FP_INIT_ROUNDMODE;
+  FP_FROM_INT_E (A, i, DI_BITS, UDItype);
+  FP_PACK_RAW_E (a, A);
+  FP_HANDLE_EXCEPTIONS;
+
+  return a;
+}
diff --git a/libgcc/soft-fp/floatsixf.c b/libgcc/soft-fp/floatsixf.c
new file mode 100644
index 00000000000..dc1589c844a
--- /dev/null
+++ b/libgcc/soft-fp/floatsixf.c
@@ -0,0 +1,43 @@
+/* Software floating-point emulation.
+   Convert a 32bit signed integer to IEEE double
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define FP_NO_EXCEPTIONS
+#include "soft-fp.h"
+#include "extended.h"
+
+XFtype
+__floatsixf (SItype i)
+{
+  FP_DECL_E (A);
+  XFtype a;
+
+  FP_FROM_INT_E (A, i, SI_BITS, USItype);
+  FP_PACK_RAW_E (a, A);
+
+  return a;
+}
diff --git a/libgcc/soft-fp/floatundixf.c b/libgcc/soft-fp/floatundixf.c
new file mode 100644
index 00000000000..fa397ff2373
--- /dev/null
+++ b/libgcc/soft-fp/floatundixf.c
@@ -0,0 +1,46 @@
+/* Software floating-point emulation.
+   Convert a 64bit unsigned integer to IEEE double
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define FP_NO_EXCEPTIONS
+#include "soft-fp.h"
+#include "extended.h"
+
+XFtype
+__floatundixf (UDItype i)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  XFtype a;
+
+  FP_INIT_ROUNDMODE;
+  FP_FROM_INT_E (A, i, DI_BITS, UDItype);
+  FP_PACK_RAW_E (a, A);
+  FP_HANDLE_EXCEPTIONS;
+
+  return a;
+}
diff --git a/libgcc/soft-fp/floatunsixf.c b/libgcc/soft-fp/floatunsixf.c
new file mode 100644
index 00000000000..09994a9d01f
--- /dev/null
+++ b/libgcc/soft-fp/floatunsixf.c
@@ -0,0 +1,43 @@
+/* Software floating-point emulation.
+   Convert a 32bit unsigned integer to IEEE double
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define FP_NO_EXCEPTIONS
+#include "soft-fp.h"
+#include "extended.h"
+
+XFtype
+__floatunsixf (USItype i)
+{
+  FP_DECL_E (A);
+  XFtype a;
+
+  FP_FROM_INT_E (A, i, SI_BITS, USItype);
+  FP_PACK_RAW_E (a, A);
+
+  return a;
+}
diff --git a/libgcc/soft-fp/gexf2.c b/libgcc/soft-fp/gexf2.c
new file mode 100644
index 00000000000..bae1915e825
--- /dev/null
+++ b/libgcc/soft-fp/gexf2.c
@@ -0,0 +1,49 @@
+/* Software floating-point emulation.
+   Return 0 iff a == b, 1 iff a > b, -2 iff a ? b, -1 iff a < b
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "extended.h"
+
+CMPtype
+__gexf2 (XFtype a, XFtype b)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  FP_DECL_E (B);
+  CMPtype r;
+
+  FP_INIT_EXCEPTIONS;
+  FP_UNPACK_RAW_E (A, a);
+  FP_UNPACK_RAW_E (B, b);
+  FP_CMP_E (r, A, B, -2, 2);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
+
+strong_alias (__gexf2, __gtxf2);
diff --git a/libgcc/soft-fp/half.h b/libgcc/soft-fp/half.h
index a8c5c318233..9c75802004d 100644
--- a/libgcc/soft-fp/half.h
+++ b/libgcc/soft-fp/half.h
@@ -164,6 +164,7 @@ union _FP_UNION_H
 /* HFmode arithmetic is not implemented.  */
 
 #define _FP_FRAC_HIGH_H(X)	_FP_FRAC_HIGH_1 (X)
+#define _FP_FRAC_ZEROHIGH_H(X)
 #define _FP_FRAC_HIGH_RAW_H(X)	_FP_FRAC_HIGH_1 (X)
 #define _FP_FRAC_HIGH_DW_H(X)	_FP_FRAC_HIGH_1 (X)
 
diff --git a/libgcc/soft-fp/lexf2.c b/libgcc/soft-fp/lexf2.c
new file mode 100644
index 00000000000..2bf1b992f3a
--- /dev/null
+++ b/libgcc/soft-fp/lexf2.c
@@ -0,0 +1,49 @@
+/* Software floating-point emulation.
+   Return 0 iff a == b, 1 iff a > b, 2 iff a ? b, -1 iff a < b
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "extended.h"
+
+CMPtype
+__lexf2 (XFtype a, XFtype b)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  FP_DECL_E (B);
+  CMPtype r;
+
+  FP_INIT_EXCEPTIONS;
+  FP_UNPACK_RAW_E (A, a);
+  FP_UNPACK_RAW_E (B, b);
+  FP_CMP_E (r, A, B, 2, 2);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
+
+strong_alias (__lexf2, __ltxf2);
diff --git a/libgcc/soft-fp/mulxf3.c b/libgcc/soft-fp/mulxf3.c
new file mode 100644
index 00000000000..d3df98b74ab
--- /dev/null
+++ b/libgcc/soft-fp/mulxf3.c
@@ -0,0 +1,51 @@
+/* Software floating-point emulation.
+   Return a * b
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#ifdef LIBGCC_HAS_XF_MODE
+#include "extended.h"
+
+XFtype
+__mulxf3 (XFtype a, XFtype b)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  FP_DECL_E (B);
+  FP_DECL_E (R);
+  XFtype r;
+
+  FP_INIT_ROUNDMODE;
+  FP_UNPACK_E (A, a);
+  FP_UNPACK_E (B, b);
+  FP_MUL_E (R, A, B);
+  FP_PACK_E (r, R);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
+#endif
diff --git a/libgcc/soft-fp/negxf2.c b/libgcc/soft-fp/negxf2.c
new file mode 100644
index 00000000000..2da7d10ab3d
--- /dev/null
+++ b/libgcc/soft-fp/negxf2.c
@@ -0,0 +1,44 @@
+/* Software floating-point emulation.
+   Return -a
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "extended.h"
+
+XFtype
+__negxf2 (XFtype a)
+{
+  FP_DECL_E (A);
+  FP_DECL_E (R);
+  XFtype r;
+
+  FP_UNPACK_RAW_E (A, a);
+  FP_NEG_E (R, A);
+  FP_PACK_RAW_E (r, R);
+
+  return r;
+}
diff --git a/libgcc/soft-fp/op-2.h b/libgcc/soft-fp/op-2.h
index 412b972e8fc..35f47a4dfc1 100644
--- a/libgcc/soft-fp/op-2.h
+++ b/libgcc/soft-fp/op-2.h
@@ -30,7 +30,7 @@
 #define SOFT_FP_OP_2_H	1
 
 #define _FP_FRAC_DECL_2(X)				\
-  _FP_W_TYPE X##_f0 _FP_ZERO_INIT, X##_f1 _FP_ZERO_INIT
+  _FP_W_TYPE X##_f0 _FP_ZERO_INIT, X##_f1 _FP_ZERO_INIT __attribute__((unused))
 #define _FP_FRAC_COPY_2(D, S)	(D##_f0 = S##_f0, D##_f1 = S##_f1)
 #define _FP_FRAC_SET_2(X, I)	__FP_FRAC_SET_2 (X, I)
 #define _FP_FRAC_HIGH_2(X)	(X##_f1)
@@ -194,9 +194,9 @@
 # undef __FP_FRAC_ADDI_2
 # define __FP_FRAC_ADDI_2(xh, xl, i)	add_ssaaaa (xh, xl, xh, xl, 0, i)
 # undef __FP_FRAC_ADD_2
-# define __FP_FRAC_ADD_2		add_ssaaaa
+# define __FP_FRAC_ADD_2(rh, rl, xh, xl, yh, yl) add_ssaaaa(rh, rl, xh, xl, yh, yl)
 # undef __FP_FRAC_SUB_2
-# define __FP_FRAC_SUB_2		sub_ddmmss
+# define __FP_FRAC_SUB_2(rh, rl, xh, xl, yh, yl) sub_ddmmss(rh, rl, xh, xl, yh, yl)
 # undef __FP_FRAC_DEC_2
 # define __FP_FRAC_DEC_2(xh, xl, yh, yl)	\
   sub_ddmmss (xh, xl, xh, xl, yh, yl)
diff --git a/libgcc/soft-fp/op-common.h b/libgcc/soft-fp/op-common.h
index 090028f8c7d..6e21a52695c 100644
--- a/libgcc/soft-fp/op-common.h
+++ b/libgcc/soft-fp/op-common.h
@@ -243,6 +243,7 @@
 	    _FP_OVERFLOW_SEMIRAW (fs, wc, X);			\
 	}							\
       _FP_FRAC_SRL_##wc (X, _FP_WORKBITS);			\
+      _FP_FRAC_ZEROHIGH_##fs(X);				\
       if (X##_e == _FP_EXPMAX_##fs && !_FP_FRAC_ZEROP_##wc (X))	\
 	{							\
 	  if (!_FP_KEEPNANFRACP)				\
@@ -820,6 +821,7 @@
 		 canceling it; renormalize.  */				\
 	      _FP_FRAC_HIGH_##fs (R) &= _FP_IMPLBIT_SH_##fs - 1;	\
 	    norm:							\
+	      _FP_FRAC_ZEROHIGH_##fs(R); \
 	      _FP_FRAC_CLZ_##wc (_FP_ADD_INTERNAL_diff, R);		\
 	      _FP_ADD_INTERNAL_diff -= _FP_WFRACXBITS_##fs;		\
 	      _FP_FRAC_SLL_##wc (R, _FP_ADD_INTERNAL_diff);		\
diff --git a/libgcc/soft-fp/quad.h b/libgcc/soft-fp/quad.h
index 71f87d36ba9..f5f5aa29801 100644
--- a/libgcc/soft-fp/quad.h
+++ b/libgcc/soft-fp/quad.h
@@ -193,6 +193,7 @@ union _FP_UNION_Q
 # define FP_FROM_INT_Q(X, r, rs, rt)	_FP_FROM_INT (Q, 4, X, (r), (rs), rt)
 
 # define _FP_FRAC_HIGH_Q(X)	_FP_FRAC_HIGH_4 (X)
+# define _FP_FRAC_ZEROHIGH_Q(X)
 # define _FP_FRAC_HIGH_RAW_Q(X)	_FP_FRAC_HIGH_4 (X)
 
 # define _FP_FRAC_HIGH_DW_Q(X)	_FP_FRAC_HIGH_8 (X)
@@ -319,6 +320,7 @@ union _FP_UNION_Q
 # define FP_FROM_INT_Q(X, r, rs, rt)	_FP_FROM_INT (Q, 2, X, (r), (rs), rt)
 
 # define _FP_FRAC_HIGH_Q(X)	_FP_FRAC_HIGH_2 (X)
+# define _FP_FRAC_ZEROHIGH_Q(X)
 # define _FP_FRAC_HIGH_RAW_Q(X)	_FP_FRAC_HIGH_2 (X)
 
 # define _FP_FRAC_HIGH_DW_Q(X)	_FP_FRAC_HIGH_4 (X)
diff --git a/libgcc/soft-fp/single.h b/libgcc/soft-fp/single.h
index 2d3a19dddeb..f846c6e3d28 100644
--- a/libgcc/soft-fp/single.h
+++ b/libgcc/soft-fp/single.h
@@ -184,6 +184,7 @@ union _FP_UNION_S
 #define FP_FROM_INT_S(X, r, rs, rt)	_FP_FROM_INT (S, 1, X, (r), (rs), rt)
 
 #define _FP_FRAC_HIGH_S(X)	_FP_FRAC_HIGH_1 (X)
+#define _FP_FRAC_ZEROHIGH_S(X)
 #define _FP_FRAC_HIGH_RAW_S(X)	_FP_FRAC_HIGH_1 (X)
 
 #if _FP_W_TYPE_SIZE < 64
diff --git a/libgcc/soft-fp/soft-fp.h b/libgcc/soft-fp/soft-fp.h
index 3799be4e09c..89d8f60d6af 100644
--- a/libgcc/soft-fp/soft-fp.h
+++ b/libgcc/soft-fp/soft-fp.h
@@ -347,4 +347,6 @@ typedef USItype UHWtype;
 # endif
 #endif
 
+#include "softfp-protos.h"
+
 #endif /* !SOFT_FP_H */
diff --git a/libgcc/soft-fp/softfp-protos.h b/libgcc/soft-fp/softfp-protos.h
new file mode 100644
index 00000000000..6bf7e9bf42e
--- /dev/null
+++ b/libgcc/soft-fp/softfp-protos.h
@@ -0,0 +1,215 @@
+#ifdef __FLT16_MANT_DIG__
+#define LIBGCC_HAS_HF_MODE
+#endif
+#ifdef __FLT_MANT_DIG__
+#define LIBGCC_HAS_SF_MODE
+#endif
+#ifdef __DBL_MANT_DIG__
+#define LIBGCC_HAS_DF_MODE
+#endif
+#if defined(__LDBL_MANT_DIG__) && __DBL_MANT_DIG__ != __LDBL_MANT_DIG__
+#define LIBGCC_HAS_XF_MODE
+#endif
+#if defined(__FLT128_MANT_DIG__) && (!defined(__LDBL_MANT_DIG__) || __FLT128_MANT_DIG__ != __LDBL_MANT_DIG__)
+#define LIBGCC_HAS_TF_MODE
+#endif
+
+/*
+ * half
+ */
+#ifdef LIBGCC_HAS_HF_MODE
+CMPtype __unordhf2(_Float16 a, _Float16 b);
+_Float16 __floatsihf (SItype a1);
+_Float16 __floatdihf (DItype a1);
+_Float16 __floatunsihf (USItype a1);
+_Float16 __floatundihf (UDItype a1);
+SItype __fixhfsi (_Float16 a1);
+DItype __fixhfdi (_Float16 a1);
+USItype __fixunshfsi (_Float16 a1);
+UDItype __fixunshfdi (_Float16 a1);
+_Float16 __addhf3 (_Float16 x1, _Float16 x2);
+_Float16 __subhf3 (_Float16 x1, _Float16 x2);
+_Float16 __mulhf3 (_Float16 x1, _Float16 x2);
+_Float16 __divhf3 (_Float16 x1, _Float16 x2);
+_Float16 __neghf2 (_Float16 x1);
+CMPtype __cmphf2 (_Float16 x1, _Float16 x2);
+CMPtype __eqhf2 (_Float16 x1, _Float16 x2);
+CMPtype __nehf2 (_Float16 x1, _Float16 x2);
+CMPtype __lthf2 (_Float16 x1, _Float16 x2);
+CMPtype __lehf2 (_Float16 x1, _Float16 x2);
+CMPtype __gthf2 (_Float16 x1, _Float16 x2);
+CMPtype __gehf2 (_Float16 x1, _Float16 x2);
+
+#ifdef LIBGCC_HAS_SF_MODE
+float __extendhfsf2 (_Float16 a1);
+#endif
+#ifdef LIBGCC_HAS_DF_MODE
+double __extendhfdf2 (_Float16 a1);
+#endif
+#ifdef LIBGCC_HAS_XF_MODE
+long double __extendhfxf2 (_Float16 a1);
+#endif
+#ifdef LIBGCC_HAS_TF_MODE
+_Float128  __extendhftf2 (_Float16 a1);
+#endif
+#endif
+
+/*
+ * single
+ */
+#ifdef LIBGCC_HAS_SF_MODE
+CMPtype __unordsf2(float a, float b);
+float __floatsisf (SItype a1);
+float __floatdisf (DItype a1);
+float __floatunsisf (USItype a1);
+float __floatundisf (UDItype a1);
+SItype __fixsfsi (float a1);
+DItype __fixsfdi (float a1);
+USItype __fixunssfsi (float a1);
+UDItype __fixunssfdi (float a1);
+float __addsf3 (float x1, float x2);
+float __subsf3 (float x1, float x2);
+float __mulsf3 (float x1, float x2);
+float __divsf3 (float x1, float x2);
+float __negsf2 (float x1);
+CMPtype __cmpsf2 (float x1, float x2);
+CMPtype __eqsf2 (float x1, float x2);
+CMPtype __nesf2 (float x1, float x2);
+CMPtype __ltsf2 (float x1, float x2);
+CMPtype __lesf2 (float x1, float x2);
+CMPtype __gtsf2 (float x1, float x2);
+CMPtype __gesf2 (float x1, float x2);
+
+#ifdef LIBGCC_HAS_HF_MODE
+_Float16 __truncsfhf2 (float a1);
+#endif
+#ifdef LIBGCC_HAS_DF_MODE
+double __extendsfdf2 (float a1);
+#endif
+#ifdef LIBGCC_HAS_XF_MODE
+long double __extendsfxf2 (float a1);
+#endif
+#ifdef LIBGCC_HAS_TF_MODE
+_Float128 __extendsftf2 (float a1);
+#endif
+#endif
+
+/*
+ * double
+ */
+#ifdef LIBGCC_HAS_DF_MODE
+CMPtype __unorddf2(double a, double b);
+double __floatsidf (SItype a1);
+double __floatdidf (DItype a1);
+double __floatunsidf (USItype a1);
+double __floatundidf (UDItype a1);
+SItype __fixdfsi (double a1);
+DItype __fixdfdi (double a1);
+USItype __fixunsdfsi (double a1);
+UDItype __fixunsdfdi (double a1);
+double __adddf3 (double x1, double x2);
+double __subdf3 (double x1, double x2);
+double __muldf3 (double x1, double x2);
+double __divdf3 (double x1, double x2);
+double __negdf2 (double x1);
+CMPtype __cmpdf2 (double x1, double x2);
+CMPtype __eqdf2 (double x1, double x2);
+CMPtype __nedf2 (double x1, double x2);
+CMPtype __ltdf2 (double x1, double x2);
+CMPtype __ledf2 (double x1, double x2);
+CMPtype __gtdf2 (double x1, double x2);
+CMPtype __gedf2 (double x1, double x2);
+
+#ifdef LIBGCC_HAS_HF_MODE
+_Float16 __truncdfhf2 (double a1);
+#endif
+#ifdef LIBGCC_HAS_SF_MODE
+float __truncdfsf2 (double a1);
+#endif
+#ifdef LIBGCC_HAS_XF_MODE
+long double __extenddfxf2(double a1);
+#endif
+#ifdef LIBGCC_HAS_TF_MODE
+_Float128 __extenddftf2(double a1);
+#endif
+#endif
+
+/*
+ * extended
+ */
+#ifdef LIBGCC_HAS_XF_MODE
+CMPtype __unordxf2(long double a, long double b);
+long double __floatsixf (SItype a1);
+long double __floatdixf (DItype a1);
+long double __floatunsixf (USItype a1);
+long double __floatundixf (UDItype a1);
+SItype __fixxfsi (long double a1);
+DItype __fixxfdi (long double a1);
+USItype __fixunsxfsi (long double a1);
+UDItype __fixunsxfdi (long double a1);
+long double __addxf3 (long double x1, long double x2);
+long double __subxf3 (long double x1, long double x2);
+long double __mulxf3 (long double x1, long double x2);
+long double __divxf3 (long double x1, long double x2);
+long double __negxf2 (long double x1);
+CMPtype __cmpxf2 (long double x1, long double x2);
+CMPtype __eqxf2 (long double x1, long double x2);
+CMPtype __nexf2 (long double x1, long double x2);
+CMPtype __ltxf2 (long double x1, long double x2);
+CMPtype __lexf2 (long double x1, long double x2);
+CMPtype __gtxf2 (long double x1, long double x2);
+CMPtype __gexf2 (long double x1, long double x2);
+
+#ifdef LIBGCC_HAS_HF_MODE
+_Float16 __truncxfhf2 (long double a1);
+#endif
+#ifdef LIBGCC_HAS_SF_MODE
+float __truncxfsf2 (long double a1);
+#endif
+#ifdef LIBGCC_HAS_DF_MODE
+double __truncxfdf2 (long double a1);
+#endif
+#ifdef LIBGCC_HAS_TF_MODE
+_Float128 __extendxftf2 (long double a1);
+#endif
+#endif
+
+/*
+ * quad
+ */
+#ifdef LIBGCC_HAS_TF_MODE
+CMPtype __unordtf2(_Float128 a, _Float128 b);
+_Float128 __floatsitf (SItype a1);
+_Float128 __floatditf (DItype a1);
+_Float128 __floatunsitf (USItype a1);
+_Float128 __floatunditf (UDItype a1);
+SItype __fixtfsi (_Float128 a1);
+DItype __fixtfdi (_Float128 a1);
+USItype __fixunstfsi (_Float128 a1);
+UDItype __fixunstfdi (_Float128 a1);
+_Float128 __addtf3 (_Float128 x1, _Float128 x2);
+_Float128 __subtf3 (_Float128 x1, _Float128 x2);
+_Float128 __multf3 (_Float128 x1, _Float128 x2);
+_Float128 __divtf3 (_Float128 x1, _Float128 x2);
+_Float128 __negtf2 (_Float128 x1);
+CMPtype __cmptf2 (_Float128 x1, _Float128 x2);
+CMPtype __eqtf2 (_Float128 x1, _Float128 x2);
+CMPtype __netf2 (_Float128 x1, _Float128 x2);
+CMPtype __lttf2 (_Float128 x1, _Float128 x2);
+CMPtype __letf2 (_Float128 x1, _Float128 x2);
+CMPtype __gttf2 (_Float128 x1, _Float128 x2);
+CMPtype __getf2 (_Float128 x1, _Float128 x2);
+
+#ifdef LIBGCC_HAS_HF_MODE
+_Float16 __trunctfhf2 (_Float128 a1);
+#endif
+#ifdef LIBGCC_HAS_SF_MODE
+float __trunctfsf2 (_Float128 a1);
+#endif
+#ifdef LIBGCC_HAS_DF_MODE
+double __trunctfdf2 (_Float128 a1);
+#endif
+#ifdef LIBGCC_HAS_XF_MODE
+long double __trunctfxf2 (_Float128 a1);
+#endif
+#endif
diff --git a/libgcc/soft-fp/subxf3.c b/libgcc/soft-fp/subxf3.c
new file mode 100644
index 00000000000..ba893c73f55
--- /dev/null
+++ b/libgcc/soft-fp/subxf3.c
@@ -0,0 +1,51 @@
+/* Software floating-point emulation.
+   Return a - b
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#ifdef LIBGCC_HAS_XF_MODE
+#include "extended.h"
+
+XFtype
+__subxf3 (XFtype a, XFtype b)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  FP_DECL_E (B);
+  FP_DECL_E (R);
+  XFtype r;
+
+  FP_INIT_ROUNDMODE;
+  FP_UNPACK_SEMIRAW_E (A, a);
+  FP_UNPACK_SEMIRAW_E (B, b);
+  FP_SUB_E (R, A, B);
+  FP_PACK_SEMIRAW_E (r, R);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
+#endif
diff --git a/libgcc/soft-fp/test-double.c b/libgcc/soft-fp/test-double.c
new file mode 100644
index 00000000000..d4253195b31
--- /dev/null
+++ b/libgcc/soft-fp/test-double.c
@@ -0,0 +1,157 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <math.h>
+#include <float.h>
+#include <endian.h>
+#include <stdint.h>
+#include <errno.h>
+#include "soft-fp.h"
+#include "softfp-protos.h"
+
+struct ieee754_double_struct
+{
+#if	__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+	unsigned int signexp:12;
+	uint32_t     mantissa0:20;
+	uint32_t     mantissa1:32;
+#else
+	uint32_t mantissa1:32;
+	uint32_t mantissa0:20;
+	unsigned int signexp:12;
+#endif
+};
+
+union ieee754_double
+{
+	struct ieee754_double_struct ieee;
+	double d;
+};
+
+
+struct test_data
+{
+	double arg1;
+	double arg2;
+	char op;
+	double expected;
+};
+
+static struct test_data const double_tests[] = {
+#define OP2(a, op, b) { a, b, #op[0], a op b }
+#define OP1(a, op, opc) { a, 0, #opc[0], op(a) }
+#define TESTOPS(a, b) \
+	OP2(a, +, b), \
+	OP2(a, -, b), \
+	OP2(a, *, b), \
+	OP2(a, /, b), \
+	OP1(a, -, ~)
+#define TEST(a, b) \
+	TESTOPS(a, b), \
+	TESTOPS(b, a), \
+	TESTOPS(-(a), -(b)), \
+	TESTOPS(-(b), -(a))
+	
+	TEST(3.0, 4.0),
+	TEST(3.0, 3.0),
+	TEST(1.123456789, 4.0),
+	TEST(1E38, 4.0),
+	TEST(1E308, 4.0),
+	TEST(1E-37, 4.0),
+	TEST(1E-307, 4.0),
+	TEST(0.0, 0.0),
+};
+
+
+double x, y;
+int a;
+long double lx, ly;
+int b;
+
+int main(void)
+{
+	int i;
+	int errors = 0;
+
+	/* to link in the comparison functions from softfp, not from libgcc */
+	a = x < y;
+	b = lx < ly;
+
+	for (i = 0; i < (int)(sizeof(double_tests) / sizeof(double_tests[0])); i++)
+	{
+		const struct test_data *lt = &double_tests[i];
+		volatile union ieee754_double a, b, z, r1;
+		double r;
+		
+#define COPY(dst, src) dst.d = src
+		
+		COPY(a, lt->arg1);
+		COPY(b, lt->arg2);
+		switch (lt->op)
+		{
+#if 0
+			case '+': r = lt->arg1 + lt->arg2; break;
+			case '-': r = lt->arg1 - lt->arg2; break;
+			case '*': r = lt->arg1 * lt->arg2; break;
+			case '/': r = lt->arg1 / lt->arg2; break;
+			case '~': r = -(lt->arg1); break;
+#else
+			case '+': r = __adddf3(lt->arg1, lt->arg2); break;
+			case '-': r = __subdf3(lt->arg1, lt->arg2); break;
+			case '*': r = __muldf3(lt->arg1, lt->arg2); break;
+			case '/': r = __divdf3(lt->arg1, lt->arg2); break;
+			case '~': r = __negdf2(lt->arg1); break;
+#endif
+			default: abort();
+		}
+		COPY(z, lt->expected);
+		COPY(r1, r);
+		if (r1.ieee.signexp != z.ieee.signexp ||
+			r1.ieee.mantissa0 != z.ieee.mantissa0 ||
+			r1.ieee.mantissa1 != z.ieee.mantissa1)
+		{
+#define is_binop(op) (op) != '~'
+			if (is_binop(lt->op))
+				printf("BAD %e %c %e\n", a.d, lt->op, b.d);
+			else
+				printf("BAD -(%e)\n", a.d);
+			printf("arg1      %.20e 0x%04x, 0x%08x, 0x%08x\n",
+				a.d,
+				a.ieee.signexp,
+				a.ieee.mantissa0,
+				a.ieee.mantissa1);
+			if (is_binop(lt->op))
+			printf("arg2      %.20e 0x%04x, 0x%08x, 0x%08x\n",
+				b.d,
+				b.ieee.signexp,
+				b.ieee.mantissa0,
+				b.ieee.mantissa1);
+			printf("expected  %.20e 0x%04x, 0x%08x, 0x%08x\n",
+				z.d,
+				z.ieee.signexp,
+				z.ieee.mantissa0,
+				z.ieee.mantissa1);
+			printf("got       %.20e 0x%04x, 0x%08x, 0x%08x\n",
+				r1.d,
+				r1.ieee.signexp,
+				r1.ieee.mantissa0,
+				r1.ieee.mantissa1);
+			errors++;
+		} else
+		{
+			if (is_binop(lt->op))
+				printf("OK %e %c %e\n", a.d, lt->op, b.d);
+			else
+				printf("OK -(%e)\n", a.d);
+		}
+	}
+
+	if (errors != 0)
+	{
+		fprintf(stderr, "got %d errors\n", errors);
+		return 1;
+	}
+	printf("no errors\n");
+	return 0;
+}
diff --git a/libgcc/soft-fp/test-float.c b/libgcc/soft-fp/test-float.c
new file mode 100644
index 00000000000..69d8dcd213a
--- /dev/null
+++ b/libgcc/soft-fp/test-float.c
@@ -0,0 +1,158 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <math.h>
+#include <float.h>
+#include <endian.h>
+#include <stdint.h>
+#include <errno.h>
+#include "soft-fp.h"
+#include "softfp-protos.h"
+
+struct ieee754_float_struct
+{
+#if	__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+	unsigned int signexp:9;
+	uint32_t     mantissa:23;
+#else
+	uint32_t mantissa:23;
+	unsigned int signexp:9;
+#endif
+};
+
+union ieee754_float
+{
+	struct ieee754_float_struct ieee;
+	float d;
+};
+
+
+struct test_data
+{
+	float arg1;
+	float arg2;
+	char op;
+	float expected;
+};
+
+static struct test_data const double_tests[] = {
+#define OP2(a, op, b) { a, b, #op[0], a op b }
+#define OP1(a, op, opc) { a, 0, #opc[0], op(a) }
+#define TESTOPS(a, b) \
+	OP2(a, +, b), \
+	OP2(a, -, b), \
+	OP2(a, *, b), \
+	OP2(a, /, b), \
+	OP1(a, -, ~)
+#define TEST(a, b) \
+	TESTOPS(a, b), \
+	TESTOPS(b, a), \
+	TESTOPS(-(a), -(b)), \
+	TESTOPS(-(b), -(a))
+	
+	TEST(3.0F, 4.0F),
+	TEST(3.0F, 3.0F),
+	TEST(1.123456789F, 4.0F),
+	TEST(1E38F, 4.0F),
+	TEST(1E-37F, 4.0F),
+	TEST(0.0F, 0.0F),
+};
+
+
+double x, y;
+int a;
+long double lx, ly;
+int b;
+
+int main(void)
+{
+	int i;
+	int errors = 0;
+	int warnings = 0;
+
+	/* to link in the comparison functions from softfp, not from libgcc */
+	a = x < y;
+	b = lx < ly;
+
+	for (i = 0; i < (int)(sizeof(double_tests) / sizeof(double_tests[0])); i++)
+	{
+		const struct test_data *lt = &double_tests[i];
+		volatile union ieee754_float a, b, z, r1;
+		double r;
+		
+#define COPY(dst, src) dst.d = src
+		
+		COPY(a, lt->arg1);
+		COPY(b, lt->arg2);
+		switch (lt->op)
+		{
+#if 0
+			case '+': r = lt->arg1 + lt->arg2; break;
+			case '-': r = lt->arg1 - lt->arg2; break;
+			case '*': r = lt->arg1 * lt->arg2; break;
+			case '/': r = lt->arg1 / lt->arg2; break;
+			case '~': r = -(lt->arg1); break;
+#else
+			case '+': r = __addsf3(lt->arg1, lt->arg2); break;
+			case '-': r = __subsf3(lt->arg1, lt->arg2); break;
+			case '*': r = __mulsf3(lt->arg1, lt->arg2); break;
+			case '/': r = __divsf3(lt->arg1, lt->arg2); break;
+			case '~': r = __negsf2(lt->arg1); break;
+#endif
+			default: abort();
+		}
+		COPY(z, lt->expected);
+		COPY(r1, r);
+		if (r1.ieee.signexp != z.ieee.signexp ||
+			(z.ieee.mantissa != r1.ieee.mantissa))
+		{
+#define is_binop(op) (op) != '~'
+			int warning = r1.ieee.signexp == z.ieee.signexp && (z.ieee.mantissa - r1.ieee.mantissa) <= 1;
+			const char *round = warning ? " (rounding)" : "";
+			if (is_binop(lt->op))
+				printf("BAD %e %c %e%s\n", a.d, lt->op, b.d, round);
+			else
+				printf("BAD -(%e)%s\n", a.d, round);
+			printf("arg1      %.20e 0x%04x, 0x%08x\n",
+				a.d,
+				a.ieee.signexp,
+				a.ieee.mantissa);
+			if (is_binop(lt->op))
+			printf("arg2      %.20e 0x%04x, 0x%08x\n",
+				b.d,
+				b.ieee.signexp,
+				b.ieee.mantissa);
+			printf("expected  %.20e 0x%04x, 0x%08x\n",
+				z.d,
+				z.ieee.signexp,
+				z.ieee.mantissa);
+			printf("got       %.20e 0x%04x, 0x%08x\n",
+				r1.d,
+				r1.ieee.signexp,
+				r1.ieee.mantissa);
+			if (warning)
+				warnings++;
+			else
+				errors++;
+		} else
+		{
+			if (is_binop(lt->op))
+				printf("OK %e %c %e\n", a.d, lt->op, b.d);
+			else
+				printf("OK -(%e)\n", a.d);
+		}
+	}
+
+	if (warnings != 0)
+	{
+		fprintf(stderr, "got %d warnings\n", warnings);
+	}
+	if (errors != 0)
+	{
+		fprintf(stderr, "got %d errors\n", errors);
+		return 1;
+	}
+	printf("no errors\n");
+	return 0;
+}
diff --git a/libgcc/soft-fp/test-ldouble.c b/libgcc/soft-fp/test-ldouble.c
new file mode 100644
index 00000000000..bd145431046
--- /dev/null
+++ b/libgcc/soft-fp/test-ldouble.c
@@ -0,0 +1,160 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <math.h>
+#include <float.h>
+#include <endian.h>
+#include <stdint.h>
+#include <errno.h>
+#include "soft-fp.h"
+#include "softfp-protos.h"
+
+struct ieee854_long_double_struct
+{
+#if	__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+	unsigned int signexp:16;
+	unsigned int empty:16;
+	uint32_t     mantissa0:32;
+	uint32_t     mantissa1:32;
+#else
+	uint32_t mantissa1:32;
+	uint32_t mantissa0:32;
+	unsigned int signexp:16;
+	unsigned int empty:16;
+#endif
+};
+
+union ieee854_long_double
+{
+	struct ieee854_long_double_struct ieee;
+	long double d;
+};
+
+struct test_data
+{
+	long double arg1;
+	long double arg2;
+	char op;
+	long double expected;
+};
+
+static struct test_data const double_tests[] = {
+#define OP2(a, op, b) { a, b, #op[0], a op b }
+#define OP1(a, op, opc) { a, 0, #opc[0], op(a) }
+#define TESTOPS(a, b) \
+	OP2(a, +, b), \
+	OP2(a, -, b), \
+	OP2(a, *, b), \
+	OP2(a, /, b), \
+	OP1(a, -, ~)
+#define TEST(a, b) \
+	TESTOPS(a, b), \
+	TESTOPS(b, a), \
+	TESTOPS(-(a), -(b)), \
+	TESTOPS(-(b), -(a))
+	
+	TEST(3.0L, 4.0L),
+	TEST(3.0L, 3.0L),
+	TEST(1.123456789L, 4.0L),
+	TEST(1E38L, 4.0L),
+	TEST(1E308L, 4.0L),
+	TEST(1E4000L, 4.0L),
+	TEST(1E-37L, 4.0L),
+	TEST(1E-307L, 4.0L),
+	TEST(1E-4000L, 4.0L),
+	TEST(0.0, 0.0),
+};
+
+
+double x, y;
+int a;
+long double lx, ly;
+int b;
+
+int main(void)
+{
+	int i;
+	int errors = 0;
+
+	/* to link in the comparison functions from softfp, not from libgcc */
+	a = x < y;
+	b = lx < ly;
+
+	for (i = 0; i < (int)(sizeof(double_tests) / sizeof(double_tests[0])); i++)
+	{
+		const struct test_data *lt = &double_tests[i];
+		volatile union ieee854_long_double a, b, z, r1;
+		long double r;
+		
+#define COPY(dst, src) dst.d = src
+		
+		COPY(a, lt->arg1);
+		COPY(b, lt->arg2);
+		switch (lt->op)
+		{
+#if 0
+			case '+': r = lt->arg1 + lt->arg2; break;
+			case '-': r = lt->arg1 - lt->arg2; break;
+			case '*': r = lt->arg1 * lt->arg2; break;
+			case '/': r = lt->arg1 / lt->arg2; break;
+			case '~': r = -(lt->arg1); break;
+#else
+			case '+': r = __addxf3(lt->arg1, lt->arg2); break;
+			case '-': r = __subxf3(lt->arg1, lt->arg2); break;
+			case '*': r = __mulxf3(lt->arg1, lt->arg2); break;
+			case '/': r = __divxf3(lt->arg1, lt->arg2); break;
+			case '~': r = __negxf2(lt->arg1); break;
+#endif
+			default: abort();
+		}
+		COPY(z, lt->expected);
+		COPY(r1, r);
+		if (r1.ieee.signexp != z.ieee.signexp ||
+			r1.ieee.mantissa0 != z.ieee.mantissa0 ||
+			r1.ieee.mantissa1 != z.ieee.mantissa1)
+		{
+#define is_binop(op) (op) != '~'
+			if (is_binop(lt->op))
+				printf("BAD %Le %c %Le\n", a.d, lt->op, b.d);
+			else
+				printf("BAD -(%Le)\n", a.d);
+			printf("arg1      %.20Le 0x%04x, 0x%08x, 0x%08x\n",
+				a.d,
+				a.ieee.signexp,
+				a.ieee.mantissa0,
+				a.ieee.mantissa1);
+			if (is_binop(lt->op))
+			printf("arg2      %.20Le 0x%04x, 0x%08x, 0x%08x\n",
+				b.d,
+				b.ieee.signexp,
+				b.ieee.mantissa0,
+				b.ieee.mantissa1);
+			printf("expected  %.20Le 0x%04x, 0x%08x, 0x%08x\n",
+				z.d,
+				z.ieee.signexp,
+				z.ieee.mantissa0,
+				z.ieee.mantissa1);
+			printf("got       %.20Le 0x%04x, 0x%08x, 0x%08x\n",
+				r1.d,
+				r1.ieee.signexp,
+				r1.ieee.mantissa0,
+				r1.ieee.mantissa1);
+			errors++;
+		} else
+		{
+			if (is_binop(lt->op))
+				printf("OK %Le %c %Le\n", a.d, lt->op, b.d);
+			else
+				printf("OK -(%Le)\n", a.d);
+		}
+	}
+
+	if (errors != 0)
+	{
+		fprintf(stderr, "got %d errors\n", errors);
+		return 1;
+	}
+	printf("no errors\n");
+	return 0;
+}
diff --git a/libgcc/soft-fp/truncxfdf2.c b/libgcc/soft-fp/truncxfdf2.c
new file mode 100644
index 00000000000..31690ed80bb
--- /dev/null
+++ b/libgcc/soft-fp/truncxfdf2.c
@@ -0,0 +1,52 @@
+/* Software floating-point emulation.
+   Truncate IEEE double into IEEE single
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "double.h"
+#include "extended.h"
+
+DFtype
+__truncxfdf2 (XFtype a)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  FP_DECL_D (R);
+  DFtype r;
+
+  FP_INIT_ROUNDMODE;
+  FP_UNPACK_SEMIRAW_E (A, a);
+#if _FP_W_TYPE_SIZE < 64
+  FP_TRUNC (D, E, 2, 4, R, A);
+#else
+  FP_TRUNC (D, E, 1, 2, R, A);
+#endif
+  FP_PACK_SEMIRAW_D (r, R);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/libgcc/soft-fp/truncxfsf2.c b/libgcc/soft-fp/truncxfsf2.c
new file mode 100644
index 00000000000..041783904f5
--- /dev/null
+++ b/libgcc/soft-fp/truncxfsf2.c
@@ -0,0 +1,52 @@
+/* Software floating-point emulation.
+   Truncate IEEE double into IEEE single
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "single.h"
+#include "extended.h"
+
+SFtype
+__truncxfsf2 (XFtype a)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  FP_DECL_S (R);
+  SFtype r;
+
+  FP_INIT_ROUNDMODE;
+  FP_UNPACK_SEMIRAW_E (A, a);
+#if _FP_W_TYPE_SIZE < 64
+  FP_TRUNC (S, E, 1, 4, R, A);
+#else
+  FP_TRUNC (S, E, 1, 2, R, A);
+#endif
+  FP_PACK_SEMIRAW_S (r, R);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/libgcc/soft-fp/unordxf2.c b/libgcc/soft-fp/unordxf2.c
new file mode 100644
index 00000000000..b2cf0511f68
--- /dev/null
+++ b/libgcc/soft-fp/unordxf2.c
@@ -0,0 +1,47 @@
+/* Software floating-point emulation.
+   Return 1 iff a or b is a NaN, 0 otherwise.
+   Copyright (C) 2006-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "extended.h"
+
+CMPtype
+__unordxf2 (XFtype a, XFtype b)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  FP_DECL_E (B);
+  CMPtype r;
+
+  FP_INIT_EXCEPTIONS;
+  FP_UNPACK_RAW_E (A, a);
+  FP_UNPACK_RAW_E (B, b);
+  FP_CMP_UNORD_E (r, A, B, 1);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/libgcc/unwind-c.c b/libgcc/unwind-c.c
index f5faa00784d..a7f9ee0603f 100644
--- a/libgcc/unwind-c.c
+++ b/libgcc/unwind-c.c
@@ -244,3 +244,11 @@ __gcc_personality_seh0 (PEXCEPTION_RECORD ms_exc, void *this_frame,
 				ms_disp, __gcc_personality_imp);
 }
 #endif /* SEH */
+
+#if defined(__MINT__)
+void *__DW_EH_PE_aligned_var
+#ifdef __ELF__
+	__attribute__((__aligned__(sizeof(void *))))
+#endif
+;
+#endif
diff --git a/libgcc/unwind-pe.h b/libgcc/unwind-pe.h
index 005a1639b78..836e12f589b 100644
--- a/libgcc/unwind-pe.h
+++ b/libgcc/unwind-pe.h
@@ -203,7 +203,18 @@ read_encoded_value_with_base (unsigned char encoding, _Unwind_Ptr base,
   if (encoding == DW_EH_PE_aligned)
     {
       _Unwind_Internal_Ptr a = (_Unwind_Internal_Ptr) p;
+#ifdef __MINT__
+      /*
+       * alignment to pointer size cannot be guaranteed by TOS at runtime
+       */
+      extern void *__DW_EH_PE_aligned_var;
+      _Unwind_Internal_Ptr base_offset = ((_Unwind_Internal_Ptr)&__DW_EH_PE_aligned_var) & 3;
+      a += base_offset; /* Where it should have been located */
+#endif
       a = (a + sizeof (void *) - 1) & - sizeof(void *);
+#ifdef __MINT__
+      a -= base_offset; /* Where it is actually aligned */
+#endif
       result = *(_Unwind_Internal_Ptr *) a;
       p = (const unsigned char *) (_Unwind_Internal_Ptr) (a + sizeof (void *));
     }
diff --git a/libgfortran/Makefile.am b/libgfortran/Makefile.am
index 60aa949fb62..3315e93ca15 100644
--- a/libgfortran/Makefile.am
+++ b/libgfortran/Makefile.am
@@ -61,7 +61,7 @@ libgfortran_la_DEPENDENCIES = $(version_dep) libgfortran.spec $(LIBQUADLIB_DEP)
 cafexeclib_LTLIBRARIES = libcaf_single.la
 cafexeclibdir = $(libdir)/gcc/$(target_alias)/$(gcc_version)$(MULTISUBDIR)
 libcaf_single_la_SOURCES = caf/single.c
-libcaf_single_la_LDFLAGS = -static
+libcaf_single_la_LDFLAGS = -static -no-undefined
 libcaf_single_la_DEPENDENCIES = caf/libcaf.h
 libcaf_single_la_LINK = $(LINK) $(libcaf_single_la_LDFLAGS)
 
diff --git a/libgfortran/Makefile.in b/libgfortran/Makefile.in
index c171b3d6219..133714c1774 100644
--- a/libgfortran/Makefile.in
+++ b/libgfortran/Makefile.in
@@ -1000,7 +1000,7 @@ libgfortran_la_DEPENDENCIES = $(version_dep) libgfortran.spec $(LIBQUADLIB_DEP)
 cafexeclib_LTLIBRARIES = libcaf_single.la
 cafexeclibdir = $(libdir)/gcc/$(target_alias)/$(gcc_version)$(MULTISUBDIR)
 libcaf_single_la_SOURCES = caf/single.c
-libcaf_single_la_LDFLAGS = -static
+libcaf_single_la_LDFLAGS = -static -no-undefined
 libcaf_single_la_DEPENDENCIES = caf/libcaf.h
 libcaf_single_la_LINK = $(LINK) $(libcaf_single_la_LDFLAGS)
 @IEEE_SUPPORT_TRUE@fincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)$(MULTISUBDIR)/finclude
diff --git a/libgfortran/configure b/libgfortran/configure
index 9898a94a372..d3f1878079f 100755
--- a/libgfortran/configure
+++ b/libgfortran/configure
@@ -6504,7 +6504,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -7271,6 +7271,12 @@ else
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
+  mint*)
+    # On MiNT this test can take minutes to run, and I'm not sure it's
+    # healthy for this platform. Let's restrict it to 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
   amigaos*)
     # On AmigaOS with pdksh, this test takes hours, literally.
     # So we just punt and use a minimum line length of 8192.
@@ -10493,7 +10499,7 @@ _LT_EOF
       fi
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
       # as there is no search path for DLLs.
       hardcode_libdir_flag_spec='-L$libdir'
@@ -10930,7 +10936,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
       export_dynamic_flag_spec=-rdynamic
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # When not using gcc, we currently assume that we are using
       # Microsoft Visual C++.
       # hardcode_libdir_flag_spec is actually meaningless, as there is
@@ -11881,14 +11887,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -11912,7 +11918,7 @@ cygwin* | mingw* | pw32* | cegcc*)
 
       sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -12560,7 +12566,7 @@ else
     lt_cv_dlopen_self=yes
     ;;
 
-  mingw* | pw32* | cegcc*)
+  mingw* | msys* | pw32* | cegcc*)
     lt_cv_dlopen="LoadLibrary"
     lt_cv_dlopen_libs=
     ;;
@@ -13335,7 +13341,7 @@ esac
 
 
 case $host in
-  *-cygwin* | *-mingw*)
+  *-cygwin* | *-mingw* | *-msys*)
     # 'host' will be top-level target in the case of a target lib,
     # we must compare to with_cross_host to decide if this is a native
     # or cross-compiler and select where to install dlls appropriately.
@@ -14557,7 +14563,7 @@ _LT_EOF
       fi
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # _LT_TAGVAR(hardcode_libdir_flag_spec, FC) is actually meaningless,
       # as there is no search path for DLLs.
       hardcode_libdir_flag_spec_FC='-L$libdir'
@@ -14982,7 +14988,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
       export_dynamic_flag_spec_FC=-rdynamic
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # When not using gcc, we currently assume that we are using
       # Microsoft Visual C++.
       # hardcode_libdir_flag_spec is actually meaningless, as there is
@@ -15727,14 +15733,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -15757,7 +15763,7 @@ cygwin* | mingw* | pw32* | cegcc*)
       soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
 
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
diff --git a/libgfortran/generated/matmul_c10.c b/libgfortran/generated/matmul_c10.c
index 07432e83c91..065e2c27728 100644
--- a/libgfortran/generated/matmul_c10.c
+++ b/libgfortran/generated/matmul_c10.c
@@ -242,6 +242,8 @@ matmul_c10_avx (gfc_array_c10 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -811,6 +813,8 @@ matmul_c10_avx2 (gfc_array_c10 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1380,6 +1384,8 @@ matmul_c10_avx512f (gfc_array_c10 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1963,6 +1969,8 @@ matmul_c10_vanilla (gfc_array_c10 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -2605,6 +2613,8 @@ matmul_c10 (gfc_array_c10 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmul_c16.c b/libgfortran/generated/matmul_c16.c
index 03ffe2d0de1..67dac5b93ec 100644
--- a/libgfortran/generated/matmul_c16.c
+++ b/libgfortran/generated/matmul_c16.c
@@ -242,6 +242,8 @@ matmul_c16_avx (gfc_array_c16 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -811,6 +813,8 @@ matmul_c16_avx2 (gfc_array_c16 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1380,6 +1384,8 @@ matmul_c16_avx512f (gfc_array_c16 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1963,6 +1969,8 @@ matmul_c16_vanilla (gfc_array_c16 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -2605,6 +2613,8 @@ matmul_c16 (gfc_array_c16 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmul_c4.c b/libgfortran/generated/matmul_c4.c
index 20d8affd9f5..7a26d04c0a8 100644
--- a/libgfortran/generated/matmul_c4.c
+++ b/libgfortran/generated/matmul_c4.c
@@ -242,6 +242,8 @@ matmul_c4_avx (gfc_array_c4 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -811,6 +813,8 @@ matmul_c4_avx2 (gfc_array_c4 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1380,6 +1384,8 @@ matmul_c4_avx512f (gfc_array_c4 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1963,6 +1969,8 @@ matmul_c4_vanilla (gfc_array_c4 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -2605,6 +2613,8 @@ matmul_c4 (gfc_array_c4 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmul_c8.c b/libgfortran/generated/matmul_c8.c
index 1919963cf38..f26516e86ee 100644
--- a/libgfortran/generated/matmul_c8.c
+++ b/libgfortran/generated/matmul_c8.c
@@ -242,6 +242,8 @@ matmul_c8_avx (gfc_array_c8 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -811,6 +813,8 @@ matmul_c8_avx2 (gfc_array_c8 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1380,6 +1384,8 @@ matmul_c8_avx512f (gfc_array_c8 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1963,6 +1969,8 @@ matmul_c8_vanilla (gfc_array_c8 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -2605,6 +2613,8 @@ matmul_c8 (gfc_array_c8 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmul_i1.c b/libgfortran/generated/matmul_i1.c
index 526755d94a2..fc9bfe4535d 100644
--- a/libgfortran/generated/matmul_i1.c
+++ b/libgfortran/generated/matmul_i1.c
@@ -242,6 +242,8 @@ matmul_i1_avx (gfc_array_m1 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -811,6 +813,8 @@ matmul_i1_avx2 (gfc_array_m1 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1380,6 +1384,8 @@ matmul_i1_avx512f (gfc_array_m1 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1963,6 +1969,8 @@ matmul_i1_vanilla (gfc_array_m1 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -2605,6 +2613,8 @@ matmul_i1 (gfc_array_m1 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmul_i16.c b/libgfortran/generated/matmul_i16.c
index e4729994498..c691e1222ff 100644
--- a/libgfortran/generated/matmul_i16.c
+++ b/libgfortran/generated/matmul_i16.c
@@ -242,6 +242,8 @@ matmul_i16_avx (gfc_array_m16 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -811,6 +813,8 @@ matmul_i16_avx2 (gfc_array_m16 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1380,6 +1384,8 @@ matmul_i16_avx512f (gfc_array_m16 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmul_i2.c b/libgfortran/generated/matmul_i2.c
index 1b9e34b4f68..19a9e594fe1 100644
--- a/libgfortran/generated/matmul_i2.c
+++ b/libgfortran/generated/matmul_i2.c
@@ -242,6 +242,8 @@ matmul_i2_avx (gfc_array_m2 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -811,6 +813,8 @@ matmul_i2_avx2 (gfc_array_m2 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1380,6 +1384,8 @@ matmul_i2_avx512f (gfc_array_m2 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1963,6 +1969,8 @@ matmul_i2_vanilla (gfc_array_m2 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -2605,6 +2613,8 @@ matmul_i2 (gfc_array_m2 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmul_i4.c b/libgfortran/generated/matmul_i4.c
index b14fafb5b0c..eff6fd06e19 100644
--- a/libgfortran/generated/matmul_i4.c
+++ b/libgfortran/generated/matmul_i4.c
@@ -242,6 +242,8 @@ matmul_i4_avx (gfc_array_m4 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -811,6 +813,8 @@ matmul_i4_avx2 (gfc_array_m4 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1380,6 +1384,8 @@ matmul_i4_avx512f (gfc_array_m4 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1963,6 +1969,8 @@ matmul_i4_vanilla (gfc_array_m4 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -2605,6 +2613,8 @@ matmul_i4 (gfc_array_m4 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmul_i8.c b/libgfortran/generated/matmul_i8.c
index 1ec49ce3bb4..8a538cda519 100644
--- a/libgfortran/generated/matmul_i8.c
+++ b/libgfortran/generated/matmul_i8.c
@@ -242,6 +242,8 @@ matmul_i8_avx (gfc_array_m8 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -811,6 +813,8 @@ matmul_i8_avx2 (gfc_array_m8 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1380,6 +1384,8 @@ matmul_i8_avx512f (gfc_array_m8 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1963,6 +1969,8 @@ matmul_i8_vanilla (gfc_array_m8 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -2605,6 +2613,8 @@ matmul_i8 (gfc_array_m8 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmul_r10.c b/libgfortran/generated/matmul_r10.c
index 755ebaed7d4..92537e6a6a2 100644
--- a/libgfortran/generated/matmul_r10.c
+++ b/libgfortran/generated/matmul_r10.c
@@ -242,6 +242,8 @@ matmul_r10_avx (gfc_array_r10 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -811,6 +813,8 @@ matmul_r10_avx2 (gfc_array_r10 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1380,6 +1384,8 @@ matmul_r10_avx512f (gfc_array_r10 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1963,6 +1969,8 @@ matmul_r10_vanilla (gfc_array_r10 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -2605,6 +2613,8 @@ matmul_r10 (gfc_array_r10 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmul_r16.c b/libgfortran/generated/matmul_r16.c
index e91b220ffb4..387fb4c8f63 100644
--- a/libgfortran/generated/matmul_r16.c
+++ b/libgfortran/generated/matmul_r16.c
@@ -242,6 +242,8 @@ matmul_r16_avx (gfc_array_r16 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -811,6 +813,8 @@ matmul_r16_avx2 (gfc_array_r16 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1380,6 +1384,8 @@ matmul_r16_avx512f (gfc_array_r16 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1963,6 +1969,8 @@ matmul_r16_vanilla (gfc_array_r16 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -2605,6 +2613,8 @@ matmul_r16 (gfc_array_r16 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmul_r4.c b/libgfortran/generated/matmul_r4.c
index 458ebc36812..97ad59c4886 100644
--- a/libgfortran/generated/matmul_r4.c
+++ b/libgfortran/generated/matmul_r4.c
@@ -242,6 +242,8 @@ matmul_r4_avx (gfc_array_r4 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -811,6 +813,8 @@ matmul_r4_avx2 (gfc_array_r4 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1380,6 +1384,8 @@ matmul_r4_avx512f (gfc_array_r4 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1963,6 +1969,8 @@ matmul_r4_vanilla (gfc_array_r4 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -2605,6 +2613,8 @@ matmul_r4 (gfc_array_r4 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmul_r8.c b/libgfortran/generated/matmul_r8.c
index 225b5c664f4..39c0b4a2f60 100644
--- a/libgfortran/generated/matmul_r8.c
+++ b/libgfortran/generated/matmul_r8.c
@@ -242,6 +242,8 @@ matmul_r8_avx (gfc_array_r8 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -811,6 +813,8 @@ matmul_r8_avx2 (gfc_array_r8 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1380,6 +1384,8 @@ matmul_r8_avx512f (gfc_array_r8 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -1963,6 +1969,8 @@ matmul_r8_vanilla (gfc_array_r8 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -2605,6 +2613,8 @@ matmul_r8 (gfc_array_r8 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmulavx128_c10.c b/libgfortran/generated/matmulavx128_c10.c
index 7094a5f80e9..933961be0ab 100644
--- a/libgfortran/generated/matmulavx128_c10.c
+++ b/libgfortran/generated/matmulavx128_c10.c
@@ -207,6 +207,8 @@ matmul_c10_avx128_fma3 (gfc_array_c10 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -777,6 +779,8 @@ matmul_c10_avx128_fma4 (gfc_array_c10 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmulavx128_c16.c b/libgfortran/generated/matmulavx128_c16.c
index 4a1a3408be9..40a260fd678 100644
--- a/libgfortran/generated/matmulavx128_c16.c
+++ b/libgfortran/generated/matmulavx128_c16.c
@@ -207,6 +207,8 @@ matmul_c16_avx128_fma3 (gfc_array_c16 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -777,6 +779,8 @@ matmul_c16_avx128_fma4 (gfc_array_c16 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmulavx128_c4.c b/libgfortran/generated/matmulavx128_c4.c
index f0014cc89e2..d9e069a90c4 100644
--- a/libgfortran/generated/matmulavx128_c4.c
+++ b/libgfortran/generated/matmulavx128_c4.c
@@ -207,6 +207,8 @@ matmul_c4_avx128_fma3 (gfc_array_c4 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -777,6 +779,8 @@ matmul_c4_avx128_fma4 (gfc_array_c4 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmulavx128_c8.c b/libgfortran/generated/matmulavx128_c8.c
index 94764a9c38b..84eab743cf7 100644
--- a/libgfortran/generated/matmulavx128_c8.c
+++ b/libgfortran/generated/matmulavx128_c8.c
@@ -207,6 +207,8 @@ matmul_c8_avx128_fma3 (gfc_array_c8 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -777,6 +779,8 @@ matmul_c8_avx128_fma4 (gfc_array_c8 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmulavx128_i1.c b/libgfortran/generated/matmulavx128_i1.c
index 3ab8eda71b3..f0356fd2bd6 100644
--- a/libgfortran/generated/matmulavx128_i1.c
+++ b/libgfortran/generated/matmulavx128_i1.c
@@ -207,6 +207,8 @@ matmul_i1_avx128_fma3 (gfc_array_i1 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -777,6 +779,8 @@ matmul_i1_avx128_fma4 (gfc_array_i1 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmulavx128_i16.c b/libgfortran/generated/matmulavx128_i16.c
index c8ef87e019c..88ded7a0409 100644
--- a/libgfortran/generated/matmulavx128_i16.c
+++ b/libgfortran/generated/matmulavx128_i16.c
@@ -207,6 +207,8 @@ matmul_i16_avx128_fma3 (gfc_array_i16 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -777,6 +779,8 @@ matmul_i16_avx128_fma4 (gfc_array_i16 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmulavx128_i2.c b/libgfortran/generated/matmulavx128_i2.c
index 88f34527249..9f60a51f690 100644
--- a/libgfortran/generated/matmulavx128_i2.c
+++ b/libgfortran/generated/matmulavx128_i2.c
@@ -207,6 +207,8 @@ matmul_i2_avx128_fma3 (gfc_array_i2 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -777,6 +779,8 @@ matmul_i2_avx128_fma4 (gfc_array_i2 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmulavx128_i4.c b/libgfortran/generated/matmulavx128_i4.c
index 272692e5351..1eb4f62ed87 100644
--- a/libgfortran/generated/matmulavx128_i4.c
+++ b/libgfortran/generated/matmulavx128_i4.c
@@ -207,6 +207,8 @@ matmul_i4_avx128_fma3 (gfc_array_i4 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -777,6 +779,8 @@ matmul_i4_avx128_fma4 (gfc_array_i4 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmulavx128_i8.c b/libgfortran/generated/matmulavx128_i8.c
index a1db25b3069..efebc954b91 100644
--- a/libgfortran/generated/matmulavx128_i8.c
+++ b/libgfortran/generated/matmulavx128_i8.c
@@ -207,6 +207,8 @@ matmul_i8_avx128_fma3 (gfc_array_i8 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -777,6 +779,8 @@ matmul_i8_avx128_fma4 (gfc_array_i8 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmulavx128_r10.c b/libgfortran/generated/matmulavx128_r10.c
index 8d164d0049c..7827b50b610 100644
--- a/libgfortran/generated/matmulavx128_r10.c
+++ b/libgfortran/generated/matmulavx128_r10.c
@@ -207,6 +207,8 @@ matmul_r10_avx128_fma3 (gfc_array_r10 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -777,6 +779,8 @@ matmul_r10_avx128_fma4 (gfc_array_r10 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmulavx128_r16.c b/libgfortran/generated/matmulavx128_r16.c
index ee536b53390..34b60979c06 100644
--- a/libgfortran/generated/matmulavx128_r16.c
+++ b/libgfortran/generated/matmulavx128_r16.c
@@ -207,6 +207,8 @@ matmul_r16_avx128_fma3 (gfc_array_r16 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -777,6 +779,8 @@ matmul_r16_avx128_fma4 (gfc_array_r16 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmulavx128_r4.c b/libgfortran/generated/matmulavx128_r4.c
index 104b1df35eb..fd6d47c0668 100644
--- a/libgfortran/generated/matmulavx128_r4.c
+++ b/libgfortran/generated/matmulavx128_r4.c
@@ -207,6 +207,8 @@ matmul_r4_avx128_fma3 (gfc_array_r4 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -777,6 +779,8 @@ matmul_r4_avx128_fma4 (gfc_array_r4 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/matmulavx128_r8.c b/libgfortran/generated/matmulavx128_r8.c
index f76301dec03..2a3f63ecd38 100644
--- a/libgfortran/generated/matmulavx128_r8.c
+++ b/libgfortran/generated/matmulavx128_r8.c
@@ -207,6 +207,8 @@ matmul_r8_avx128_fma3 (gfc_array_r8 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
@@ -777,6 +779,8 @@ matmul_r8_avx128_fma4 (gfc_array_r8 * const restrict retarray,
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/generated/unpack_c10.c b/libgfortran/generated/unpack_c10.c
index 3d68e8a95ca..cbeb7f57dc9 100644
--- a/libgfortran/generated/unpack_c10.c
+++ b/libgfortran/generated/unpack_c10.c
@@ -81,6 +81,7 @@ unpack0_c10 (gfc_array_c10 *ret, const gfc_array_c10 *vector,
 
   /* Initialize to avoid -Wmaybe-uninitialized complaints.  */
   rstride[0] = 1;
+  mstride[0] = 0;
   if (ret->base_addr == NULL)
     {
       /* The front end has signalled that we need to populate the
diff --git a/libgfortran/generated/unpack_c16.c b/libgfortran/generated/unpack_c16.c
index ec2068add0d..b2ce24a4c8a 100644
--- a/libgfortran/generated/unpack_c16.c
+++ b/libgfortran/generated/unpack_c16.c
@@ -81,6 +81,7 @@ unpack0_c16 (gfc_array_c16 *ret, const gfc_array_c16 *vector,
 
   /* Initialize to avoid -Wmaybe-uninitialized complaints.  */
   rstride[0] = 1;
+  mstride[0] = 0;
   if (ret->base_addr == NULL)
     {
       /* The front end has signalled that we need to populate the
diff --git a/libgfortran/generated/unpack_c17.c b/libgfortran/generated/unpack_c17.c
index 7bf5eac99da..0fbc1267c3c 100644
--- a/libgfortran/generated/unpack_c17.c
+++ b/libgfortran/generated/unpack_c17.c
@@ -81,6 +81,7 @@ unpack0_c17 (gfc_array_c17 *ret, const gfc_array_c17 *vector,
 
   /* Initialize to avoid -Wmaybe-uninitialized complaints.  */
   rstride[0] = 1;
+  mstride[0] = 0;
   if (ret->base_addr == NULL)
     {
       /* The front end has signalled that we need to populate the
diff --git a/libgfortran/generated/unpack_c4.c b/libgfortran/generated/unpack_c4.c
index 1475a26d9c7..7e162f2f78c 100644
--- a/libgfortran/generated/unpack_c4.c
+++ b/libgfortran/generated/unpack_c4.c
@@ -81,6 +81,7 @@ unpack0_c4 (gfc_array_c4 *ret, const gfc_array_c4 *vector,
 
   /* Initialize to avoid -Wmaybe-uninitialized complaints.  */
   rstride[0] = 1;
+  mstride[0] = 0;
   if (ret->base_addr == NULL)
     {
       /* The front end has signalled that we need to populate the
diff --git a/libgfortran/generated/unpack_c8.c b/libgfortran/generated/unpack_c8.c
index d62c0013b89..715e7df59f4 100644
--- a/libgfortran/generated/unpack_c8.c
+++ b/libgfortran/generated/unpack_c8.c
@@ -81,6 +81,7 @@ unpack0_c8 (gfc_array_c8 *ret, const gfc_array_c8 *vector,
 
   /* Initialize to avoid -Wmaybe-uninitialized complaints.  */
   rstride[0] = 1;
+  mstride[0] = 0;
   if (ret->base_addr == NULL)
     {
       /* The front end has signalled that we need to populate the
diff --git a/libgfortran/generated/unpack_i1.c b/libgfortran/generated/unpack_i1.c
index 530836544e9..814cacc38fe 100644
--- a/libgfortran/generated/unpack_i1.c
+++ b/libgfortran/generated/unpack_i1.c
@@ -81,6 +81,7 @@ unpack0_i1 (gfc_array_i1 *ret, const gfc_array_i1 *vector,
 
   /* Initialize to avoid -Wmaybe-uninitialized complaints.  */
   rstride[0] = 1;
+  mstride[0] = 0;
   if (ret->base_addr == NULL)
     {
       /* The front end has signalled that we need to populate the
diff --git a/libgfortran/generated/unpack_i16.c b/libgfortran/generated/unpack_i16.c
index 566df21e16f..0f2266d6f3a 100644
--- a/libgfortran/generated/unpack_i16.c
+++ b/libgfortran/generated/unpack_i16.c
@@ -81,6 +81,7 @@ unpack0_i16 (gfc_array_i16 *ret, const gfc_array_i16 *vector,
 
   /* Initialize to avoid -Wmaybe-uninitialized complaints.  */
   rstride[0] = 1;
+  mstride[0] = 0;
   if (ret->base_addr == NULL)
     {
       /* The front end has signalled that we need to populate the
diff --git a/libgfortran/generated/unpack_i2.c b/libgfortran/generated/unpack_i2.c
index 769d12f2344..fcbbcdef5dd 100644
--- a/libgfortran/generated/unpack_i2.c
+++ b/libgfortran/generated/unpack_i2.c
@@ -81,6 +81,7 @@ unpack0_i2 (gfc_array_i2 *ret, const gfc_array_i2 *vector,
 
   /* Initialize to avoid -Wmaybe-uninitialized complaints.  */
   rstride[0] = 1;
+  mstride[0] = 0;
   if (ret->base_addr == NULL)
     {
       /* The front end has signalled that we need to populate the
diff --git a/libgfortran/generated/unpack_i4.c b/libgfortran/generated/unpack_i4.c
index af92fdfcbcd..1e880a31e18 100644
--- a/libgfortran/generated/unpack_i4.c
+++ b/libgfortran/generated/unpack_i4.c
@@ -81,6 +81,7 @@ unpack0_i4 (gfc_array_i4 *ret, const gfc_array_i4 *vector,
 
   /* Initialize to avoid -Wmaybe-uninitialized complaints.  */
   rstride[0] = 1;
+  mstride[0] = 0;
   if (ret->base_addr == NULL)
     {
       /* The front end has signalled that we need to populate the
diff --git a/libgfortran/generated/unpack_i8.c b/libgfortran/generated/unpack_i8.c
index e7abf354790..021079b1a3e 100644
--- a/libgfortran/generated/unpack_i8.c
+++ b/libgfortran/generated/unpack_i8.c
@@ -81,6 +81,7 @@ unpack0_i8 (gfc_array_i8 *ret, const gfc_array_i8 *vector,
 
   /* Initialize to avoid -Wmaybe-uninitialized complaints.  */
   rstride[0] = 1;
+  mstride[0] = 0;
   if (ret->base_addr == NULL)
     {
       /* The front end has signalled that we need to populate the
diff --git a/libgfortran/generated/unpack_r10.c b/libgfortran/generated/unpack_r10.c
index 26b738e73a4..db0877f2d58 100644
--- a/libgfortran/generated/unpack_r10.c
+++ b/libgfortran/generated/unpack_r10.c
@@ -81,6 +81,7 @@ unpack0_r10 (gfc_array_r10 *ret, const gfc_array_r10 *vector,
 
   /* Initialize to avoid -Wmaybe-uninitialized complaints.  */
   rstride[0] = 1;
+  mstride[0] = 0;
   if (ret->base_addr == NULL)
     {
       /* The front end has signalled that we need to populate the
diff --git a/libgfortran/generated/unpack_r16.c b/libgfortran/generated/unpack_r16.c
index 48709c73ca0..0d7441a990f 100644
--- a/libgfortran/generated/unpack_r16.c
+++ b/libgfortran/generated/unpack_r16.c
@@ -81,6 +81,7 @@ unpack0_r16 (gfc_array_r16 *ret, const gfc_array_r16 *vector,
 
   /* Initialize to avoid -Wmaybe-uninitialized complaints.  */
   rstride[0] = 1;
+  mstride[0] = 0;
   if (ret->base_addr == NULL)
     {
       /* The front end has signalled that we need to populate the
diff --git a/libgfortran/generated/unpack_r17.c b/libgfortran/generated/unpack_r17.c
index 7ed16710679..c987152d32a 100644
--- a/libgfortran/generated/unpack_r17.c
+++ b/libgfortran/generated/unpack_r17.c
@@ -81,6 +81,7 @@ unpack0_r17 (gfc_array_r17 *ret, const gfc_array_r17 *vector,
 
   /* Initialize to avoid -Wmaybe-uninitialized complaints.  */
   rstride[0] = 1;
+  mstride[0] = 0;
   if (ret->base_addr == NULL)
     {
       /* The front end has signalled that we need to populate the
diff --git a/libgfortran/generated/unpack_r4.c b/libgfortran/generated/unpack_r4.c
index ed2389dc7dc..fc40c409fb1 100644
--- a/libgfortran/generated/unpack_r4.c
+++ b/libgfortran/generated/unpack_r4.c
@@ -81,6 +81,7 @@ unpack0_r4 (gfc_array_r4 *ret, const gfc_array_r4 *vector,
 
   /* Initialize to avoid -Wmaybe-uninitialized complaints.  */
   rstride[0] = 1;
+  mstride[0] = 0;
   if (ret->base_addr == NULL)
     {
       /* The front end has signalled that we need to populate the
diff --git a/libgfortran/generated/unpack_r8.c b/libgfortran/generated/unpack_r8.c
index f24e0a59d97..23811320252 100644
--- a/libgfortran/generated/unpack_r8.c
+++ b/libgfortran/generated/unpack_r8.c
@@ -81,6 +81,7 @@ unpack0_r8 (gfc_array_r8 *ret, const gfc_array_r8 *vector,
 
   /* Initialize to avoid -Wmaybe-uninitialized complaints.  */
   rstride[0] = 1;
+  mstride[0] = 0;
   if (ret->base_addr == NULL)
     {
       /* The front end has signalled that we need to populate the
diff --git a/libgfortran/intrinsics/c99_functions.c b/libgfortran/intrinsics/c99_functions.c
index ff71ce4b3fa..2e2f1e67f1e 100644
--- a/libgfortran/intrinsics/c99_functions.c
+++ b/libgfortran/intrinsics/c99_functions.c
@@ -914,12 +914,15 @@ carg (double complex z)
 #define HAVE_CARGL 1
 long double cargl (long double complex z);
 
+#ifndef __mcoldfire__
+/* ??? gives internal compiler error? */
 long double
 cargl (long double complex z)
 {
   return atan2l (IMAGPART (z), REALPART (z));
 }
 #endif
+#endif
 
 
 /* exp(z) = exp(a)*(cos(b) + i sin(b))  */
@@ -1145,7 +1148,7 @@ csqrtf (float complex z)
       else
         {
           s = sqrtf (0.5 * d - 0.5 * re);
-          r = fabsf ((0.5 * im) / s);
+	  r = fabsf ((float)((0.5 * im) / s));
         }
 
       COMPLEX_ASSIGN (v, r, copysignf (s, im));
diff --git a/libgfortran/intrinsics/date_and_time.c b/libgfortran/intrinsics/date_and_time.c
index 0478c77a931..5d63a208830 100644
--- a/libgfortran/intrinsics/date_and_time.c
+++ b/libgfortran/intrinsics/date_and_time.c
@@ -123,6 +123,9 @@ extern void date_and_time (char *, char *, char *, gfc_array_i4 *,
 			   GFC_INTEGER_4, GFC_INTEGER_4, GFC_INTEGER_4);
 export_proto(date_and_time);
 
+#pragma GCC diagnostic ignored "-Wformat-truncation"
+
+
 void
 date_and_time (char *__date, char *__time, char *__zone,
 	       gfc_array_i4 *__values, GFC_INTEGER_4 __date_len,
diff --git a/libgfortran/intrinsics/execute_command_line.c b/libgfortran/intrinsics/execute_command_line.c
index bf3a2ec38fe..1561eba75f1 100644
--- a/libgfortran/intrinsics/execute_command_line.c
+++ b/libgfortran/intrinsics/execute_command_line.c
@@ -99,6 +99,9 @@ execute_command_line (const char *command, bool wait, int *exitstat,
       set_cmdstat (cmdstat, EXEC_NOERROR);
 
 #if defined(HAVE_SIGACTION) && defined(HAVE_WAITPID)
+#ifndef SA_RESTART
+#  define SA_RESTART 0
+#endif
       static bool sig_init_saved;
       bool sig_init = __atomic_load_n (&sig_init_saved, __ATOMIC_RELAXED);
       if (!sig_init)
diff --git a/libgfortran/io/async.c b/libgfortran/io/async.c
index 509a1d43547..85e8316ef31 100644
--- a/libgfortran/io/async.c
+++ b/libgfortran/io/async.c
@@ -503,6 +503,9 @@ init_async_unit (gfc_unit *u)
 void
 enqueue_transfer (async_unit *au, transfer_args *arg, enum aio_do type)
 {
+  (void)au;
+  (void)arg;
+  (void)type;
   return;
 }
 
@@ -511,6 +514,8 @@ enqueue_transfer (async_unit *au, transfer_args *arg, enum aio_do type)
 int
 enqueue_done_id (async_unit *au, enum aio_do type)
 {
+  (void)au;
+  (void)type;
   return 0;
 }
 
@@ -519,6 +524,8 @@ enqueue_done_id (async_unit *au, enum aio_do type)
 void
 enqueue_done (async_unit *au, enum aio_do type)
 {
+  (void)au;
+  (void)type;
   return;
 }
 
@@ -527,6 +534,7 @@ enqueue_done (async_unit *au, enum aio_do type)
 void
 enqueue_close (async_unit *au)
 {
+  (void)au;
   return;
 }
 
@@ -535,6 +543,9 @@ enqueue_close (async_unit *au)
 void
 enqueue_data_transfer_init (async_unit *au, st_parameter_dt *dt, int read_flag)
 {
+  (void)au;
+  (void)dt;
+  (void)read_flag;
   return;
 }
 
@@ -543,6 +554,8 @@ enqueue_data_transfer_init (async_unit *au, st_parameter_dt *dt, int read_flag)
 bool
 collect_async_errors (st_parameter_common *cmp, async_unit *au)
 {
+  (void)cmp;
+  (void)au;
   return false;
 }
 
@@ -551,6 +564,9 @@ collect_async_errors (st_parameter_common *cmp, async_unit *au)
 bool
 async_wait_id (st_parameter_common *cmp, async_unit *au, int i)
 {
+  (void)cmp;
+  (void)au;
+  (void)i;
   return false;
 }
 
@@ -559,6 +575,8 @@ async_wait_id (st_parameter_common *cmp, async_unit *au, int i)
 bool
 async_wait (st_parameter_common *cmp, async_unit *au)
 {
+  (void)cmp;
+  (void)au;
   return false;
 }
 
@@ -567,6 +585,7 @@ async_wait (st_parameter_common *cmp, async_unit *au)
 void
 async_close (async_unit *au)
 {
+  (void)au;
   return;
 }
 
diff --git a/libgfortran/io/transfer.c b/libgfortran/io/transfer.c
index 3fc53938b4a..d58d65940bc 100644
--- a/libgfortran/io/transfer.c
+++ b/libgfortran/io/transfer.c
@@ -2963,7 +2963,7 @@ us_read (st_parameter_dt *dtp, int continued)
   else
     n = compile_options.record_marker;
 
-  nr = sread (dtp->u.p.current_unit->s, &i, n);
+  nr = sread (dtp->u.p.current_unit->s, &i8, n);
   if (unlikely (nr < 0))
     {
       generate_error (&dtp->common, LIBERROR_BAD_US, NULL);
@@ -2990,12 +2990,11 @@ us_read (st_parameter_dt *dtp, int continued)
       switch (nr)
 	{
 	case sizeof(GFC_INTEGER_4):
-	  memcpy (&i4, &i, sizeof (i4));
+	  memcpy (&i4, &i8, sizeof (i4));
 	  i = i4;
 	  break;
 
 	case sizeof(GFC_INTEGER_8):
-	  memcpy (&i8, &i, sizeof (i8));
 	  i = i8;
 	  break;
 
@@ -3011,14 +3010,14 @@ us_read (st_parameter_dt *dtp, int continued)
       switch (nr)
 	{
 	case sizeof(GFC_INTEGER_4):
-	  memcpy (&u32, &i, sizeof (u32));
+	  memcpy (&u32, &i8, sizeof (u32));
 	  u32 = __builtin_bswap32 (u32);
 	  memcpy (&i4, &u32, sizeof (i4));
 	  i = i4;
 	  break;
 
 	case sizeof(GFC_INTEGER_8):
-	  memcpy (&u64, &i, sizeof (u64));
+	  memcpy (&u64, &i8, sizeof (u64));
 	  u64 = __builtin_bswap64 (u64);
 	  memcpy (&i8, &u64, sizeof (i8));
 	  i = i8;
@@ -3053,7 +3052,7 @@ static void
 us_write (st_parameter_dt *dtp, int continued)
 {
   ssize_t nbytes;
-  gfc_offset dummy;
+  uint64_t dummy;
 
   dummy = 0;
 
diff --git a/libgfortran/io/unit.c b/libgfortran/io/unit.c
index 62a8c514c18..58a2b4537f9 100644
--- a/libgfortran/io/unit.c
+++ b/libgfortran/io/unit.c
@@ -635,7 +635,7 @@ init_units (void)
 
   if (sizeof (max_offset) == 8)
     {
-      max_offset = GFC_INTEGER_8_HUGE;
+      max_offset = (gfc_offset) GFC_INTEGER_8_HUGE;
       /* Why this weird value? Because if the recl specifier in the
 	 inquire statement is a 4 byte value, u->recl is truncated,
 	 and this trick ensures it becomes HUGE(0) rather than -1.
diff --git a/libgfortran/m4/matmul_internal.m4 b/libgfortran/m4/matmul_internal.m4
index 20b1a486a4a..890576366fe 100644
--- a/libgfortran/m4/matmul_internal.m4
+++ b/libgfortran/m4/matmul_internal.m4
@@ -158,6 +158,8 @@ sinclude(`matmul_asm_'rtype_code`.m4')dnl
      itself.  */
 
 #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))
+#undef min
+#undef max
 #define min(a,b) ((a) <= (b) ? (a) : (b))
 #define max(a,b) ((a) >= (b) ? (a) : (b))
 
diff --git a/libgfortran/runtime/ISO_Fortran_binding.c b/libgfortran/runtime/ISO_Fortran_binding.c
index 1057f37b7d4..d5231262c46 100644
--- a/libgfortran/runtime/ISO_Fortran_binding.c
+++ b/libgfortran/runtime/ISO_Fortran_binding.c
@@ -197,9 +197,9 @@ void *CFI_address (const CFI_cdesc_t *dv, const CFI_index_t subscripts[])
 		       "lower_bound = %" PRIiPTR ", upper bound = %" PRIiPTR
 		       ", extent = %" PRIiPTR "\n",
 		       i, i, (int)subscripts[i],
-		       (ptrdiff_t)dv->dim[i].lower_bound,
-		       (ptrdiff_t)(dv->dim[i].extent - dv->dim[i].lower_bound),
-		       (ptrdiff_t)dv->dim[i].extent);
+		       (int)dv->dim[i].lower_bound,
+		       (int)(dv->dim[i].extent - dv->dim[i].lower_bound),
+		       (int)dv->dim[i].extent);
               return NULL;
             }
 
@@ -418,7 +418,7 @@ int CFI_establish (CFI_cdesc_t *dv, void *base_addr, CFI_attribute_t attribute,
 	    {
 	      fprintf (stderr, "CFI_establish: Extents must be nonnegative "
 		       "(extents[%d] = %" PRIiPTR ").\n",
-		       i, (ptrdiff_t)extents[i]);
+		       i, (int)extents[i]);
 	      return CFI_INVALID_EXTENT;
 	    }
 	  dv->dim[i].lower_bound = 0;
@@ -545,7 +545,7 @@ int CFI_section (CFI_cdesc_t *result, const CFI_cdesc_t *source,
 	  fprintf (stderr, "CFI_section: The element lengths of "
 		   "source (source->elem_len = %" PRIiPTR ") and result "
 		   "(result->elem_len = %" PRIiPTR ") must be equal.\n",
-		   (ptrdiff_t)source->elem_len, (ptrdiff_t)result->elem_len);
+		   (int)source->elem_len, (int)result->elem_len);
 	  return CFI_INVALID_ELEM_LEN;
 	}
 
@@ -629,8 +629,8 @@ int CFI_section (CFI_cdesc_t *result, const CFI_cdesc_t *source,
 	      fprintf (stderr, "CFI_section: If strides[%d] = 0, then "
 		       "lower_bounds[%d] = %" PRIiPTR " and "
 		       "upper_bounds[%d] = %" PRIiPTR " must be equal.\n",
-		       i, i, (ptrdiff_t)lower_bounds[i], i,
-		       (ptrdiff_t)upper_bounds[i]);
+		       i, i, (int)lower_bounds[i], i,
+		       (int)upper_bounds[i]);
 	      return CFI_ERROR_OUT_OF_BOUNDS;
 	    }
 	}
@@ -655,9 +655,9 @@ int CFI_section (CFI_cdesc_t *result, const CFI_cdesc_t *source,
 		     "+ source->dim[%d].extent - 1, "
 		     "%" PRIiPTR " <= %" PRIiPTR " <= %" PRIiPTR ").\n",
 		     i, i, i, i,
-		     (ptrdiff_t)source->dim[i].lower_bound,
-		     (ptrdiff_t)lower[i],
-		     (ptrdiff_t)ub);
+		     (int)source->dim[i].lower_bound,
+		     (int)lower[i],
+		     (int)ub);
 	    return CFI_ERROR_OUT_OF_BOUNDS;
 	  }
 
@@ -672,9 +672,9 @@ int CFI_section (CFI_cdesc_t *result, const CFI_cdesc_t *source,
 		     "+ source->dim[%d].extent - 1, "
 		     "%" PRIiPTR " !<= %" PRIiPTR " !<= %" PRIiPTR ").\n",
 		     i, i, i, i,
-		     (ptrdiff_t)source->dim[i].lower_bound,
-		     (ptrdiff_t)upper[i],
-		     (ptrdiff_t)ub);
+		     (int)source->dim[i].lower_bound,
+		     (int)upper[i],
+		     (int)ub);
 	    return CFI_ERROR_OUT_OF_BOUNDS;
 	  }
 
@@ -685,8 +685,8 @@ int CFI_section (CFI_cdesc_t *result, const CFI_cdesc_t *source,
 		     "lower[%d], %" PRIiPTR " < %" PRIiPTR "), then the "
 		     "stride for said dimension must be negative "
 		     "(stride[%d] < 0, %" PRIiPTR " < 0).\n",
-		     i, i, (ptrdiff_t)upper[i], (ptrdiff_t)lower[i],
-		     i, (ptrdiff_t)stride[i]);
+		     i, i, (int)upper[i], (int)lower[i],
+		     i, (int)stride[i]);
 	    return CFI_INVALID_STRIDE;
 	  }
       }
@@ -780,8 +780,8 @@ int CFI_select_part (CFI_cdesc_t *result, const CFI_cdesc_t *source,
 	  fprintf (stderr, "CFI_select_part: Displacement must be within the "
 		   "bounds of source (0 <= displacement <= source->elem_len "
 		   "- 1, 0 <= %" PRIiPTR " <= %" PRIiPTR ").\n",
-		   (ptrdiff_t)displacement,
-		   (ptrdiff_t)(source->elem_len - 1));
+		   (int)displacement,
+		   (int)(source->elem_len - 1));
 	  return CFI_ERROR_OUT_OF_BOUNDS;
 	}
 
@@ -795,9 +795,9 @@ int CFI_select_part (CFI_cdesc_t *result, const CFI_cdesc_t *source,
 		   "<= source->elem_len, "
 		   "%" PRIiPTR " + %" PRIiPTR " = %" PRIiPTR " <= %" PRIiPTR
 		   ").\n",
-		   (ptrdiff_t)displacement, (ptrdiff_t)result->elem_len,
-		   (ptrdiff_t)(displacement + result->elem_len),
-		   (ptrdiff_t)source->elem_len);
+		   (int)displacement, (int)result->elem_len,
+		   (int)(displacement + result->elem_len),
+		   (int)source->elem_len);
 	  return CFI_ERROR_OUT_OF_BOUNDS;
 	}
     }
@@ -870,8 +870,8 @@ int CFI_setpointer (CFI_cdesc_t *result, CFI_cdesc_t *source,
 		       "(result->elem_len = %" PRIiPTR ") and source "
 		       "(source->elem_len = %" PRIiPTR ") "
 		       " must be the same.\n",
-		       (ptrdiff_t)result->elem_len,
-		       (ptrdiff_t)source->elem_len);
+		       (int)result->elem_len,
+		       (int)source->elem_len);
 	      return CFI_INVALID_ELEM_LEN;
 	    }
 
diff --git a/libgfortran/runtime/error.c b/libgfortran/runtime/error.c
index d2ae7be16f4..2cc0fa8d44b 100644
--- a/libgfortran/runtime/error.c
+++ b/libgfortran/runtime/error.c
@@ -24,8 +24,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 
 #include "libgfortran.h"
-#include "io.h"
-#include "async.h"
+#include "io/io.h"
+#include "io/async.h"
 
 #include <assert.h>
 #include <string.h>
diff --git a/libgm2/configure b/libgm2/configure
index 8ffdb311625..b664b2435ef 100755
--- a/libgm2/configure
+++ b/libgm2/configure
@@ -22575,6 +22575,7 @@ case ${host} in
   *-*-solaris2*) M2_HOST_OS=solaris ;;
   *-*-aix*)      M2_HOST_OS=aix ;;
   *-*-gnu*)      M2_HOST_OS=hurd ;;
+  *-*-mint*)     M2_HOST_OS=mint ;;
 esac
 
 M2_TARGET_OS=unknown
@@ -22588,6 +22589,7 @@ case ${target} in
   *-*-solaris2*) M2_TARGET_OS=solaris ;;
   *-*-aix*)      M2_TARGET_OS=aix ;;
   *-*-gnu*)      M2_TARGET_OS=hurd ;;
+  *-*-mint*)     M2_TARGET_OS=mint ;;
 esac
 
 # M2_HOST_OS=unknown
diff --git a/libgm2/configure.ac b/libgm2/configure.ac
index 437485fcf0f..6150cff71a9 100644
--- a/libgm2/configure.ac
+++ b/libgm2/configure.ac
@@ -398,6 +398,7 @@ case ${host} in
   *-*-solaris2*) M2_HOST_OS=solaris ;;
   *-*-aix*)      M2_HOST_OS=aix ;;
   *-*-gnu*)      M2_HOST_OS=hurd ;;
+  *-*-mint*)     M2_HOST_OS=mint ;;
 esac
 
 M2_TARGET_OS=unknown
@@ -411,6 +412,7 @@ case ${target} in
   *-*-solaris2*) M2_TARGET_OS=solaris ;;
   *-*-aix*)      M2_TARGET_OS=aix ;;
   *-*-gnu*)      M2_TARGET_OS=hurd ;;
+  *-*-mint*)     M2_TARGET_OS=mint ;;
 esac
 
 # M2_HOST_OS=unknown
diff --git a/libgm2/libm2iso/RTco.cc b/libgm2/libm2iso/RTco.cc
index 190c897c0c0..e694b89c95a 100644
--- a/libgm2/libm2iso/RTco.cc
+++ b/libgm2/libm2iso/RTco.cc
@@ -27,6 +27,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #include "config.h"
 #include <unistd.h>
 #include <pthread.h>
+#undef system
 #include <sys/select.h>
 #include <stdlib.h>
 #include <m2rts.h>
@@ -74,8 +75,10 @@ typedef struct threadCB_s
   pthread_t p;
   int tid;   /* The thread id.  */
   unsigned int interruptLevel;
+#ifndef GCC_GTHR_SINGLE_H
   __gthread_cond_t run_counter;  /* Used to block the thread and force
 				    a context switch.  */
+#endif
   int value;    /* Count 0 or 1.  */
   bool waiting; /* Is this thread waiting on the run_counter?  */
 } threadCB;
@@ -83,7 +86,9 @@ typedef struct threadCB_s
 
 typedef struct threadSem_s
 {
+#ifndef GCC_GTHR_SINGLE_H
   __gthread_cond_t counter;
+#endif
   bool waiting;
   int sem_value;
 } threadSem;
@@ -94,8 +99,10 @@ static unsigned int nSemaphores = 0;
 static threadSem **semArray = NULL;
 
 /* These are used to lock the above module data structures.  */
+#ifndef GCC_GTHR_SINGLE_H
 static __gthread_mutex_t lock;  /* This is the only mutex for
 				   the whole module.  */
+#endif
 static bool initialized = false;
 
 extern "C" int EXPORT(init) (void);
@@ -119,7 +126,9 @@ M2EXPORT(fini) (int argc, char *argv[], char *envp[])
 static void
 initSem (threadSem *sem, int value)
 {
+#ifndef GCC_GTHR_SINGLE_H
   __GTHREAD_COND_INIT_FUNCTION (&sem->counter);
+#endif
   sem->waiting = false;
   sem->sem_value = value;
 }
@@ -127,27 +136,40 @@ initSem (threadSem *sem, int value)
 static void
 waitSem (threadSem *sem)
 {
+#ifndef GCC_GTHR_SINGLE_H
   __gthread_mutex_lock (&lock);
+#endif
   if (sem->sem_value == 0)
     {
       sem->waiting = true;
+#ifndef GCC_GTHR_SINGLE_H
       __gthread_cond_wait (&sem->counter, &lock);
+#endif
       sem->waiting = false;
     }
   else
     sem->sem_value--;
+#ifndef GCC_GTHR_SINGLE_H
   __gthread_mutex_unlock (&lock);
+#endif
 }
 
 static void
 signalSem (threadSem *sem)
 {
+#ifndef GCC_GTHR_SINGLE_H
   __gthread_mutex_lock (&lock);
+#endif
   if (sem->waiting)
+  {
+#ifndef GCC_GTHR_SINGLE_H
     __gthread_cond_signal (&sem->counter);
-  else
+#endif
+  } else
     sem->sem_value++;
+#ifndef GCC_GTHR_SINGLE_H
   __gthread_mutex_unlock (&lock);
+#endif
 }
 
 extern "C" void
@@ -217,9 +239,13 @@ EXPORT(initSemaphore) (int value)
   tprintf ("initSemaphore (%d) called\n", value);
   EXPORT(init) ();
   tprintf ("about to access lock\n");
+#ifndef GCC_GTHR_SINGLE_H
   __gthread_mutex_lock (&lock);
+#endif
   sid = initSemaphore (value);
+#ifndef GCC_GTHR_SINGLE_H
   __gthread_mutex_unlock (&lock);
+#endif
   return sid;
 }
 
@@ -241,10 +267,14 @@ EXPORT(currentThread) (void)
   int tid;
 
   EXPORT(init) ();
+#ifndef GCC_GTHR_SINGLE_H
   __gthread_mutex_lock (&lock);
+#endif
   tid = currentThread ();
   tprintf ("currentThread %d\n", tid);
+#ifndef GCC_GTHR_SINGLE_H
   __gthread_mutex_unlock (&lock);
+#endif
   return tid;
 }
 
@@ -254,12 +284,16 @@ extern "C" unsigned int
 EXPORT(currentInterruptLevel) (void)
 {
   EXPORT(init) ();
+#ifndef GCC_GTHR_SINGLE_H
   __gthread_mutex_lock (&lock);
+#endif
   int current = currentThread ();
   tprintf ("currentInterruptLevel %d\n",
            threadArray[current].interruptLevel);
   int level = threadArray[current].interruptLevel;
+#ifndef GCC_GTHR_SINGLE_H
   __gthread_mutex_unlock (&lock);
+#endif
   return level;
 }
 
@@ -270,12 +304,16 @@ extern "C" unsigned int
 EXPORT(turnInterrupts) (unsigned int newLevel)
 {
   EXPORT(init) ();
+#ifndef GCC_GTHR_SINGLE_H
   __gthread_mutex_lock (&lock);
+#endif
   int current = currentThread ();
   unsigned int old = threadArray[current].interruptLevel;
   tprintf ("turnInterrupts from %d to %d\n", old, newLevel);
   threadArray[current].interruptLevel = newLevel;
+#ifndef GCC_GTHR_SINGLE_H
   __gthread_mutex_unlock (&lock);
+#endif
   return old;
 }
 
@@ -292,7 +330,9 @@ execThread (void *t)
   threadCB *tp = (threadCB *)t;
 
   tprintf ("exec thread tid = %d coming to life\n", tp->tid);
+#ifndef GCC_GTHR_SINGLE_H
   __gthread_mutex_lock (&lock);
+#endif
   tprintf ("exec thread tid = %d  function = 0x%p  arg = 0x%p\n", tp->tid,
            tp->proc, t);
   /* Has the thread been signalled?  */
@@ -302,7 +342,9 @@ execThread (void *t)
       tprintf ("%s: forcing thread tid = %d to wait\n",
 	       __FUNCTION__, tp->tid);
       tp->waiting = true;  /* We are waiting.  */
+#ifndef GCC_GTHR_SINGLE_H
       __gthread_cond_wait (&tp->run_counter, &lock);
+#endif
       tp->waiting = false; /* Running again.  */
     }
   else
@@ -314,7 +356,9 @@ execThread (void *t)
     }
   tprintf ("  running exec thread [%d]  function = 0x%p  arg = 0x%p\n", tp->tid,
            tp->proc, t);
+#ifndef GCC_GTHR_SINGLE_H
   __gthread_mutex_unlock (&lock);
+#endif
   tp->proc (); /* Now execute user procedure.  */
 #if 0
   m2iso_M2RTS_CoroutineException ( __FILE__, __LINE__, __COLUMN__, __FUNCTION__, "coroutine finishing");
@@ -360,7 +404,9 @@ initThread (void (*proc) (void), unsigned int stackSize,
   threadArray[tid].proc = proc;
   threadArray[tid].tid = tid;
   /* Initialize the thread run_counter used to force a context switch.  */
+#ifndef GCC_GTHR_SINGLE_H
   __GTHREAD_COND_INIT_FUNCTION (&threadArray[tid].run_counter);
+#endif
   threadArray[tid].interruptLevel = interrupt;
   threadArray[tid].waiting = false;     /* The thread is running.  */
   threadArray[tid].value = 0;  /* No signal has been seen yet.  */
@@ -398,9 +444,13 @@ EXPORT(initThread) (void (*proc) (void), unsigned int stackSize,
   int tid;
 
   EXPORT(init) ();
+#ifndef GCC_GTHR_SINGLE_H
   __gthread_mutex_lock (&lock);
+#endif
   tid = initThread (proc, stackSize, interrupt);
+#ifndef GCC_GTHR_SINGLE_H
   __gthread_mutex_unlock (&lock);
+#endif
   return tid;
 }
 
@@ -411,7 +461,9 @@ EXPORT(initThread) (void (*proc) (void), unsigned int stackSize,
 extern "C" void
 EXPORT(transfer) (int *p1, int p2)
 {
+#ifndef GCC_GTHR_SINGLE_H
   __gthread_mutex_lock (&lock);
+#endif
   {
     int current = currentThread ();
     if (!initialized)
@@ -434,7 +486,9 @@ EXPORT(transfer) (int *p1, int p2)
 	  {
 	    /* p2 is blocked on the condition variable, release it.  */
 	    tprintf ("p1 = %d cond_signal to p2 (%d)\n", current, p2);
+#ifndef GCC_GTHR_SINGLE_H
 	  __gthread_cond_signal (&threadArray[p2].run_counter);
+#endif
 	  tprintf ("after p1 = %d cond_signal to p2 (%d)\n", current, p2);
 	  }
 	else
@@ -451,7 +505,9 @@ EXPORT(transfer) (int *p1, int p2)
 	  {
 	    /* Record we are about to wait on the condition variable.  */
 	    threadArray[old].waiting = true;
+#ifndef GCC_GTHR_SINGLE_H
 	    __gthread_cond_wait (&threadArray[old].run_counter, &lock);
+#endif
 	    threadArray[old].waiting = false;
 	    /* We are running again.  */
 	  }
@@ -470,7 +526,9 @@ EXPORT(transfer) (int *p1, int p2)
 			     __FILE__, __FUNCTION__, __LINE__);
       }
   }
+#ifndef GCC_GTHR_SINGLE_H
   __gthread_mutex_unlock (&lock);
+#endif
 }
 
 extern "C" int
@@ -490,8 +548,10 @@ EXPORT(init) (void)
       initialized = true;
 
       tprintf ("RTco initialized\n");
+#ifndef GCC_GTHR_SINGLE_H
       __GTHREAD_MUTEX_INIT_FUNCTION (&lock);
       __gthread_mutex_lock (&lock);
+#endif
       /* Create initial thread container.  */
 #if defined(POOL)
       threadArray = (threadCB *)malloc (sizeof (threadCB) * THREAD_POOL);
@@ -501,14 +561,18 @@ EXPORT(init) (void)
       int tid = newThread ();  /* For the current initial thread.  */
       threadArray[tid].p = pthread_self ();
       threadArray[tid].tid = tid;
+#ifndef GCC_GTHR_SINGLE_H
       __GTHREAD_COND_INIT_FUNCTION (&threadArray[tid].run_counter);
+#endif
       threadArray[tid].interruptLevel = 0;
       /* The line below shouldn't be necessary as we are already running.  */
       threadArray[tid].proc = never;
       threadArray[tid].waiting = false;   /* We are running.  */
       threadArray[tid].value = 0;   /* No signal from anyone yet.  */
       tprintf ("RTco initialized completed\n");
+#ifndef GCC_GTHR_SINGLE_H
       __gthread_mutex_unlock (&lock);
+#endif
     }
   return 0;
 }
diff --git a/libgm2/libm2pim/SysExceptions.cc b/libgm2/libm2pim/SysExceptions.cc
index d93e79e3d55..3d5fdf2172c 100644
--- a/libgm2/libm2pim/SysExceptions.cc
+++ b/libgm2/libm2pim/SysExceptions.cc
@@ -126,6 +126,15 @@ static void (*systemProc) (void *);
 static void (*coroutineProc) (void *);
 static void (*exceptionProc) (void *);
 
+#ifdef __MINT__
+#ifndef SA_SIGINFO
+#define NO_SIGINFO
+typedef struct _siginfo_t siginfo_t;
+#define SA_SIGINFO 0
+#endif
+#endif
+
+#ifndef NO_SIGINFO
 static void
 sigbusDespatcher (int signum, siginfo_t *info, void *ucontext)
 {
@@ -141,7 +150,9 @@ sigbusDespatcher (int signum, siginfo_t *info, void *ucontext)
       perror ("not expecting to arrive here with this signal");
     }
 }
+#endif
 
+#ifndef NO_SIGINFO
 static void
 sigfpeDespatcher (int signum, siginfo_t *info, void *ucontext)
 {
@@ -175,6 +186,7 @@ sigfpeDespatcher (int signum, siginfo_t *info, void *ucontext)
       perror ("not expecting to arrive here with this signal");
     }
 }
+#endif
 
 extern "C" void
 EXPORT(InitExceptionHandlers) (
@@ -204,21 +216,27 @@ EXPORT(InitExceptionHandlers) (
   coroutineProc = coroutine;
   exceptionProc = exception;
 
+#ifndef NO_SIGINFO
   sigbus.sa_sigaction = sigbusDespatcher;
+#endif
   sigbus.sa_flags = (SA_SIGINFO);
   sigemptyset (&sigbus.sa_mask);
 
   if (sigaction (SIGBUS, &sigbus, &old) != 0)
     perror ("unable to install the sigbus signal handler");
 
+#ifndef NO_SIGINFO
   sigsegv.sa_sigaction = sigbusDespatcher;
+#endif
   sigsegv.sa_flags = (SA_SIGINFO);
   sigemptyset (&sigsegv.sa_mask);
 
   if (sigaction (SIGSEGV, &sigsegv, &old) != 0)
     perror ("unable to install the sigsegv signal handler");
 
+#ifndef NO_SIGINFO
   sigfpe.sa_sigaction = sigfpeDespatcher;
+#endif
   sigfpe.sa_flags = (SA_SIGINFO);
   sigemptyset (&sigfpe.sa_mask);
 
diff --git a/libgm2/libm2pim/wrapc.cc b/libgm2/libm2pim/wrapc.cc
index 5c31f1e2687..202f3b95476 100644
--- a/libgm2/libm2pim/wrapc.cc
+++ b/libgm2/libm2pim/wrapc.cc
@@ -97,7 +97,7 @@ EXPORT(filesize) (int f, unsigned int *low, unsigned int *high)
   if (res == 0)
     {
       *low = (unsigned int)s.st_size;
-      *high = (unsigned int)(s.st_size >> (sizeof (unsigned int) * 8));
+      *high = sizeof(s.st_size) > sizeof (unsigned int) ? (unsigned int)(s.st_size >> (sizeof (unsigned int) * 8)) : 0;
     }
   return res;
 #else
@@ -133,10 +133,7 @@ EXPORT(fileinode) (int f, unsigned int *low, unsigned int *high)
   if (fstat (f, (struct stat *)&s) == 0)
     {
       *low = (unsigned int)s.st_ino;
-      if ((sizeof (s.st_ino) == (sizeof (unsigned int))))
-	*high = 0;
-      else
-	*high = (unsigned int)(s.st_ino >> (sizeof (unsigned int) * 8));
+      *high = sizeof (s.st_ino) > sizeof (unsigned int) ? (unsigned int)(s.st_ino >> (sizeof (unsigned int) * 8)) : 0;
       return 0;
     }
   else
@@ -223,7 +220,7 @@ EXPORT(signbitl) (long double r)
 
   /* signbit is a macro which tests its argument against sizeof(float),
      sizeof(double).  */
-  return signbitl (r);
+  return signbit (r);
 #else
   return false;
 #endif
@@ -236,7 +233,7 @@ EXPORT(signbitf) (float r)
 
   /* signbit is a macro which tests its argument against sizeof(float),
      sizeof(double).  */
-  return signbitf (r);
+  return signbit (r);
 #else
   return false;
 #endif
diff --git a/libgo/config/libtool.m4 b/libgo/config/libtool.m4
index 4ca90ee71bc..98c2c5d39d9 100644
--- a/libgo/config/libtool.m4
+++ b/libgo/config/libtool.m4
@@ -1733,7 +1733,7 @@ else
     lt_cv_dlopen_self=yes
     ;;
 
-  mingw* | pw32* | cegcc*)
+  mingw* | msys* | pw32* | cegcc*)
     lt_cv_dlopen="LoadLibrary"
     lt_cv_dlopen_libs=
     ;;
@@ -2209,14 +2209,14 @@ bsdi[[45]]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -2240,7 +2240,7 @@ cygwin* | mingw* | pw32* | cegcc*)
 m4_if([$1], [],[
       sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"])
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -2836,7 +2836,7 @@ if test "$GCC" = yes; then
   # Check if gcc -print-prog-name=ld gives a path.
   AC_MSG_CHECKING([for ld used by $CC])
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -4398,7 +4398,7 @@ _LT_EOF
       fi
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,
       # as there is no search path for DLLs.
       _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
@@ -4771,7 +4771,7 @@ _LT_EOF
       _LT_TAGVAR(export_dynamic_flag_spec, $1)=-rdynamic
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # When not using gcc, we currently assume that we are using
       # Microsoft Visual C++.
       # hardcode_libdir_flag_spec is actually meaningless, as there is
@@ -5715,7 +5715,7 @@ if test "$_lt_caught_CXX_error" != yes; then
         esac
         ;;
 
-      cygwin* | mingw* | pw32* | cegcc*)
+      cygwin* | mingw* | msys* | pw32* | cegcc*)
         # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,
         # as there is no search path for DLLs.
         _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
diff --git a/libgo/configure b/libgo/configure
index b1a2228fa1b..e19545a9b5a 100755
--- a/libgo/configure
+++ b/libgo/configure
@@ -5169,7 +5169,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -9291,7 +9291,7 @@ _LT_EOF
       fi
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
       # as there is no search path for DLLs.
       hardcode_libdir_flag_spec='-L$libdir'
@@ -9722,7 +9722,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
       export_dynamic_flag_spec=-rdynamic
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # When not using gcc, we currently assume that we are using
       # Microsoft Visual C++.
       # hardcode_libdir_flag_spec is actually meaningless, as there is
@@ -10623,14 +10623,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -10654,7 +10654,7 @@ cygwin* | mingw* | pw32* | cegcc*)
 
       sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -11275,7 +11275,7 @@ else
     lt_cv_dlopen_self=yes
     ;;
 
-  mingw* | pw32* | cegcc*)
+  mingw* | msys* | pw32* | cegcc*)
     lt_cv_dlopen="LoadLibrary"
     lt_cv_dlopen_libs=
     ;;
@@ -12698,7 +12698,7 @@ _LT_EOF
       fi
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # _LT_TAGVAR(hardcode_libdir_flag_spec, GO) is actually meaningless,
       # as there is no search path for DLLs.
       hardcode_libdir_flag_spec_GO='-L$libdir'
@@ -13129,7 +13129,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
       export_dynamic_flag_spec_GO=-rdynamic
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # When not using gcc, we currently assume that we are using
       # Microsoft Visual C++.
       # hardcode_libdir_flag_spec is actually meaningless, as there is
diff --git a/libgomp/configure b/libgomp/configure
index df1fc8df30e..678328deeed 100755
--- a/libgomp/configure
+++ b/libgomp/configure
@@ -5297,7 +5297,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -5656,6 +5656,12 @@ else
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
+  mint*)
+    # On MiNT this test can take minutes to run, and I'm not sure it's
+    # healthy for this platform. Let's restrict it to 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
   amigaos*)
     # On AmigaOS with pdksh, this test takes hours, literally.
     # So we just punt and use a minimum line length of 8192.
@@ -9142,7 +9148,7 @@ _LT_EOF
       fi
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
       # as there is no search path for DLLs.
       hardcode_libdir_flag_spec='-L$libdir'
@@ -9573,7 +9579,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
       export_dynamic_flag_spec=-rdynamic
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # When not using gcc, we currently assume that we are using
       # Microsoft Visual C++.
       # hardcode_libdir_flag_spec is actually meaningless, as there is
@@ -10521,14 +10527,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -10552,7 +10558,7 @@ cygwin* | mingw* | pw32* | cegcc*)
 
       sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -11197,7 +11203,7 @@ else
     lt_cv_dlopen_self=yes
     ;;
 
-  mingw* | pw32* | cegcc*)
+  mingw* | msys* | pw32* | cegcc*)
     lt_cv_dlopen="LoadLibrary"
     lt_cv_dlopen_libs=
     ;;
@@ -11816,7 +11822,7 @@ CC="$lt_save_CC"
 
 
 case $host in
-  *-cygwin* | *-mingw*)
+  *-cygwin* | *-mingw* | *-msys*)
     # 'host' will be top-level target in the case of a target lib,
     # we must compare to with_cross_host to decide if this is a native
     # or cross-compiler and select where to install dlls appropriately.
@@ -13076,7 +13082,7 @@ _LT_EOF
       fi
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # _LT_TAGVAR(hardcode_libdir_flag_spec, FC) is actually meaningless,
       # as there is no search path for DLLs.
       hardcode_libdir_flag_spec_FC='-L$libdir'
@@ -13495,7 +13501,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
       export_dynamic_flag_spec_FC=-rdynamic
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # When not using gcc, we currently assume that we are using
       # Microsoft Visual C++.
       # hardcode_libdir_flag_spec is actually meaningless, as there is
@@ -14237,14 +14243,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -14267,7 +14273,7 @@ cygwin* | mingw* | pw32* | cegcc*)
       soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
 
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -16047,7 +16053,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
diff --git a/libgomp/configure.tgt b/libgomp/configure.tgt
index 46af75f978f..359f5fae4ef 100644
--- a/libgomp/configure.tgt
+++ b/libgomp/configure.tgt
@@ -145,7 +145,7 @@ case "${target}" in
 	esac
 	;;
 
-  *-*-mingw32*)
+  *-*-mingw*)
 	config_path="mingw32 posix"
 	;;
 
diff --git a/libiberty/configure b/libiberty/configure
index 02fbaabe89e..cf3d21131e9 100755
--- a/libiberty/configure
+++ b/libiberty/configure
@@ -4626,7 +4626,7 @@ ac_libiberty_warn_cflags=
 save_CFLAGS="$CFLAGS"
 for real_option in -W -Wall -Wwrite-strings -Wc++-compat \
 			  -Wstrict-prototypes \
-			  -Wshadow=local; do
+			  ; do
   # Do the check with the no- prefix removed since gcc silently
   # accepts any -Wno-* option on purpose
   case $real_option in
@@ -5338,7 +5338,9 @@ case "${host}" in
 	;;
     i[34567]86-*-cygwin* | x86_64-*-cygwin*)
 	;;
-    i[34567]86-*-mingw* | x86_64-*-mingw*)
+    i[34567]86-*-mingw* | x86_64-*-mingw* | x86_64-*-msys*)
+	;;
+    *-*-mint*)
 	;;
     i[34567]86-*-interix[3-9]*)
 	# Interix 3.x gcc -fpic/-fPIC options generate broken code.
@@ -6506,7 +6508,7 @@ _ACEOF
   # Mingw provides and which ones we will be expected to provide.
 
   case "${host}" in
-  *-*-mingw*)
+  *-*-mingw* | *-*-msys*)
     case " $LIBOBJS " in
   *" asprintf.$ac_objext "* ) ;;
   *) LIBOBJS="$LIBOBJS asprintf.$ac_objext"
@@ -6722,7 +6724,7 @@ fi
 
 
 case "${host}" in
-  *-*-cygwin* | *-*-mingw*)
+  *-*-cygwin* | *-*-mingw* | *-*-mint* | *-*-msys*)
     $as_echo "#define HAVE_SYS_ERRLIST 1" >>confdefs.h
 
     $as_echo "#define HAVE_SYS_NERR 1" >>confdefs.h
@@ -6852,7 +6854,7 @@ esac
 
     ;;
 
-  *-*-mingw32*)
+  *-*-mingw32* | *-*-msys*)
     # Under mingw32, sys_nerr and sys_errlist exist, but they are
     # macros, so the test below won't find them.
     libiberty_cv_var_sys_nerr=yes
@@ -7636,7 +7638,7 @@ fi
 
 # Figure out which version of pexecute to use.
 case "${host}" in
-     *-*-mingw* | *-*-winnt*)	pexecute=pex-win32  ;;
+     *-*-mingw* | *-*-winnt* | *-*-msys*)	pexecute=pex-win32  ;;
      *-*-msdosdjgpp*)		pexecute=pex-djgpp  ;;
      *-*-msdos*)		pexecute=pex-msdos  ;;
      *)				pexecute=pex-unix   ;;
diff --git a/libiberty/configure.ac b/libiberty/configure.ac
index 3de5eca0df2..5c61a737d06 100644
--- a/libiberty/configure.ac
+++ b/libiberty/configure.ac
@@ -178,7 +178,7 @@ AC_PROG_CPP_WERROR
 
 ACX_PROG_CC_WARNING_OPTS([-W -Wall -Wwrite-strings -Wc++-compat \
 			  -Wstrict-prototypes \
-			  -Wshadow=local], [ac_libiberty_warn_cflags])
+			  ], [ac_libiberty_warn_cflags])
 ACX_PROG_CC_WARNING_ALMOST_PEDANTIC([], [ac_libiberty_warn_cflags])
 
 AC_PROG_CC_C_O
@@ -504,7 +504,7 @@ if test -n "${with_target_subdir}"; then
   # Mingw provides and which ones we will be expected to provide.
 
   case "${host}" in
-  *-*-mingw*)
+  *-*-mingw* | *-*-msys*)
     AC_LIBOBJ([asprintf])
     AC_LIBOBJ([basename])
     AC_LIBOBJ([bcmp])
@@ -583,7 +583,7 @@ AC_SUBST(CHECK)
 AC_SUBST(target_header_dir)
 
 case "${host}" in
-  *-*-cygwin* | *-*-mingw*)
+  *-*-cygwin* | *-*-mingw* | *-*-mint* | *-*-msys*)
     AC_DEFINE(HAVE_SYS_ERRLIST)
     AC_DEFINE(HAVE_SYS_NERR)
     ;;
@@ -647,7 +647,7 @@ if test -z "${setobjs}"; then
     AC_LIBOBJ([vsnprintf])
     ;;
 
-  *-*-mingw32*)
+  *-*-mingw32* | *-*-msys*)
     # Under mingw32, sys_nerr and sys_errlist exist, but they are
     # macros, so the test below won't find them.
     libiberty_cv_var_sys_nerr=yes
@@ -743,7 +743,7 @@ fi
 
 # Figure out which version of pexecute to use.
 case "${host}" in
-     *-*-mingw* | *-*-winnt*)	pexecute=pex-win32  ;;
+     *-*-mingw* | *-*-winnt* | *-*-msys*)	pexecute=pex-win32  ;;
      *-*-msdosdjgpp*)		pexecute=pex-djgpp  ;;
      *-*-msdos*)		pexecute=pex-msdos  ;;
      *)				pexecute=pex-unix   ;;
diff --git a/libiberty/hex.c b/libiberty/hex.c
index 4be701d5600..ce612ad09a9 100644
--- a/libiberty/hex.c
+++ b/libiberty/hex.c
@@ -24,7 +24,7 @@ Boston, MA 02110-1301, USA.  */
 #include "libiberty.h"
 #include "safe-ctype.h" /* for HOST_CHARSET_ASCII */
 
-#if EOF != -1
+#if !(EOF == -1)	/* gcc 2.95.3 has bug in '!=' operator for negative constants */
  #error "hex.c requires EOF == -1"
 #endif
 
diff --git a/libiberty/safe-ctype.c b/libiberty/safe-ctype.c
index 95d3f6dcf1a..94a66e11ede 100644
--- a/libiberty/safe-ctype.c
+++ b/libiberty/safe-ctype.c
@@ -118,7 +118,7 @@ sets of characters:
 #include <safe-ctype.h>
 #include <stdio.h>  /* for EOF */
 
-#if EOF != -1
+#if !(EOF == -1)	/* gcc 2.95.3 has bug in '!=' operator for negative constants */
  #error "<safe-ctype.h> requires EOF == -1"
 #endif
 
diff --git a/libiberty/strsignal.c b/libiberty/strsignal.c
index 36b41f17e12..de7a5317b60 100644
--- a/libiberty/strsignal.c
+++ b/libiberty/strsignal.c
@@ -551,7 +551,7 @@ followed by a newline.
 #ifndef HAVE_PSIGNAL
 
 void
-psignal (int signo, char *message)
+psignal (int signo, const char *message)
 {
   if (signal_names == NULL)
     {
diff --git a/libitm/configure b/libitm/configure
index 9ba7fb03a57..5c82012bd09 100755
--- a/libitm/configure
+++ b/libitm/configure
@@ -5958,7 +5958,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -9804,7 +9804,7 @@ _LT_EOF
       fi
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
       # as there is no search path for DLLs.
       hardcode_libdir_flag_spec='-L$libdir'
@@ -10235,7 +10235,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
       export_dynamic_flag_spec=-rdynamic
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # When not using gcc, we currently assume that we are using
       # Microsoft Visual C++.
       # hardcode_libdir_flag_spec is actually meaningless, as there is
@@ -11183,14 +11183,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -11214,7 +11214,7 @@ cygwin* | mingw* | pw32* | cegcc*)
 
       sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -11859,7 +11859,7 @@ else
     lt_cv_dlopen_self=yes
     ;;
 
-  mingw* | pw32* | cegcc*)
+  mingw* | msys* | pw32* | cegcc*)
     lt_cv_dlopen="LoadLibrary"
     lt_cv_dlopen_libs=
     ;;
@@ -12733,7 +12733,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -13086,7 +13086,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
         esac
         ;;
 
-      cygwin* | mingw* | pw32* | cegcc*)
+      cygwin* | mingw* | msys* | pw32* | cegcc*)
         # _LT_TAGVAR(hardcode_libdir_flag_spec, CXX) is actually meaningless,
         # as there is no search path for DLLs.
         hardcode_libdir_flag_spec_CXX='-L$libdir'
@@ -14911,14 +14911,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -14941,7 +14941,7 @@ cygwin* | mingw* | pw32* | cegcc*)
       soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
 
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -16248,7 +16248,7 @@ else
    # Systems known to be in this category are Windows (all variants),
    # VMS, and Darwin.
    case "$host_os" in
-     *vms* | cygwin* | pe | mingw* | darwin* | ultrix* | hpux10* | hpux11.00)
+     *vms* | cygwin* | pe | mingw* | msys* | darwin* | ultrix* | hpux10* | hpux11.00)
         gcc_cv_func_mmap_dev_zero=no ;;
      *)
         gcc_cv_func_mmap_dev_zero=yes;;
@@ -16305,7 +16305,7 @@ else
    # above for use of /dev/zero.
    # Systems known to be in this category are Windows, VMS, and SCO Unix.
    case "$host_os" in
-     *vms* | cygwin* | pe | mingw* | sco* | udk* )
+     *vms* | cygwin* | pe | mingw* | msys* | sco* | udk* )
         gcc_cv_func_mmap_anon=no ;;
      *)
         gcc_cv_func_mmap_anon=yes;;
@@ -17054,7 +17054,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
diff --git a/libobjc/configure b/libobjc/configure
index 68172549137..a894ade7c17 100755
--- a/libobjc/configure
+++ b/libobjc/configure
@@ -3419,7 +3419,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
 case $host in
-  *-cygwin* | *-mingw*)
+  *-cygwin* | *-mingw* | *-msys*)
     # 'host' will be top-level target in the case of a target lib,
     # we must compare to with_cross_host to decide if this is a native
     # or cross-compiler and select where to install dlls appropriately.
@@ -4635,7 +4635,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -4994,6 +4994,12 @@ else
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
+  mint*)
+    # On MiNT this test can take minutes to run, and I'm not sure it's
+    # healthy for this platform. Let's restrict it to 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
   amigaos*)
     # On AmigaOS with pdksh, this test takes hours, literally.
     # So we just punt and use a minimum line length of 8192.
@@ -8522,7 +8528,7 @@ _LT_EOF
       fi
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
       # as there is no search path for DLLs.
       hardcode_libdir_flag_spec='-L$libdir'
@@ -8959,7 +8965,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
       export_dynamic_flag_spec=-rdynamic
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # When not using gcc, we currently assume that we are using
       # Microsoft Visual C++.
       # hardcode_libdir_flag_spec is actually meaningless, as there is
@@ -9910,14 +9916,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -9941,7 +9947,7 @@ cygwin* | mingw* | pw32* | cegcc*)
 
       sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -10589,7 +10595,7 @@ else
     lt_cv_dlopen_self=yes
     ;;
 
-  mingw* | pw32* | cegcc*)
+  mingw* | msys* | pw32* | cegcc*)
     lt_cv_dlopen="LoadLibrary"
     lt_cv_dlopen_libs=
     ;;
@@ -11279,7 +11285,7 @@ case "${host}" in
       extra_ldflags_libobjc="${extra_ldflags_libobjc} -Wl,-rpath,@loader_path"
     fi
     ;;
-  *-cygwin*|*-mingw*)
+  *-cygwin*|*-mingw*|*-*-msys*)
     # Tell libtool to build DLLs on Windows
     extra_ldflags_libobjc='$(lt_host_flags)'
     ;;
diff --git a/libobjc/configure.ac b/libobjc/configure.ac
index 073b84f7d97..1f346232826 100644
--- a/libobjc/configure.ac
+++ b/libobjc/configure.ac
@@ -190,7 +190,7 @@ case "${host}" in
       extra_ldflags_libobjc="${extra_ldflags_libobjc} -Wl,-rpath,@loader_path"
     fi
     ;;
-  *-cygwin*|*-mingw*)
+  *-cygwin*|*-mingw*|*-*-msys*)
     # Tell libtool to build DLLs on Windows
     extra_ldflags_libobjc='$(lt_host_flags)'
     ;;
diff --git a/libquadmath/configure b/libquadmath/configure
index f82dd3d0d6d..348f18c9713 100755
--- a/libquadmath/configure
+++ b/libquadmath/configure
@@ -4985,7 +4985,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -8568,7 +8568,7 @@ _LT_EOF
       fi
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
       # as there is no search path for DLLs.
       hardcode_libdir_flag_spec='-L$libdir'
@@ -9005,7 +9005,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
       export_dynamic_flag_spec=-rdynamic
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # When not using gcc, we currently assume that we are using
       # Microsoft Visual C++.
       # hardcode_libdir_flag_spec is actually meaningless, as there is
@@ -9956,14 +9956,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -9987,7 +9987,7 @@ cygwin* | mingw* | pw32* | cegcc*)
 
       sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -10635,7 +10635,7 @@ else
     lt_cv_dlopen_self=yes
     ;;
 
-  mingw* | pw32* | cegcc*)
+  mingw* | msys* | pw32* | cegcc*)
     lt_cv_dlopen="LoadLibrary"
     lt_cv_dlopen_libs=
     ;;
@@ -11269,7 +11269,7 @@ CC="$lt_save_CC"
 
 
 case $host in
-  *-cygwin* | *-mingw*)
+  *-cygwin* | *-mingw* | *-msys*)
     # 'host' will be top-level target in the case of a target lib,
     # we must compare to with_cross_host to decide if this is a native
     # or cross-compiler and select where to install dlls appropriately.
diff --git a/libsanitizer/configure b/libsanitizer/configure
index 6bfd28916d2..c3db4b392f0 100755
--- a/libsanitizer/configure
+++ b/libsanitizer/configure
@@ -6572,7 +6572,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -10148,7 +10148,7 @@ _LT_EOF
       fi
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
       # as there is no search path for DLLs.
       hardcode_libdir_flag_spec='-L$libdir'
@@ -10579,7 +10579,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
       export_dynamic_flag_spec=-rdynamic
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # When not using gcc, we currently assume that we are using
       # Microsoft Visual C++.
       # hardcode_libdir_flag_spec is actually meaningless, as there is
@@ -11527,14 +11527,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -11558,7 +11558,7 @@ cygwin* | mingw* | pw32* | cegcc*)
 
       sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -12203,7 +12203,7 @@ else
     lt_cv_dlopen_self=yes
     ;;
 
-  mingw* | pw32* | cegcc*)
+  mingw* | msys* | pw32* | cegcc*)
     lt_cv_dlopen="LoadLibrary"
     lt_cv_dlopen_libs=
     ;;
@@ -13077,7 +13077,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -13430,7 +13430,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
         esac
         ;;
 
-      cygwin* | mingw* | pw32* | cegcc*)
+      cygwin* | mingw* | msys* | pw32* | cegcc*)
         # _LT_TAGVAR(hardcode_libdir_flag_spec, CXX) is actually meaningless,
         # as there is no search path for DLLs.
         hardcode_libdir_flag_spec_CXX='-L$libdir'
@@ -15255,14 +15255,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -15285,7 +15285,7 @@ cygwin* | mingw* | pw32* | cegcc*)
       soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
 
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -16936,7 +16936,7 @@ fi
 # Check for the fcntl function.
 if test -n "${with_target_subdir}"; then
    case "${host}" in
-   *-*-mingw*) have_fcntl=no ;;
+   *-*-mingw* | *-*-msys*) have_fcntl=no ;;
    *) have_fcntl=yes ;;
    esac
 else
diff --git a/libsanitizer/configure.ac b/libsanitizer/configure.ac
index 8037c941774..5830ddb4d34 100644
--- a/libsanitizer/configure.ac
+++ b/libsanitizer/configure.ac
@@ -319,7 +319,7 @@ fi
 # Check for the fcntl function.
 if test -n "${with_target_subdir}"; then
    case "${host}" in
-   *-*-mingw*) have_fcntl=no ;;
+   *-*-mingw* | *-*-msys*) have_fcntl=no ;;
    *) have_fcntl=yes ;;
    esac
 else
diff --git a/libssp/configure b/libssp/configure
index 0052e03650d..02eb6c3f791 100755
--- a/libssp/configure
+++ b/libssp/configure
@@ -4458,6 +4458,8 @@ XCFLAGS="$XCFLAGS $CET_FLAGS"
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether hidden visibility is supported" >&5
 $as_echo_n "checking whether hidden visibility is supported... " >&6; }
+save_CFLAGS="$CFLAGS"
+CFLAGS="$CFLAGS -Werror"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -4478,6 +4480,7 @@ fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ssp_hidden" >&5
 $as_echo "$ssp_hidden" >&6; }
+CFLAGS="$save_CFLAGS"
 if test x$ssp_hidden = xyes; then
 
 $as_echo "#define HAVE_HIDDEN_VISIBILITY 1" >>confdefs.h
@@ -5227,7 +5230,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -5586,6 +5589,12 @@ else
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
+  mint*)
+    # On MiNT this test can take minutes to run, and I'm not sure it's
+    # healthy for this platform. Let's restrict it to 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
   amigaos*)
     # On AmigaOS with pdksh, this test takes hours, literally.
     # So we just punt and use a minimum line length of 8192.
@@ -8810,7 +8819,7 @@ _LT_EOF
       fi
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
       # as there is no search path for DLLs.
       hardcode_libdir_flag_spec='-L$libdir'
@@ -9247,7 +9256,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
       export_dynamic_flag_spec=-rdynamic
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # When not using gcc, we currently assume that we are using
       # Microsoft Visual C++.
       # hardcode_libdir_flag_spec is actually meaningless, as there is
@@ -10198,14 +10207,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -10229,7 +10238,7 @@ cygwin* | mingw* | pw32* | cegcc*)
 
       sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -10877,7 +10886,7 @@ else
     lt_cv_dlopen_self=yes
     ;;
 
-  mingw* | pw32* | cegcc*)
+  mingw* | msys* | pw32* | cegcc*)
     lt_cv_dlopen="LoadLibrary"
     lt_cv_dlopen_libs=
     ;;
@@ -11511,7 +11520,7 @@ CC="$lt_save_CC"
 
 
 case $host in
-  *-cygwin* | *-mingw*)
+  *-cygwin* | *-mingw* | *-msys*)
     # 'host' will be top-level target in the case of a target lib,
     # we must compare to with_cross_host to decide if this is a native
     # or cross-compiler and select where to install dlls appropriately.
diff --git a/libssp/configure.ac b/libssp/configure.ac
index 5c5698fa3a2..19f0ae52074 100644
--- a/libssp/configure.ac
+++ b/libssp/configure.ac
@@ -67,10 +67,13 @@ XCFLAGS="$XCFLAGS $CET_FLAGS"
 AC_SUBST(XCFLAGS)
 
 AC_MSG_CHECKING([whether hidden visibility is supported])
+save_CFLAGS="$CFLAGS"
+CFLAGS="$CFLAGS -Werror"
 AC_TRY_COMPILE([
 void __attribute__((visibility ("hidden"))) bar (void) {}],,
 [ssp_hidden=yes],[ssp_hidden=no])
 AC_MSG_RESULT($ssp_hidden)
+CFLAGS="$save_CFLAGS"
 if test x$ssp_hidden = xyes; then
   AC_DEFINE([HAVE_HIDDEN_VISIBILITY],[1],[__attribute__((visibility ("hidden"))) supported])
 fi
diff --git a/libssp/ssp.c b/libssp/ssp.c
index 1cc067661f0..07367482826 100644
--- a/libssp/ssp.c
+++ b/libssp/ssp.c
@@ -66,6 +66,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #ifdef HAVE_SYSLOG_H
 # include <syslog.h>
 #endif
+#ifdef __MINT__
+#include <mint/osbind.h>
+#endif
 
 void *__stack_chk_guard = 0;
 
@@ -115,6 +118,9 @@ fail (const char *msg1, size_t msg1len, const char *msg3)
 {
 #ifdef __GNU_LIBRARY__
   extern char * __progname;
+#elif defined (__MINT__)
+  extern char * program_invocation_short_name;
+  #define __progname program_invocation_short_name
 #else
   static const char __progname[] = "";
 #endif
@@ -156,6 +162,9 @@ fail (const char *msg1, size_t msg1len, const char *msg3)
     syslog (LOG_CRIT, "%s", msg3);
 #endif /* HAVE_SYSLOG_H */
 
+#ifdef __MINT__
+    Pterm(127);
+#else
   /* Try very hard to exit.  Note that signals may be blocked preventing
      the first two options from working.  The use of volatile is here to
      prevent optimizers from "knowing" that __builtin_trap is called first,
@@ -177,6 +186,7 @@ fail (const char *msg1, size_t msg1len, const char *msg3)
           break;
         }
   }
+#endif
 }
 
 void
diff --git a/libstdc++-v3/acinclude.m4 b/libstdc++-v3/acinclude.m4
index a0094c2dd95..88aa8571b3a 100644
--- a/libstdc++-v3/acinclude.m4
+++ b/libstdc++-v3/acinclude.m4
@@ -3143,7 +3143,7 @@ AC_DEFUN([GLIBCXX_ENABLE_VTABLE_VERIFY], [
   vtv_cygmin=no
   if test $enable_vtable_verify = yes; then
     case ${target_os} in
-      cygwin*|mingw32*)
+      cygwin*|mingw*)
         VTV_CXXFLAGS="-fvtable-verify=std -Wl,-lvtv,-u_vtable_map_vars_start,-u_vtable_map_vars_end"
         VTV_CXXLINKFLAGS="-L${toplevel_builddir}/libvtv/.libs -Wl,--rpath -Wl,${toplevel_builddir}/libvtv/.libs"
         vtv_cygmin=yes
diff --git a/libstdc++-v3/config/abi/pre/gnu.ver b/libstdc++-v3/config/abi/pre/gnu.ver
index 29bc7d86256..acc6f838b60 100644
--- a/libstdc++-v3/config/abi/pre/gnu.ver
+++ b/libstdc++-v3/config/abi/pre/gnu.ver
@@ -2738,7 +2738,7 @@ CXXABI_1.3.6 {
     __cxa_allocate_dependent_exception;
     __cxa_free_dependent_exception;
     __cxa_deleted_virtual;
-
+    _ZTC*;
 } CXXABI_1.3.5;
 
 CXXABI_1.3.7 {
diff --git a/libstdc++-v3/config/locale/dragonfly/c_locale.h b/libstdc++-v3/config/locale/dragonfly/c_locale.h
index dd2eaab3c69..c2bcaf39e8a 100644
--- a/libstdc++-v3/config/locale/dragonfly/c_locale.h
+++ b/libstdc++-v3/config/locale/dragonfly/c_locale.h
@@ -55,7 +55,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   // fall back to the unsafe vsprintf which, in general, can be dangerous
   // and should be avoided.
   inline int
-  __convert_from_v(const __c_locale& __cloc, char* __out,
+  __convert_from_v(const __c_locale& __cloc, char* ___out,
 		   const int __size __attribute__ ((__unused__)),
 		   const char* __fmt, ...)
   {
@@ -65,9 +65,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     __builtin_va_start(__args, __fmt);
 
 #if _GLIBCXX_USE_C99_STDIO
-    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);
+    const int __ret = __builtin_vsnprintf(___out, __size, __fmt, __args);
 #else
-    const int __ret = __builtin_vsprintf(__out, __fmt, __args);
+    const int __ret = __builtin_vsprintf(___out, __fmt, __args);
 #endif
 
     __builtin_va_end(__args);
diff --git a/libstdc++-v3/config/locale/generic/c_locale.h b/libstdc++-v3/config/locale/generic/c_locale.h
index d556d87fcdc..62957055070 100644
--- a/libstdc++-v3/config/locale/generic/c_locale.h
+++ b/libstdc++-v3/config/locale/generic/c_locale.h
@@ -53,7 +53,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   // fall back to the unsafe vsprintf which, in general, can be dangerous
   // and should be avoided.
   inline int
-  __convert_from_v(const __c_locale&, char* __out,
+  __convert_from_v(const __c_locale&, char* ___out,
 		   const int __size __attribute__((__unused__)),
 		   const char* __fmt, ...)
   {
@@ -71,9 +71,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     __builtin_va_start(__args, __fmt);
 
 #if _GLIBCXX_USE_C99_STDIO && !_GLIBCXX_HAVE_BROKEN_VSNPRINTF
-    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);
+    const int __ret = __builtin_vsnprintf(___out, __size, __fmt, __args);
 #else
-    const int __ret = __builtin_vsprintf(__out, __fmt, __args);
+    const int __ret = __builtin_vsprintf(___out, __fmt, __args);
 #endif
 
     __builtin_va_end(__args);
diff --git a/libstdc++-v3/config/locale/gnu/c_locale.h b/libstdc++-v3/config/locale/gnu/c_locale.h
index d9a310b7027..607421d2aa2 100644
--- a/libstdc++-v3/config/locale/gnu/c_locale.h
+++ b/libstdc++-v3/config/locale/gnu/c_locale.h
@@ -72,7 +72,7 @@ namespace __gnu_cxx_ieee128 {
   // and should be avoided.
   inline int
   __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
-		   char* __out,
+		   char* ___out,
 		   const int __size __attribute__ ((__unused__)),
 		   const char* __fmt, ...)
   {
@@ -94,9 +94,9 @@ namespace __gnu_cxx_ieee128 {
     __builtin_va_start(__args, __fmt);
 
 #if _GLIBCXX_USE_C99_STDIO
-    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);
+    const int __ret = __builtin_vsnprintf(___out, __size, __fmt, __args);
 #else
-    const int __ret = __builtin_vsprintf(__out, __fmt, __args);
+    const int __ret = __builtin_vsprintf(___out, __fmt, __args);
 #endif
 
     __builtin_va_end(__args);
diff --git a/libstdc++-v3/config/os/mint/ctype_base.h b/libstdc++-v3/config/os/mint/ctype_base.h
new file mode 100644
index 00000000000..0f2e672c6fe
--- /dev/null
+++ b/libstdc++-v3/config/os/mint/ctype_base.h
@@ -0,0 +1,67 @@
+// Locale support -*- C++ -*-
+
+// Copyright (C) 1997-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+//
+// ISO C++ 14882: 22.1  Locales
+//
+
+//  We don't use the C-locale masks defined in /usr/include/ctype.h
+//  because those masks do not conform to the requirements of 22.2.1.
+//  In particular, a separate 'print' bitmask does not exist (isprint(c)
+//  relies on a combination of flags) and the  '_ALPHA' mask is also a
+//  combination of simple bitmasks.  Thus, we define libstdc++-specific
+//  masks here, based on the generic masks, and the corresponding
+//  classic_table in ctype_noninline.h.
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  /// @brief  Base class for ctype.
+  struct ctype_base
+  {
+    // Non-standard typedefs.
+    typedef const int* 		__to_type;
+
+    // NB: Offsets into ctype<char>::_M_table force a particular size
+    // on the mask type. Because of this, we don't use an enum.
+    typedef unsigned short 	mask;
+    static const mask upper	= 1 << 0;
+    static const mask lower	= 1 << 1;
+    static const mask alpha	= 1 << 2;
+    static const mask digit	= 1 << 3;
+    static const mask xdigit	= 1 << 4;
+    static const mask space	= 1 << 5;
+    static const mask print	= 1 << 6;
+    static const mask graph	= (1 << 2) | (1 << 3) | (1 << 9);  // alnum|punct
+    static const mask cntrl	= 1 << 8;
+    static const mask punct 	= 1 << 9;
+    static const mask alnum	= (1 << 2) | (1 << 3);  // alpha|digit
+#if __cplusplus >= 201103L
+    static const mask blank	= 1 << 10;
+#endif
+  };
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
diff --git a/libstdc++-v3/config/os/mint/ctype_configure_char.cc b/libstdc++-v3/config/os/mint/ctype_configure_char.cc
new file mode 100644
index 00000000000..840c4730312
--- /dev/null
+++ b/libstdc++-v3/config/os/mint/ctype_configure_char.cc
@@ -0,0 +1,243 @@
+// Locale support -*- C++ -*-
+
+// Copyright (C) 2011-2017 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file ctype_configure_char.cc */
+
+//
+// ISO C++ 14882: 22.1  Locales
+//
+
+#include <locale>
+#include <cstdlib>
+#include <cstring>
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  // The classic table used in libstdc++ is *not* the C _ctype table
+  // used by mscvrt, but is based on the ctype masks defined for libstdc++
+  // in ctype_base.h.
+
+  const ctype_base::mask*
+  ctype<char>::classic_table() throw()
+  {
+    static const ctype_base::mask _S_classic_table[256] =
+    {
+      cntrl /* null */,
+      cntrl /* ^A */,
+      cntrl /* ^B */,
+      cntrl /* ^C */,
+      cntrl /* ^D */,
+      cntrl /* ^E */,
+      cntrl /* ^F */,
+      cntrl /* ^G */,
+      cntrl /* ^H */,
+      ctype_base::mask(space | cntrl | blank) /* tab */,
+      ctype_base::mask(space | cntrl) /* LF */,
+      ctype_base::mask(space | cntrl) /* ^K */,
+      ctype_base::mask(space | cntrl) /* FF */,
+      ctype_base::mask(space | cntrl) /* ^M */,
+      cntrl /* ^N */,
+      cntrl /* ^O */,
+      cntrl /* ^P */,
+      cntrl /* ^Q */,
+      cntrl /* ^R */,
+      cntrl /* ^S */,
+      cntrl /* ^T */,
+      cntrl /* ^U */,
+      cntrl /* ^V */,
+      cntrl /* ^W */,
+      cntrl /* ^X */,
+      cntrl /* ^Y */,
+      cntrl /* ^Z */,
+      cntrl /* esc */,
+      cntrl /* ^\ */,
+      cntrl /* ^] */,
+      cntrl /* ^^ */,
+      cntrl /* ^_ */,
+      ctype_base::mask(space | print | blank) /*   */,
+      ctype_base::mask(punct | print) /* ! */,
+      ctype_base::mask(punct | print) /* " */,
+      ctype_base::mask(punct | print) /* # */,
+      ctype_base::mask(punct | print) /* $ */,
+      ctype_base::mask(punct | print) /* % */,
+      ctype_base::mask(punct | print) /* & */,
+      ctype_base::mask(punct | print) /* ' */,
+      ctype_base::mask(punct | print) /* ( */,
+      ctype_base::mask(punct | print) /* ) */,
+      ctype_base::mask(punct | print) /* * */,
+      ctype_base::mask(punct | print) /* + */,
+      ctype_base::mask(punct | print) /* , */,
+      ctype_base::mask(punct | print) /* - */,
+      ctype_base::mask(punct | print) /* . */,
+      ctype_base::mask(punct | print) /* / */,
+      ctype_base::mask(digit | xdigit | print) /* 0 */,
+      ctype_base::mask(digit | xdigit | print) /* 1 */,
+      ctype_base::mask(digit | xdigit | print) /* 2 */,
+      ctype_base::mask(digit | xdigit | print) /* 3 */,
+      ctype_base::mask(digit | xdigit | print) /* 4 */,
+      ctype_base::mask(digit | xdigit | print) /* 5 */,
+      ctype_base::mask(digit | xdigit | print) /* 6 */,
+      ctype_base::mask(digit | xdigit | print) /* 7 */,
+      ctype_base::mask(digit | xdigit | print) /* 8 */,
+      ctype_base::mask(digit | xdigit | print) /* 9 */,
+      ctype_base::mask(punct | print) /* : */,
+      ctype_base::mask(punct | print) /* ; */,
+      ctype_base::mask(punct | print) /* < */,
+      ctype_base::mask(punct | print) /* = */,
+      ctype_base::mask(punct | print) /* > */,
+      ctype_base::mask(punct | print) /* ? */,
+      ctype_base::mask(punct | print) /* ! */,
+      ctype_base::mask(alpha | upper | xdigit | print) /* A */,
+      ctype_base::mask(alpha | upper | xdigit | print) /* B */,
+      ctype_base::mask(alpha | upper | xdigit | print) /* C */,
+      ctype_base::mask(alpha | upper | xdigit | print) /* D */,
+      ctype_base::mask(alpha | upper | xdigit | print) /* E */,
+      ctype_base::mask(alpha | upper | xdigit | print) /* F */,
+      ctype_base::mask(alpha | upper | print) /* G */,
+      ctype_base::mask(alpha | upper | print) /* H */,
+      ctype_base::mask(alpha | upper | print) /* I */,
+      ctype_base::mask(alpha | upper | print) /* J */,
+      ctype_base::mask(alpha | upper | print) /* K */,
+      ctype_base::mask(alpha | upper | print) /* L */,
+      ctype_base::mask(alpha | upper | print) /* M */,
+      ctype_base::mask(alpha | upper | print) /* N */,
+      ctype_base::mask(alpha | upper | print) /* O */,
+      ctype_base::mask(alpha | upper | print) /* P */,
+      ctype_base::mask(alpha | upper | print) /* Q */,
+      ctype_base::mask(alpha | upper | print) /* R */,
+      ctype_base::mask(alpha | upper | print) /* S */,
+      ctype_base::mask(alpha | upper | print) /* T */,
+      ctype_base::mask(alpha | upper | print) /* U */,
+      ctype_base::mask(alpha | upper | print) /* V */,
+      ctype_base::mask(alpha | upper | print) /* W */,
+      ctype_base::mask(alpha | upper | print) /* X */,
+      ctype_base::mask(alpha | upper | print) /* Y */,
+      ctype_base::mask(alpha | upper | print) /* Z */,
+      ctype_base::mask(punct | print) /* [ */,
+      ctype_base::mask(punct | print) /* \ */,
+      ctype_base::mask(punct | print) /* ] */,
+      ctype_base::mask(punct | print) /* ^ */,
+      ctype_base::mask(punct | print) /* _ */,
+      ctype_base::mask(punct | print) /* ` */,
+      ctype_base::mask(alpha | lower | xdigit | print) /* a */,
+      ctype_base::mask(alpha | lower | xdigit | print) /* b */,
+      ctype_base::mask(alpha | lower | xdigit | print) /* c */,
+      ctype_base::mask(alpha | lower | xdigit | print) /* d */,
+      ctype_base::mask(alpha | lower | xdigit | print) /* e */,
+      ctype_base::mask(alpha | lower | xdigit | print) /* f */,
+      ctype_base::mask(alpha | lower | print) /* g */,
+      ctype_base::mask(alpha | lower | print) /* h */,
+      ctype_base::mask(alpha | lower | print) /* i */,
+      ctype_base::mask(alpha | lower | print) /* j */,
+      ctype_base::mask(alpha | lower | print) /* k */,
+      ctype_base::mask(alpha | lower | print) /* l */,
+      ctype_base::mask(alpha | lower | print) /* m */,
+      ctype_base::mask(alpha | lower | print) /* n */,
+      ctype_base::mask(alpha | lower | print) /* o */,
+      ctype_base::mask(alpha | lower | print) /* p */,
+      ctype_base::mask(alpha | lower | print) /* q */,
+      ctype_base::mask(alpha | lower | print) /* r */,
+      ctype_base::mask(alpha | lower | print) /* s */,
+      ctype_base::mask(alpha | lower | print) /* t */,
+      ctype_base::mask(alpha | lower | print) /* u */,
+      ctype_base::mask(alpha | lower | print) /* v */,
+      ctype_base::mask(alpha | lower | print) /* w */,
+      ctype_base::mask(alpha | lower | print) /* x */,
+      ctype_base::mask(alpha | lower | print) /* y */,
+      ctype_base::mask(alpha | lower | print) /* x */,
+      ctype_base::mask(punct | print) /* { */,
+      ctype_base::mask(punct | print) /* | */,
+      ctype_base::mask(punct | print) /* } */,
+      ctype_base::mask(punct | print) /* ~ */,
+      cntrl /* del (0x7f)*/,
+      /* The next 128 entries are all 0.   */
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+    };
+    return _S_classic_table;
+  }
+
+  ctype<char>::ctype(__c_locale, const mask* __table, bool __del,
+		     size_t __refs)
+  : facet(__refs), _M_del(__table != 0 && __del),
+  _M_toupper(NULL), _M_tolower(NULL),
+  _M_table(__table ? __table : classic_table())
+  {
+    memset(_M_widen, 0, sizeof(_M_widen));
+    _M_widen_ok = 0;
+    memset(_M_narrow, 0, sizeof(_M_narrow));
+    _M_narrow_ok = 0;
+  }
+
+  ctype<char>::ctype(const mask* __table, bool __del, size_t __refs)
+  : facet(__refs), _M_del(__table != 0 && __del),
+  _M_toupper(NULL), _M_tolower(NULL),
+  _M_table(__table ? __table : classic_table())
+  {
+    memset(_M_widen, 0, sizeof(_M_widen));
+    _M_widen_ok = 0;
+    memset(_M_narrow, 0, sizeof(_M_narrow));
+    _M_narrow_ok = 0;
+  }
+
+  char
+  ctype<char>::do_toupper(char __c) const
+  { return (this->is(ctype_base::lower, __c) ? (__c - 'a' + 'A') : __c); }
+
+  const char*
+  ctype<char>::do_toupper(char* __low, const char* __high) const
+  {
+    while (__low < __high)
+      {
+	*__low = this->do_toupper(*__low);
+	++__low;
+      }
+    return __high;
+  }
+
+  char
+  ctype<char>::do_tolower(char __c) const
+  { return (this->is(ctype_base::upper, __c) ? (__c - 'A' + 'a') : __c); }
+
+  const char*
+  ctype<char>::do_tolower(char* __low, const char* __high) const
+  {
+    while (__low < __high)
+      {
+	*__low = this->do_tolower(*__low);
+	++__low;
+      }
+    return __high;
+  }
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
diff --git a/libstdc++-v3/config/os/mint/ctype_inline.h b/libstdc++-v3/config/os/mint/ctype_inline.h
new file mode 100644
index 00000000000..b2d7b9861bf
--- /dev/null
+++ b/libstdc++-v3/config/os/mint/ctype_inline.h
@@ -0,0 +1,75 @@
+// Locale support -*- C++ -*-
+
+// Copyright (C) 2000-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/ctype_inline.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{locale}
+ */
+
+//
+// ISO C++ 14882: 22.1  Locales
+//
+
+// ctype bits to be inlined go here. Non-inlinable (ie virtual do_*)
+// functions go in ctype.cc
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  bool
+  ctype<char>::
+  is(mask __m, char __c) const
+  { return (_M_table[static_cast<unsigned char>(__c) ] & __m); }
+
+
+  const char*
+  ctype<char>::
+  is(const char* __low, const char* __high, mask* __vec) const
+  {
+    while (__low < __high)
+      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
+    return __high;
+  }
+
+  const char*
+  ctype<char>::
+  scan_is(mask __m, const char* __low, const char* __high) const
+  {
+    while (__low < __high && !this->is(__m, *__low))
+      ++__low;
+    return __low;
+  }
+
+  const char*
+  ctype<char>::
+  scan_not(mask __m, const char* __low, const char* __high) const
+  {
+    while (__low < __high && this->is(__m, *__low) != 0)
+      ++__low;
+    return __low;
+  }
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
diff --git a/libstdc++-v3/config/os/mint/os_defines.h b/libstdc++-v3/config/os/mint/os_defines.h
new file mode 100644
index 00000000000..cf72499370a
--- /dev/null
+++ b/libstdc++-v3/config/os/mint/os_defines.h
@@ -0,0 +1,36 @@
+// Specific definitions for generic platforms  -*- C++ -*-
+
+// Copyright (C) 2000-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/os_defines.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{iosfwd}
+ */
+
+#ifndef _GLIBCXX_OS_DEFINES
+#define _GLIBCXX_OS_DEFINES 1
+
+// System-specific #define, typedefs, corrections, etc, go here.  This
+// file will come before all others.
+
+#endif
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index 819a1d82876..8541269f375 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -6226,7 +6226,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -6574,6 +6574,12 @@ else
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
+  mint*)
+    # On MiNT this test can take minutes to run, and I'm not sure it's
+    # healthy for this platform. Let's restrict it to 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
   amigaos*)
     # On AmigaOS with pdksh, this test takes hours, literally.
     # So we just punt and use a minimum line length of 8192.
@@ -9926,7 +9932,7 @@ _LT_EOF
       fi
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
       # as there is no search path for DLLs.
       hardcode_libdir_flag_spec='-L$libdir'
@@ -10363,7 +10369,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
       export_dynamic_flag_spec=-rdynamic
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # When not using gcc, we currently assume that we are using
       # Microsoft Visual C++.
       # hardcode_libdir_flag_spec is actually meaningless, as there is
@@ -11314,14 +11320,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -11345,7 +11351,7 @@ cygwin* | mingw* | pw32* | cegcc*)
 
       sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -11993,7 +11999,7 @@ else
     lt_cv_dlopen_self=yes
     ;;
 
-  mingw* | pw32* | cegcc*)
+  mingw* | msys* | pw32* | cegcc*)
     lt_cv_dlopen="LoadLibrary"
     lt_cv_dlopen_libs=
     ;;
@@ -12882,7 +12888,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -13241,7 +13247,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
         esac
         ;;
 
-      cygwin* | mingw* | pw32* | cegcc*)
+      cygwin* | mingw* | msys* | pw32* | cegcc*)
         # _LT_TAGVAR(hardcode_libdir_flag_spec, CXX) is actually meaningless,
         # as there is no search path for DLLs.
         hardcode_libdir_flag_spec_CXX='-L$libdir'
@@ -15066,14 +15072,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -15096,7 +15102,7 @@ cygwin* | mingw* | pw32* | cegcc*)
       soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
 
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -15718,7 +15724,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
 case $host in
-  *-cygwin* | *-mingw*)
+  *-cygwin* | *-mingw* | *-msys*)
     # 'host' will be top-level target in the case of a target lib,
     # we must compare to with_cross_host to decide if this is a native
     # or cross-compiler and select where to install dlls appropriately.
@@ -19572,7 +19578,7 @@ $as_echo "$enable_vtable_verify" >&6; }
   vtv_cygmin=no
   if test $enable_vtable_verify = yes; then
     case ${target_os} in
-      cygwin*|mingw32*)
+      cygwin*|mingw*)
         VTV_CXXFLAGS="-fvtable-verify=std -Wl,-lvtv,-u_vtable_map_vars_start,-u_vtable_map_vars_end"
         VTV_CXXLINKFLAGS="-L${toplevel_builddir}/libvtv/.libs -Wl,--rpath -Wl,${toplevel_builddir}/libvtv/.libs"
         vtv_cygmin=yes
@@ -22822,7 +22828,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -26453,7 +26459,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by GCC" >&5
 $as_echo_n "checking for ld used by GCC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -38856,7 +38862,7 @@ $as_echo "#define HAVE_TLS 1" >>confdefs.h
 
   fi
     ;;
-  *-linux* | *-uclinux* | *-gnu* | *-kfreebsd*-gnu | *-cygwin* | *-solaris*)
+  *-linux* | *-uclinux* | *-gnu* | *-kfreebsd*-gnu | *-cygwin* | *-solaris* | *-mint*)
 
   # All these tests are for C++; save the language and the compiler flags.
   # The CXXFLAGS thing is suspicious, but based on similar bits previously
@@ -42353,7 +42359,7 @@ done
 
 
     ;;
-  *-mingw32*)
+  *-mingw*)
 
   # If we're not using GNU ld, then there's no point in even trying these
   # tests.  Check for that first.  We should have already tested for gld
diff --git a/libstdc++-v3/configure.host b/libstdc++-v3/configure.host
index 253e5a9ad0d..608a6a7adf3 100644
--- a/libstdc++-v3/configure.host
+++ b/libstdc++-v3/configure.host
@@ -293,6 +293,10 @@ case "${host_os}" in
     esac
     OPT_LDFLAGS="${OPT_LDFLAGS} \$(lt_host_flags)"
     ;;
+  mint*)
+    SECTION_FLAGS="${SECTION_FLAGS} -D_GNU_SOURCE"
+    os_include_dir="os/mint"
+    ;;
   netbsd*)
     os_include_dir="os/bsd/netbsd"
     ;;
diff --git a/libstdc++-v3/crossconfig.m4 b/libstdc++-v3/crossconfig.m4
index b3269cb88e0..34a88662c10 100644
--- a/libstdc++-v3/crossconfig.m4
+++ b/libstdc++-v3/crossconfig.m4
@@ -174,7 +174,7 @@ case "${host}" in
 
     GCC_CHECK_TLS
     ;;
-  *-linux* | *-uclinux* | *-gnu* | *-kfreebsd*-gnu | *-cygwin* | *-solaris*)
+  *-linux* | *-uclinux* | *-gnu* | *-kfreebsd*-gnu | *-cygwin* | *-solaris* | *-mint*)
     GLIBCXX_CHECK_COMPILER_FEATURES
     GLIBCXX_CHECK_LINKER_FEATURES
     GLIBCXX_CHECK_MATH_SUPPORT
@@ -190,7 +190,7 @@ case "${host}" in
     AC_CHECK_FUNCS(secure_getenv)
     AM_ICONV
     ;;
-  *-mingw32*)
+  *-mingw*)
     GLIBCXX_CHECK_LINKER_FEATURES
     GLIBCXX_CHECK_MATH_SUPPORT
     GLIBCXX_CHECK_STDLIB_SUPPORT
diff --git a/libstdc++-v3/include/bits/basic_string.h b/libstdc++-v3/include/bits/basic_string.h
index c90bd099b63..e4c1d3c57e7 100644
--- a/libstdc++-v3/include/bits/basic_string.h
+++ b/libstdc++-v3/include/bits/basic_string.h
@@ -4426,13 +4426,13 @@ _GLIBCXX_END_NAMESPACE_CXX11
 
   template<>
     basic_istream<char>&
-    getline(basic_istream<char>& __in, basic_string<char>& __str,
+    getline(basic_istream<char>& ___in, basic_string<char>& __str,
 	    char __delim);
 
 #ifdef _GLIBCXX_USE_WCHAR_T
   template<>
     basic_istream<wchar_t>&
-    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
+    getline(basic_istream<wchar_t>& ___in, basic_string<wchar_t>& __str,
 	    wchar_t __delim);
 #endif
 
diff --git a/libstdc++-v3/include/bits/basic_string.tcc b/libstdc++-v3/include/bits/basic_string.tcc
index bca55bc5658..fdb098f81d7 100644
--- a/libstdc++-v3/include/bits/basic_string.tcc
+++ b/libstdc++-v3/include/bits/basic_string.tcc
@@ -863,7 +863,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   // 21.3.7.9 basic_string::getline and operators
   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_istream<_CharT, _Traits>&
-    operator>>(basic_istream<_CharT, _Traits>& __in,
+    operator>>(basic_istream<_CharT, _Traits>& ___in,
 	       basic_string<_CharT, _Traits, _Alloc>& __str)
     {
       typedef basic_istream<_CharT, _Traits>		__istream_type;
@@ -876,7 +876,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
       __size_type __extracted = 0;
       typename __ios_base::iostate __err = __ios_base::goodbit;
-      typename __istream_type::sentry __cerb(__in, false);
+      typename __istream_type::sentry __cerb(___in, false);
       if (__cerb)
 	{
 	  __try
@@ -885,12 +885,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	      __str.erase();
 	      _CharT __buf[128];
 	      __size_type __len = 0;	      
-	      const streamsize __w = __in.width();
+	      const streamsize __w = ___in.width();
 	      const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
 		                              : __str.max_size();
-	      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
+	      const __ctype_type& __ct = use_facet<__ctype_type>(___in.getloc());
 	      const __int_type __eof = _Traits::eof();
-	      __int_type __c = __in.rdbuf()->sgetc();
+	      __int_type __c = ___in.rdbuf()->sgetc();
 
 	      while (__extracted < __n
 		     && !_Traits::eq_int_type(__c, __eof)
@@ -904,17 +904,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 		    }
 		  __buf[__len++] = _Traits::to_char_type(__c);
 		  ++__extracted;
-		  __c = __in.rdbuf()->snextc();
+		  __c = ___in.rdbuf()->snextc();
 		}
 	      __str.append(__buf, __len);
 
 	      if (__extracted < __n && _Traits::eq_int_type(__c, __eof))
 		__err |= __ios_base::eofbit;
-	      __in.width(0);
+	      ___in.width(0);
 	    }
 	  __catch(__cxxabiv1::__forced_unwind&)
 	    {
-	      __in._M_setstate(__ios_base::badbit);
+	      ___in._M_setstate(__ios_base::badbit);
 	      __throw_exception_again;
 	    }
 	  __catch(...)
@@ -922,20 +922,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
 	      // 91. Description of operator>> and getline() for string<>
 	      // might cause endless loop
-	      __in._M_setstate(__ios_base::badbit);
+	      ___in._M_setstate(__ios_base::badbit);
 	    }
 	}
       // 211.  operator>>(istream&, string&) doesn't set failbit
       if (!__extracted)
 	__err |= __ios_base::failbit;
       if (__err)
-	__in.setstate(__err);
-      return __in;
+	___in.setstate(__err);
+      return ___in;
     }
 
   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_istream<_CharT, _Traits>&
-    getline(basic_istream<_CharT, _Traits>& __in,
+    getline(basic_istream<_CharT, _Traits>& ___in,
 	    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
     {
       typedef basic_istream<_CharT, _Traits>		__istream_type;
@@ -947,7 +947,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __size_type __extracted = 0;
       const __size_type __n = __str.max_size();
       typename __ios_base::iostate __err = __ios_base::goodbit;
-      typename __istream_type::sentry __cerb(__in, true);
+      typename __istream_type::sentry __cerb(___in, true);
       if (__cerb)
 	{
 	  __try
@@ -955,7 +955,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	      __str.erase();
 	      const __int_type __idelim = _Traits::to_int_type(__delim);
 	      const __int_type __eof = _Traits::eof();
-	      __int_type __c = __in.rdbuf()->sgetc();
+	      __int_type __c = ___in.rdbuf()->sgetc();
 
 	      while (__extracted < __n
 		     && !_Traits::eq_int_type(__c, __eof)
@@ -963,7 +963,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 		{
 		  __str += _Traits::to_char_type(__c);
 		  ++__extracted;
-		  __c = __in.rdbuf()->snextc();
+		  __c = ___in.rdbuf()->snextc();
 		}
 
 	      if (_Traits::eq_int_type(__c, __eof))
@@ -971,14 +971,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	      else if (_Traits::eq_int_type(__c, __idelim))
 		{
 		  ++__extracted;		  
-		  __in.rdbuf()->sbumpc();
+		  ___in.rdbuf()->sbumpc();
 		}
 	      else
 		__err |= __ios_base::failbit;
 	    }
 	  __catch(__cxxabiv1::__forced_unwind&)
 	    {
-	      __in._M_setstate(__ios_base::badbit);
+	      ___in._M_setstate(__ios_base::badbit);
 	      __throw_exception_again;
 	    }
 	  __catch(...)
@@ -986,14 +986,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
 	      // 91. Description of operator>> and getline() for string<>
 	      // might cause endless loop
-	      __in._M_setstate(__ios_base::badbit);
+	      ___in._M_setstate(__ios_base::badbit);
 	    }
 	}
       if (!__extracted)
 	__err |= __ios_base::failbit;
       if (__err)
-	__in.setstate(__err);
-      return __in;
+	___in.setstate(__err);
+      return ___in;
     }
 
   // Inhibit implicit instantiations for required instantiations,
diff --git a/libstdc++-v3/include/bits/chrono_io.h b/libstdc++-v3/include/bits/chrono_io.h
index b83edc44ea9..1ca044c8a83 100644
--- a/libstdc++-v3/include/bits/chrono_io.h
+++ b/libstdc++-v3/include/bits/chrono_io.h
@@ -105,15 +105,15 @@ namespace __detail
 
   template<typename _Period, typename _CharT, typename _Out>
     inline _Out
-    __fmt_units_suffix(_Out __out) noexcept
+    __fmt_units_suffix(_Out ___out) noexcept
     {
       if (auto __s = __detail::__units_suffix<_Period, _CharT>(); __s.size())
-	return __format::__write(std::move(__out), __s);
+	return __format::__write(std::move(___out), __s);
       else if constexpr (_Period::den == 1)
-	return std::format_to(std::move(__out), _GLIBCXX_WIDEN("[{}]s"),
+	return std::format_to(std::move(___out), _GLIBCXX_WIDEN("[{}]s"),
 			      (uintmax_t)_Period::num);
       else
-	return std::format_to(std::move(__out), _GLIBCXX_WIDEN("[{}/{}]s"),
+	return std::format_to(std::move(___out), _GLIBCXX_WIDEN("[{}/{}]s"),
 			      (uintmax_t)_Period::num,
 			      (uintmax_t)_Period::den);
     }
@@ -526,7 +526,7 @@ namespace __format
 		}
 #endif
 
-	  _Sink_iter<_CharT> __out;
+	  _Sink_iter<_CharT> ___out;
 	  __format::_Str_sink<_CharT> __sink;
 	  bool __write_direct = false;
 	  if constexpr (is_same_v<typename _FormatContext::iterator,
@@ -534,29 +534,29 @@ namespace __format
 	    {
 	      if (_M_spec._M_width_kind == __format::_WP_none)
 		{
-		  __out = __fc.out();
+		  ___out = __fc.out();
 		  __write_direct = true;
 		}
 	      else
-		__out = __sink.out();
+		___out = __sink.out();
 	    }
 	  else
-	    __out = __sink.out();
+	    ___out = __sink.out();
 
 	  // formatter<duration> passes the correct value of __is_neg
 	  // for durations but for hh_mm_ss we decide it here.
 	  if constexpr (__is_specialization_of<_Tp, chrono::hh_mm_ss>)
 	    __is_neg = __t.is_negative();
 
-	  auto __print_sign = [&__is_neg, &__out] {
+	  auto __print_sign = [&__is_neg, &___out] {
 	    if constexpr (chrono::__is_duration_v<_Tp>
 			    || __is_specialization_of<_Tp, chrono::hh_mm_ss>)
 	      if (__is_neg)
 		{
-		  *__out++ = _S_plus_minus[1];
+		  *___out++ = _S_plus_minus[1];
 		  __is_neg = false;
 		}
-	    return std::move(__out);
+	    return std::move(___out);
 	  };
 
 	  // Characters to output for "%n", "%t" and "%%" specifiers.
@@ -572,63 +572,63 @@ namespace __format
 		{
 		case 'a':
 		case 'A':
-		  __out = _M_a_A(__t, std::move(__out), __fc, __c == 'A');
+		  ___out = _M_a_A(__t, std::move(___out), __fc, __c == 'A');
 		  break;
 		case 'b':
 		case 'h':
 		case 'B':
-		  __out = _M_b_B(__t, std::move(__out), __fc, __c == 'B');
+		  ___out = _M_b_B(__t, std::move(___out), __fc, __c == 'B');
 		  break;
 		case 'c':
 		case 'r':
 		case 'x':
 		case 'X':
-		  __out = _M_c_r_x_X(__t, std::move(__out), __fc, __c, __mod);
+		  ___out = _M_c_r_x_X(__t, std::move(___out), __fc, __c, __mod);
 		  break;
 		case 'C':
 		case 'y':
 		case 'Y':
-		  __out = _M_C_y_Y(__t, std::move(__out), __fc, __c, __mod);
+		  ___out = _M_C_y_Y(__t, std::move(___out), __fc, __c, __mod);
 		  break;
 		case 'd':
 		case 'e':
-		  __out = _M_d_e(__t, std::move(__out), __fc, __c, __mod == 'O');
+		  ___out = _M_d_e(__t, std::move(___out), __fc, __c, __mod == 'O');
 		  break;
 		case 'D':
-		  __out = _M_D(__t, std::move(__out), __fc);
+		  ___out = _M_D(__t, std::move(___out), __fc);
 		  break;
 		case 'F':
-		  __out = _M_F(__t, std::move(__out), __fc);
+		  ___out = _M_F(__t, std::move(___out), __fc);
 		  break;
 		case 'g':
 		case 'G':
-		  __out = _M_g_G(__t, std::move(__out), __fc, __c == 'G');
+		  ___out = _M_g_G(__t, std::move(___out), __fc, __c == 'G');
 		  break;
 		case 'H':
 		case 'I':
-		  __out = _M_H_I(__t, __print_sign(), __fc, __c, __mod == 'O');
+		  ___out = _M_H_I(__t, __print_sign(), __fc, __c, __mod == 'O');
 		  break;
 		case 'j':
-		  __out = _M_j(__t, __print_sign(), __fc);
+		  ___out = _M_j(__t, __print_sign(), __fc);
 		  break;
 		case 'm':
-		  __out = _M_m(__t, std::move(__out), __fc, __mod == 'O');
+		  ___out = _M_m(__t, std::move(___out), __fc, __mod == 'O');
 		  break;
 		case 'M':
-		  __out = _M_M(__t, __print_sign(), __fc, __mod == 'O');
+		  ___out = _M_M(__t, __print_sign(), __fc, __mod == 'O');
 		  break;
 		case 'p':
-		  __out = _M_p(__t, std::move(__out), __fc);
+		  ___out = _M_p(__t, std::move(___out), __fc);
 		  break;
 		case 'q':
-		  __out = _M_q(__t, std::move(__out), __fc);
+		  ___out = _M_q(__t, std::move(___out), __fc);
 		  break;
 		case 'Q':
 		  // %Q The duration's numeric value.
 		  if constexpr (chrono::__is_duration_v<_Tp>)
 		    // _GLIBCXX_RESOLVE_LIB_DEFECTS
 		    // 4118. How should duration formatters format custom rep?
-		    __out = std::format_to(__print_sign(), _S_empty_spec,
+		    ___out = std::format_to(__print_sign(), _S_empty_spec,
 					   +__t.count());
 		  else
 		    __throw_format_error("chrono format error: argument is "
@@ -636,35 +636,35 @@ namespace __format
 		  break;
 		case 'R':
 		case 'T':
-		  __out = _M_R_T(__t, __print_sign(), __fc, __c == 'T');
+		  ___out = _M_R_T(__t, __print_sign(), __fc, __c == 'T');
 		  break;
 		case 'S':
-		  __out = _M_S(__t, __print_sign(), __fc, __mod == 'O');
+		  ___out = _M_S(__t, __print_sign(), __fc, __mod == 'O');
 		  break;
 		case 'u':
 		case 'w':
-		  __out = _M_u_w(__t, std::move(__out), __fc, __c, __mod == 'O');
+		  ___out = _M_u_w(__t, std::move(___out), __fc, __c, __mod == 'O');
 		  break;
 		case 'U':
 		case 'V':
 		case 'W':
-		  __out = _M_U_V_W(__t, std::move(__out), __fc, __c,
+		  ___out = _M_U_V_W(__t, std::move(___out), __fc, __c,
 				   __mod == 'O');
 		  break;
 		case 'z':
-		  __out = _M_z(__t, std::move(__out), __fc, (bool)__mod);
+		  ___out = _M_z(__t, std::move(___out), __fc, (bool)__mod);
 		  break;
 		case 'Z':
-		  __out = _M_Z(__t, std::move(__out), __fc);
+		  ___out = _M_Z(__t, std::move(___out), __fc);
 		  break;
 		case 'n':
-		  *__out++ = __literals[0];
+		  *___out++ = __literals[0];
 		  break;
 		case 't':
-		  *__out++ = __literals[1];
+		  *___out++ = __literals[1];
 		  break;
 		case '%':
-		  *__out++ = __literals[2];
+		  *___out++ = __literals[2];
 		  break;
 		case 'O':
 		case 'E':
@@ -689,7 +689,7 @@ namespace __format
 		      __str.remove_suffix(__str.length() - __pos);
 		      __first += __pos + 1;
 		    }
-		  __out = __format::__write(std::move(__out), __str);
+		  ___out = __format::__write(std::move(___out), __str);
 		}
 	    }
 	  while (__first != __last);
@@ -697,7 +697,7 @@ namespace __format
 	  if constexpr (is_same_v<typename _FormatContext::iterator,
 				  _Sink_iter<_CharT>>)
 	    if (__write_direct)
-	      return __out;
+	      return ___out;
 
 	  auto __span = __sink.view();
 	  __string_view __str(__span.data(), __span.size());
@@ -810,7 +810,7 @@ namespace __format
 
       template<typename _OutIter>
 	_OutIter
-	_M_write(_OutIter __out, const locale& __loc, __string_view __s) const
+	_M_write(_OutIter ___out, const locale& __loc, __string_view __s) const
 	{
 #if defined _GLIBCXX_USE_NL_LANGINFO_L && __CHAR_BIT__ == 8
 	  __sso_string __buf;
@@ -828,12 +828,12 @@ namespace __format
 		  __s = __locale_encoding_to_utf8(__loc, __s, &__buf);
 		}
 #endif
-	  return __format::__write(std::move(__out), __s);
+	  return __format::__write(std::move(___out), __s);
 	}
 
       template<typename _Tp, typename _FormatContext>
 	typename _FormatContext::iterator
-	_M_a_A(const _Tp& __t, typename _FormatContext::iterator __out,
+	_M_a_A(const _Tp& __t, typename _FormatContext::iterator ___out,
 	       _FormatContext& __ctx, bool __full) const
 	{
 	  // %a Locale's abbreviated weekday name.
@@ -850,12 +850,12 @@ namespace __format
 	  else
 	    __tp._M_days_abbreviated(__days);
 	  __string_view __str(__days[__wd.c_encoding()]);
-	  return _M_write(std::move(__out), __loc, __str);
+	  return _M_write(std::move(___out), __loc, __str);
 	}
 
       template<typename _Tp, typename _FormatContext>
 	typename _FormatContext::iterator
-	_M_b_B(const _Tp& __t, typename _FormatContext::iterator __out,
+	_M_b_B(const _Tp& __t, typename _FormatContext::iterator ___out,
 	       _FormatContext& __ctx, bool __full) const
 	{
 	  // %b Locale's abbreviated month name.
@@ -871,12 +871,12 @@ namespace __format
 	  else
 	    __tp._M_months_abbreviated(__months);
 	  __string_view __str(__months[(unsigned)__m - 1]);
-	  return _M_write(std::move(__out), __loc, __str);
+	  return _M_write(std::move(___out), __loc, __str);
 	}
 
       template<typename _Tp, typename _FormatContext>
 	typename _FormatContext::iterator
-	_M_c_r_x_X(const _Tp& __t, typename _FormatContext::iterator __out,
+	_M_c_r_x_X(const _Tp& __t, typename _FormatContext::iterator ___out,
 		   _FormatContext& __ctx, _CharT __conv, _CharT __mod) const
 	{
 	  // %c  Locale's date and time representation.
@@ -941,13 +941,13 @@ namespace __format
 	    __tm.tm_sec = __hms.seconds().count();
 	  }
 
-	  return _M_locale_fmt(std::move(__out), _M_locale(__ctx), __tm,
+	  return _M_locale_fmt(std::move(___out), _M_locale(__ctx), __tm,
 			       __conv, __mod);
 	}
 
       template<typename _Tp, typename _FormatContext>
 	typename _FormatContext::iterator
-	_M_C_y_Y(const _Tp& __t, typename _FormatContext::iterator __out,
+	_M_C_y_Y(const _Tp& __t, typename _FormatContext::iterator ___out,
 	       _FormatContext& __ctx, _CharT __conv, _CharT __mod = 0) const
 	{
 	  // %C  Year divided by 100 using floored division.
@@ -965,7 +965,7 @@ namespace __format
 	      {
 		struct tm __tm{};
 		__tm.tm_year = (int)__y - 1900;
-		return _M_locale_fmt(std::move(__out), __loc, __tm,
+		return _M_locale_fmt(std::move(___out), __loc, __tm,
 				     __conv, __mod);
 	      }
 
@@ -995,12 +995,12 @@ namespace __format
 	  if (__conv == 'Y' || __conv == 'y')
 	    __s += _S_two_digits(__yi % 100);
 
-	  return __format::__write(std::move(__out), __string_view(__s));
+	  return __format::__write(std::move(___out), __string_view(__s));
 	}
 
       template<typename _Tp, typename _FormatContext>
 	typename _FormatContext::iterator
-	_M_D(const _Tp& __t, typename _FormatContext::iterator __out,
+	_M_D(const _Tp& __t, typename _FormatContext::iterator ___out,
 	     _FormatContext&) const
 	{
 	  auto __ymd = _S_date(__t);
@@ -1013,12 +1013,12 @@ namespace __format
 	  __s += _S_two_digits((unsigned)__ymd.day());
 	  __s += _S_slash;
 	  __s += _S_two_digits(__builtin_abs((int)__ymd.year()) % 100);
-	  return __format::__write(std::move(__out), __string_view(__s));
+	  return __format::__write(std::move(___out), __string_view(__s));
 	}
 
       template<typename _Tp, typename _FormatContext>
 	typename _FormatContext::iterator
-	_M_d_e(const _Tp& __t, typename _FormatContext::iterator __out,
+	_M_d_e(const _Tp& __t, typename _FormatContext::iterator ___out,
 	       _FormatContext& __ctx, _CharT __conv, bool __mod = false) const
 	{
 	  // %d  The day of month as a decimal number.
@@ -1034,7 +1034,7 @@ namespace __format
 	      {
 		struct tm __tm{};
 		__tm.tm_mday = __i;
-		return _M_locale_fmt(std::move(__out), __loc, __tm,
+		return _M_locale_fmt(std::move(___out), __loc, __tm,
 				     (char)__conv, 'O');
 	      }
 
@@ -1046,12 +1046,12 @@ namespace __format
 	      __buf[1] = __sv[1];
 	      __sv = {__buf, 2};
 	    }
-	  return __format::__write(std::move(__out), __sv);
+	  return __format::__write(std::move(___out), __sv);
 	}
 
       template<typename _Tp, typename _FormatContext>
 	typename _FormatContext::iterator
-	_M_F(const _Tp& __t, typename _FormatContext::iterator __out,
+	_M_F(const _Tp& __t, typename _FormatContext::iterator ___out,
 	     _FormatContext&) const
 	{
 	  auto __ymd = _S_date(__t);
@@ -1064,12 +1064,12 @@ namespace __format
 	  __s[__s.size() - 2] = __sv[0];
 	  __s[__s.size() - 1] = __sv[1];
 	  __sv = __s;
-	  return __format::__write(std::move(__out), __sv);
+	  return __format::__write(std::move(___out), __sv);
 	}
 
       template<typename _Tp, typename _FormatContext>
 	typename _FormatContext::iterator
-	_M_g_G(const _Tp& __t, typename _FormatContext::iterator __out,
+	_M_g_G(const _Tp& __t, typename _FormatContext::iterator ___out,
 	     _FormatContext& __ctx, bool __full) const
 	{
 	  // %g last two decimal digits of the ISO week-based year.
@@ -1080,12 +1080,12 @@ namespace __format
 	  __d -= (weekday(__d) - Monday) - days(3);
 	  // ISO week-based year is the year that contains that Thursday:
 	  year __y = year_month_day(__d).year();
-	  return _M_C_y_Y(__y, std::move(__out), __ctx, "yY"[__full]);
+	  return _M_C_y_Y(__y, std::move(___out), __ctx, "yY"[__full]);
 	}
 
       template<typename _Tp, typename _FormatContext>
 	typename _FormatContext::iterator
-	_M_H_I(const _Tp& __t, typename _FormatContext::iterator __out,
+	_M_H_I(const _Tp& __t, typename _FormatContext::iterator ___out,
 	       _FormatContext& __ctx, _CharT __conv, bool __mod = false) const
 	{
 	  // %H  The hour (24-hour clock) as a decimal number.
@@ -1101,7 +1101,7 @@ namespace __format
 	      {
 		struct tm __tm{};
 		__tm.tm_hour = __i;
-		return _M_locale_fmt(std::move(__out), __loc, __tm,
+		return _M_locale_fmt(std::move(___out), __loc, __tm,
 				     (char)__conv, 'O');
 	      }
 
@@ -1112,19 +1112,19 @@ namespace __format
 	      else if (__i > 12)
 		__i -= 12;
 	    }
-	  return __format::__write(std::move(__out), _S_two_digits(__i));
+	  return __format::__write(std::move(___out), _S_two_digits(__i));
 	}
 
       template<typename _Tp, typename _FormatContext>
 	typename _FormatContext::iterator
-	_M_j(const _Tp& __t, typename _FormatContext::iterator __out,
+	_M_j(const _Tp& __t, typename _FormatContext::iterator ___out,
 	     _FormatContext&) const
 	{
 	  if constexpr (chrono::__is_duration_v<_Tp>)
 	    {
 	      // Decimal number of days, without padding.
 	      unsigned __d = chrono::duration_cast<chrono::days>(__t).count();
-	      return std::format_to(std::move(__out), _S_empty_spec, __d);
+	      return std::format_to(std::move(___out), _S_empty_spec, __d);
 	    }
 	  else
 	    {
@@ -1139,14 +1139,14 @@ namespace __format
 		__d = __day - local_days(__ymd.year()/January/0);
 	      else
 		__d = __day - sys_days(__ymd.year()/January/0);
-	      return std::format_to(std::move(__out), _GLIBCXX_WIDEN("{:03d}"),
+	      return std::format_to(std::move(___out), _GLIBCXX_WIDEN("{:03d}"),
 				    __d.count());
 	    }
 	}
 
       template<typename _Tp, typename _FormatContext>
 	typename _FormatContext::iterator
-	_M_m(const _Tp& __t, typename _FormatContext::iterator __out,
+	_M_m(const _Tp& __t, typename _FormatContext::iterator ___out,
 	     _FormatContext& __ctx, bool __mod) const
 	{
 	  // %m  month as a decimal number.
@@ -1160,16 +1160,16 @@ namespace __format
 	      {
 		struct tm __tm{};
 		__tm.tm_mon = __i - 1;
-		return _M_locale_fmt(std::move(__out), __loc, __tm,
+		return _M_locale_fmt(std::move(___out), __loc, __tm,
 				     'm', 'O');
 	      }
 
-	  return __format::__write(std::move(__out), _S_two_digits(__i));
+	  return __format::__write(std::move(___out), _S_two_digits(__i));
 	}
 
       template<typename _Tp, typename _FormatContext>
 	typename _FormatContext::iterator
-	_M_M(const _Tp& __t, typename _FormatContext::iterator __out,
+	_M_M(const _Tp& __t, typename _FormatContext::iterator ___out,
 	     _FormatContext& __ctx, bool __mod) const
 	{
 	  // %M  The minute as a decimal number.
@@ -1183,16 +1183,16 @@ namespace __format
 	      {
 		struct tm __tm{};
 		__tm.tm_min = __i;
-		return _M_locale_fmt(std::move(__out), __loc, __tm,
+		return _M_locale_fmt(std::move(___out), __loc, __tm,
 				     'M', 'O');
 	      }
 
-	  return __format::__write(std::move(__out), _S_two_digits(__i));
+	  return __format::__write(std::move(___out), _S_two_digits(__i));
 	}
 
       template<typename _Tp, typename _FormatContext>
 	typename _FormatContext::iterator
-	_M_p(const _Tp& __t, typename _FormatContext::iterator __out,
+	_M_p(const _Tp& __t, typename _FormatContext::iterator ___out,
 	     _FormatContext& __ctx) const
 	{
 	  // %p The locale's equivalent of the AM/PM designations.
@@ -1201,13 +1201,13 @@ namespace __format
 	  const auto& __tp = use_facet<__timepunct<_CharT>>(__loc);
 	  const _CharT* __ampm[2];
 	  __tp._M_am_pm(__ampm);
-	  return _M_write(std::move(__out), __loc,
+	  return _M_write(std::move(___out), __loc,
 			  __ampm[__hms.hours().count() >= 12]);
 	}
 
       template<typename _Tp, typename _FormatContext>
 	typename _FormatContext::iterator
-	_M_q(const _Tp&, typename _FormatContext::iterator __out,
+	_M_q(const _Tp&, typename _FormatContext::iterator ___out,
 	     _FormatContext&) const
 	{
 	  // %q The duration's unit suffix
@@ -1217,7 +1217,7 @@ namespace __format
 	    {
 	      namespace __d = chrono::__detail;
 	      using period = typename _Tp::period;
-	      return __d::__fmt_units_suffix<period, _CharT>(std::move(__out));
+	      return __d::__fmt_units_suffix<period, _CharT>(std::move(___out));
 	    }
 	}
 
@@ -1225,7 +1225,7 @@ namespace __format
 
       template<typename _Tp, typename _FormatContext>
 	typename _FormatContext::iterator
-	_M_R_T(const _Tp& __t, typename _FormatContext::iterator __out,
+	_M_R_T(const _Tp& __t, typename _FormatContext::iterator ___out,
 	       _FormatContext& __ctx, bool __secs) const
 	{
 	  // %R Equivalent to %H:%M
@@ -1238,18 +1238,18 @@ namespace __format
 	  __s[__s.size() - 2] = __sv[0];
 	  __s[__s.size() - 1] = __sv[1];
 	  __sv = __s;
-	  __out = __format::__write(std::move(__out), __sv);
+	  ___out = __format::__write(std::move(___out), __sv);
 	  if (__secs)
 	    {
-	      *__out++ = _S_colon;
-	      __out = _M_S(__hms, std::move(__out), __ctx);
+	      *___out++ = _S_colon;
+	      ___out = _M_S(__hms, std::move(___out), __ctx);
 	    }
-	  return __out;
+	  return ___out;
 	}
 
       template<typename _Tp, typename _FormatContext>
 	typename _FormatContext::iterator
-	_M_S(const _Tp& __t, typename _FormatContext::iterator __out,
+	_M_S(const _Tp& __t, typename _FormatContext::iterator ___out,
 	     _FormatContext& __ctx, bool __mod = false) const
 	{
 	  // %S  Seconds as a decimal number.
@@ -1264,17 +1264,17 @@ namespace __format
 		  {
 		    struct tm __tm{};
 		    __tm.tm_sec = (int)__s.count();
-		    return _M_locale_fmt(std::move(__out), __loc, __tm,
+		    return _M_locale_fmt(std::move(___out), __loc, __tm,
 					 'S', 'O');
 		  }
 
 	      // %OS formats don't include subseconds, so just format that:
-	      return __format::__write(std::move(__out),
+	      return __format::__write(std::move(___out),
 				       _S_two_digits(__s.count()));
 	    }
 
 	  if constexpr (__hms.fractional_width == 0)
-	    __out = __format::__write(std::move(__out),
+	    ___out = __format::__write(std::move(___out),
 				      _S_two_digits(__s.count()));
 	  else
 	    {
@@ -1284,7 +1284,7 @@ namespace __format
 	      if constexpr (is_floating_point_v<rep>)
 		{
 		  chrono::duration<rep> __fs = __s + __ss;
-		  __out = std::format_to(std::move(__out), __loc,
+		  ___out = std::format_to(std::move(___out), __loc,
 					 _GLIBCXX_WIDEN("{:#0{}.{}Lf}"),
 					 __fs.count(),
 					 3 + __hms.fractional_width,
@@ -1294,32 +1294,32 @@ namespace __format
 		{
 		  const auto& __np
 		    = use_facet<numpunct<_CharT>>(__loc);
-		  __out = __format::__write(std::move(__out),
+		  ___out = __format::__write(std::move(___out),
 					    _S_two_digits(__s.count()));
-		  *__out++ = __np.decimal_point();
+		  *___out++ = __np.decimal_point();
 		  if constexpr (is_integral_v<rep>)
-		    __out = std::format_to(std::move(__out),
+		    ___out = std::format_to(std::move(___out),
 					   _GLIBCXX_WIDEN("{:0{}}"),
 					   __ss.count(),
 					   __hms.fractional_width);
 		  else
 		    {
 		      auto __str = std::format(_S_empty_spec, __ss.count());
-		      __out = std::format_to(std::move(__out),
+		      ___out = std::format_to(std::move(___out),
 					     _GLIBCXX_WIDEN("{:0>{}s}"),
 					     __str,
 					     __hms.fractional_width);
 		    }
 		}
 	    }
-	  return __out;
+	  return ___out;
 	}
 
       // %t handled in _M_format
 
       template<typename _Tp, typename _FormatContext>
 	typename _FormatContext::iterator
-	_M_u_w(const _Tp& __t, typename _FormatContext::iterator __out,
+	_M_u_w(const _Tp& __t, typename _FormatContext::iterator ___out,
 	       _FormatContext& __ctx, _CharT __conv, bool __mod = false) const
 	{
 	  // %u  ISO weekday as a decimal number (1-7), where Monday is 1.
@@ -1334,19 +1334,19 @@ namespace __format
 	      {
 		struct tm __tm{};
 		__tm.tm_wday = __wd.c_encoding();
-		return _M_locale_fmt(std::move(__out), __loc, __tm,
+		return _M_locale_fmt(std::move(___out), __loc, __tm,
 				     (char)__conv, 'O');
 	      }
 
 	  unsigned __wdi = __conv == 'u' ? __wd.iso_encoding()
 					 : __wd.c_encoding();
 	  const _CharT __d = _S_digit(__wdi);
-	  return __format::__write(std::move(__out), __string_view(&__d, 1));
+	  return __format::__write(std::move(___out), __string_view(&__d, 1));
 	}
 
       template<typename _Tp, typename _FormatContext>
 	typename _FormatContext::iterator
-	_M_U_V_W(const _Tp& __t, typename _FormatContext::iterator __out,
+	_M_U_V_W(const _Tp& __t, typename _FormatContext::iterator ___out,
 		 _FormatContext& __ctx, _CharT __conv, bool __mod = false) const
 	{
 	  // %U  Week number of the year as a decimal number, from first Sunday.
@@ -1368,7 +1368,7 @@ namespace __format
 		__tm.tm_year = (int)__y - 1900;
 		__tm.tm_yday = (__d - _TDays(__y/January/1)).count();
 		__tm.tm_wday = weekday(__d).c_encoding();
-		return _M_locale_fmt(std::move(__out), __loc, __tm,
+		return _M_locale_fmt(std::move(___out), __loc, __tm,
 				     (char)__conv, 'O');
 	      }
 
@@ -1393,12 +1393,12 @@ namespace __format
 	    }
 	  auto __weeks = chrono::floor<weeks>(__d - __first);
 	  __string_view __sv = _S_two_digits(__weeks.count() + 1);
-	  return __format::__write(std::move(__out), __sv);
+	  return __format::__write(std::move(___out), __sv);
 	}
 
       template<typename _Tp, typename _FormatContext>
 	typename _FormatContext::iterator
-	_M_z(const _Tp& __t, typename _FormatContext::iterator __out,
+	_M_z(const _Tp& __t, typename _FormatContext::iterator ___out,
 	     _FormatContext&, bool __mod = false) const
 	{
 	  using ::std::chrono::__detail::__utc_leap_second;
@@ -1411,7 +1411,7 @@ namespace __format
 	    {
 	      if constexpr (is_same_v<typename _Tp::clock,
 				      chrono::system_clock>)
-		return __format::__write(std::move(__out), __utc);
+		return __format::__write(std::move(___out), __utc);
 	    }
 	  else if constexpr (__is_specialization_of<_Tp, __local_time_fmt>)
 	    {
@@ -1429,18 +1429,18 @@ namespace __format
 		      __s += _S_two_digits(__hms.minutes().count());
 		      __sv = __s;
 		    }
-		  return __format::__write(std::move(__out), __sv);
+		  return __format::__write(std::move(___out), __sv);
 		}
 	    }
 	  else if constexpr (__is_specialization_of<_Tp, __utc_leap_second>)
-	    return __format::__write(std::move(__out), __utc);
+	    return __format::__write(std::move(___out), __utc);
 
 	  __no_timezone_available();
 	}
 
       template<typename _Tp, typename _FormatContext>
 	typename _FormatContext::iterator
-	_M_Z(const _Tp& __t, typename _FormatContext::iterator __out,
+	_M_Z(const _Tp& __t, typename _FormatContext::iterator ___out,
 	     _FormatContext& __ctx) const
 	{
 	  using ::std::chrono::__detail::__utc_leap_second;
@@ -1451,7 +1451,7 @@ namespace __format
 	    {
 	      if constexpr (is_same_v<typename _Tp::clock,
 				      chrono::system_clock>)
-		return __format::__write(std::move(__out), __utc);
+		return __format::__write(std::move(___out), __utc);
 	    }
 	  else if constexpr (__is_specialization_of<_Tp, __local_time_fmt>)
 	    {
@@ -1459,7 +1459,7 @@ namespace __format
 		{
 		  string_view __sv = *__t._M_abbrev;
 		  if constexpr (is_same_v<_CharT, char>)
-		    return __format::__write(std::move(__out), __sv);
+		    return __format::__write(std::move(___out), __sv);
 		  else
 		    {
 		      // TODO use resize_and_overwrite
@@ -1467,12 +1467,12 @@ namespace __format
 		      auto& __ct = use_facet<ctype<_CharT>>(_M_locale(__ctx));
 		      __ct.widen(__sv.begin(), __sv.end(), __ws.data());
 		      __string_view __wsv = __ws;
-		      return __format::__write(std::move(__out), __wsv);
+		      return __format::__write(std::move(___out), __wsv);
 		    }
 		}
 	    }
 	  else if constexpr (__is_specialization_of<_Tp, __utc_leap_second>)
-	    return __format::__write(std::move(__out), __utc);
+	    return __format::__write(std::move(___out), __utc);
 
 	  __no_timezone_available();
 	}
@@ -1663,7 +1663,7 @@ namespace __format
       // a locale-specific representation.
       template<typename _Iter>
 	_Iter
-	_M_locale_fmt(_Iter __out, const locale& __loc, const struct tm& __tm,
+	_M_locale_fmt(_Iter ___out, const locale& __loc, const struct tm& __tm,
 		      char __fmt, char __mod) const
 	{
 	  basic_ostringstream<_CharT> __os;
@@ -1671,8 +1671,8 @@ namespace __format
 	  const auto& __tp = use_facet<time_put<_CharT>>(__loc);
 	  __tp.put(__os, __os, _S_space, &__tm, __fmt, __mod);
 	  if (__os)
-	    __out = _M_write(std::move(__out), __loc, __os.view());
-	  return __out;
+	    ___out = _M_write(std::move(___out), __loc, __os.view());
+	  return ___out;
 	}
     };
 
diff --git a/libstdc++-v3/include/bits/istream.tcc b/libstdc++-v3/include/bits/istream.tcc
index 7a5f5b0f0d8..f46aff67332 100644
--- a/libstdc++-v3/include/bits/istream.tcc
+++ b/libstdc++-v3/include/bits/istream.tcc
@@ -49,22 +49,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   template<typename _CharT, typename _Traits>
     basic_istream<_CharT, _Traits>::sentry::
-    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
+    sentry(basic_istream<_CharT, _Traits>& ___in, bool __noskip) : _M_ok(false)
     {
       ios_base::iostate __err = ios_base::goodbit;
-      if (__in.good())
+      if (___in.good())
 	{
 	  __try
 	    {
-	      if (__in.tie())
-		__in.tie()->flush();
-	      if (!__noskip && bool(__in.flags() & ios_base::skipws))
+	      if (___in.tie())
+		___in.tie()->flush();
+	      if (!__noskip && bool(___in.flags() & ios_base::skipws))
 		{
 		  const __int_type __eof = traits_type::eof();
-		  __streambuf_type* __sb = __in.rdbuf();
+		  __streambuf_type* __sb = ___in.rdbuf();
 		  __int_type __c = __sb->sgetc();
 
-		  const __ctype_type& __ct = __check_facet(__in._M_ctype);
+		  const __ctype_type& __ct = __check_facet(___in._M_ctype);
 		  while (!traits_type::eq_int_type(__c, __eof)
 			 && __ct.is(ctype_base::space,
 				    traits_type::to_char_type(__c)))
@@ -79,19 +79,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	    }
 	  __catch(__cxxabiv1::__forced_unwind&)
 	    {
-	      __in._M_setstate(ios_base::badbit);
+	      ___in._M_setstate(ios_base::badbit);
 	      __throw_exception_again;
 	    }
 	  __catch(...)
-	    { __in._M_setstate(ios_base::badbit); }
+	    { ___in._M_setstate(ios_base::badbit); }
 	}
 
-      if (__in.good() && __err == ios_base::goodbit)
+      if (___in.good() && __err == ios_base::goodbit)
 	_M_ok = true;
       else
 	{
 	  __err |= ios_base::failbit;
-	  __in.setstate(__err);
+	  ___in.setstate(__err);
 	}
     }
 
@@ -980,18 +980,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   // 27.6.1.2.3 Character extraction templates
   template<typename _CharT, typename _Traits>
     basic_istream<_CharT, _Traits>&
-    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
+    operator>>(basic_istream<_CharT, _Traits>& ___in, _CharT& __c)
     {
       typedef basic_istream<_CharT, _Traits>		__istream_type;
       typedef typename __istream_type::int_type         __int_type;
 
-      typename __istream_type::sentry __cerb(__in, false);
+      typename __istream_type::sentry __cerb(___in, false);
       if (__cerb)
 	{
 	  ios_base::iostate __err = ios_base::goodbit;
 	  __try
 	    {
-	      const __int_type __cb = __in.rdbuf()->sbumpc();
+	      const __int_type __cb = ___in.rdbuf()->sbumpc();
 	      if (!_Traits::eq_int_type(__cb, _Traits::eof()))
 		__c = _Traits::to_char_type(__cb);
 	      else
@@ -999,20 +999,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	    }
 	  __catch(__cxxabiv1::__forced_unwind&)
 	    {
-	      __in._M_setstate(ios_base::badbit);
+	      ___in._M_setstate(ios_base::badbit);
 	      __throw_exception_again;
 	    }
 	  __catch(...)
-	    { __in._M_setstate(ios_base::badbit); }
+	    { ___in._M_setstate(ios_base::badbit); }
 	  if (__err)
-	    __in.setstate(__err);
+	    ___in.setstate(__err);
 	}
-      return __in;
+      return ___in;
     }
 
   template<typename _CharT, typename _Traits>
     void
-    __istream_extract(basic_istream<_CharT, _Traits>& __in, _CharT* __s,
+    __istream_extract(basic_istream<_CharT, _Traits>& ___in, _CharT* __s,
 		      streamsize __num)
     {
       typedef basic_istream<_CharT, _Traits>		__istream_type;
@@ -1023,20 +1023,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
       streamsize __extracted = 0;
       ios_base::iostate __err = ios_base::goodbit;
-      typename __istream_type::sentry __cerb(__in, false);
+      typename __istream_type::sentry __cerb(___in, false);
       if (__cerb)
 	{
 	  __try
 	    {
 	      // Figure out how many characters to extract.
-	      streamsize __width = __in.width();
+	      streamsize __width = ___in.width();
 	      if (0 < __width && __width < __num)
 		__num = __width;
 
-	      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
+	      const __ctype_type& __ct = use_facet<__ctype_type>(___in.getloc());
 
 	      const int_type __eof = _Traits::eof();
-	      __streambuf_type* __sb = __in.rdbuf();
+	      __streambuf_type* __sb = ___in.rdbuf();
 	      int_type __c = __sb->sgetc();
 
 	      while (__extracted < __num - 1
@@ -1056,26 +1056,26 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
 	      // 68.  Extractors for char* should store null at end
 	      *__s = char_type();
-	      __in.width(0);
+	      ___in.width(0);
 	    }
 	  __catch(__cxxabiv1::__forced_unwind&)
 	    {
-	      __in._M_setstate(ios_base::badbit);
+	      ___in._M_setstate(ios_base::badbit);
 	      __throw_exception_again;
 	    }
 	  __catch(...)
-	    { __in._M_setstate(ios_base::badbit); }
+	    { ___in._M_setstate(ios_base::badbit); }
 	}
       if (!__extracted)
 	__err |= ios_base::failbit;
       if (__err)
-	__in.setstate(__err);
+	___in.setstate(__err);
     }
 
   // 27.6.1.4 Standard basic_istream manipulators
   template<typename _CharT, typename _Traits>
     basic_istream<_CharT, _Traits>&
-    ws(basic_istream<_CharT, _Traits>& __in)
+    ws(basic_istream<_CharT, _Traits>& ___in)
     {
       typedef basic_istream<_CharT, _Traits>		__istream_type;
       typedef basic_streambuf<_CharT, _Traits>          __streambuf_type;
@@ -1084,15 +1084,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 451. behavior of std::ws
-      typename __istream_type::sentry __cerb(__in, true);
+      typename __istream_type::sentry __cerb(___in, true);
       if (__cerb)
 	{
 	  ios_base::iostate __err = ios_base::goodbit;
 	  __try
 	    {
-	      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
+	      const __ctype_type& __ct = use_facet<__ctype_type>(___in.getloc());
 	      const __int_type __eof = _Traits::eof();
-	      __streambuf_type* __sb = __in.rdbuf();
+	      __streambuf_type* __sb = ___in.rdbuf();
 	      __int_type __c = __sb->sgetc();
 
 	      while (true)
@@ -1109,17 +1109,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	    }
 	  __catch (const __cxxabiv1::__forced_unwind&)
 	    {
-	      __in._M_setstate(ios_base::badbit);
+	      ___in._M_setstate(ios_base::badbit);
 	      __throw_exception_again;
 	    }
 	  __catch (...)
 	    {
-	      __in._M_setstate(ios_base::badbit);
+	      ___in._M_setstate(ios_base::badbit);
 	    }
 	  if (__err)
-	    __in.setstate(__err);
+	    ___in.setstate(__err);
 	}
-      return __in;
+      return ___in;
     }
 
   // Inhibit implicit instantiations for required instantiations,
diff --git a/libstdc++-v3/include/bits/locale_conv.h b/libstdc++-v3/include/bits/locale_conv.h
index 076e14ff762..b36a1417c1a 100644
--- a/libstdc++-v3/include/bits/locale_conv.h
+++ b/libstdc++-v3/include/bits/locale_conv.h
@@ -337,10 +337,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       {
 	if (!_M_with_cvtstate)
 	  _M_state = state_type();
-	wide_string __out{ _M_wide_err_string.get_allocator() };
-	if (__str_codecvt_in(__first, __last, __out, *_M_cvt, _M_state,
+	wide_string ___out{ _M_wide_err_string.get_allocator() };
+	if (__str_codecvt_in(__first, __last, ___out, *_M_cvt, _M_state,
 			     _M_count))
-	  return __out;
+	  return ___out;
 	if (_M_with_strings)
 	  return _M_wide_err_string;
 	__throw_range_error("wstring_convert::from_bytes");
@@ -373,10 +373,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       {
 	if (!_M_with_cvtstate)
 	  _M_state = state_type();
-	byte_string __out{ _M_byte_err_string.get_allocator() };
-	if (__str_codecvt_out(__first, __last, __out, *_M_cvt, _M_state,
+	byte_string ___out{ _M_byte_err_string.get_allocator() };
+	if (__str_codecvt_out(__first, __last, ___out, *_M_cvt, _M_state,
 			      _M_count))
-	  return __out;
+	  return ___out;
 	if (_M_with_strings)
 	  return _M_byte_err_string;
 	__throw_range_error("wstring_convert::to_bytes");
@@ -466,13 +466,13 @@ _GLIBCXX_END_NAMESPACE_CXX11
       { return _M_buf && _M_conv_put() && !_M_buf->pubsync() ? 0 : -1; }
 
       typename _Wide_streambuf::int_type
-      overflow(typename _Wide_streambuf::int_type __out)
+      overflow(typename _Wide_streambuf::int_type ___out)
       {
 	if (!_M_buf || !_M_conv_put())
 	  return _Tr::eof();
-	else if (!_Tr::eq_int_type(__out, _Tr::eof()))
-	  return this->sputc(__out);
-	return _Tr::not_eof(__out);
+	else if (!_Tr::eq_int_type(___out, _Tr::eof()))
+	  return this->sputc(___out);
+	return _Tr::not_eof(___out);
       }
 
       typename _Wide_streambuf::int_type
diff --git a/libstdc++-v3/include/bits/locale_facets.h b/libstdc++-v3/include/bits/locale_facets.h
index 54d39206fb0..5c87a21a2ea 100644
--- a/libstdc++-v3/include/bits/locale_facets.h
+++ b/libstdc++-v3/include/bits/locale_facets.h
@@ -1998,7 +1998,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
        *  except if the value is 1, sets @a v to true, if the value is 0, sets
        *  @a v to false, and otherwise set err to ios_base::failbit.
        *
-       *  @param  __in  Start of input stream.
+       *  @param  ___in  Start of input stream.
        *  @param  __end  End of input stream.
        *  @param  __io  Source of locale and flags.
        *  @param  __err  Error flags to set.
@@ -2006,9 +2006,9 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
        *  @return  Iterator after reading.
       */
       iter_type
-      get(iter_type __in, iter_type __end, ios_base& __io,
+      get(iter_type ___in, iter_type __end, ios_base& __io,
 	  ios_base::iostate& __err, bool& __v) const
-      { return this->do_get(__in, __end, __io, __err, __v); }
+      { return this->do_get(___in, __end, __io, __err, __v); }
 
       ///@{
       /**
@@ -2035,7 +2035,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
        *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.
        *  Sets err to ios_base::eofbit if the stream is emptied.
        *
-       *  @param  __in  Start of input stream.
+       *  @param  ___in  Start of input stream.
        *  @param  __end  End of input stream.
        *  @param  __io  Source of locale and flags.
        *  @param  __err  Error flags to set.
@@ -2043,37 +2043,37 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
        *  @return  Iterator after reading.
       */
       iter_type
-      get(iter_type __in, iter_type __end, ios_base& __io,
+      get(iter_type ___in, iter_type __end, ios_base& __io,
 	  ios_base::iostate& __err, long& __v) const
-      { return this->do_get(__in, __end, __io, __err, __v); }
+      { return this->do_get(___in, __end, __io, __err, __v); }
 
       iter_type
-      get(iter_type __in, iter_type __end, ios_base& __io,
+      get(iter_type ___in, iter_type __end, ios_base& __io,
 	  ios_base::iostate& __err, unsigned short& __v) const
-      { return this->do_get(__in, __end, __io, __err, __v); }
+      { return this->do_get(___in, __end, __io, __err, __v); }
 
       iter_type
-      get(iter_type __in, iter_type __end, ios_base& __io,
+      get(iter_type ___in, iter_type __end, ios_base& __io,
 	  ios_base::iostate& __err, unsigned int& __v)   const
-      { return this->do_get(__in, __end, __io, __err, __v); }
+      { return this->do_get(___in, __end, __io, __err, __v); }
 
       iter_type
-      get(iter_type __in, iter_type __end, ios_base& __io,
+      get(iter_type ___in, iter_type __end, ios_base& __io,
 	  ios_base::iostate& __err, unsigned long& __v)  const
-      { return this->do_get(__in, __end, __io, __err, __v); }
+      { return this->do_get(___in, __end, __io, __err, __v); }
 
 #ifdef _GLIBCXX_USE_LONG_LONG
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wlong-long"
       iter_type
-      get(iter_type __in, iter_type __end, ios_base& __io,
+      get(iter_type ___in, iter_type __end, ios_base& __io,
 	  ios_base::iostate& __err, long long& __v) const
-      { return this->do_get(__in, __end, __io, __err, __v); }
+      { return this->do_get(___in, __end, __io, __err, __v); }
 
       iter_type
-      get(iter_type __in, iter_type __end, ios_base& __io,
+      get(iter_type ___in, iter_type __end, ios_base& __io,
 	  ios_base::iostate& __err, unsigned long long& __v)  const
-      { return this->do_get(__in, __end, __io, __err, __v); }
+      { return this->do_get(___in, __end, __io, __err, __v); }
 #pragma GCC diagnostic pop
 #endif
       ///@}
@@ -2098,7 +2098,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
        *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.
        *  Sets err to ios_base::eofbit if the stream is emptied.
        *
-       *  @param  __in  Start of input stream.
+       *  @param  ___in  Start of input stream.
        *  @param  __end  End of input stream.
        *  @param  __io  Source of locale and flags.
        *  @param  __err  Error flags to set.
@@ -2106,19 +2106,19 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
        *  @return  Iterator after reading.
       */
       iter_type
-      get(iter_type __in, iter_type __end, ios_base& __io,
+      get(iter_type ___in, iter_type __end, ios_base& __io,
 	  ios_base::iostate& __err, float& __v) const
-      { return this->do_get(__in, __end, __io, __err, __v); }
+      { return this->do_get(___in, __end, __io, __err, __v); }
 
       iter_type
-      get(iter_type __in, iter_type __end, ios_base& __io,
+      get(iter_type ___in, iter_type __end, ios_base& __io,
 	  ios_base::iostate& __err, double& __v) const
-      { return this->do_get(__in, __end, __io, __err, __v); }
+      { return this->do_get(___in, __end, __io, __err, __v); }
 
       iter_type
-      get(iter_type __in, iter_type __end, ios_base& __io,
+      get(iter_type ___in, iter_type __end, ios_base& __io,
 	  ios_base::iostate& __err, long double& __v) const
-      { return this->do_get(__in, __end, __io, __err, __v); }
+      { return this->do_get(___in, __end, __io, __err, __v); }
       ///@}
 
       /**
@@ -2141,7 +2141,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
        *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.
        *  Sets err to ios_base::eofbit if the stream is emptied.
        *
-       *  @param  __in  Start of input stream.
+       *  @param  ___in  Start of input stream.
        *  @param  __end  End of input stream.
        *  @param  __io  Source of locale and flags.
        *  @param  __err  Error flags to set.
@@ -2149,9 +2149,9 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
        *  @return  Iterator after reading.
       */
       iter_type
-      get(iter_type __in, iter_type __end, ios_base& __io,
+      get(iter_type ___in, iter_type __end, ios_base& __io,
 	  ios_base::iostate& __err, void*& __v) const
-      { return this->do_get(__in, __end, __io, __err, __v); }
+      { return this->do_get(___in, __end, __io, __err, __v); }
 
     protected:
       /// Destructor.
diff --git a/libstdc++-v3/include/bits/ostream.h b/libstdc++-v3/include/bits/ostream.h
index d19a76ab247..c53dce92f1a 100644
--- a/libstdc++-v3/include/bits/ostream.h
+++ b/libstdc++-v3/include/bits/ostream.h
@@ -608,14 +608,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   ///@{
   /**
    *  @brief  Character inserters
-   *  @param  __out  An output stream.
+   *  @param  ___out  An output stream.
    *  @param  __c  A character.
    *  @return  out
    *
    *  Behaves like one of the formatted arithmetic inserters described in
    *  std::basic_ostream.  After constructing a sentry object with good
    *  status, this function inserts a single character and any required
-   *  padding (as determined by [22.2.2.2.2]).  @c __out.width(0) is then
+   *  padding (as determined by [22.2.2.2.2]).  @c ___out.width(0) is then
    *  called.
    *
    *  If @p __c is of type @c char and the character type of the stream is not
@@ -623,40 +623,40 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   */
   template<typename _CharT, typename _Traits>
     inline basic_ostream<_CharT, _Traits>&
-    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
+    operator<<(basic_ostream<_CharT, _Traits>& ___out, _CharT __c)
     {
-      if (__out.width() != 0)
-	return __ostream_insert(__out, &__c, 1);
-      __out.put(__c);
-      return __out;
+      if (___out.width() != 0)
+	return __ostream_insert(___out, &__c, 1);
+      ___out.put(__c);
+      return ___out;
     }
 
   template<typename _CharT, typename _Traits>
     inline basic_ostream<_CharT, _Traits>&
-    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
-    { return (__out << __out.widen(__c)); }
+    operator<<(basic_ostream<_CharT, _Traits>& ___out, char __c)
+    { return (___out << ___out.widen(__c)); }
 
   // Specialization
   template<typename _Traits>
     inline basic_ostream<char, _Traits>&
-    operator<<(basic_ostream<char, _Traits>& __out, char __c)
+    operator<<(basic_ostream<char, _Traits>& ___out, char __c)
     {
-      if (__out.width() != 0)
-	return __ostream_insert(__out, &__c, 1);
-      __out.put(__c);
-      return __out;
+      if (___out.width() != 0)
+	return __ostream_insert(___out, &__c, 1);
+      ___out.put(__c);
+      return ___out;
     }
 
   // Signed and unsigned
   template<typename _Traits>
     inline basic_ostream<char, _Traits>&
-    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
-    { return (__out << static_cast<char>(__c)); }
+    operator<<(basic_ostream<char, _Traits>& ___out, signed char __c)
+    { return (___out << static_cast<char>(__c)); }
 
   template<typename _Traits>
     inline basic_ostream<char, _Traits>&
-    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
-    { return (__out << static_cast<char>(__c)); }
+    operator<<(basic_ostream<char, _Traits>& ___out, unsigned char __c)
+    { return (___out << static_cast<char>(__c)); }
 
 #if __cplusplus > 201703L
   // The following deleted overloads prevent formatting character values as
@@ -701,7 +701,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   ///@{
   /**
    *  @brief  String inserters
-   *  @param  __out  An output stream.
+   *  @param  ___out  An output stream.
    *  @param  __s  A character string.
    *  @return  out
    *  @pre  @p __s must be a non-NULL pointer
@@ -710,47 +710,47 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  std::basic_ostream.  After constructing a sentry object with good
    *  status, this function inserts @c traits::length(__s) characters starting
    *  at @p __s, widened if necessary, followed by any required padding (as
-   *  determined by [22.2.2.2.2]).  @c __out.width(0) is then called.
+   *  determined by [22.2.2.2.2]).  @c ___out.width(0) is then called.
   */
   template<typename _CharT, typename _Traits>
     inline basic_ostream<_CharT, _Traits>&
-    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
+    operator<<(basic_ostream<_CharT, _Traits>& ___out, const _CharT* __s)
     {
       if (!__s)
-	__out.setstate(ios_base::badbit);
+	___out.setstate(ios_base::badbit);
       else
-	__ostream_insert(__out, __s,
+	__ostream_insert(___out, __s,
 			 static_cast<streamsize>(_Traits::length(__s)));
-      return __out;
+      return ___out;
     }
 
   template<typename _CharT, typename _Traits>
     basic_ostream<_CharT, _Traits> &
-    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);
+    operator<<(basic_ostream<_CharT, _Traits>& ___out, const char* __s);
 
   // Partial specializations
   template<typename _Traits>
     inline basic_ostream<char, _Traits>&
-    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
+    operator<<(basic_ostream<char, _Traits>& ___out, const char* __s)
     {
       if (!__s)
-	__out.setstate(ios_base::badbit);
+	___out.setstate(ios_base::badbit);
       else
-	__ostream_insert(__out, __s,
+	__ostream_insert(___out, __s,
 			 static_cast<streamsize>(_Traits::length(__s)));
-      return __out;
+      return ___out;
     }
 
   // Signed and unsigned
   template<typename _Traits>
     inline basic_ostream<char, _Traits>&
-    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
-    { return (__out << reinterpret_cast<const char*>(__s)); }
+    operator<<(basic_ostream<char, _Traits>& ___out, const signed char* __s)
+    { return (___out << reinterpret_cast<const char*>(__s)); }
 
   template<typename _Traits>
     inline basic_ostream<char, _Traits> &
-    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
-    { return (__out << reinterpret_cast<const char*>(__s)); }
+    operator<<(basic_ostream<char, _Traits>& ___out, const unsigned char* __s)
+    { return (___out << reinterpret_cast<const char*>(__s)); }
 
 #if __cplusplus > 201703L
    // The following deleted overloads prevent formatting strings as
diff --git a/libstdc++-v3/include/bits/ostream.tcc b/libstdc++-v3/include/bits/ostream.tcc
index a4fe9d467cd..dbb6bc79108 100644
--- a/libstdc++-v3/include/bits/ostream.tcc
+++ b/libstdc++-v3/include/bits/ostream.tcc
@@ -308,10 +308,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   template<typename _CharT, typename _Traits>
     basic_ostream<_CharT, _Traits>&
-    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
+    operator<<(basic_ostream<_CharT, _Traits>& ___out, const char* __s)
     {
       if (!__s)
-	__out.setstate(ios_base::badbit);
+	___out.setstate(ios_base::badbit);
       else
 	{
 	  // _GLIBCXX_RESOLVE_LIB_DEFECTS
@@ -329,18 +329,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
 	      _CharT *__ws = __pg.__get();
 	      for (size_t  __i = 0; __i < __clen; ++__i)
-		__ws[__i] = __out.widen(__s[__i]);
-	      __ostream_insert(__out, __ws, __clen);
+		__ws[__i] = ___out.widen(__s[__i]);
+	      __ostream_insert(___out, __ws, __clen);
 	    }
 	  __catch(__cxxabiv1::__forced_unwind&)
 	    {
-	      __out._M_setstate(ios_base::badbit);
+	      ___out._M_setstate(ios_base::badbit);
 	      __throw_exception_again;
 	    }
 	  __catch(...)
-	    { __out._M_setstate(ios_base::badbit); }
+	    { ___out._M_setstate(ios_base::badbit); }
 	}
-      return __out;
+      return ___out;
     }
 
   // Inhibit implicit instantiations for required instantiations,
diff --git a/libstdc++-v3/include/bits/ostream_insert.h b/libstdc++-v3/include/bits/ostream_insert.h
index c18fb9dabca..70f31dabbd4 100644
--- a/libstdc++-v3/include/bits/ostream_insert.h
+++ b/libstdc++-v3/include/bits/ostream_insert.h
@@ -49,31 +49,31 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   template<typename _CharT, typename _Traits>
     inline void
-    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
+    __ostream_write(basic_ostream<_CharT, _Traits>& ___out,
 		    const _CharT* __s, streamsize __n)
     {
       typedef basic_ostream<_CharT, _Traits>       __ostream_type;
       typedef typename __ostream_type::ios_base    __ios_base;
 
-      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
+      const streamsize __put = ___out.rdbuf()->sputn(__s, __n);
       if (__put != __n)
-	__out.setstate(__ios_base::badbit);
+	___out.setstate(__ios_base::badbit);
     }
 
   template<typename _CharT, typename _Traits>
     inline void
-    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
+    __ostream_fill(basic_ostream<_CharT, _Traits>& ___out, streamsize __n)
     {
       typedef basic_ostream<_CharT, _Traits>       __ostream_type;
       typedef typename __ostream_type::ios_base    __ios_base;
 
-      const _CharT __c = __out.fill();
+      const _CharT __c = ___out.fill();
       for (; __n > 0; --__n)
 	{
-	  const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
+	  const typename _Traits::int_type __put = ___out.rdbuf()->sputc(__c);
 	  if (_Traits::eq_int_type(__put, _Traits::eof()))
 	    {
-	      __out.setstate(__ios_base::badbit);
+	      ___out.setstate(__ios_base::badbit);
 	      break;
 	    }
 	}
@@ -81,43 +81,43 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   template<typename _CharT, typename _Traits>
     basic_ostream<_CharT, _Traits>&
-    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
+    __ostream_insert(basic_ostream<_CharT, _Traits>& ___out,
 		     const _CharT* __s, streamsize __n)
     {
       typedef basic_ostream<_CharT, _Traits>       __ostream_type;
       typedef typename __ostream_type::ios_base    __ios_base;
 
-      typename __ostream_type::sentry __cerb(__out);
+      typename __ostream_type::sentry __cerb(___out);
       if (__cerb)
 	{
 	  __try
 	    {
-	      const streamsize __w = __out.width();
+	      const streamsize __w = ___out.width();
 	      if (__w > __n)
 		{
-		  const bool __left = ((__out.flags()
+		  const bool __left = ((___out.flags()
 					& __ios_base::adjustfield)
 				       == __ios_base::left);
 		  if (!__left)
-		    __ostream_fill(__out, __w - __n);
-		  if (__out.good())
-		    __ostream_write(__out, __s, __n);
-		  if (__left && __out.good())
-		    __ostream_fill(__out, __w - __n);
+		    __ostream_fill(___out, __w - __n);
+		  if (___out.good())
+		    __ostream_write(___out, __s, __n);
+		  if (__left && ___out.good())
+		    __ostream_fill(___out, __w - __n);
 		}
 	      else
-		__ostream_write(__out, __s, __n);
-	      __out.width(0);
+		__ostream_write(___out, __s, __n);
+	      ___out.width(0);
 	    }
 	  __catch(__cxxabiv1::__forced_unwind&)
 	    {
-	      __out._M_setstate(__ios_base::badbit);
+	      ___out._M_setstate(__ios_base::badbit);
 	      __throw_exception_again;
 	    }
 	  __catch(...)
-	    { __out._M_setstate(__ios_base::badbit); }
+	    { ___out._M_setstate(__ios_base::badbit); }
 	}
-      return __out;
+      return ___out;
     }
 
   // Inhibit implicit instantiations for required instantiations,
diff --git a/libstdc++-v3/include/bits/ranges_algo.h b/libstdc++-v3/include/bits/ranges_algo.h
index f36e7dd5991..8da03c98cc2 100644
--- a/libstdc++-v3/include/bits/ranges_algo.h
+++ b/libstdc++-v3/include/bits/ranges_algo.h
@@ -1552,7 +1552,7 @@ namespace ranges
 	&& indirectly_copyable<_Iter, _Out>
 	&& uniform_random_bit_generator<remove_reference_t<_Gen>>
       _Out
-      operator()(_Iter __first, _Sent __last, _Out __out,
+      operator()(_Iter __first, _Sent __last, _Out ___out,
 		 iter_difference_t<_Iter> __n, _Gen&& __g) const
       {
 	if constexpr (forward_iterator<_Iter>)
@@ -1561,7 +1561,7 @@ namespace ranges
 	    // which may take linear time.
 	    auto __lasti = ranges::next(__first, __last);
 	    return _GLIBCXX_STD_A::
-	      sample(std::move(__first), std::move(__lasti), std::move(__out),
+	      sample(std::move(__first), std::move(__lasti), std::move(___out),
 		     __n, std::forward<_Gen>(__g));
 	  }
 	else
@@ -1573,7 +1573,7 @@ namespace ranges
 	    iter_difference_t<_Iter> __sample_sz = 0;
 	    while (__first != __last && __sample_sz != __n)
 	      {
-		__out[__sample_sz++] = *__first;
+		___out[__sample_sz++] = *__first;
 		++__first;
 	      }
 	    for (auto __pop_sz = __sample_sz; __first != __last;
@@ -1581,9 +1581,9 @@ namespace ranges
 	      {
 		const auto __k = __d(__g, __param_type{0, __pop_sz});
 		if (__k < __n)
-		  __out[__k] = *__first;
+		  ___out[__k] = *__first;
 	      }
-	    return __out + __sample_sz;
+	    return ___out + __sample_sz;
 	  }
       }
 
@@ -1592,11 +1592,11 @@ namespace ranges
 	&& indirectly_copyable<iterator_t<_Range>, _Out>
 	&& uniform_random_bit_generator<remove_reference_t<_Gen>>
       _Out
-      operator()(_Range&& __r, _Out __out,
+      operator()(_Range&& __r, _Out ___out,
 		 range_difference_t<_Range> __n, _Gen&& __g) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__out), __n,
+		       std::move(___out), __n,
 		       std::forward<_Gen>(__g));
       }
   };
@@ -1973,11 +1973,11 @@ namespace ranges
 				      projected<iterator_t<_Range2>, _Proj2>>
       constexpr partial_sort_copy_result<borrowed_iterator_t<_Range1>,
 					 borrowed_iterator_t<_Range2>>
-      operator()(_Range1&& __r, _Range2&& __out, _Comp __comp = {},
+      operator()(_Range1&& __r, _Range2&& ___out, _Comp __comp = {},
 		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       ranges::begin(__out), ranges::end(__out),
+		       ranges::begin(___out), ranges::end(___out),
 		       std::move(__comp),
 		       std::move(__proj1), std::move(__proj2));
       }
diff --git a/libstdc++-v3/include/bits/ranges_algobase.h b/libstdc++-v3/include/bits/ranges_algobase.h
index a08f659b3ae..2ac72811cb3 100644
--- a/libstdc++-v3/include/bits/ranges_algobase.h
+++ b/libstdc++-v3/include/bits/ranges_algobase.h
@@ -193,12 +193,12 @@ namespace __detail
   template<bool _IsMove, typename _OutIter, typename _InIter>
     [[__gnu__::__always_inline__]]
     constexpr void
-    __assign_one(_OutIter& __out, _InIter& __in)
+    __assign_one(_OutIter& ___out, _InIter& ___in)
     {
       if constexpr (_IsMove)
-	*__out = ranges::iter_move(__in);
+	*___out = ranges::iter_move(___in);
       else
-	*__out = *__in;
+	*___out = *___in;
     }
 } // namespace __detail
 
@@ -264,34 +264,34 @@ namespace __detail
       using __detail::__is_normal_iterator;
       if constexpr (__is_move_iterator<_Iter> && same_as<_Iter, _Sent>)
 	{
-	  auto [__in, __out]
+	  auto [___in, ___out]
 	    = ranges::__copy_or_move<true>(std::move(__first).base(),
 					   std::move(__last).base(),
 					   std::move(__result));
-	  return {move_iterator{std::move(__in)}, std::move(__out)};
+	  return {move_iterator{std::move(___in)}, std::move(___out)};
 	}
       else if constexpr (__is_reverse_iterator<_Iter> && same_as<_Iter, _Sent>
 			 && __is_reverse_iterator<_Out>)
 	{
-	  auto [__in,__out]
+	  auto [___in,___out]
 	    = ranges::__copy_or_move_backward<_IsMove>(std::move(__last).base(),
 						       std::move(__first).base(),
 						       std::move(__result).base());
-	  return {reverse_iterator{std::move(__in)},
-		  reverse_iterator{std::move(__out)}};
+	  return {reverse_iterator{std::move(___in)},
+		  reverse_iterator{std::move(___out)}};
 	}
       else if constexpr (__is_normal_iterator<_Iter> && same_as<_Iter, _Sent>)
 	{
-	  auto [__in,__out]
+	  auto [___in,___out]
 	    = ranges::__copy_or_move<_IsMove>(__first.base(), __last.base(),
 					      std::move(__result));
-	  return {decltype(__first){__in}, std::move(__out)};
+	  return {decltype(__first){___in}, std::move(___out)};
 	}
       else if constexpr (__is_normal_iterator<_Out>)
 	{
-	  auto [__in,__out]
+	  auto [___in,___out]
 	    = ranges::__copy_or_move<_IsMove>(std::move(__first), __last, __result.base());
-	  return {std::move(__in), decltype(__result){__out}};
+	  return {std::move(___in), decltype(__result){___out}};
 	}
       else if constexpr (sized_sentinel_for<_Sent, _Iter>)
 	{
@@ -398,28 +398,28 @@ namespace __detail
       if constexpr (__is_reverse_iterator<_Iter> && same_as<_Iter, _Sent>
 		    && __is_reverse_iterator<_Out>)
 	{
-	  auto [__in,__out]
+	  auto [___in,___out]
 	    = ranges::__copy_or_move<_IsMove>(std::move(__last).base(),
 					      std::move(__first).base(),
 					      std::move(__result).base());
-	  return {reverse_iterator{std::move(__in)},
-		  reverse_iterator{std::move(__out)}};
+	  return {reverse_iterator{std::move(___in)},
+		  reverse_iterator{std::move(___out)}};
 	}
       else if constexpr (__is_normal_iterator<_Iter> && same_as<_Iter, _Sent>)
 	{
-	  auto [__in,__out]
+	  auto [___in,___out]
 	    = ranges::__copy_or_move_backward<_IsMove>(__first.base(),
 						       __last.base(),
 						       std::move(__result));
-	  return {decltype(__first){__in}, std::move(__out)};
+	  return {decltype(__first){___in}, std::move(___out)};
 	}
       else if constexpr (__is_normal_iterator<_Out>)
 	{
-	  auto [__in,__out]
+	  auto [___in,___out]
 	    = ranges::__copy_or_move_backward<_IsMove>(std::move(__first),
 						       std::move(__last),
 						       __result.base());
-	  return {std::move(__in), decltype(__result){__out}};
+	  return {std::move(___in), decltype(__result){___out}};
 	}
       else if constexpr (sized_sentinel_for<_Sent, _Iter>)
 	{
diff --git a/libstdc++-v3/include/bits/ranges_uninitialized.h b/libstdc++-v3/include/bits/ranges_uninitialized.h
index 12a714b68aa..c81eefa5d1a 100644
--- a/libstdc++-v3/include/bits/ranges_uninitialized.h
+++ b/libstdc++-v3/include/bits/ranges_uninitialized.h
@@ -380,10 +380,10 @@ namespace ranges
 	    auto __d = __ilast - __ifirst;
 	    if (auto __d2 = __olast - __ofirst; __d2 < __d)
 	      __d = static_cast<iter_difference_t<_Iter>>(__d2);
-	    auto [__in, __out]
+	    auto [___in, ___out]
 	      = ranges::copy_n(std::make_move_iterator(std::move(__ifirst)),
 			       __d, __ofirst);
-	    return {std::move(__in).base(), __out};
+	    return {std::move(___in).base(), ___out};
 	  }
 	else
 	  {
@@ -435,10 +435,10 @@ namespace ranges
 	  {
 	    if (auto __d = __olast - __ofirst; __d < __n)
 	      __n = static_cast<iter_difference_t<_Iter>>(__d);
-	    auto [__in, __out]
+	    auto [___in, ___out]
 	      = ranges::copy_n(std::make_move_iterator(std::move(__ifirst)),
 			       __n, __ofirst);
-	    return {std::move(__in).base(), __out};
+	    return {std::move(___in).base(), ___out};
 	  }
 	else
 	  {
diff --git a/libstdc++-v3/include/bits/regex.h b/libstdc++-v3/include/bits/regex.h
index 50d8863537d..3d031fdffd7 100644
--- a/libstdc++-v3/include/bits/regex.h
+++ b/libstdc++-v3/include/bits/regex.h
@@ -2051,7 +2051,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        */
       template<typename _Out_iter>
 	_Out_iter
-	format(_Out_iter __out, const char_type* __fmt_first,
+	format(_Out_iter ___out, const char_type* __fmt_first,
 	       const char_type* __fmt_last,
 	       match_flag_type __flags = regex_constants::format_default) const;
 
@@ -2060,10 +2060,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        */
       template<typename _Out_iter, typename _St, typename _Sa>
 	_Out_iter
-	format(_Out_iter __out, const basic_string<char_type, _St, _Sa>& __fmt,
+	format(_Out_iter ___out, const basic_string<char_type, _St, _Sa>& __fmt,
 	       match_flag_type __flags = regex_constants::format_default) const
 	{
-	  return format(__out, __fmt.data(), __fmt.data() + __fmt.size(),
+	  return format(___out, __fmt.data(), __fmt.data() + __fmt.size(),
 			__flags);
 	}
 
@@ -2572,7 +2572,7 @@ _GLIBCXX_END_NAMESPACE_CXX11
   template<typename _Out_iter, typename _Bi_iter,
 	   typename _Rx_traits, typename _Ch_type>
     _Out_iter
-    __regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,
+    __regex_replace(_Out_iter ___out, _Bi_iter __first, _Bi_iter __last,
 		    const basic_regex<_Ch_type, _Rx_traits>& __e,
 		    const _Ch_type* __fmt, size_t __len,
 		    regex_constants::match_flag_type __flags);
@@ -2581,53 +2581,53 @@ _GLIBCXX_END_NAMESPACE_CXX11
   /**
    * @brief Search for a regular expression within a range for multiple times,
    and replace the matched parts through filling a format string.
-   * @param __out   [OUT] The output iterator.
+   * @param ___out   [OUT] The output iterator.
    * @param __first [IN]  The start of the string to search.
    * @param __last  [IN]  One-past-the-end of the string to search.
    * @param __e     [IN]  The regular expression to search for.
    * @param __fmt   [IN]  The format string.
    * @param __flags [IN]  Search and replace policy flags.
    *
-   * @returns __out
+   * @returns ___out
    * @throws an exception of type regex_error.
    */
   template<typename _Out_iter, typename _Bi_iter,
 	   typename _Rx_traits, typename _Ch_type,
 	   typename _St, typename _Sa>
     inline _Out_iter
-    regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,
+    regex_replace(_Out_iter ___out, _Bi_iter __first, _Bi_iter __last,
 		  const basic_regex<_Ch_type, _Rx_traits>& __e,
 		  const basic_string<_Ch_type, _St, _Sa>& __fmt,
 		  regex_constants::match_flag_type __flags
 		  = regex_constants::match_default)
     {
-      return std::__regex_replace(__out, __first, __last, __e, __fmt.c_str(),
+      return std::__regex_replace(___out, __first, __last, __e, __fmt.c_str(),
 				  __fmt.length(), __flags);
     }
 
   /**
    * @brief Search for a regular expression within a range for multiple times,
    and replace the matched parts through filling a format C-string.
-   * @param __out   [OUT] The output iterator.
+   * @param ___out   [OUT] The output iterator.
    * @param __first [IN]  The start of the string to search.
    * @param __last  [IN]  One-past-the-end of the string to search.
    * @param __e     [IN]  The regular expression to search for.
    * @param __fmt   [IN]  The format C-string.
    * @param __flags [IN]  Search and replace policy flags.
    *
-   * @returns __out
+   * @returns ___out
    * @throws an exception of type regex_error.
    */
   template<typename _Out_iter, typename _Bi_iter,
 	   typename _Rx_traits, typename _Ch_type>
     _Out_iter
-    regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,
+    regex_replace(_Out_iter ___out, _Bi_iter __first, _Bi_iter __last,
 		  const basic_regex<_Ch_type, _Rx_traits>& __e,
 		  const _Ch_type* __fmt,
 		  regex_constants::match_flag_type __flags
 		  = regex_constants::match_default)
     {
-      return std::__regex_replace(__out, __first, __last, __e, __fmt,
+      return std::__regex_replace(___out, __first, __last, __e, __fmt,
 				  char_traits<_Ch_type>::length(__fmt),
 				  __flags);
     }
diff --git a/libstdc++-v3/include/bits/regex.tcc b/libstdc++-v3/include/bits/regex.tcc
index b94fe4490f7..a33ce563b5e 100644
--- a/libstdc++-v3/include/bits/regex.tcc
+++ b/libstdc++-v3/include/bits/regex.tcc
@@ -350,7 +350,7 @@ namespace __detail
   template<typename _Out_iter>
     _Out_iter
     match_results<_Bi_iter, _Alloc>::
-    format(_Out_iter __out,
+    format(_Out_iter ___out,
 	   const match_results<_Bi_iter, _Alloc>::char_type* __fmt_first,
 	   const match_results<_Bi_iter, _Alloc>::char_type* __fmt_last,
 	   match_flag_type __flags) const
@@ -365,7 +365,7 @@ namespace __detail
 	{
 	  auto& __sub = (*this)[__idx];
 	  if (__sub.matched)
-	    __out = std::copy(__sub.first, __sub.second, __out);
+	    ___out = std::copy(__sub.first, __sub.second, ___out);
 	};
 
       if (__flags & regex_constants::format_sed)
@@ -379,7 +379,7 @@ namespace __detail
 		  if (__fctyp.is(__ctype_type::digit, *__fmt_first))
 		    __output(__traits.value(*__fmt_first, 10));
 		  else
-		    *__out++ = *__fmt_first;
+		    *___out++ = *__fmt_first;
 		  continue;
 		}
 	      if (*__fmt_first == '\\')
@@ -392,10 +392,10 @@ namespace __detail
 		  __output(0);
 		  continue;
 		}
-	      *__out++ = *__fmt_first;
+	      *___out++ = *__fmt_first;
 	    }
 	  if (__escaping)
-	    *__out++ = '\\';
+	    *___out++ = '\\';
 	}
       else
 	{
@@ -405,7 +405,7 @@ namespace __detail
 	      if (__next == __fmt_last)
 		break;
 
-	      __out = std::copy(__fmt_first, __next, __out);
+	      ___out = std::copy(__fmt_first, __next, ___out);
 
 	      auto __eat = [&](char __ch) -> bool
 		{
@@ -418,22 +418,22 @@ namespace __detail
 		};
 
 	      if (++__next == __fmt_last)
-		*__out++ = '$';
+		*___out++ = '$';
 	      else if (__eat('$'))
-		*__out++ = '$';
+		*___out++ = '$';
 	      else if (__eat('&'))
 		__output(0);
 	      else if (__eat('`'))
 		{
 		  auto& __sub = _M_prefix();
 		  if (__sub.matched)
-		    __out = std::copy(__sub.first, __sub.second, __out);
+		    ___out = std::copy(__sub.first, __sub.second, ___out);
 		}
 	      else if (__eat('\''))
 		{
 		  auto& __sub = _M_suffix();
 		  if (__sub.matched)
-		    __out = std::copy(__sub.first, __sub.second, __out);
+		    ___out = std::copy(__sub.first, __sub.second, ___out);
 		}
 	      else if (__fctyp.is(__ctype_type::digit, *__next))
 		{
@@ -448,18 +448,18 @@ namespace __detail
 		    __output(__num);
 		}
 	      else
-		*__out++ = '$';
+		*___out++ = '$';
 	      __fmt_first = __next;
 	    }
-	  __out = std::copy(__fmt_first, __fmt_last, __out);
+	  ___out = std::copy(__fmt_first, __fmt_last, ___out);
 	}
-      return __out;
+      return ___out;
     }
 
   template<typename _Out_iter, typename _Bi_iter,
 	   typename _Rx_traits, typename _Ch_type>
     _Out_iter
-    __regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,
+    __regex_replace(_Out_iter ___out, _Bi_iter __first, _Bi_iter __last,
 		    const basic_regex<_Ch_type, _Rx_traits>& __e,
 		    const _Ch_type* __fmt, size_t __len,
 		    regex_constants::match_flag_type __flags)
@@ -470,7 +470,7 @@ namespace __detail
       if (__i == __end)
 	{
 	  if (!(__flags & regex_constants::format_no_copy))
-	    __out = std::copy(__first, __last, __out);
+	    ___out = std::copy(__first, __last, ___out);
 	}
       else
 	{
@@ -478,17 +478,17 @@ namespace __detail
 	  for (; __i != __end; ++__i)
 	    {
 	      if (!(__flags & regex_constants::format_no_copy))
-		__out = std::copy(__i->prefix().first, __i->prefix().second,
-				  __out);
-	      __out = __i->format(__out, __fmt, __fmt + __len, __flags);
+		___out = std::copy(__i->prefix().first, __i->prefix().second,
+				  ___out);
+	      ___out = __i->format(___out, __fmt, __fmt + __len, __flags);
 	      __last = __i->suffix();
 	      if (__flags & regex_constants::format_first_only)
 		break;
 	    }
 	  if (!(__flags & regex_constants::format_no_copy))
-	    __out = std::copy(__last.first, __last.second, __out);
+	    ___out = std::copy(__last.first, __last.second, ___out);
 	}
-      return __out;
+      return ___out;
     }
 
   template<typename _Bi_iter,
diff --git a/libstdc++-v3/include/bits/std_thread.h b/libstdc++-v3/include/bits/std_thread.h
index b6e795ce497..f4c7f0be96a 100644
--- a/libstdc++-v3/include/bits/std_thread.h
+++ b/libstdc++-v3/include/bits/std_thread.h
@@ -122,7 +122,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
       template<class _CharT, class _Traits>
 	friend basic_ostream<_CharT, _Traits>&
-	operator<<(basic_ostream<_CharT, _Traits>& __out, id __id);
+	operator<<(basic_ostream<_CharT, _Traits>& ___out, id __id);
 
 #if __glibcxx_formatters
       friend formatter<id, char>;
diff --git a/libstdc++-v3/include/bits/stl_algo.h b/libstdc++-v3/include/bits/stl_algo.h
index 71ead103d2b..67dc53f9ad8 100644
--- a/libstdc++-v3/include/bits/stl_algo.h
+++ b/libstdc++-v3/include/bits/stl_algo.h
@@ -5805,7 +5805,7 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
            typename _Size, typename _UniformRandomBitGenerator>
     _RandomAccessIterator
     __sample(_InputIterator __first, _InputIterator __last, input_iterator_tag,
-	     _RandomAccessIterator __out, random_access_iterator_tag,
+	     _RandomAccessIterator ___out, random_access_iterator_tag,
 	     _Size __n, _UniformRandomBitGenerator&& __g)
     {
       using __distrib_type = uniform_int_distribution<_Size>;
@@ -5814,7 +5814,7 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
       _Size __sample_sz = 0;
       while (__first != __last && __sample_sz != __n)
 	{
-	  __out[__sample_sz++] = *__first;
+	  ___out[__sample_sz++] = *__first;
 	  ++__first;
 	}
       for (auto __pop_sz = __sample_sz; __first != __last;
@@ -5822,9 +5822,9 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
 	{
 	  const auto __k = __d(__g, __param_type{0, __pop_sz});
 	  if (__k < __n)
-	    __out[__k] = *__first;
+	    ___out[__k] = *__first;
 	}
-      return __out + __sample_sz;
+      return ___out + __sample_sz;
     }
 
   /// Selection sampling algorithm.
@@ -5833,7 +5833,7 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
     _OutputIterator
     __sample(_ForwardIterator __first, _ForwardIterator __last,
 	     forward_iterator_tag,
-	     _OutputIterator __out, _Cat,
+	     _OutputIterator ___out, _Cat,
 	     _Size __n, _UniformRandomBitGenerator&& __g)
     {
       using __distrib_type = uniform_int_distribution<_Size>;
@@ -5843,7 +5843,7 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
       using __uc_type = common_type_t<typename _Gen::result_type, _USize>;
 
       if (__first == __last)
-	return __out;
+	return ___out;
 
       __distrib_type __d{};
       _Size __unsampled_sz = std::distance(__first, __last);
@@ -5865,7 +5865,7 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
 	      --__unsampled_sz;
 	      if (__p.first < __n)
 		{
-		  *__out++ = *__first;
+		  *___out++ = *__first;
 		  --__n;
 		}
 
@@ -5876,7 +5876,7 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
 	      --__unsampled_sz;
 	      if (__p.second < __n)
 		{
-		  *__out++ = *__first;
+		  *___out++ = *__first;
 		  --__n;
 		}
 
@@ -5889,10 +5889,10 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
       for (; __n != 0; ++__first)
 	if (__d(__g, __param_type{0, --__unsampled_sz}) < __n)
 	  {
-	    *__out++ = *__first;
+	    *___out++ = *__first;
 	    --__n;
 	  }
-      return __out;
+      return ___out;
     }
 #endif // C++14
 
@@ -5902,7 +5902,7 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
            typename _Distance, typename _UniformRandomBitGenerator>
     _SampleIterator
     sample(_PopulationIterator __first, _PopulationIterator __last,
-	   _SampleIterator __out, _Distance __n,
+	   _SampleIterator ___out, _Distance __n,
 	   _UniformRandomBitGenerator&& __g)
     {
       using __pop_cat = typename
@@ -5921,7 +5921,7 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
 
       typename iterator_traits<_PopulationIterator>::difference_type __d = __n;
       return _GLIBCXX_STD_A::
-	__sample(__first, __last, __pop_cat{}, __out, __samp_cat{}, __d,
+	__sample(__first, __last, __pop_cat{}, ___out, __samp_cat{}, __d,
 		 std::forward<_UniformRandomBitGenerator>(__g));
     }
 #endif // __glibcxx_sample
diff --git a/libstdc++-v3/include/bits/stl_algobase.h b/libstdc++-v3/include/bits/stl_algobase.h
index 4d5662ca45b..d16d1ec720e 100644
--- a/libstdc++-v3/include/bits/stl_algobase.h
+++ b/libstdc++-v3/include/bits/stl_algobase.h
@@ -397,14 +397,14 @@ _GLIBCXX_END_NAMESPACE_CONTAINER
   template<bool _IsMove, typename _OutIter, typename _InIter>
     __attribute__((__always_inline__)) _GLIBCXX20_CONSTEXPR
     inline void
-    __assign_one(_OutIter& __out, _InIter& __in)
+    __assign_one(_OutIter& ___out, _InIter& ___in)
     {
 #if __cplusplus >= 201103L
       if constexpr (_IsMove)
-	*__out = std::move(*__in);
+	*___out = std::move(*___in);
       else
 #endif
-	*__out = *__in;
+	*___out = *___in;
     }
 
   template<bool _IsMove, typename _InIter, typename _Sent, typename _OutIter>
diff --git a/libstdc++-v3/include/bits/stl_pair.h b/libstdc++-v3/include/bits/stl_pair.h
index 8c57712b461..60dba9f07ad 100644
--- a/libstdc++-v3/include/bits/stl_pair.h
+++ b/libstdc++-v3/include/bits/stl_pair.h
@@ -106,19 +106,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   template<size_t _Int, class _Tp1, class _Tp2>
     constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
-    get(pair<_Tp1, _Tp2>& __in) noexcept;
+    get(pair<_Tp1, _Tp2>& ___in) noexcept;
 
   template<size_t _Int, class _Tp1, class _Tp2>
     constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
-    get(pair<_Tp1, _Tp2>&& __in) noexcept;
+    get(pair<_Tp1, _Tp2>&& ___in) noexcept;
 
   template<size_t _Int, class _Tp1, class _Tp2>
     constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
-    get(const pair<_Tp1, _Tp2>& __in) noexcept;
+    get(const pair<_Tp1, _Tp2>& ___in) noexcept;
 
   template<size_t _Int, class _Tp1, class _Tp2>
     constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
-    get(const pair<_Tp1, _Tp2>&& __in) noexcept;
+    get(const pair<_Tp1, _Tp2>&& ___in) noexcept;
 
   template<size_t __i, typename... _Elements>
     constexpr __tuple_element_t<__i, tuple<_Elements...>>&
@@ -1280,23 +1280,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   template<size_t _Int, class _Tp1, class _Tp2>
     constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
-    get(pair<_Tp1, _Tp2>& __in) noexcept
-    { return __pair_get<_Int>::__get(__in); }
+    get(pair<_Tp1, _Tp2>& ___in) noexcept
+    { return __pair_get<_Int>::__get(___in); }
 
   template<size_t _Int, class _Tp1, class _Tp2>
     constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
-    get(pair<_Tp1, _Tp2>&& __in) noexcept
-    { return __pair_get<_Int>::__move_get(std::move(__in)); }
+    get(pair<_Tp1, _Tp2>&& ___in) noexcept
+    { return __pair_get<_Int>::__move_get(std::move(___in)); }
 
   template<size_t _Int, class _Tp1, class _Tp2>
     constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
-    get(const pair<_Tp1, _Tp2>& __in) noexcept
-    { return __pair_get<_Int>::__const_get(__in); }
+    get(const pair<_Tp1, _Tp2>& ___in) noexcept
+    { return __pair_get<_Int>::__const_get(___in); }
 
   template<size_t _Int, class _Tp1, class _Tp2>
     constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
-    get(const pair<_Tp1, _Tp2>&& __in) noexcept
-    { return __pair_get<_Int>::__const_move_get(std::move(__in)); }
+    get(const pair<_Tp1, _Tp2>&& ___in) noexcept
+    { return __pair_get<_Int>::__const_move_get(std::move(___in)); }
 
 
 #ifdef __glibcxx_tuples_by_type // C++ >= 14
diff --git a/libstdc++-v3/include/bits/stl_uninitialized.h b/libstdc++-v3/include/bits/stl_uninitialized.h
index d90e6aaf302..e07fc534d13 100644
--- a/libstdc++-v3/include/bits/stl_uninitialized.h
+++ b/libstdc++-v3/include/bits/stl_uninitialized.h
@@ -1335,9 +1335,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	    {
 	      // Can't use memcpy. Wrap the pointer so that __relocate_a_1
 	      // resolves to the non-trivial overload above.
-	      __gnu_cxx::__normal_iterator<_Tp*, void> __out(__result);
-	      __out = std::__relocate_a_1(__first, __last, __out, __alloc);
-	      return __out.base();
+	      __gnu_cxx::__normal_iterator<_Tp*, void> ___out(__result);
+	      ___out = std::__relocate_a_1(__first, __last, ___out, __alloc);
+	      return ___out.base();
 	    }
 #endif
 	  __builtin_memcpy(__result, __first, __count * sizeof(_Tp));
diff --git a/libstdc++-v3/include/experimental/algorithm b/libstdc++-v3/include/experimental/algorithm
index 2a505b7fc2d..1d78f0edd96 100644
--- a/libstdc++-v3/include/experimental/algorithm
+++ b/libstdc++-v3/include/experimental/algorithm
@@ -63,7 +63,7 @@ inline namespace fundamentals_v2
            typename _Distance, typename _UniformRandomNumberGenerator>
     _SampleIterator
     sample(_PopulationIterator __first, _PopulationIterator __last,
-	   _SampleIterator __out, _Distance __n,
+	   _SampleIterator ___out, _Distance __n,
 	   _UniformRandomNumberGenerator&& __g)
     {
       using __pop_cat = typename
@@ -82,7 +82,7 @@ inline namespace fundamentals_v2
 
       typename iterator_traits<_PopulationIterator>::difference_type __d = __n;
       return _GLIBCXX_STD_A::
-	__sample(__first, __last, __pop_cat{}, __out, __samp_cat{}, __d,
+	__sample(__first, __last, __pop_cat{}, ___out, __samp_cat{}, __d,
 		 std::forward<_UniformRandomNumberGenerator>(__g));
     }
 
@@ -90,9 +90,9 @@ inline namespace fundamentals_v2
            typename _Distance>
     inline _SampleIterator
     sample(_PopulationIterator __first, _PopulationIterator __last,
-	   _SampleIterator __out, _Distance __n)
+	   _SampleIterator ___out, _Distance __n)
     {
-      return experimental::sample(__first, __last, __out, __n,
+      return experimental::sample(__first, __last, ___out, __n,
 				  _S_randint_engine());
     }
 
diff --git a/libstdc++-v3/include/experimental/bits/simd.h b/libstdc++-v3/include/experimental/bits/simd.h
index f0cb101aaa8..aa59d935ace 100644
--- a/libstdc++-v3/include/experimental/bits/simd.h
+++ b/libstdc++-v3/include/experimental/bits/simd.h
@@ -2291,20 +2291,20 @@ template <int _Offset,
 	  typename _TVT = _VectorTraits<_Tp>,
 	  typename _R = __vector_type_t<typename _TVT::value_type, _TVT::_S_full_size / _SplitBy>>
   _GLIBCXX_SIMD_INTRINSIC constexpr _R
-  __extract(_Tp __in)
+  __extract(_Tp ___in)
   {
     using value_type = typename _TVT::value_type;
 #if _GLIBCXX_SIMD_X86INTRIN // {{{
     if constexpr (sizeof(_Tp) == 64 && _SplitBy == 4 && _Offset > 0)
       {
 	if constexpr (__have_avx512dq && is_same_v<double, value_type>)
-	  return _mm512_extractf64x2_pd(__to_intrin(__in), _Offset);
+	  return _mm512_extractf64x2_pd(__to_intrin(___in), _Offset);
 	else if constexpr (is_floating_point_v<value_type>)
 	  return __vector_bitcast<value_type>(
-	    _mm512_extractf32x4_ps(__intrin_bitcast<__m512>(__in), _Offset));
+	    _mm512_extractf32x4_ps(__intrin_bitcast<__m512>(___in), _Offset));
 	else
 	  return reinterpret_cast<_R>(
-	    _mm512_extracti32x4_epi32(__intrin_bitcast<__m512i>(__in),
+	    _mm512_extracti32x4_epi32(__intrin_bitcast<__m512i>(___in),
 				      _Offset));
       }
     else
@@ -2317,12 +2317,12 @@ template <int _Offset,
 	static_assert(sizeof(_R) % sizeof(_W) == 0);
 	constexpr int __return_width = sizeof(_R) / sizeof(_W);
 	using _Up = __vector_type_t<_W, __return_width>;
-	const auto __x = __vector_bitcast<_W>(__in);
+	const auto __x = __vector_bitcast<_W>(___in);
 #else
       constexpr int __return_width = _TVT::_S_full_size / _SplitBy;
       using _Up = _R;
       const __vector_type_t<value_type, _TVT::_S_full_size>& __x
-	= __in; // only needed for _Tp = _SimdWrapper<value_type, _Np>
+	= ___in; // only needed for _Tp = _SimdWrapper<value_type, _Np>
 #endif
 	constexpr int _O = _Offset * __return_width;
 	return __call_with_subscripts<__return_width, _O>(
diff --git a/libstdc++-v3/include/experimental/internet b/libstdc++-v3/include/experimental/internet
index f9f61f796a9..5bea55e7d81 100644
--- a/libstdc++-v3/include/experimental/internet
+++ b/libstdc++-v3/include/experimental/internet
@@ -836,9 +836,9 @@ namespace ip
     if (__p == nullptr)
       return __make_address_v6(__str, nullptr, __ec);
     char __buf[64];
-    char* __out = __buf;
+    char* ___out = __buf;
     bool __skip_leading_zero = true;
-    while (__str < __p && __out < std::end(__buf))
+    while (__str < __p && ___out < std::end(__buf))
       {
 	if (!__skip_leading_zero || *__str != '0')
 	  {
@@ -846,18 +846,18 @@ namespace ip
 	      __skip_leading_zero = true;
 	    else
 	      __skip_leading_zero = false;
-	    *__out = *__str;
+	    *___out = *__str;
 	  }
 	__str++;
       }
-    if (__out == std::end(__buf))
+    if (___out == std::end(__buf))
       {
 	__ec = std::make_error_code(std::errc::invalid_argument);
 	return {};
       }
     else
       {
-	*__out = '\0';
+	*___out = '\0';
 	return __make_address_v6(__buf, __p + 1, __ec);
       }
   }
@@ -873,10 +873,10 @@ namespace ip
     if (__pos == string::npos)
       return __make_address_v6(__str.c_str(), nullptr, __ec);
     char __buf[64];
-    char* __out = __buf;
+    char* ___out = __buf;
     bool __skip_leading_zero = true;
     size_t __n = 0;
-    while (__n < __pos && __out < std::end(__buf))
+    while (__n < __pos && ___out < std::end(__buf))
       {
 	if (!__skip_leading_zero || __str[__n] != '0')
 	  {
@@ -884,18 +884,18 @@ namespace ip
 	      __skip_leading_zero = true;
 	    else
 	      __skip_leading_zero = false;
-	    *__out = __str[__n];
+	    *___out = __str[__n];
 	  }
 	__n++;
       }
-    if (__out == std::end(__buf))
+    if (___out == std::end(__buf))
       {
 	__ec = std::make_error_code(std::errc::invalid_argument);
 	return {};
       }
     else
       {
-	*__out = '\0';
+	*___out = '\0';
 	return __make_address_v6(__buf, __str.c_str() + __pos + 1, __ec);
       }
   }
@@ -908,20 +908,20 @@ namespace ip
   make_address_v6(string_view __str, error_code& __ec) noexcept
   {
     char __buf[64];
-    char* __out = __buf;
+    char* ___out = __buf;
     char* __scope = nullptr;
     bool __skip_leading_zero = true;
     size_t __n = 0;
-    while (__n < __str.length() && __out < std::end(__buf))
+    while (__n < __str.length() && ___out < std::end(__buf))
       {
 	if (__str[__n] == '%')
 	  {
 	    if (__scope)
-	      __out = std::end(__buf);
+	      ___out = std::end(__buf);
 	    else
 	      {
-		*__out = '\0';
-		__scope = ++__out;
+		*___out = '\0';
+		__scope = ++___out;
 		__skip_leading_zero = true;
 	      }
 	  }
@@ -931,19 +931,19 @@ namespace ip
 	      __skip_leading_zero = true;
 	    else
 	      __skip_leading_zero = false;
-	    *__out = __str[__n];
-	    __out++;
+	    *___out = __str[__n];
+	    ___out++;
 	  }
 	__n++;
       }
-    if (__out == std::end(__buf))
+    if (___out == std::end(__buf))
       {
 	__ec = std::make_error_code(std::errc::invalid_argument);
 	return {};
       }
     else
       {
-	*__out = '\0';
+	*___out = '\0';
 	return __make_address_v6(__buf, __scope, __ec);
       }
   }
diff --git a/libstdc++-v3/include/ext/algorithm b/libstdc++-v3/include/ext/algorithm
index 86f3e6269f4..368d2d37681 100644
--- a/libstdc++-v3/include/ext/algorithm
+++ b/libstdc++-v3/include/ext/algorithm
@@ -262,7 +262,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	   typename _Distance>
     _OutputIterator
     random_sample_n(_ForwardIterator __first, _ForwardIterator __last,
-                    _OutputIterator __out, const _Distance __n)
+                    _OutputIterator ___out, const _Distance __n)
     {
       // concept requirements
       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
@@ -277,14 +277,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	{
 	  if ((std::rand() % __remaining) < __m)
 	    {
-	      *__out = *__first;
-	      ++__out;
+	      *___out = *__first;
+	      ++___out;
 	      --__m;
 	    }
 	  --__remaining;
 	  ++__first;
 	}
-      return __out;
+      return ___out;
     }
 
   /**
@@ -296,7 +296,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	   typename _Distance, typename _RandomNumberGenerator>
     _OutputIterator
     random_sample_n(_ForwardIterator __first, _ForwardIterator __last,
-                   _OutputIterator __out, const _Distance __n,
+                   _OutputIterator ___out, const _Distance __n,
 		   _RandomNumberGenerator& __rand)
     {
       // concept requirements
@@ -314,44 +314,44 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	{
 	  if (__rand(__remaining) < __m)
 	    {
-	      *__out = *__first;
-	      ++__out;
+	      *___out = *__first;
+	      ++___out;
 	      --__m;
 	    }
 	  --__remaining;
 	  ++__first;
 	}
-      return __out;
+      return ___out;
     }
 
   template<typename _InputIterator, typename _RandomAccessIterator,
 	   typename _Distance>
     _RandomAccessIterator
     __random_sample(_InputIterator __first, _InputIterator __last,
-		    _RandomAccessIterator __out,
+		    _RandomAccessIterator ___out,
 		    const _Distance __n)
     {
       _Distance __m = 0;
       _Distance __t = __n;
       for ( ; __first != __last && __m < __n; ++__m, ++__first)
-	__out[__m] = *__first;
+	___out[__m] = *__first;
 
       while (__first != __last)
 	{
 	  ++__t;
 	  _Distance __M = std::rand() % (__t);
 	  if (__M < __n)
-	    __out[__M] = *__first;
+	    ___out[__M] = *__first;
 	  ++__first;
 	}
-      return __out + __m;
+      return ___out + __m;
     }
 
   template<typename _InputIterator, typename _RandomAccessIterator,
 	   typename _RandomNumberGenerator, typename _Distance>
     _RandomAccessIterator
     __random_sample(_InputIterator __first, _InputIterator __last,
-		    _RandomAccessIterator __out,
+		    _RandomAccessIterator ___out,
 		    _RandomNumberGenerator& __rand,
 		    const _Distance __n)
     {
@@ -362,17 +362,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       _Distance __m = 0;
       _Distance __t = __n;
       for ( ; __first != __last && __m < __n; ++__m, ++__first)
-	__out[__m] = *__first;
+	___out[__m] = *__first;
 
       while (__first != __last)
 	{
 	  ++__t;
 	  _Distance __M = __rand(__t);
 	  if (__M < __n)
-	    __out[__M] = *__first;
+	    ___out[__M] = *__first;
 	  ++__first;
 	}
-      return __out + __m;
+      return ___out + __m;
     }
 
   /**
diff --git a/libstdc++-v3/include/ext/pb_ds/detail/debug_map_base.hpp b/libstdc++-v3/include/ext/pb_ds/detail/debug_map_base.hpp
index 067a6a79382..f93790943cc 100644
--- a/libstdc++-v3/include/ext/pb_ds/detail/debug_map_base.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/detail/debug_map_base.hpp
@@ -57,9 +57,9 @@ namespace __gnu_pbds
     // Need std::pair ostream extractor.
     template<typename _CharT, typename _Traits, typename _Tp1, typename _Tp2>
     inline std::basic_ostream<_CharT, _Traits>&
-    operator<<(std::basic_ostream<_CharT, _Traits>& __out,
+    operator<<(std::basic_ostream<_CharT, _Traits>& ___out,
 	       const std::pair<_Tp1, _Tp2>& p)
-    { return (__out << '(' << p.first << ',' << p.second << ')'); }
+    { return (___out << '(' << p.first << ',' << p.second << ')'); }
 
 #define PB_DS_CLASS_T_DEC \
     template<typename Key, typename Eq_Fn, typename Const_Key_Reference>
diff --git a/libstdc++-v3/include/ext/random.tcc b/libstdc++-v3/include/ext/random.tcc
index e11b7d1a8ed..08188929faa 100644
--- a/libstdc++-v3/include/ext/random.tcc
+++ b/libstdc++-v3/include/ext/random.tcc
@@ -212,38 +212,38 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   namespace {
 
     template<size_t __shift>
-      inline void __rshift(uint32_t *__out, const uint32_t *__in)
+      inline void __rshift(uint32_t *___out, const uint32_t *___in)
       {
-	uint64_t __th = ((static_cast<uint64_t>(__in[3]) << 32)
-			 | static_cast<uint64_t>(__in[2]));
-	uint64_t __tl = ((static_cast<uint64_t>(__in[1]) << 32)
-			 | static_cast<uint64_t>(__in[0]));
+	uint64_t __th = ((static_cast<uint64_t>(___in[3]) << 32)
+			 | static_cast<uint64_t>(___in[2]));
+	uint64_t __tl = ((static_cast<uint64_t>(___in[1]) << 32)
+			 | static_cast<uint64_t>(___in[0]));
 
 	uint64_t __oh = __th >> (__shift * 8);
 	uint64_t __ol = __tl >> (__shift * 8);
 	__ol |= __th << (64 - __shift * 8);
-	__out[1] = static_cast<uint32_t>(__ol >> 32);
-	__out[0] = static_cast<uint32_t>(__ol);
-	__out[3] = static_cast<uint32_t>(__oh >> 32);
-	__out[2] = static_cast<uint32_t>(__oh);
+	___out[1] = static_cast<uint32_t>(__ol >> 32);
+	___out[0] = static_cast<uint32_t>(__ol);
+	___out[3] = static_cast<uint32_t>(__oh >> 32);
+	___out[2] = static_cast<uint32_t>(__oh);
       }
 
 
     template<size_t __shift>
-      inline void __lshift(uint32_t *__out, const uint32_t *__in)
+      inline void __lshift(uint32_t *___out, const uint32_t *___in)
       {
-	uint64_t __th = ((static_cast<uint64_t>(__in[3]) << 32)
-			 | static_cast<uint64_t>(__in[2]));
-	uint64_t __tl = ((static_cast<uint64_t>(__in[1]) << 32)
-			 | static_cast<uint64_t>(__in[0]));
+	uint64_t __th = ((static_cast<uint64_t>(___in[3]) << 32)
+			 | static_cast<uint64_t>(___in[2]));
+	uint64_t __tl = ((static_cast<uint64_t>(___in[1]) << 32)
+			 | static_cast<uint64_t>(___in[0]));
 
 	uint64_t __oh = __th << (__shift * 8);
 	uint64_t __ol = __tl << (__shift * 8);
 	__oh |= __tl >> (64 - __shift * 8);
-	__out[1] = static_cast<uint32_t>(__ol >> 32);
-	__out[0] = static_cast<uint32_t>(__ol);
-	__out[3] = static_cast<uint32_t>(__oh >> 32);
-	__out[2] = static_cast<uint32_t>(__oh);
+	___out[1] = static_cast<uint32_t>(__ol >> 32);
+	___out[0] = static_cast<uint32_t>(__ol);
+	___out[3] = static_cast<uint32_t>(__oh >> 32);
+	___out[2] = static_cast<uint32_t>(__oh);
       }
 
 
diff --git a/libstdc++-v3/include/ext/vstring.tcc b/libstdc++-v3/include/ext/vstring.tcc
index 41c830a1478..5f8201e8a63 100644
--- a/libstdc++-v3/include/ext/vstring.tcc
+++ b/libstdc++-v3/include/ext/vstring.tcc
@@ -553,7 +553,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   template<typename _CharT, typename _Traits, typename _Alloc,
            template <typename, typename, typename> class _Base>
     basic_istream<_CharT, _Traits>&
-    operator>>(basic_istream<_CharT, _Traits>& __in,
+    operator>>(basic_istream<_CharT, _Traits>& ___in,
 	       __gnu_cxx::__versa_string<_CharT, _Traits,
 	                                 _Alloc, _Base>& __str)
     {
@@ -568,7 +568,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
       __size_type __extracted = 0;
       typename __ios_base::iostate __err = __ios_base::goodbit;
-      typename __istream_type::sentry __cerb(__in, false);
+      typename __istream_type::sentry __cerb(___in, false);
       if (__cerb)
 	{
 	  __try
@@ -577,12 +577,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	      __str.erase();
 	      _CharT __buf[128];
 	      __size_type __len = 0;
-	      const streamsize __w = __in.width();
+	      const streamsize __w = ___in.width();
 	      const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
 		                              : __str.max_size();
-	      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
+	      const __ctype_type& __ct = use_facet<__ctype_type>(___in.getloc());
 	      const __int_type __eof = _Traits::eof();
-	      __int_type __c = __in.rdbuf()->sgetc();
+	      __int_type __c = ___in.rdbuf()->sgetc();
 
 	      while (__extracted < __n
 		     && !_Traits::eq_int_type(__c, __eof)
@@ -596,17 +596,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 		    }
 		  __buf[__len++] = _Traits::to_char_type(__c);
 		  ++__extracted;
-		  __c = __in.rdbuf()->snextc();
+		  __c = ___in.rdbuf()->snextc();
 		}
 	      __str.append(__buf, __len);
 
 	      if (_Traits::eq_int_type(__c, __eof))
 		__err |= __ios_base::eofbit;
-	      __in.width(0);
+	      ___in.width(0);
 	    }
 	  __catch(__cxxabiv1::__forced_unwind&)
 	    {
-	      __in._M_setstate(__ios_base::badbit);
+	      ___in._M_setstate(__ios_base::badbit);
 	      __throw_exception_again;
 	    }
 	  __catch(...)
@@ -614,21 +614,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
 	      // 91. Description of operator>> and getline() for string<>
 	      // might cause endless loop
-	      __in._M_setstate(__ios_base::badbit);
+	      ___in._M_setstate(__ios_base::badbit);
 	    }
 	}
       // 211.  operator>>(istream&, string&) doesn't set failbit
       if (!__extracted)
 	__err |= __ios_base::failbit;
       if (__err)
-	__in.setstate(__err);
-      return __in;
+	___in.setstate(__err);
+      return ___in;
     }      
 
   template<typename _CharT, typename _Traits, typename _Alloc,
            template <typename, typename, typename> class _Base>
     basic_istream<_CharT, _Traits>&
-    getline(basic_istream<_CharT, _Traits>& __in,
+    getline(basic_istream<_CharT, _Traits>& ___in,
 	    __gnu_cxx::__versa_string<_CharT, _Traits, _Alloc, _Base>& __str,
 	    _CharT __delim)
     {
@@ -642,7 +642,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __size_type __extracted = 0;
       const __size_type __n = __str.max_size();
       typename __ios_base::iostate __err = __ios_base::goodbit;
-      typename __istream_type::sentry __cerb(__in, true);
+      typename __istream_type::sentry __cerb(___in, true);
       if (__cerb)
 	{
 	  __try
@@ -653,7 +653,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	      __size_type __len = 0;
 	      const __int_type __idelim = _Traits::to_int_type(__delim);
 	      const __int_type __eof = _Traits::eof();
-	      __int_type __c = __in.rdbuf()->sgetc();
+	      __int_type __c = ___in.rdbuf()->sgetc();
 
 	      while (__extracted < __n
 		     && !_Traits::eq_int_type(__c, __eof)
@@ -666,7 +666,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 		    }
 		  __buf[__len++] = _Traits::to_char_type(__c);
 		  ++__extracted;
-		  __c = __in.rdbuf()->snextc();
+		  __c = ___in.rdbuf()->snextc();
 		}
 	      __str.append(__buf, __len);
 
@@ -675,14 +675,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	      else if (_Traits::eq_int_type(__c, __idelim))
 		{
 		  ++__extracted;		  
-		  __in.rdbuf()->sbumpc();
+		  ___in.rdbuf()->sbumpc();
 		}
 	      else
 		__err |= __ios_base::failbit;
 	    }
 	  __catch(__cxxabiv1::__forced_unwind&)
 	    {
-	      __in._M_setstate(__ios_base::badbit);
+	      ___in._M_setstate(__ios_base::badbit);
 	      __throw_exception_again;
 	    }
 	  __catch(...)
@@ -690,14 +690,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
 	      // 91. Description of operator>> and getline() for string<>
 	      // might cause endless loop
-	      __in._M_setstate(__ios_base::badbit);
+	      ___in._M_setstate(__ios_base::badbit);
 	    }
 	}
       if (!__extracted)
 	__err |= __ios_base::failbit;
       if (__err)
-	__in.setstate(__err);
-      return __in;
+	___in.setstate(__err);
+      return ___in;
     }      
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/parallel/algo.h b/libstdc++-v3/include/parallel/algo.h
index aa115191e18..9a84fe64481 100644
--- a/libstdc++-v3/include/parallel/algo.h
+++ b/libstdc++-v3/include/parallel/algo.h
@@ -289,67 +289,67 @@ namespace __parallel
   // Sequential fallback
   template<typename _IIter, typename _OutputIterator>
     inline _OutputIterator
-    unique_copy(_IIter __begin1, _IIter __end1, _OutputIterator __out,
+    unique_copy(_IIter __begin1, _IIter __end1, _OutputIterator ___out,
 		__gnu_parallel::sequential_tag)
-    { return _GLIBCXX_STD_A::unique_copy(__begin1, __end1, __out); }
+    { return _GLIBCXX_STD_A::unique_copy(__begin1, __end1, ___out); }
 
   // Sequential fallback
   template<typename _IIter, typename _OutputIterator,
 	   typename _Predicate>
     inline _OutputIterator
-    unique_copy(_IIter __begin1, _IIter __end1, _OutputIterator __out,
+    unique_copy(_IIter __begin1, _IIter __end1, _OutputIterator ___out,
 		_Predicate __pred, __gnu_parallel::sequential_tag)
-    { return _GLIBCXX_STD_A::unique_copy(__begin1, __end1, __out, __pred); }
+    { return _GLIBCXX_STD_A::unique_copy(__begin1, __end1, ___out, __pred); }
 
   // Sequential fallback for input iterator case
   template<typename _IIter, typename _OutputIterator,
 	   typename _Predicate, typename _IteratorTag1, typename _IteratorTag2>
     inline _OutputIterator
     __unique_copy_switch(_IIter __begin, _IIter __last,
-		       _OutputIterator __out, _Predicate __pred,
+		       _OutputIterator ___out, _Predicate __pred,
 		       _IteratorTag1, _IteratorTag2)
-    { return _GLIBCXX_STD_A::unique_copy(__begin, __last, __out, __pred); }
+    { return _GLIBCXX_STD_A::unique_copy(__begin, __last, ___out, __pred); }
 
   // Parallel unique_copy for random access iterators
   template<typename _RAIter, typename _RandomAccessOutputIterator,
 	   typename _Predicate>
     _RandomAccessOutputIterator
     __unique_copy_switch(_RAIter __begin, _RAIter __last,
-			 _RandomAccessOutputIterator __out, _Predicate __pred,
+			 _RandomAccessOutputIterator ___out, _Predicate __pred,
 			 random_access_iterator_tag, random_access_iterator_tag)
     {
       if (_GLIBCXX_PARALLEL_CONDITION(
 	    static_cast<__gnu_parallel::_SequenceIndex>(__last - __begin)
 	    > __gnu_parallel::_Settings::get().unique_copy_minimal_n))
 	return __gnu_parallel::__parallel_unique_copy(
-		 __begin, __last, __out, __pred);
+		 __begin, __last, ___out, __pred);
       else
-	return _GLIBCXX_STD_A::unique_copy(__begin, __last, __out, __pred);
+	return _GLIBCXX_STD_A::unique_copy(__begin, __last, ___out, __pred);
     }
 
   // Public interface
   template<typename _IIter, typename _OutputIterator>
     inline _OutputIterator
-    unique_copy(_IIter __begin1, _IIter __end1, _OutputIterator __out)
+    unique_copy(_IIter __begin1, _IIter __end1, _OutputIterator ___out)
     {
       typedef typename std::iterator_traits<_IIter>::value_type _ValueType;
 
       return __unique_copy_switch(
-	       __begin1, __end1, __out, equal_to<_ValueType>(),
+	       __begin1, __end1, ___out, equal_to<_ValueType>(),
 	       std::__iterator_category(__begin1),
-	       std::__iterator_category(__out));
+	       std::__iterator_category(___out));
     }
 
   // Public interface
   template<typename _IIter, typename _OutputIterator, typename _Predicate>
     inline _OutputIterator
-    unique_copy(_IIter __begin1, _IIter __end1, _OutputIterator __out,
+    unique_copy(_IIter __begin1, _IIter __end1, _OutputIterator ___out,
 		_Predicate __pred)
     {
       return __unique_copy_switch(
-	       __begin1, __end1, __out, __pred,
+	       __begin1, __end1, ___out, __pred,
 	       std::__iterator_category(__begin1),
-	       std::__iterator_category(__out));
+	       std::__iterator_category(___out));
     }
 
   // Sequential fallback
@@ -358,9 +358,9 @@ namespace __parallel
     inline _OutputIterator
     set_union(_IIter1 __begin1, _IIter1 __end1,
 	      _IIter2 __begin2, _IIter2 __end2,
-	      _OutputIterator __out, __gnu_parallel::sequential_tag)
+	      _OutputIterator ___out, __gnu_parallel::sequential_tag)
     { return _GLIBCXX_STD_A::set_union(
-	       __begin1, __end1, __begin2, __end2, __out); }
+	       __begin1, __end1, __begin2, __end2, ___out); }
 
   // Sequential fallback
   template<typename _IIter1, typename _IIter2,
@@ -368,10 +368,10 @@ namespace __parallel
     inline _OutputIterator
     set_union(_IIter1 __begin1, _IIter1 __end1,
 	      _IIter2 __begin2, _IIter2 __end2,
-	      _OutputIterator __out, _Predicate __pred,
+	      _OutputIterator ___out, _Predicate __pred,
 	      __gnu_parallel::sequential_tag)
     { return _GLIBCXX_STD_A::set_union(__begin1, __end1,
-				       __begin2, __end2, __out, __pred); }
+				       __begin2, __end2, ___out, __pred); }
 
   // Sequential fallback for input iterator case
   template<typename _IIter1, typename _IIter2, typename _Predicate,
@@ -412,17 +412,17 @@ namespace __parallel
 	   typename _OutputIterator>
     inline _OutputIterator
     set_union(_IIter1 __begin1, _IIter1 __end1,
-	      _IIter2 __begin2, _IIter2 __end2, _OutputIterator __out)
+	      _IIter2 __begin2, _IIter2 __end2, _OutputIterator ___out)
     {
       typedef typename std::iterator_traits<_IIter1>::value_type _ValueType1;
       typedef typename std::iterator_traits<_IIter2>::value_type _ValueType2;
 
       return __set_union_switch(
-	       __begin1, __end1, __begin2, __end2, __out,
+	       __begin1, __end1, __begin2, __end2, ___out,
 	       __gnu_parallel::_Less<_ValueType1, _ValueType2>(),
 	       std::__iterator_category(__begin1),
 	       std::__iterator_category(__begin2),
-	       std::__iterator_category(__out));
+	       std::__iterator_category(___out));
     }
 
   // Public interface
@@ -431,13 +431,13 @@ namespace __parallel
     inline _OutputIterator
     set_union(_IIter1 __begin1, _IIter1 __end1,
 	      _IIter2 __begin2, _IIter2 __end2,
-	      _OutputIterator __out, _Predicate __pred)
+	      _OutputIterator ___out, _Predicate __pred)
     {
       return __set_union_switch(
-	       __begin1, __end1, __begin2, __end2, __out, __pred,
+	       __begin1, __end1, __begin2, __end2, ___out, __pred,
 	       std::__iterator_category(__begin1),
 	       std::__iterator_category(__begin2),
-	       std::__iterator_category(__out));
+	       std::__iterator_category(___out));
     }
 
   // Sequential fallback.
@@ -446,9 +446,9 @@ namespace __parallel
     inline _OutputIterator
     set_intersection(_IIter1 __begin1, _IIter1 __end1,
 		     _IIter2 __begin2, _IIter2 __end2,
-		     _OutputIterator __out, __gnu_parallel::sequential_tag)
+		     _OutputIterator ___out, __gnu_parallel::sequential_tag)
     { return _GLIBCXX_STD_A::set_intersection(__begin1, __end1,
-					      __begin2, __end2, __out); }
+					      __begin2, __end2, ___out); }
 
   // Sequential fallback.
   template<typename _IIter1, typename _IIter2,
@@ -456,10 +456,10 @@ namespace __parallel
     inline _OutputIterator
     set_intersection(_IIter1 __begin1, _IIter1 __end1,
 		     _IIter2 __begin2, _IIter2 __end2,
-		     _OutputIterator __out, _Predicate __pred,
+		     _OutputIterator ___out, _Predicate __pred,
 		     __gnu_parallel::sequential_tag)
     { return _GLIBCXX_STD_A::set_intersection(
-	       __begin1, __end1, __begin2, __end2, __out, __pred); }
+	       __begin1, __end1, __begin2, __end2, ___out, __pred); }
 
   // Sequential fallback for input iterator case
   template<typename _IIter1, typename _IIter2,
@@ -506,17 +506,17 @@ namespace __parallel
     inline _OutputIterator
     set_intersection(_IIter1 __begin1, _IIter1 __end1,
 		     _IIter2 __begin2, _IIter2 __end2,
-		     _OutputIterator __out)
+		     _OutputIterator ___out)
     {
       typedef typename std::iterator_traits<_IIter1>::value_type _ValueType1;
       typedef typename std::iterator_traits<_IIter2>::value_type _ValueType2;
 
       return __set_intersection_switch(
-	       __begin1, __end1, __begin2, __end2, __out,
+	       __begin1, __end1, __begin2, __end2, ___out,
 	       __gnu_parallel::_Less<_ValueType1, _ValueType2>(),
 	       std::__iterator_category(__begin1),
 	       std::__iterator_category(__begin2),
-	       std::__iterator_category(__out));
+	       std::__iterator_category(___out));
     }
 
   template<typename _IIter1, typename _IIter2,
@@ -524,13 +524,13 @@ namespace __parallel
     inline _OutputIterator
     set_intersection(_IIter1 __begin1, _IIter1 __end1,
 		     _IIter2 __begin2, _IIter2 __end2,
-		     _OutputIterator __out, _Predicate __pred)
+		     _OutputIterator ___out, _Predicate __pred)
     {
       return __set_intersection_switch(
-	       __begin1, __end1, __begin2, __end2, __out, __pred,
+	       __begin1, __end1, __begin2, __end2, ___out, __pred,
 	       std::__iterator_category(__begin1),
 	       std::__iterator_category(__begin2),
-	       std::__iterator_category(__out));
+	       std::__iterator_category(___out));
     }
 
   // Sequential fallback
@@ -539,10 +539,10 @@ namespace __parallel
     inline _OutputIterator
     set_symmetric_difference(_IIter1 __begin1, _IIter1 __end1,
 			     _IIter2 __begin2, _IIter2 __end2,
-			     _OutputIterator __out,
+			     _OutputIterator ___out,
 			     __gnu_parallel::sequential_tag)
     { return _GLIBCXX_STD_A::set_symmetric_difference(
-	       __begin1, __end1, __begin2, __end2, __out); }
+	       __begin1, __end1, __begin2, __end2, ___out); }
 
   // Sequential fallback
   template<typename _IIter1, typename _IIter2,
@@ -550,10 +550,10 @@ namespace __parallel
     inline _OutputIterator
     set_symmetric_difference(_IIter1 __begin1, _IIter1 __end1,
 			     _IIter2 __begin2, _IIter2 __end2,
-			     _OutputIterator __out, _Predicate __pred,
+			     _OutputIterator ___out, _Predicate __pred,
 			     __gnu_parallel::sequential_tag)
     { return _GLIBCXX_STD_A::set_symmetric_difference(
-	       __begin1, __end1, __begin2, __end2, __out, __pred); }
+	       __begin1, __end1, __begin2, __end2, ___out, __pred); }
 
   // Sequential fallback for input iterator case
   template<typename _IIter1, typename _IIter2,
@@ -600,17 +600,17 @@ namespace __parallel
     inline _OutputIterator
     set_symmetric_difference(_IIter1 __begin1, _IIter1 __end1,
 			     _IIter2 __begin2, _IIter2 __end2,
-			     _OutputIterator __out)
+			     _OutputIterator ___out)
     {
       typedef typename std::iterator_traits<_IIter1>::value_type _ValueType1;
       typedef typename std::iterator_traits<_IIter2>::value_type _ValueType2;
 
       return __set_symmetric_difference_switch(
-	       __begin1, __end1, __begin2, __end2, __out,
+	       __begin1, __end1, __begin2, __end2, ___out,
 	       __gnu_parallel::_Less<_ValueType1, _ValueType2>(),
 	       std::__iterator_category(__begin1),
 	       std::__iterator_category(__begin2),
-	       std::__iterator_category(__out));
+	       std::__iterator_category(___out));
     }
 
   // Public interface.
@@ -619,13 +619,13 @@ namespace __parallel
     inline _OutputIterator
     set_symmetric_difference(_IIter1 __begin1, _IIter1 __end1,
 			     _IIter2 __begin2, _IIter2 __end2,
-			     _OutputIterator __out, _Predicate __pred)
+			     _OutputIterator ___out, _Predicate __pred)
     {
       return __set_symmetric_difference_switch(
-	       __begin1, __end1, __begin2, __end2, __out, __pred,
+	       __begin1, __end1, __begin2, __end2, ___out, __pred,
 	       std::__iterator_category(__begin1),
 	       std::__iterator_category(__begin2),
-	       std::__iterator_category(__out));
+	       std::__iterator_category(___out));
     }
 
   // Sequential fallback.
@@ -634,9 +634,9 @@ namespace __parallel
     inline _OutputIterator
     set_difference(_IIter1 __begin1, _IIter1 __end1,
 		   _IIter2 __begin2, _IIter2 __end2,
-		   _OutputIterator __out, __gnu_parallel::sequential_tag)
+		   _OutputIterator ___out, __gnu_parallel::sequential_tag)
     { return _GLIBCXX_STD_A::set_difference(
-	       __begin1,__end1, __begin2, __end2, __out); }
+	       __begin1,__end1, __begin2, __end2, ___out); }
 
   // Sequential fallback.
   template<typename _IIter1, typename _IIter2,
@@ -644,10 +644,10 @@ namespace __parallel
     inline _OutputIterator
     set_difference(_IIter1 __begin1, _IIter1 __end1,
 		   _IIter2 __begin2, _IIter2 __end2,
-		   _OutputIterator __out, _Predicate __pred,
+		   _OutputIterator ___out, _Predicate __pred,
 		   __gnu_parallel::sequential_tag)
     { return _GLIBCXX_STD_A::set_difference(__begin1, __end1,
-					    __begin2, __end2, __out, __pred); }
+					    __begin2, __end2, ___out, __pred); }
 
   // Sequential fallback for input iterator case.
   template<typename _IIter1, typename _IIter2, typename _Predicate,
@@ -692,17 +692,17 @@ namespace __parallel
     inline _OutputIterator
     set_difference(_IIter1 __begin1, _IIter1 __end1,
 		   _IIter2 __begin2, _IIter2 __end2,
-		   _OutputIterator __out)
+		   _OutputIterator ___out)
     {
       typedef typename std::iterator_traits<_IIter1>::value_type _ValueType1;
       typedef typename std::iterator_traits<_IIter2>::value_type _ValueType2;
 
       return __set_difference_switch(
-	       __begin1, __end1, __begin2, __end2, __out,
+	       __begin1, __end1, __begin2, __end2, ___out,
 	       __gnu_parallel::_Less<_ValueType1, _ValueType2>(),
 	       std::__iterator_category(__begin1),
 	       std::__iterator_category(__begin2),
-	       std::__iterator_category(__out));
+	       std::__iterator_category(___out));
     }
 
   // Public interface
@@ -711,13 +711,13 @@ namespace __parallel
     inline _OutputIterator
     set_difference(_IIter1 __begin1, _IIter1 __end1,
 		   _IIter2 __begin2, _IIter2 __end2,
-		   _OutputIterator __out, _Predicate __pred)
+		   _OutputIterator ___out, _Predicate __pred)
     {
       return __set_difference_switch(
-	       __begin1, __end1, __begin2, __end2, __out, __pred,
+	       __begin1, __end1, __begin2, __end2, ___out, __pred,
 	       std::__iterator_category(__begin1),
 	       std::__iterator_category(__begin2),
-	       std::__iterator_category(__out));
+	       std::__iterator_category(___out));
     }
 
   // Sequential fallback
diff --git a/libstdc++-v3/include/parallel/multiway_merge.h b/libstdc++-v3/include/parallel/multiway_merge.h
index 2c10bc2c155..93d923fc99c 100644
--- a/libstdc++-v3/include/parallel/multiway_merge.h
+++ b/libstdc++-v3/include/parallel/multiway_merge.h
@@ -1372,7 +1372,7 @@ namespace __gnu_parallel
    *     for (int __j = 0; __i < 10; ++__j)
    *       sequences[__i][__j] = __j;
    *
-   *   int __out[33];
+   *   int ___out[33];
    *   std::vector<std::pair<int*> > seqs;
    *   for (int __i = 0; __i < 10; ++__i)
    *     { seqs.push(std::make_pair<int*>(sequences[__i],
@@ -1733,7 +1733,7 @@ namespace __gnu_parallel
    *     for (int __j = 0; __i < 11; ++__j)
    *       sequences[__i][__j] = __j; // __last one is sentinel!
    *
-   *   int __out[33];
+   *   int ___out[33];
    *   std::vector<std::pair<int*> > seqs;
    *   for (int __i = 0; __i < 10; ++__i)
    *     { seqs.push(std::make_pair<int*>(sequences[__i],
diff --git a/libstdc++-v3/include/parallel/set_operations.h b/libstdc++-v3/include/parallel/set_operations.h
index 50b6e30643f..0d6a7e5e90f 100644
--- a/libstdc++-v3/include/parallel/set_operations.h
+++ b/libstdc++-v3/include/parallel/set_operations.h
@@ -130,12 +130,12 @@ namespace __gnu_parallel
       }
 
       _OutputIterator
-      __first_empty(_IIter __c, _IIter __d, _OutputIterator __out) const
-      { return std::copy(__c, __d, __out); }
+      __first_empty(_IIter __c, _IIter __d, _OutputIterator ___out) const
+      { return std::copy(__c, __d, ___out); }
 
       _OutputIterator
-      __second_empty(_IIter __a, _IIter __b, _OutputIterator __out) const
-      { return std::copy(__a, __b, __out); }
+      __second_empty(_IIter __a, _IIter __b, _OutputIterator ___out) const
+      { return std::copy(__a, __b, ___out); }
     };
 
 
@@ -198,12 +198,12 @@ namespace __gnu_parallel
       }
 
       _OutputIterator
-      __first_empty(_IIter, _IIter, _OutputIterator __out) const
-      { return __out; }
+      __first_empty(_IIter, _IIter, _OutputIterator ___out) const
+      { return ___out; }
 
       _OutputIterator
-      __second_empty(_IIter __a, _IIter __b, _OutputIterator __out) const
-      { return std::copy(__a, __b, __out); }
+      __second_empty(_IIter __a, _IIter __b, _OutputIterator ___out) const
+      { return std::copy(__a, __b, ___out); }
     };
 
 
@@ -265,12 +265,12 @@ namespace __gnu_parallel
       }
 
       _OutputIterator
-      __first_empty(_IIter, _IIter, _OutputIterator __out) const
-      { return __out; }
+      __first_empty(_IIter, _IIter, _OutputIterator ___out) const
+      { return ___out; }
 
       _OutputIterator
-      __second_empty(_IIter, _IIter, _OutputIterator __out) const
-      { return __out; }
+      __second_empty(_IIter, _IIter, _OutputIterator ___out) const
+      { return ___out; }
     };
 
   template<class _IIter, class _OutputIterator, class _Compare>
@@ -335,12 +335,12 @@ namespace __gnu_parallel
       }
 
       _OutputIterator
-      __first_empty(_IIter __c, _IIter __d, _OutputIterator __out) const
-      { return std::copy(__c, __d, __out); }
+      __first_empty(_IIter __c, _IIter __d, _OutputIterator ___out) const
+      { return std::copy(__c, __d, ___out); }
 
       _OutputIterator
-      __second_empty(_IIter __a, _IIter __b, _OutputIterator __out) const
-      { return std::copy(__a, __b, __out); }
+      __second_empty(_IIter __a, _IIter __b, _OutputIterator ___out) const
+      { return std::copy(__a, __b, ___out); }
     };
 
   template<typename _IIter,
diff --git a/libstdc++-v3/include/parallel/unique_copy.h b/libstdc++-v3/include/parallel/unique_copy.h
index aea60f384b8..dc548ee8689 100644
--- a/libstdc++-v3/include/parallel/unique_copy.h
+++ b/libstdc++-v3/include/parallel/unique_copy.h
@@ -85,7 +85,7 @@ namespace __gnu_parallel
 	// Check for length without duplicates
 	// Needed for position in output
 	_DifferenceType __i = 0;
-	_OutputIterator __out = __result;
+	_OutputIterator ___out = __result;
 
 	if (__iam == 0)
           {
@@ -93,7 +93,7 @@ namespace __gnu_parallel
             __end = __borders[__iam + 1];
 
             ++__i;
-            *__out++ = *__first;
+            *___out++ = *__first;
 
             for (_IIter __iter = __first + __begin; __iter < __first + __end;
 		 ++__iter)
@@ -101,7 +101,7 @@ namespace __gnu_parallel
         	if (!__binary_pred(*__iter, *(__iter - 1)))
                   {
                     ++__i;
-                    *__out++ = *__iter;
+                    *___out++ = *__iter;
                   }
               }
           }
diff --git a/libstdc++-v3/include/std/format b/libstdc++-v3/include/std/format
index 7d6b75228d1..1d0bda1028a 100644
--- a/libstdc++-v3/include/std/format
+++ b/libstdc++-v3/include/std/format
@@ -781,24 +781,24 @@ namespace __format
   template<typename _Out, typename _CharT>
     requires output_iterator<_Out, const _CharT&>
     inline _Out
-    __write(_Out __out, basic_string_view<_CharT> __str)
+    __write(_Out ___out, basic_string_view<_CharT> __str)
     {
       if constexpr (is_same_v<_Out, _Sink_iter<_CharT>>)
 	{
 	  if (__str.size())
-	    __out = __str;
+	    ___out = __str;
 	}
       else
 	for (_CharT __c : __str)
-	  *__out++ = __c;
-      return __out;
+	  *___out++ = __c;
+      return ___out;
     }
 
   // Write STR to OUT with NFILL copies of FILL_CHAR specified by ALIGN.
   // pre: __align != _Align_default
   template<typename _Out, typename _CharT>
     _Out
-    __write_padded(_Out __out, basic_string_view<_CharT> __str,
+    __write_padded(_Out ___out, basic_string_view<_CharT> __str,
 		   _Align __align, size_t __nfill, char32_t __fill_char)
     {
       const size_t __buflen = 0x20;
@@ -848,11 +848,11 @@ namespace __format
 	    basic_string<_CharT> __padstr(__v.begin(), __v.end());
 	    __padding = __padstr;
 	    while (__l-- > 0)
-	      __out = __format::__write(std::move(__out), __padding);
-	    __out = __format::__write(std::move(__out), __str);
+	      ___out = __format::__write(std::move(___out), __padding);
+	    ___out = __format::__write(std::move(___out), __str);
 	    while (__r-- > 0)
-	      __out = __format::__write(std::move(__out), __padding);
-	    return __out;
+	      ___out = __format::__write(std::move(___out), __padding);
+	    return ___out;
 	  }
 
       if (__max < __buflen)
@@ -861,11 +861,11 @@ namespace __format
 	__max = __buflen;
 
       char_traits<_CharT>::assign(__padding_chars, __max, __fill_char);
-      __pad(__l, __out);
-      __out = __format::__write(std::move(__out), __str);
-      __pad(__r, __out);
+      __pad(__l, ___out);
+      ___out = __format::__write(std::move(___out), __str);
+      __pad(__r, ___out);
 
-      return __out;
+      return ___out;
     }
 
   // Write STR to OUT, with alignment and padding as determined by SPEC.
@@ -1008,7 +1008,7 @@ namespace __format
   using uint_least32_t = __UINT_LEAST32_TYPE__;
   template<typename _Out, typename _CharT>
     _Out
-    __write_escape_seq(_Out __out, uint_least32_t __val,
+    __write_escape_seq(_Out ___out, uint_least32_t __val,
 		       basic_string_view<_CharT> __prefix)
     {
       using _Str_view = basic_string_view<_CharT>;
@@ -1018,46 +1018,46 @@ namespace __format
 	__buf,
 	std::__to_chars_i<uint_least32_t>(__buf, __buf + __max, __val, 16).ptr);
 
-      __out = __format::__write(__out, __prefix);
-      *__out = _Separators<_CharT>::_S_braces()[0];
-      ++__out;
+      ___out = __format::__write(___out, __prefix);
+      *___out = _Separators<_CharT>::_S_braces()[0];
+      ++___out;
       if constexpr (is_same_v<char, _CharT>)
-	__out = __format::__write(__out, __narrow);
+	___out = __format::__write(___out, __narrow);
 #ifdef _GLIBCXX_USE_WCHAR_T
       else
 	{
 	  _CharT __wbuf[__max];
 	  const size_t __n = __narrow.size();
 	  std::__to_wstring_numeric(__narrow.data(), __n, __wbuf);
-	  __out = __format::__write(__out, _Str_view(__wbuf, __n));
+	  ___out = __format::__write(___out, _Str_view(__wbuf, __n));
 	}
 #endif
-      *__out = _Separators<_CharT>::_S_braces()[1];
-      return ++__out;
+      *___out = _Separators<_CharT>::_S_braces()[1];
+      return ++___out;
     }
 
   template<typename _Out, typename _CharT>
     _Out
-    __write_escaped_char(_Out __out, _CharT __c)
+    __write_escaped_char(_Out ___out, _CharT __c)
     {
       using _UChar = make_unsigned_t<_CharT>;
       using _Esc = _Escapes<_CharT>;
       switch (__c)
 	{
 	  case _Esc::_S_tab()[0]:
-	    return __format::__write(__out, _Esc::_S_tab().substr(1, 2));
+	    return __format::__write(___out, _Esc::_S_tab().substr(1, 2));
 	  case _Esc::_S_newline()[0]:
-	    return __format::__write(__out, _Esc::_S_newline().substr(1, 2));
+	    return __format::__write(___out, _Esc::_S_newline().substr(1, 2));
 	  case _Esc::_S_return()[0]:
-	    return __format::__write(__out, _Esc::_S_return().substr(1, 2));
+	    return __format::__write(___out, _Esc::_S_return().substr(1, 2));
 	  case _Esc::_S_bslash()[0]:
-	    return __format::__write(__out, _Esc::_S_bslash().substr(1, 2));
+	    return __format::__write(___out, _Esc::_S_bslash().substr(1, 2));
 	  case _Esc::_S_quote()[0]:
-	    return __format::__write(__out, _Esc::_S_quote().substr(1, 2));
+	    return __format::__write(___out, _Esc::_S_quote().substr(1, 2));
 	  case _Esc::_S_apos()[0]:
-	    return __format::__write(__out, _Esc::_S_apos().substr(1, 2));
+	    return __format::__write(___out, _Esc::_S_apos().substr(1, 2));
 	  default:
-	    return __format::__write_escape_seq(__out,
+	    return __format::__write_escape_seq(___out,
 				static_cast<_UChar>(__c),
 						_Esc::_S_u());
 	}
@@ -1065,7 +1065,7 @@ namespace __format
 
   template<typename _CharT, typename _Out>
     _Out
-    __write_escaped_ascii(_Out __out,
+    __write_escaped_ascii(_Out ___out,
 			  basic_string_view<_CharT> __str,
 			  _Term_char __term)
     {
@@ -1081,21 +1081,21 @@ namespace __format
 	  ++__print;
 
 	if (__print != __first)
-	  __out = __format::__write(__out, _Str_view(__first, __print));
+	  ___out = __format::__write(___out, _Str_view(__first, __print));
 
 	if (__print == __last)
-	  return __out;
+	  return ___out;
 
 	__first = __print;
-	__out = __format::__write_escaped_char(__out, *__first);
+	___out = __format::__write_escaped_char(___out, *__first);
 	++__first;
       }
-      return __out;
+      return ___out;
     }
 
   template<typename _CharT, typename _Out>
     _Out
-    __write_escaped_unicode(_Out __out,
+    __write_escaped_unicode(_Out ___out,
 			    basic_string_view<_CharT> __str,
 			    _Term_char __term)
     {
@@ -1146,46 +1146,46 @@ namespace __format
 	    }
 
 	  if (__print != __first)
-	    __out = __format::__write(__out, _Str_view(__first.base(), __print.base()));
+	    ___out = __format::__write(___out, _Str_view(__first.base(), __print.base()));
 
 	  if (__print == __last)
-	    return __out;
+	    return ___out;
 
 	  __first = __print;
 	  if (__esc_ascii)
-	    __out = __format::__write_escaped_char(__out, *__first.base());
+	    ___out = __format::__write_escaped_char(___out, *__first.base());
 	  else if (__esc_unicode)
-	    __out = __format::__write_escape_seq(__out, *__first, _Esc::_S_u());
+	    ___out = __format::__write_escape_seq(___out, *__first, _Esc::_S_u());
 	  else // __esc_replace
 	    for (_CharT __c : _Str_view(__first.base(), __first._M_units()))
-	      __out = __format::__write_escape_seq(__out,
+	      ___out = __format::__write_escape_seq(___out,
 						   static_cast<_UChar>(__c),
 						   _Esc::_S_x());
 	  __prev_esc = true;
 	  ++__first;
 
 	}
-      return __out;
+      return ___out;
     }
 
   template<typename _CharT, typename _Out>
     _Out
-    __write_escaped(_Out __out,  basic_string_view<_CharT> __str, _Term_char __term)
+    __write_escaped(_Out ___out,  basic_string_view<_CharT> __str, _Term_char __term)
     {
-      *__out = _Escapes<_CharT>::_S_term(__term);
-      ++__out;
+      *___out = _Escapes<_CharT>::_S_term(__term);
+      ++___out;
 
       if constexpr (__unicode::__literal_encoding_is_unicode<_CharT>())
-	__out = __format::__write_escaped_unicode(__out, __str, __term);
+	___out = __format::__write_escaped_unicode(___out, __str, __term);
       else if constexpr (is_same_v<char, _CharT>
 			  && __unicode::__literal_encoding_is_extended_ascii())
-	__out = __format::__write_escaped_ascii(__out, __str, __term);
+	___out = __format::__write_escaped_ascii(___out, __str, __term);
       else
 	// TODO Handle non-ascii extended encoding
-	__out = __format::__write_escaped_ascii(__out, __str, __term);
+	___out = __format::__write_escaped_ascii(___out, __str, __term);
 
-      *__out = _Escapes<_CharT>::_S_term(__term);
-      return ++__out;
+      *___out = _Escapes<_CharT>::_S_term(__term);
+      return ++___out;
     }
 
   // A lightweight optional<locale>.
@@ -1707,13 +1707,13 @@ namespace __format
 	{
 	  using _Esc = _Escapes<_CharT>;
 	  constexpr auto __term = __format::_Term_char::_Tc_apos;
-	  const basic_string_view<_CharT> __in(&__c, 1u);
+	  const basic_string_view<_CharT> ___in(&__c, 1u);
 	  if (_M_spec._M_get_width(__fc) <= 3u)
-	    return __format::__write_escaped(__fc.out(), __in, __term);
+	    return __format::__write_escaped(__fc.out(), ___in, __term);
 
 	  _CharT __buf[12];
 	  __format::_Fixedbuf_sink<_CharT> __sink(__buf);
-	  __format::__write_escaped(__sink.out(), __in, __term);
+	  __format::__write_escaped(__sink.out(), ___in, __term);
 
 	  const basic_string_view<_CharT> __escaped = __sink.view();
 	  size_t __estimated_width;
@@ -1800,7 +1800,7 @@ namespace __format
 	  _Align __align = _M_spec._M_align;
 
 	  size_t __nfill = __width - __str.size();
-	  auto __out = __fc.out();
+	  auto ___out = __fc.out();
 	  if (__align == _Align_default)
 	    {
 	      __align = _Align_right;
@@ -1810,7 +1810,7 @@ namespace __format
 		  // Write sign and base prefix before zero filling.
 		  if (__prefix_len != 0)
 		    {
-		      __out = __format::__write(std::move(__out),
+		      ___out = __format::__write(std::move(___out),
 						__str.substr(0, __prefix_len));
 		      __str.remove_prefix(__prefix_len);
 		    }
@@ -1818,7 +1818,7 @@ namespace __format
 	      else
 		__fill_char = _CharT(' ');
 	    }
-	  return __format::__write_padded(std::move(__out), __str,
+	  return __format::__write_padded(std::move(___out), __str,
 					  __align, __nfill, __fill_char);
 	}
 
@@ -2289,7 +2289,7 @@ namespace __format
 	  _Align __align = _M_spec._M_align;
 
 	  size_t __nfill = __width - __str.size();
-	  auto __out = __fc.out();
+	  auto ___out = __fc.out();
 	  if (__align == _Align_default)
 	    {
 	      __align = _Align_right;
@@ -2299,14 +2299,14 @@ namespace __format
 		  // Write sign before zero filling.
 		  if (!__format::__is_xdigit(__narrow_str[0]))
 		    {
-		      *__out++ = __str[0];
+		      *___out++ = __str[0];
 		      __str.remove_prefix(1);
 		    }
 		}
 	      else
 		__fill_char = _CharT(' ');
 	    }
-	  return __format::__write_padded(std::move(__out), __str,
+	  return __format::__write_padded(std::move(___out), __str,
 					  __align, __nfill, __fill_char);
 	}
 
@@ -2955,12 +2955,12 @@ namespace __format
 	      if (__width <= __str.size())
 		return __format::__write(__fc.out(), __str);
 
-	      auto __out = __fc.out();
+	      auto ___out = __fc.out();
 	      // Write "0x" or "0X" prefix before zero-filling.
-	      __out = __format::__write(std::move(__out), __str.substr(0, 2));
+	      ___out = __format::__write(std::move(___out), __str.substr(0, 2));
 	      __str.remove_prefix(2);
 	      size_t __nfill = __width - __n;
-	      return __format::__write_padded(std::move(__out), __str,
+	      return __format::__write_padded(std::move(___out), __str,
 					      __format::_Align_right,
 					      __nfill, _CharT('0'));
 	    }
@@ -3432,8 +3432,8 @@ namespace __format
     public:
       [[__gnu__::__always_inline__]]
       explicit
-      _Iter_sink(_OutIter __out, iter_difference_t<_OutIter> __max = -1)
-      : _M_out(std::move(__out)), _M_max(__max)
+      _Iter_sink(_OutIter ___out, iter_difference_t<_OutIter> __max = -1)
+      : _M_out(std::move(___out)), _M_max(__max)
       { }
 
       using _Sink<_CharT>::out;
@@ -3542,9 +3542,9 @@ namespace __format
 
     public:
       explicit
-      _Iter_sink(_OutIter __out, iter_difference_t<_OutIter> __n = -1) noexcept
-      : _Sink<_CharT>(_S_make_span(std::to_address(__out), __n, _M_buf)),
-	_M_first(__out), _M_max(__n)
+      _Iter_sink(_OutIter ___out, iter_difference_t<_OutIter> __n = -1) noexcept
+      : _Sink<_CharT>(_S_make_span(std::to_address(___out), __n, _M_buf)),
+	_M_first(___out), _M_max(__n)
       { }
 
       format_to_n_result<_OutIter>
@@ -4386,13 +4386,13 @@ namespace __format
       __format::_Optional_locale _M_loc;
 
       basic_format_context(basic_format_args<basic_format_context> __args,
-			   _Out __out)
-      : _M_args(__args), _M_out(std::move(__out))
+			   _Out ___out)
+      : _M_args(__args), _M_out(std::move(___out))
       { }
 
       basic_format_context(basic_format_args<basic_format_context> __args,
-			   _Out __out, const std::locale& __loc)
-      : _M_args(__args), _M_out(std::move(__out)), _M_loc(__loc)
+			   _Out ___out, const std::locale& __loc)
+      : _M_args(__args), _M_out(std::move(___out)), _M_loc(__loc)
       { }
 
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
@@ -4675,15 +4675,15 @@ namespace __format
 
   template<typename _Out, typename _CharT, typename _Context>
     inline _Out
-    __do_vformat_to(_Out __out, basic_string_view<_CharT> __fmt,
+    __do_vformat_to(_Out ___out, basic_string_view<_CharT> __fmt,
 		    const basic_format_args<_Context>& __args,
 		    const locale* __loc)
     {
-      _Iter_sink<_CharT, _Out> __sink(std::move(__out));
+      _Iter_sink<_CharT, _Out> __sink(std::move(___out));
       _Sink_iter<_CharT> __sink_out;
 
       if constexpr (is_same_v<_Out, _Sink_iter<_CharT>>)
-	__sink_out = __out; // Already a sink iterator, safe to use post-move.
+	__sink_out = ___out; // Already a sink iterator, safe to use post-move.
       else
 	__sink_out = __sink.out();
 
@@ -4815,34 +4815,34 @@ namespace __format
   template<typename _Out> requires output_iterator<_Out, const char&>
     [[__gnu__::__always_inline__]]
     inline _Out
-    vformat_to(_Out __out, string_view __fmt, format_args __args)
-    { return __format::__do_vformat_to(std::move(__out), __fmt, __args); }
+    vformat_to(_Out ___out, string_view __fmt, format_args __args)
+    { return __format::__do_vformat_to(std::move(___out), __fmt, __args); }
 
 #ifdef _GLIBCXX_USE_WCHAR_T
   template<typename _Out> requires output_iterator<_Out, const wchar_t&>
     [[__gnu__::__always_inline__]]
     inline _Out
-    vformat_to(_Out __out, wstring_view __fmt, wformat_args __args)
-    { return __format::__do_vformat_to(std::move(__out), __fmt, __args); }
+    vformat_to(_Out ___out, wstring_view __fmt, wformat_args __args)
+    { return __format::__do_vformat_to(std::move(___out), __fmt, __args); }
 #endif
 
   template<typename _Out> requires output_iterator<_Out, const char&>
     [[__gnu__::__always_inline__]]
     inline _Out
-    vformat_to(_Out __out, const locale& __loc, string_view __fmt,
+    vformat_to(_Out ___out, const locale& __loc, string_view __fmt,
 	       format_args __args)
     {
-      return __format::__do_vformat_to(std::move(__out), __fmt, __args, &__loc);
+      return __format::__do_vformat_to(std::move(___out), __fmt, __args, &__loc);
     }
 
 #ifdef _GLIBCXX_USE_WCHAR_T
   template<typename _Out> requires output_iterator<_Out, const wchar_t&>
     [[__gnu__::__always_inline__]]
     inline _Out
-    vformat_to(_Out __out, const locale& __loc, wstring_view __fmt,
+    vformat_to(_Out ___out, const locale& __loc, wstring_view __fmt,
 	       wformat_args __args)
     {
-      return __format::__do_vformat_to(std::move(__out), __fmt, __args, &__loc);
+      return __format::__do_vformat_to(std::move(___out), __fmt, __args, &__loc);
     }
 #endif
 
@@ -4925,9 +4925,9 @@ namespace __format
   template<typename _Out, typename... _Args>
     requires output_iterator<_Out, const char&>
     inline _Out
-    format_to(_Out __out, format_string<_Args...> __fmt, _Args&&... __args)
+    format_to(_Out ___out, format_string<_Args...> __fmt, _Args&&... __args)
     {
-      return std::vformat_to(std::move(__out), __fmt.get(),
+      return std::vformat_to(std::move(___out), __fmt.get(),
 			     std::make_format_args(__args...));
     }
 
@@ -4935,9 +4935,9 @@ namespace __format
   template<typename _Out, typename... _Args>
     requires output_iterator<_Out, const wchar_t&>
     inline _Out
-    format_to(_Out __out, wformat_string<_Args...> __fmt, _Args&&... __args)
+    format_to(_Out ___out, wformat_string<_Args...> __fmt, _Args&&... __args)
     {
-      return std::vformat_to(std::move(__out), __fmt.get(),
+      return std::vformat_to(std::move(___out), __fmt.get(),
 			     std::make_wformat_args(__args...));
     }
 #endif
@@ -4945,10 +4945,10 @@ namespace __format
   template<typename _Out, typename... _Args>
     requires output_iterator<_Out, const char&>
     inline _Out
-    format_to(_Out __out, const locale& __loc, format_string<_Args...> __fmt,
+    format_to(_Out ___out, const locale& __loc, format_string<_Args...> __fmt,
 	      _Args&&... __args)
     {
-      return std::vformat_to(std::move(__out), __loc, __fmt.get(),
+      return std::vformat_to(std::move(___out), __loc, __fmt.get(),
 			     std::make_format_args(__args...));
     }
 
@@ -4956,10 +4956,10 @@ namespace __format
   template<typename _Out, typename... _Args>
     requires output_iterator<_Out, const wchar_t&>
     inline _Out
-    format_to(_Out __out, const locale& __loc, wformat_string<_Args...> __fmt,
+    format_to(_Out ___out, const locale& __loc, wformat_string<_Args...> __fmt,
 	      _Args&&... __args)
     {
-      return std::vformat_to(std::move(__out), __loc, __fmt.get(),
+      return std::vformat_to(std::move(___out), __loc, __fmt.get(),
 			     std::make_wformat_args(__args...));
     }
 #endif
@@ -4967,10 +4967,10 @@ namespace __format
   template<typename _Out, typename... _Args>
     requires output_iterator<_Out, const char&>
     inline format_to_n_result<_Out>
-    format_to_n(_Out __out, iter_difference_t<_Out> __n,
+    format_to_n(_Out ___out, iter_difference_t<_Out> __n,
 		format_string<_Args...> __fmt, _Args&&... __args)
     {
-      __format::_Iter_sink<char, _Out> __sink(std::move(__out), __n);
+      __format::_Iter_sink<char, _Out> __sink(std::move(___out), __n);
       std::vformat_to(__sink.out(), __fmt.get(),
 		      std::make_format_args(__args...));
       return std::move(__sink)._M_finish();
@@ -4980,10 +4980,10 @@ namespace __format
   template<typename _Out, typename... _Args>
     requires output_iterator<_Out, const wchar_t&>
     inline format_to_n_result<_Out>
-    format_to_n(_Out __out, iter_difference_t<_Out> __n,
+    format_to_n(_Out ___out, iter_difference_t<_Out> __n,
 		wformat_string<_Args...> __fmt, _Args&&... __args)
     {
-      __format::_Iter_sink<wchar_t, _Out> __sink(std::move(__out), __n);
+      __format::_Iter_sink<wchar_t, _Out> __sink(std::move(___out), __n);
       std::vformat_to(__sink.out(), __fmt.get(),
 		      std::make_wformat_args(__args...));
       return std::move(__sink)._M_finish();
@@ -4993,10 +4993,10 @@ namespace __format
   template<typename _Out, typename... _Args>
     requires output_iterator<_Out, const char&>
     inline format_to_n_result<_Out>
-    format_to_n(_Out __out, iter_difference_t<_Out> __n, const locale& __loc,
+    format_to_n(_Out ___out, iter_difference_t<_Out> __n, const locale& __loc,
 		format_string<_Args...> __fmt, _Args&&... __args)
     {
-      __format::_Iter_sink<char, _Out> __sink(std::move(__out), __n);
+      __format::_Iter_sink<char, _Out> __sink(std::move(___out), __n);
       std::vformat_to(__sink.out(), __loc, __fmt.get(),
 		      std::make_format_args(__args...));
       return std::move(__sink)._M_finish();
@@ -5006,10 +5006,10 @@ namespace __format
   template<typename _Out, typename... _Args>
     requires output_iterator<_Out, const wchar_t&>
     inline format_to_n_result<_Out>
-    format_to_n(_Out __out, iter_difference_t<_Out> __n, const locale& __loc,
+    format_to_n(_Out ___out, iter_difference_t<_Out> __n, const locale& __loc,
 		wformat_string<_Args...> __fmt, _Args&&... __args)
     {
-      __format::_Iter_sink<wchar_t, _Out> __sink(std::move(__out), __n);
+      __format::_Iter_sink<wchar_t, _Out> __sink(std::move(___out), __n);
       std::vformat_to(__sink.out(), __loc, __fmt.get(),
 		      std::make_wformat_args(__args...));
       return std::move(__sink)._M_finish();
@@ -5636,23 +5636,23 @@ namespace __format
 	_M_format_elems(_Rg& __rg,
 			basic_format_context<_Out, _CharT>& __fc) const
 	{
-	  auto __out = __format::__write(__fc.out(), _M_open);
+	  auto ___out = __format::__write(__fc.out(), _M_open);
 
 	  auto __first = ranges::begin(__rg);
 	  auto const __last = ranges::end(__rg);
 	  if (__first == __last)
-	    return __format::__write(__out, _M_close);
+	    return __format::__write(___out, _M_close);
 
-	  __fc.advance_to(__out);
-	  __out = _M_fval.format(*__first, __fc);
+	  __fc.advance_to(___out);
+	  ___out = _M_fval.format(*__first, __fc);
 	  for (++__first; __first != __last; ++__first)
 	    {
-	      __out = __format::__write(__out, _M_sep);
-	      __fc.advance_to(__out);
-	      __out = _M_fval.format(*__first, __fc);
+	      ___out = __format::__write(___out, _M_sep);
+	      __fc.advance_to(___out);
+	      ___out = _M_fval.format(*__first, __fc);
 	    }
 
-	  return __format::__write(__out, _M_close);
+	  return __format::__write(___out, _M_close);
 	}
 
       __format::_Spec<_CharT> _M_spec{};
diff --git a/libstdc++-v3/include/std/istream b/libstdc++-v3/include/std/istream
index d5bb1876001..369cb67b834 100644
--- a/libstdc++-v3/include/std/istream
+++ b/libstdc++-v3/include/std/istream
@@ -833,7 +833,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   ///@{
   /**
    *  @brief  Character extractors
-   *  @param  __in  An input stream.
+   *  @param  ___in  An input stream.
    *  @param  __c  A character reference.
    *  @return  in
    *
@@ -844,17 +844,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   */
   template<typename _CharT, typename _Traits>
     basic_istream<_CharT, _Traits>&
-    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);
+    operator>>(basic_istream<_CharT, _Traits>& ___in, _CharT& __c);
 
   template<class _Traits>
     inline basic_istream<char, _Traits>&
-    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
-    { return (__in >> reinterpret_cast<char&>(__c)); }
+    operator>>(basic_istream<char, _Traits>& ___in, unsigned char& __c)
+    { return (___in >> reinterpret_cast<char&>(__c)); }
 
   template<class _Traits>
     inline basic_istream<char, _Traits>&
-    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
-    { return (__in >> reinterpret_cast<char&>(__c)); }
+    operator>>(basic_istream<char, _Traits>& ___in, signed char& __c)
+    { return (___in >> reinterpret_cast<char&>(__c)); }
   ///@}
 
 
@@ -867,9 +867,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   ///@{
   /**
    *  @brief  Character string extractors
-   *  @param  __in  An input stream.
+   *  @param  ___in  An input stream.
    *  @param  __s  A character array (or a pointer to an array before C++20).
-   *  @return  __in
+   *  @return  ___in
    *
    *  Behaves like one of the formatted arithmetic extractors described in
    *  `std::basic_istream`.  After constructing a sentry object with good
@@ -895,7 +895,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   template<typename _CharT, typename _Traits>
     __attribute__((__nonnull__(2), __access__(__write_only__, 2)))
     inline basic_istream<_CharT, _Traits>&
-    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
+    operator>>(basic_istream<_CharT, _Traits>& ___in, _CharT* __s)
     {
 #ifdef __OPTIMIZE__
       // Function inlining might make the buffer size known, allowing us to
@@ -906,22 +906,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  // There is not even space for the required null terminator.
 	  __glibcxx_assert(__n >= sizeof(_CharT));
 	  // No point calling __istream_extract, but still need to reset width.
-	  __in.width(0);
-	  __in.setstate(ios_base::failbit);
+	  ___in.width(0);
+	  ___in.setstate(ios_base::failbit);
 	}
       else if (__n != (size_t)-1)
 	{
 	  __n /= sizeof(_CharT);
-	  streamsize __w = __in.width();
-	  std::__istream_extract(__in, __s, __n);
-	  if (__in.good() && (__w <= 0 || __n < (size_t)__w))
+	  streamsize __w = ___in.width();
+	  std::__istream_extract(___in, __s, __n);
+	  if (___in.good() && (__w <= 0 || __n < (size_t)__w))
 	    {
 	      // Stopped extracting early to avoid overflowing the buffer,
 	      // but might have stopped anyway (and set eofbit) if at EOF.
-	      const typename _Traits::int_type __c = __in.rdbuf()->sgetc();
+	      const typename _Traits::int_type __c = ___in.rdbuf()->sgetc();
 	      const bool __eof = _Traits::eq_int_type(__c, _Traits::eof());
 	      if (__builtin_expect(__eof, true)) // Assume EOF, not overflow.
-		__in.setstate(ios_base::eofbit);
+		___in.setstate(ios_base::eofbit);
 	    }
 	}
       else
@@ -930,43 +930,43 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  // Buffer size is unknown, have to assume it's huge.
 	  streamsize __n = __gnu_cxx::__numeric_traits<streamsize>::__max;
 	  __n /= sizeof(_CharT);
-	  std::__istream_extract(__in, __s, __n);
+	  std::__istream_extract(___in, __s, __n);
 	}
-      return __in;
+      return ___in;
     }
 
   template<class _Traits>
     __attribute__((__nonnull__(2), __access__(__write_only__, 2)))
     inline basic_istream<char, _Traits>&
-    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
-    { return __in >> reinterpret_cast<char*>(__s); }
+    operator>>(basic_istream<char, _Traits>& ___in, unsigned char* __s)
+    { return ___in >> reinterpret_cast<char*>(__s); }
 
   template<class _Traits>
     __attribute__((__nonnull__(2), __access__(__write_only__, 2)))
     inline basic_istream<char, _Traits>&
-    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
-    { return __in >> reinterpret_cast<char*>(__s); }
+    operator>>(basic_istream<char, _Traits>& ___in, signed char* __s)
+    { return ___in >> reinterpret_cast<char*>(__s); }
 #else
   // _GLIBCXX_RESOLVE_LIB_DEFECTS
   // 2499. operator>>(istream&, char*) makes it hard to avoid buffer overflows
   template<typename _CharT, typename _Traits, size_t _Num>
     inline basic_istream<_CharT, _Traits>&
-    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT (&__s)[_Num])
+    operator>>(basic_istream<_CharT, _Traits>& ___in, _CharT (&__s)[_Num])
     {
       static_assert(_Num <= __gnu_cxx::__numeric_traits<streamsize>::__max);
-      std::__istream_extract(__in, __s, _Num);
-      return __in;
+      std::__istream_extract(___in, __s, _Num);
+      return ___in;
     }
 
   template<class _Traits, size_t _Num>
     inline basic_istream<char, _Traits>&
-    operator>>(basic_istream<char, _Traits>& __in, unsigned char (&__s)[_Num])
-    { return __in >> reinterpret_cast<char(&)[_Num]>(__s); }
+    operator>>(basic_istream<char, _Traits>& ___in, unsigned char (&__s)[_Num])
+    { return ___in >> reinterpret_cast<char(&)[_Num]>(__s); }
 
   template<class _Traits, size_t _Num>
     inline basic_istream<char, _Traits>&
-    operator>>(basic_istream<char, _Traits>& __in, signed char (&__s)[_Num])
-    { return __in >> reinterpret_cast<char(&)[_Num]>(__s); }
+    operator>>(basic_istream<char, _Traits>& ___in, signed char (&__s)[_Num])
+    { return ___in >> reinterpret_cast<char(&)[_Num]>(__s); }
 #endif
   ///@}
 
diff --git a/libstdc++-v3/include/std/ostream b/libstdc++-v3/include/std/ostream
index 644e568e882..a6bc22c5340 100644
--- a/libstdc++-v3/include/std/ostream
+++ b/libstdc++-v3/include/std/ostream
@@ -164,11 +164,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       {
 	__format::_Str_sink<char> __buf;
 	std::vformat_to(__buf.out(), __os.getloc(), __fmt, __args);
-	auto __out = __buf.view();
+	auto ___out = __buf.view();
 
 	__try
 	  {
-	    std::__ostream_write(__os, __out.data(), __out.size());
+	    std::__ostream_write(__os, ___out.data(), ___out.size());
 	  }
 	__catch(const __cxxabiv1::__forced_unwind&)
 	  {
@@ -193,7 +193,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       {
 	__format::_Str_sink<char> __buf;
 	std::vformat_to(__buf.out(), __os.getloc(), __fmt, __args);
-	auto __out = __buf.view();
+	auto ___out = __buf.view();
 
 	void* __open_terminal(streambuf*);
 	error_code __write_to_terminal(void*, span<char>);
@@ -221,7 +221,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	      {
 		if (__os.rdbuf()->pubsync() == -1)
 		  __err = ios::badbit;
-		else if (auto __e = __write_to_terminal(__term, __out))
+		else if (auto __e = __write_to_terminal(__term, ___out))
 		  if (__e != std::make_error_code(errc::illegal_byte_sequence))
 		    __err = ios::badbit;
 	      }
@@ -241,7 +241,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	// Otherwise just insert the string as vprint_nonunicode does.
 	__try
 	  {
-	    std::__ostream_write(__os, __out.data(), __out.size());
+	    std::__ostream_write(__os, ___out.data(), ___out.size());
 	  }
 	__catch(const __cxxabiv1::__forced_unwind&)
 	  {
diff --git a/libstdc++-v3/include/std/print b/libstdc++-v3/include/std/print
index ea1aaac4389..408dbce6840 100644
--- a/libstdc++-v3/include/std/print
+++ b/libstdc++-v3/include/std/print
@@ -58,8 +58,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   {
     __format::_Str_sink<char> __buf;
     std::vformat_to(__buf.out(), __fmt, __args);
-    auto __out = __buf.view();
-    if (std::fwrite(__out.data(), 1, __out.size(), __stream) != __out.size())
+    auto ___out = __buf.view();
+    if (std::fwrite(___out.data(), 1, ___out.size(), __stream) != ___out.size())
       __throw_system_error(EIO);
   }
 
@@ -73,18 +73,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #else
     __format::_Str_sink<char> __buf;
     std::vformat_to(__buf.out(), __fmt, __args);
-    auto __out = __buf.view();
+    auto ___out = __buf.view();
 
     void* __open_terminal(FILE*);
     error_code __write_to_terminal(void*, span<char>);
     // If stream refers to a terminal, write a native Unicode string to it.
     if (auto __term = __open_terminal(__stream))
       {
-	string __out = std::vformat(__fmt, __args);
+	string ___out = std::vformat(__fmt, __args);
 	error_code __e;
 	if (!std::fflush(__stream))
 	  {
-	    __e = __write_to_terminal(__term, __out);
+	    __e = __write_to_terminal(__term, ___out);
 	    if (!__e)
 	      return;
 	    if (__e == std::make_error_code(errc::illegal_byte_sequence))
@@ -96,7 +96,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       }
 
     // Otherwise just write the string to the file as vprint_nonunicode does.
-    if (std::fwrite(__out.data(), 1, __out.size(), __stream) != __out.size())
+    if (std::fwrite(___out.data(), 1, ___out.size(), __stream) != ___out.size())
       __throw_system_error(EIO);
 #endif
   }
diff --git a/libstdc++-v3/include/std/thread b/libstdc++-v3/include/std/thread
index d2f91ad8995..6953ae830ae 100644
--- a/libstdc++-v3/include/std/thread
+++ b/libstdc++-v3/include/std/thread
@@ -104,7 +104,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   template<class _CharT, class _Traits>
     inline basic_ostream<_CharT, _Traits>&
-    operator<<(basic_ostream<_CharT, _Traits>& __out, thread::id __id)
+    operator<<(basic_ostream<_CharT, _Traits>& ___out, thread::id __id)
     {
       // Convert non-void pointers to const void* for formatted output.
       using __output_type
@@ -113,9 +113,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			  thread::native_handle_type>;
 
       if (__id == thread::id())
-	return __out << "thread::id of a non-executing thread";
+	return ___out << "thread::id of a non-executing thread";
       else
-	return __out << static_cast<__output_type>(__id._M_thread);
+	return ___out << static_cast<__output_type>(__id._M_thread);
     }
   /// @}
 
diff --git a/libstdc++-v3/include/std/tuple b/libstdc++-v3/include/std/tuple
index 2e69af13a98..5d4a5667d56 100644
--- a/libstdc++-v3/include/std/tuple
+++ b/libstdc++-v3/include/std/tuple
@@ -325,35 +325,35 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
       template<typename... _UElements>
 	constexpr
-	_Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
-	: _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
-	  _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in))
+	_Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& ___in)
+	: _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(___in)),
+	  _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(___in))
 	{ }
 
       template<typename _UHead, typename... _UTails>
 	constexpr
-	_Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
+	_Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& ___in)
 	: _Inherited(std::move
-		     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
+		     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(___in))),
 	  _Base(std::forward<_UHead>
-		(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)))
+		(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(___in)))
 	{ }
 
 #if __cpp_lib_ranges_zip // >= C++23
       template<typename... _UElements>
 	constexpr
-	_Tuple_impl(_Tuple_impl<_Idx, _UElements...>& __in)
-	: _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
-	  _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in))
+	_Tuple_impl(_Tuple_impl<_Idx, _UElements...>& ___in)
+	: _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(___in)),
+	  _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(___in))
 	{ }
 
       template<typename _UHead, typename... _UTails>
 	constexpr
-	_Tuple_impl(const _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
+	_Tuple_impl(const _Tuple_impl<_Idx, _UHead, _UTails...>&& ___in)
 	: _Inherited(std::move
-		     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
+		     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(___in))),
 	  _Base(std::forward<const _UHead>
-		(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)))
+		(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(___in)))
 	{ }
 #endif // C++23
 
@@ -393,61 +393,61 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       template<typename _Alloc>
 	_GLIBCXX20_CONSTEXPR
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
-		    const _Tuple_impl& __in)
-	: _Inherited(__tag, __a, _M_tail(__in)),
-	  _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in))
+		    const _Tuple_impl& ___in)
+	: _Inherited(__tag, __a, _M_tail(___in)),
+	  _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(___in))
 	{ }
 
       template<typename _Alloc>
 	_GLIBCXX20_CONSTEXPR
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
-		    _Tuple_impl&& __in)
-	: _Inherited(__tag, __a, std::move(_M_tail(__in))),
+		    _Tuple_impl&& ___in)
+	: _Inherited(__tag, __a, std::move(_M_tail(___in))),
 	  _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
-		std::forward<_Head>(_M_head(__in)))
+		std::forward<_Head>(_M_head(___in)))
 	{ }
 
       template<typename _Alloc, typename _UHead, typename... _UTails>
 	_GLIBCXX20_CONSTEXPR
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
-		    const _Tuple_impl<_Idx, _UHead, _UTails...>& __in)
+		    const _Tuple_impl<_Idx, _UHead, _UTails...>& ___in)
 	: _Inherited(__tag, __a,
-		     _Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)),
+		     _Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(___in)),
 	  _Base(__use_alloc<_Head, _Alloc, const _UHead&>(__a),
-		_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))
+		_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(___in))
 	{ }
 
       template<typename _Alloc, typename _UHead, typename... _UTails>
 	_GLIBCXX20_CONSTEXPR
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
-		    _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
+		    _Tuple_impl<_Idx, _UHead, _UTails...>&& ___in)
 	: _Inherited(__tag, __a, std::move
-		     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
+		     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(___in))),
 	  _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
 		std::forward<_UHead>
-		(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)))
+		(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(___in)))
 	{ }
 
 #if __cpp_lib_ranges_zip // >= C++23
       template<typename _Alloc, typename _UHead, typename... _UTails>
 	constexpr
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
-		    _Tuple_impl<_Idx, _UHead, _UTails...>& __in)
+		    _Tuple_impl<_Idx, _UHead, _UTails...>& ___in)
 	: _Inherited(__tag, __a,
-		     _Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)),
+		     _Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(___in)),
 	  _Base(__use_alloc<_Head, _Alloc, _UHead&>(__a),
-		_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))
+		_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(___in))
 	{ }
 
       template<typename _Alloc, typename _UHead, typename... _UTails>
 	constexpr
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
-		    const _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
+		    const _Tuple_impl<_Idx, _UHead, _UTails...>&& ___in)
 	: _Inherited(__tag, __a, std::move
-		     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
+		     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(___in))),
 	  _Base(__use_alloc<_Head, _Alloc, const _UHead>(__a),
 		std::forward<const _UHead>
-		(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)))
+		(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(___in)))
 	{ }
 #endif // C++23
 
@@ -463,42 +463,42 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       template<typename... _UElements>
 	_GLIBCXX20_CONSTEXPR
 	void
-	_M_assign(const _Tuple_impl<_Idx, _UElements...>& __in)
+	_M_assign(const _Tuple_impl<_Idx, _UElements...>& ___in)
 	{
-	  _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
+	  _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(___in);
 	  _M_tail(*this)._M_assign(
-	      _Tuple_impl<_Idx, _UElements...>::_M_tail(__in));
+	      _Tuple_impl<_Idx, _UElements...>::_M_tail(___in));
 	}
 
       template<typename _UHead, typename... _UTails>
 	_GLIBCXX20_CONSTEXPR
 	void
-	_M_assign(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
+	_M_assign(_Tuple_impl<_Idx, _UHead, _UTails...>&& ___in)
 	{
 	  _M_head(*this) = std::forward<_UHead>
-	    (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
+	    (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(___in));
 	  _M_tail(*this)._M_assign(
-	      std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)));
+	      std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(___in)));
 	}
 
 #if __cpp_lib_ranges_zip // >= C++23
       template<typename... _UElements>
 	constexpr void
-	_M_assign(const _Tuple_impl<_Idx, _UElements...>& __in) const
+	_M_assign(const _Tuple_impl<_Idx, _UElements...>& ___in) const
 	{
-	  _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
+	  _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(___in);
 	  _M_tail(*this)._M_assign(
-	      _Tuple_impl<_Idx, _UElements...>::_M_tail(__in));
+	      _Tuple_impl<_Idx, _UElements...>::_M_tail(___in));
 	}
 
       template<typename _UHead, typename... _UTails>
 	constexpr void
-	_M_assign(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in) const
+	_M_assign(_Tuple_impl<_Idx, _UHead, _UTails...>&& ___in) const
 	{
 	  _M_head(*this) = std::forward<_UHead>
-	    (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
+	    (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(___in));
 	  _M_tail(*this)._M_assign(
-	      std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)));
+	      std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(___in)));
 	}
 #endif // C++23
 
@@ -523,20 +523,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     protected:
       _GLIBCXX20_CONSTEXPR
       void
-      _M_swap(_Tuple_impl& __in)
+      _M_swap(_Tuple_impl& ___in)
       {
 	using std::swap;
-	swap(_M_head(*this), _M_head(__in));
-	_Inherited::_M_swap(_M_tail(__in));
+	swap(_M_head(*this), _M_head(___in));
+	_Inherited::_M_swap(_M_tail(___in));
       }
 
 #if __cpp_lib_ranges_zip // >= C++23
       constexpr void
-      _M_swap(const _Tuple_impl& __in) const
+      _M_swap(const _Tuple_impl& ___in) const
       {
 	using std::swap;
-	swap(_M_head(*this), _M_head(__in));
-	_Inherited::_M_swap(_M_tail(__in));
+	swap(_M_head(*this), _M_head(___in));
+	_Inherited::_M_swap(_M_tail(___in));
       }
 #endif // C++23
     };
@@ -581,35 +581,35 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       _Tuple_impl(_Tuple_impl&&) = default;
 #else
       constexpr
-      _Tuple_impl(_Tuple_impl&& __in)
+      _Tuple_impl(_Tuple_impl&& ___in)
       noexcept(is_nothrow_move_constructible<_Head>::value)
-      : _Base(static_cast<_Base&&>(__in))
+      : _Base(static_cast<_Base&&>(___in))
       { }
 #endif
 
       template<typename _UHead>
 	constexpr
-	_Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
-	: _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in))
+	_Tuple_impl(const _Tuple_impl<_Idx, _UHead>& ___in)
+	: _Base(_Tuple_impl<_Idx, _UHead>::_M_head(___in))
 	{ }
 
       template<typename _UHead>
 	constexpr
-	_Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
-	: _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
+	_Tuple_impl(_Tuple_impl<_Idx, _UHead>&& ___in)
+	: _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(___in)))
 	{ }
 
 #if __cpp_lib_ranges_zip // >= C++23
       template<typename _UHead>
 	constexpr
-	_Tuple_impl(_Tuple_impl<_Idx, _UHead>& __in)
-	: _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in))
+	_Tuple_impl(_Tuple_impl<_Idx, _UHead>& ___in)
+	: _Base(_Tuple_impl<_Idx, _UHead>::_M_head(___in))
 	{ }
 
       template<typename _UHead>
 	constexpr
-	_Tuple_impl(const _Tuple_impl<_Idx, _UHead>&& __in)
-	: _Base(std::forward<const _UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
+	_Tuple_impl(const _Tuple_impl<_Idx, _UHead>&& ___in)
+	: _Base(std::forward<const _UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(___in)))
 	{ }
 #endif // C++23
 
@@ -645,49 +645,49 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       template<typename _Alloc>
 	_GLIBCXX20_CONSTEXPR
 	_Tuple_impl(allocator_arg_t, const _Alloc& __a,
-		    const _Tuple_impl& __in)
-	: _Base(__use_alloc<_Head, _Alloc, const _Head&>(__a), _M_head(__in))
+		    const _Tuple_impl& ___in)
+	: _Base(__use_alloc<_Head, _Alloc, const _Head&>(__a), _M_head(___in))
 	{ }
 
       template<typename _Alloc>
 	_GLIBCXX20_CONSTEXPR
 	_Tuple_impl(allocator_arg_t, const _Alloc& __a,
-		    _Tuple_impl&& __in)
+		    _Tuple_impl&& ___in)
 	: _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
-		std::forward<_Head>(_M_head(__in)))
+		std::forward<_Head>(_M_head(___in)))
 	{ }
 
       template<typename _Alloc, typename _UHead>
 	_GLIBCXX20_CONSTEXPR
 	_Tuple_impl(allocator_arg_t, const _Alloc& __a,
-		    const _Tuple_impl<_Idx, _UHead>& __in)
+		    const _Tuple_impl<_Idx, _UHead>& ___in)
 	: _Base(__use_alloc<_Head, _Alloc, const _UHead&>(__a),
-		_Tuple_impl<_Idx, _UHead>::_M_head(__in))
+		_Tuple_impl<_Idx, _UHead>::_M_head(___in))
 	{ }
 
       template<typename _Alloc, typename _UHead>
 	_GLIBCXX20_CONSTEXPR
 	_Tuple_impl(allocator_arg_t, const _Alloc& __a,
-		    _Tuple_impl<_Idx, _UHead>&& __in)
+		    _Tuple_impl<_Idx, _UHead>&& ___in)
 	: _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
-		std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
+		std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(___in)))
 	{ }
 
 #if __cpp_lib_ranges_zip // >= C++23
       template<typename _Alloc, typename _UHead>
 	constexpr
 	_Tuple_impl(allocator_arg_t, const _Alloc& __a,
-		    _Tuple_impl<_Idx, _UHead>& __in)
+		    _Tuple_impl<_Idx, _UHead>& ___in)
 	: _Base(__use_alloc<_Head, _Alloc, _UHead&>(__a),
-		_Tuple_impl<_Idx, _UHead>::_M_head(__in))
+		_Tuple_impl<_Idx, _UHead>::_M_head(___in))
 	{ }
 
       template<typename _Alloc, typename _UHead>
 	constexpr
 	_Tuple_impl(allocator_arg_t, const _Alloc& __a,
-		    const _Tuple_impl<_Idx, _UHead>&& __in)
+		    const _Tuple_impl<_Idx, _UHead>&& ___in)
 	: _Base(__use_alloc<_Head, _Alloc, const _UHead>(__a),
-		std::forward<const _UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
+		std::forward<const _UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(___in)))
 	{ }
 #endif // C++23
 
@@ -703,34 +703,34 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       template<typename _UHead>
 	_GLIBCXX20_CONSTEXPR
 	void
-	_M_assign(const _Tuple_impl<_Idx, _UHead>& __in)
+	_M_assign(const _Tuple_impl<_Idx, _UHead>& ___in)
 	{
-	  _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
+	  _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(___in);
 	}
 
       template<typename _UHead>
 	_GLIBCXX20_CONSTEXPR
 	void
-	_M_assign(_Tuple_impl<_Idx, _UHead>&& __in)
+	_M_assign(_Tuple_impl<_Idx, _UHead>&& ___in)
 	{
 	  _M_head(*this)
-	    = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
+	    = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(___in));
 	}
 
 #if __cpp_lib_ranges_zip // >= C++23
       template<typename _UHead>
 	constexpr void
-	_M_assign(const _Tuple_impl<_Idx, _UHead>& __in) const
+	_M_assign(const _Tuple_impl<_Idx, _UHead>& ___in) const
 	{
-	  _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
+	  _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(___in);
 	}
 
       template<typename _UHead>
 	constexpr void
-	_M_assign(_Tuple_impl<_Idx, _UHead>&& __in) const
+	_M_assign(_Tuple_impl<_Idx, _UHead>&& ___in) const
 	{
 	  _M_head(*this)
-	    = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
+	    = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(___in));
 	}
 #endif // C++23
 
@@ -749,18 +749,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     protected:
       _GLIBCXX20_CONSTEXPR
       void
-      _M_swap(_Tuple_impl& __in)
+      _M_swap(_Tuple_impl& ___in)
       {
 	using std::swap;
-	swap(_M_head(*this), _M_head(__in));
+	swap(_M_head(*this), _M_head(___in));
       }
 
 #if __cpp_lib_ranges_zip // >= C++23
       constexpr void
-      _M_swap(const _Tuple_impl& __in) const
+      _M_swap(const _Tuple_impl& ___in) const
       {
 	using std::swap;
-	swap(_M_head(*this), _M_head(__in));
+	swap(_M_head(*this), _M_head(___in));
       }
 #endif // C++23
     };
@@ -1508,9 +1508,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			   && !__use_other_ctor<const tuple<_UElements...>&>(),
 	       _ImplicitCtor<_Valid, const _UElements&...> = true>
 	constexpr
-	tuple(const tuple<_UElements...>& __in)
+	tuple(const tuple<_UElements...>& ___in)
 	noexcept(__nothrow_constructible<const _UElements&...>())
-	: _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
+	: _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(___in))
 	{ __glibcxx_no_dangling_refs(const _UElements&); }
 
       template<typename... _UElements,
@@ -1518,9 +1518,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			   && !__use_other_ctor<const tuple<_UElements...>&>(),
 	       _ExplicitCtor<_Valid, const _UElements&...> = false>
 	explicit constexpr
-	tuple(const tuple<_UElements...>& __in)
+	tuple(const tuple<_UElements...>& ___in)
 	noexcept(__nothrow_constructible<const _UElements&...>())
-	: _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
+	: _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(___in))
 	{ __glibcxx_no_dangling_refs(const _UElements&); }
 
       template<typename... _UElements,
@@ -1528,9 +1528,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			     && !__use_other_ctor<tuple<_UElements...>&&>(),
 	       _ImplicitCtor<_Valid, _UElements...> = true>
 	constexpr
-	tuple(tuple<_UElements...>&& __in)
+	tuple(tuple<_UElements...>&& ___in)
 	noexcept(__nothrow_constructible<_UElements...>())
-	: _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
+	: _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(___in))
 	{ __glibcxx_no_dangling_refs(_UElements&&); }
 
       template<typename... _UElements,
@@ -1538,9 +1538,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			     && !__use_other_ctor<tuple<_UElements...>&&>(),
 	       _ExplicitCtor<_Valid, _UElements...> = false>
 	explicit constexpr
-	tuple(tuple<_UElements...>&& __in)
+	tuple(tuple<_UElements...>&& ___in)
 	noexcept(__nothrow_constructible<_UElements...>())
-	: _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
+	: _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(___in))
 	{ __glibcxx_no_dangling_refs(_UElements&&); }
 
       // Allocator-extended constructors.
@@ -1594,13 +1594,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
       template<typename _Alloc>
 	_GLIBCXX20_CONSTEXPR
-	tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
-	: _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }
+	tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& ___in)
+	: _Inherited(__tag, __a, static_cast<const _Inherited&>(___in)) { }
 
       template<typename _Alloc>
 	_GLIBCXX20_CONSTEXPR
-	tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
-	: _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }
+	tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& ___in)
+	: _Inherited(__tag, __a, static_cast<_Inherited&&>(___in)) { }
 
       template<typename _Alloc, typename... _UElements,
 	       bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
@@ -1608,9 +1608,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	       _ImplicitCtor<_Valid, const _UElements&...> = true>
 	_GLIBCXX20_CONSTEXPR
 	tuple(allocator_arg_t __tag, const _Alloc& __a,
-	      const tuple<_UElements...>& __in)
+	      const tuple<_UElements...>& ___in)
 	: _Inherited(__tag, __a,
-		     static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
+		     static_cast<const _Tuple_impl<0, _UElements...>&>(___in))
 	{ __glibcxx_no_dangling_refs(const _UElements&); }
 
       template<typename _Alloc, typename... _UElements,
@@ -1620,9 +1620,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	_GLIBCXX20_CONSTEXPR
 	explicit
 	tuple(allocator_arg_t __tag, const _Alloc& __a,
-	      const tuple<_UElements...>& __in)
+	      const tuple<_UElements...>& ___in)
 	: _Inherited(__tag, __a,
-		     static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
+		     static_cast<const _Tuple_impl<0, _UElements...>&>(___in))
 	{ __glibcxx_no_dangling_refs(const _UElements&); }
 
       template<typename _Alloc, typename... _UElements,
@@ -1631,9 +1631,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	       _ImplicitCtor<_Valid, _UElements...> = true>
 	_GLIBCXX20_CONSTEXPR
 	tuple(allocator_arg_t __tag, const _Alloc& __a,
-	      tuple<_UElements...>&& __in)
+	      tuple<_UElements...>&& ___in)
 	: _Inherited(__tag, __a,
-		     static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
+		     static_cast<_Tuple_impl<0, _UElements...>&&>(___in))
 	{ __glibcxx_no_dangling_refs(_UElements&&); }
 
       template<typename _Alloc, typename... _UElements,
@@ -1643,9 +1643,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	_GLIBCXX20_CONSTEXPR
 	explicit
 	tuple(allocator_arg_t __tag, const _Alloc& __a,
-	      tuple<_UElements...>&& __in)
+	      tuple<_UElements...>&& ___in)
 	: _Inherited(__tag, __a,
-		     static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
+		     static_cast<_Tuple_impl<0, _UElements...>&&>(___in))
 	{ __glibcxx_no_dangling_refs(_UElements&&); }
 #endif // concepts && conditional_explicit
 
@@ -1905,10 +1905,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       tuple&
       operator=(__conditional_t<__assignable<const _Elements&...>(),
 				const tuple&,
-				const __nonesuch&> __in)
+				const __nonesuch&> ___in)
       noexcept(__nothrow_assignable<const _Elements&...>())
       {
-	this->_M_assign(__in);
+	this->_M_assign(___in);
 	return *this;
       }
 
@@ -1916,30 +1916,30 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       tuple&
       operator=(__conditional_t<__assignable<_Elements...>(),
 				tuple&&,
-				__nonesuch&&> __in)
+				__nonesuch&&> ___in)
       noexcept(__nothrow_assignable<_Elements...>())
       {
-	this->_M_assign(std::move(__in));
+	this->_M_assign(std::move(___in));
 	return *this;
       }
 
       template<typename... _UElements>
 	_GLIBCXX20_CONSTEXPR
 	__enable_if_t<__assignable<const _UElements&...>(), tuple&>
-	operator=(const tuple<_UElements...>& __in)
+	operator=(const tuple<_UElements...>& ___in)
 	noexcept(__nothrow_assignable<const _UElements&...>())
 	{
-	  this->_M_assign(__in);
+	  this->_M_assign(___in);
 	  return *this;
 	}
 
       template<typename... _UElements>
 	_GLIBCXX20_CONSTEXPR
 	__enable_if_t<__assignable<_UElements...>(), tuple&>
-	operator=(tuple<_UElements...>&& __in)
+	operator=(tuple<_UElements...>&& ___in)
 	noexcept(__nothrow_assignable<_UElements...>())
 	{
-	  this->_M_assign(std::move(__in));
+	  this->_M_assign(std::move(___in));
 	  return *this;
 	}
 #endif // concepts && consteval
@@ -1947,9 +1947,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       // tuple swap
       _GLIBCXX20_CONSTEXPR
       void
-      swap(tuple& __in)
+      swap(tuple& ___in)
       noexcept(__and_<__is_nothrow_swappable<_Elements>...>::value)
-      { _Inherited::_M_swap(__in); }
+      { _Inherited::_M_swap(___in); }
 
 #if __cpp_lib_ranges_zip // >= C++23
       // As an extension, we constrain the const swap member function in order
@@ -1959,10 +1959,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       // this function and yield a hard error.  This constraint shouldn't
       // affect the behavior of valid programs.
       constexpr void
-      swap(const tuple& __in) const
+      swap(const tuple& ___in) const
       noexcept(__and_v<__is_nothrow_swappable<const _Elements>...>)
       requires (is_swappable_v<const _Elements> && ...)
-      { _Inherited::_M_swap(__in); }
+      { _Inherited::_M_swap(___in); }
 #endif // C++23
     };
 
@@ -2135,67 +2135,67 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       template<typename _U1, typename _U2,
 	       _ImplicitCtor<true, const _U1&, const _U2&> = true>
 	constexpr
-	tuple(const tuple<_U1, _U2>& __in)
+	tuple(const tuple<_U1, _U2>& ___in)
 	noexcept(__nothrow_constructible<const _U1&, const _U2&>())
-	: _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
+	: _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(___in))
 	{ __glibcxx_no_dangling_refs(const _U1&, const _U2&); }
 
       template<typename _U1, typename _U2,
 	       _ExplicitCtor<true, const _U1&, const _U2&> = false>
 	explicit constexpr
-	tuple(const tuple<_U1, _U2>& __in)
+	tuple(const tuple<_U1, _U2>& ___in)
 	noexcept(__nothrow_constructible<const _U1&, const _U2&>())
-	: _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
+	: _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(___in))
 	{ __glibcxx_no_dangling_refs(const _U1&, const _U2&); }
 
       template<typename _U1, typename _U2,
 	       _ImplicitCtor<true, _U1, _U2> = true>
 	constexpr
-	tuple(tuple<_U1, _U2>&& __in)
+	tuple(tuple<_U1, _U2>&& ___in)
 	noexcept(__nothrow_constructible<_U1, _U2>())
-	: _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
+	: _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(___in))
 	{ __glibcxx_no_dangling_refs(_U1&&, _U2&&); }
 
       template<typename _U1, typename _U2,
 	       _ExplicitCtor<true, _U1, _U2> = false>
 	explicit constexpr
-	tuple(tuple<_U1, _U2>&& __in)
+	tuple(tuple<_U1, _U2>&& ___in)
 	noexcept(__nothrow_constructible<_U1, _U2>())
-	: _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
+	: _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(___in))
 	{ __glibcxx_no_dangling_refs(_U1&&, _U2&&); }
 
       template<typename _U1, typename _U2,
 	       _ImplicitCtor<true, const _U1&, const _U2&> = true>
 	constexpr
-	tuple(const pair<_U1, _U2>& __in)
+	tuple(const pair<_U1, _U2>& ___in)
 	noexcept(__nothrow_constructible<const _U1&, const _U2&>())
-	: _Inherited(__in.first, __in.second)
+	: _Inherited(___in.first, ___in.second)
 	{ __glibcxx_no_dangling_refs(const _U1&, const _U2&); }
 
       template<typename _U1, typename _U2,
 	       _ExplicitCtor<true, const _U1&, const _U2&> = false>
 	explicit constexpr
-	tuple(const pair<_U1, _U2>& __in)
+	tuple(const pair<_U1, _U2>& ___in)
 	noexcept(__nothrow_constructible<const _U1&, const _U2&>())
-	: _Inherited(__in.first, __in.second)
+	: _Inherited(___in.first, ___in.second)
 	{ __glibcxx_no_dangling_refs(const _U1&, const _U2&); }
 
       template<typename _U1, typename _U2,
 	       _ImplicitCtor<true, _U1, _U2> = true>
 	constexpr
-	tuple(pair<_U1, _U2>&& __in)
+	tuple(pair<_U1, _U2>&& ___in)
 	noexcept(__nothrow_constructible<_U1, _U2>())
-	: _Inherited(std::forward<_U1>(__in.first),
-		     std::forward<_U2>(__in.second))
+	: _Inherited(std::forward<_U1>(___in.first),
+		     std::forward<_U2>(___in.second))
 	{ __glibcxx_no_dangling_refs(_U1&&, _U2&&); }
 
       template<typename _U1, typename _U2,
 	       _ExplicitCtor<true, _U1, _U2> = false>
 	explicit constexpr
-	tuple(pair<_U1, _U2>&& __in)
+	tuple(pair<_U1, _U2>&& ___in)
 	noexcept(__nothrow_constructible<_U1, _U2>())
-	: _Inherited(std::forward<_U1>(__in.first),
-		     std::forward<_U2>(__in.second))
+	: _Inherited(std::forward<_U1>(___in.first),
+		     std::forward<_U2>(___in.second))
 	{ __glibcxx_no_dangling_refs(_U1&&, _U2&&); }
 
       // Allocator-extended constructors.
@@ -2248,21 +2248,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
       template<typename _Alloc>
 	_GLIBCXX20_CONSTEXPR
-	tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
-	: _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }
+	tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& ___in)
+	: _Inherited(__tag, __a, static_cast<const _Inherited&>(___in)) { }
 
       template<typename _Alloc>
 	_GLIBCXX20_CONSTEXPR
-	tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
-	: _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }
+	tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& ___in)
+	: _Inherited(__tag, __a, static_cast<_Inherited&&>(___in)) { }
 
       template<typename _Alloc, typename _U1, typename _U2,
 	       _ImplicitCtor<true, const _U1&, const _U2&> = true>
 	_GLIBCXX20_CONSTEXPR
 	tuple(allocator_arg_t __tag, const _Alloc& __a,
-	      const tuple<_U1, _U2>& __in)
+	      const tuple<_U1, _U2>& ___in)
 	: _Inherited(__tag, __a,
-		     static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
+		     static_cast<const _Tuple_impl<0, _U1, _U2>&>(___in))
 	{ __glibcxx_no_dangling_refs(const _U1&, const _U2&); }
 
       template<typename _Alloc, typename _U1, typename _U2,
@@ -2270,32 +2270,32 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	explicit
 	_GLIBCXX20_CONSTEXPR
 	tuple(allocator_arg_t __tag, const _Alloc& __a,
-	      const tuple<_U1, _U2>& __in)
+	      const tuple<_U1, _U2>& ___in)
 	: _Inherited(__tag, __a,
-		     static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
+		     static_cast<const _Tuple_impl<0, _U1, _U2>&>(___in))
 	{ __glibcxx_no_dangling_refs(const _U1&, const _U2&); }
 
       template<typename _Alloc, typename _U1, typename _U2,
 	       _ImplicitCtor<true, _U1, _U2> = true>
 	_GLIBCXX20_CONSTEXPR
-	tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
-	: _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
+	tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& ___in)
+	: _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(___in))
 	{ __glibcxx_no_dangling_refs(_U1&&, _U2&&); }
 
       template<typename _Alloc, typename _U1, typename _U2,
 	       _ExplicitCtor<true, _U1, _U2> = false>
 	explicit
 	_GLIBCXX20_CONSTEXPR
-	tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
-	: _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
+	tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& ___in)
+	: _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(___in))
 	{ __glibcxx_no_dangling_refs(_U1&&, _U2&&); }
 
       template<typename _Alloc, typename _U1, typename _U2,
 	       _ImplicitCtor<true, const _U1&, const _U2&> = true>
 	_GLIBCXX20_CONSTEXPR
 	tuple(allocator_arg_t __tag, const _Alloc& __a,
-	      const pair<_U1, _U2>& __in)
-	: _Inherited(__tag, __a, __in.first, __in.second)
+	      const pair<_U1, _U2>& ___in)
+	: _Inherited(__tag, __a, ___in.first, ___in.second)
 	{ __glibcxx_no_dangling_refs(const _U1&, const _U2&); }
 
       template<typename _Alloc, typename _U1, typename _U2,
@@ -2303,25 +2303,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	explicit
 	_GLIBCXX20_CONSTEXPR
 	tuple(allocator_arg_t __tag, const _Alloc& __a,
-	      const pair<_U1, _U2>& __in)
-	: _Inherited(__tag, __a, __in.first, __in.second)
+	      const pair<_U1, _U2>& ___in)
+	: _Inherited(__tag, __a, ___in.first, ___in.second)
 	{ __glibcxx_no_dangling_refs(const _U1&, const _U2&); }
 
       template<typename _Alloc, typename _U1, typename _U2,
 	       _ImplicitCtor<true, _U1, _U2> = true>
 	_GLIBCXX20_CONSTEXPR
-	tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
-	: _Inherited(__tag, __a, std::forward<_U1>(__in.first),
-		     std::forward<_U2>(__in.second))
+	tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& ___in)
+	: _Inherited(__tag, __a, std::forward<_U1>(___in.first),
+		     std::forward<_U2>(___in.second))
 	{ __glibcxx_no_dangling_refs(_U1&&, _U2&&); }
 
       template<typename _Alloc, typename _U1, typename _U2,
 	       _ExplicitCtor<true, _U1, _U2> = false>
 	explicit
 	_GLIBCXX20_CONSTEXPR
-	tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
-	: _Inherited(__tag, __a, std::forward<_U1>(__in.first),
-		     std::forward<_U2>(__in.second))
+	tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& ___in)
+	: _Inherited(__tag, __a, std::forward<_U1>(___in.first),
+		     std::forward<_U2>(___in.second))
 	{ __glibcxx_no_dangling_refs(_U1&&, _U2&&); }
 
       // Tuple assignment.
@@ -2330,10 +2330,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       tuple&
       operator=(__conditional_t<__assignable<const _T1&, const _T2&>(),
 				const tuple&,
-				const __nonesuch&> __in)
+				const __nonesuch&> ___in)
       noexcept(__nothrow_assignable<const _T1&, const _T2&>())
       {
-	this->_M_assign(__in);
+	this->_M_assign(___in);
 	return *this;
       }
 
@@ -2341,61 +2341,61 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       tuple&
       operator=(__conditional_t<__assignable<_T1, _T2>(),
 				tuple&&,
-				__nonesuch&&> __in)
+				__nonesuch&&> ___in)
       noexcept(__nothrow_assignable<_T1, _T2>())
       {
-	this->_M_assign(std::move(__in));
+	this->_M_assign(std::move(___in));
 	return *this;
       }
 
       template<typename _U1, typename _U2>
 	_GLIBCXX20_CONSTEXPR
 	__enable_if_t<__assignable<const _U1&, const _U2&>(), tuple&>
-	operator=(const tuple<_U1, _U2>& __in)
+	operator=(const tuple<_U1, _U2>& ___in)
 	noexcept(__nothrow_assignable<const _U1&, const _U2&>())
 	{
-	  this->_M_assign(__in);
+	  this->_M_assign(___in);
 	  return *this;
 	}
 
       template<typename _U1, typename _U2>
 	_GLIBCXX20_CONSTEXPR
 	__enable_if_t<__assignable<_U1, _U2>(), tuple&>
-	operator=(tuple<_U1, _U2>&& __in)
+	operator=(tuple<_U1, _U2>&& ___in)
 	noexcept(__nothrow_assignable<_U1, _U2>())
 	{
-	  this->_M_assign(std::move(__in));
+	  this->_M_assign(std::move(___in));
 	  return *this;
 	}
 
       template<typename _U1, typename _U2>
 	_GLIBCXX20_CONSTEXPR
 	__enable_if_t<__assignable<const _U1&, const _U2&>(), tuple&>
-	operator=(const pair<_U1, _U2>& __in)
+	operator=(const pair<_U1, _U2>& ___in)
 	noexcept(__nothrow_assignable<const _U1&, const _U2&>())
 	{
-	  this->_M_head(*this) = __in.first;
-	  this->_M_tail(*this)._M_head(*this) = __in.second;
+	  this->_M_head(*this) = ___in.first;
+	  this->_M_tail(*this)._M_head(*this) = ___in.second;
 	  return *this;
 	}
 
       template<typename _U1, typename _U2>
 	_GLIBCXX20_CONSTEXPR
 	__enable_if_t<__assignable<_U1, _U2>(), tuple&>
-	operator=(pair<_U1, _U2>&& __in)
+	operator=(pair<_U1, _U2>&& ___in)
 	noexcept(__nothrow_assignable<_U1, _U2>())
 	{
-	  this->_M_head(*this) = std::forward<_U1>(__in.first);
-	  this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
+	  this->_M_head(*this) = std::forward<_U1>(___in.first);
+	  this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(___in.second);
 	  return *this;
 	}
 
       _GLIBCXX20_CONSTEXPR
       void
-      swap(tuple& __in)
+      swap(tuple& ___in)
       noexcept(__and_<__is_nothrow_swappable<_T1>,
 		      __is_nothrow_swappable<_T2>>::value)
-      { _Inherited::_M_swap(__in); }
+      { _Inherited::_M_swap(___in); }
     };
 #endif // concepts && conditional_explicit
 
diff --git a/libstdc++-v3/include/tr1/regex b/libstdc++-v3/include/tr1/regex
index c120a3f5f7e..a99b2659467 100644
--- a/libstdc++-v3/include/tr1/regex
+++ b/libstdc++-v3/include/tr1/regex
@@ -2009,7 +2009,7 @@ namespace regex_constants
        */
       template<typename _Out_iter>
         _Out_iter
-        format(_Out_iter __out, const string_type& __fmt,
+        format(_Out_iter ___out, const string_type& __fmt,
 	       regex_constants::match_flag_type __flags
 	       = regex_constants::format_default) const;
 
@@ -2405,7 +2405,7 @@ namespace regex_constants
   template<typename _Out_iter, typename _Bi_iter,
 	   typename _Rx_traits, typename _Ch_type>
     inline _Out_iter
-    regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,
+    regex_replace(_Out_iter ___out, _Bi_iter __first, _Bi_iter __last,
 		  const basic_regex<_Ch_type, _Rx_traits>& __e,
 		  const basic_string<_Ch_type>& __fmt,
 		  regex_constants::match_flag_type __flags
diff --git a/libstdc++-v3/include/tr1/tuple b/libstdc++-v3/include/tr1/tuple
index e793d55673a..bdcc933ed02 100644
--- a/libstdc++-v3/include/tr1/tuple
+++ b/libstdc++-v3/include/tr1/tuple
@@ -109,26 +109,26 @@ namespace tr1
       : _Inherited(__tail...), _M_head(__head) { }
 
       template<typename... _UElements>
-      _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
-      : _Inherited(__in._M_tail()), _M_head(__in._M_head) { }
+      _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& ___in)
+      : _Inherited(___in._M_tail()), _M_head(___in._M_head) { }
 
-      _Tuple_impl(const _Tuple_impl& __in)
-      : _Inherited(__in._M_tail()), _M_head(__in._M_head) { }
+      _Tuple_impl(const _Tuple_impl& ___in)
+      : _Inherited(___in._M_tail()), _M_head(___in._M_head) { }
      
       template<typename... _UElements>
         _Tuple_impl&
-        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)
+        operator=(const _Tuple_impl<_Idx, _UElements...>& ___in)
         {
-	  _M_head = __in._M_head;
-	  _M_tail() = __in._M_tail();
+	  _M_head = ___in._M_head;
+	  _M_tail() = ___in._M_tail();
 	  return *this;
 	}
 
       _Tuple_impl&
-      operator=(const _Tuple_impl& __in)
+      operator=(const _Tuple_impl& ___in)
       {
-	_M_head = __in._M_head;
-	_M_tail() = __in._M_tail();
+	_M_head = ___in._M_head;
+	_M_tail() = ___in._M_tail();
 	return *this;
       }
     };
@@ -146,24 +146,24 @@ namespace tr1
       : _Inherited(__elements...) { }
 
       template<typename... _UElements>
-        tuple(const tuple<_UElements...>& __in)
-	: _Inherited(__in) { }
+        tuple(const tuple<_UElements...>& ___in)
+	: _Inherited(___in) { }
 
-      tuple(const tuple& __in)
-      : _Inherited(__in) { }
+      tuple(const tuple& ___in)
+      : _Inherited(___in) { }
 
       template<typename... _UElements>
         tuple&
-        operator=(const tuple<_UElements...>& __in)
+        operator=(const tuple<_UElements...>& ___in)
         {
-	  static_cast<_Inherited&>(*this) = __in;
+	  static_cast<_Inherited&>(*this) = ___in;
 	  return *this;
 	}
 
       tuple&
-      operator=(const tuple& __in)
+      operator=(const tuple& ___in)
       {
-	static_cast<_Inherited&>(*this) = __in;
+	static_cast<_Inherited&>(*this) = ___in;
 	return *this;
       }
     };
@@ -185,41 +185,41 @@ namespace tr1
       : _Inherited(__a1, __a2) { }
 
       template<typename _U1, typename _U2>
-        tuple(const tuple<_U1, _U2>& __in)
-	: _Inherited(__in) { }
+        tuple(const tuple<_U1, _U2>& ___in)
+	: _Inherited(___in) { }
 
-      tuple(const tuple& __in)
-      : _Inherited(__in) { }
+      tuple(const tuple& ___in)
+      : _Inherited(___in) { }
 
       template<typename _U1, typename _U2>
-        tuple(const pair<_U1, _U2>& __in)
+        tuple(const pair<_U1, _U2>& ___in)
 	: _Inherited(_Tuple_impl<0, 
 		     typename __add_c_ref<_U1>::type,
-		     typename __add_c_ref<_U2>::type>(__in.first, 
-						      __in.second))
+		     typename __add_c_ref<_U2>::type>(___in.first, 
+						      ___in.second))
         { }
   
       template<typename _U1, typename _U2>
         tuple&
-        operator=(const tuple<_U1, _U2>& __in)
+        operator=(const tuple<_U1, _U2>& ___in)
         {
-	  static_cast<_Inherited&>(*this) = __in;
+	  static_cast<_Inherited&>(*this) = ___in;
 	  return *this;
 	}
 
       tuple&
-      operator=(const tuple& __in)
+      operator=(const tuple& ___in)
       {
-	static_cast<_Inherited&>(*this) = __in;
+	static_cast<_Inherited&>(*this) = ___in;
 	return *this;
       }
 
       template<typename _U1, typename _U2>
         tuple&
-        operator=(const pair<_U1, _U2>& __in)
+        operator=(const pair<_U1, _U2>& ___in)
         {
-	  this->_M_head = __in.first;
-	  this->_M_tail()._M_head = __in.second;
+	  this->_M_head = ___in.first;
+	  this->_M_tail()._M_head = ___in.second;
 	  return *this;
 	}
     };
diff --git a/libstdc++-v3/include/tr1/utility b/libstdc++-v3/include/tr1/utility
index 7fe76c24de7..f80a50dd338 100644
--- a/libstdc++-v3/include/tr1/utility
+++ b/libstdc++-v3/include/tr1/utility
@@ -97,13 +97,13 @@ namespace tr1
 
   template<int _Int, class _Tp1, class _Tp2>
     inline typename tuple_element<_Int, std::pair<_Tp1, _Tp2> >::type&
-    get(std::pair<_Tp1, _Tp2>& __in)
-    { return __pair_get<_Int>::__get(__in); }
+    get(std::pair<_Tp1, _Tp2>& ___in)
+    { return __pair_get<_Int>::__get(___in); }
 
   template<int _Int, class _Tp1, class _Tp2>
     inline const typename tuple_element<_Int, std::pair<_Tp1, _Tp2> >::type&
-    get(const std::pair<_Tp1, _Tp2>& __in)
-    { return __pair_get<_Int>::__const_get(__in); }
+    get(const std::pair<_Tp1, _Tp2>& ___in)
+    { return __pair_get<_Int>::__const_get(___in); }
 }
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/tr2/bool_set b/libstdc++-v3/include/tr2/bool_set
index c003ace5a42..be625204deb 100644
--- a/libstdc++-v3/include/tr2/bool_set
+++ b/libstdc++-v3/include/tr2/bool_set
@@ -133,18 +133,18 @@ namespace tr2
 
     template<typename CharT, typename Traits>
       friend std::basic_ostream<CharT, Traits>&
-      operator<<(std::basic_ostream<CharT, Traits>& __out, bool_set __b)
+      operator<<(std::basic_ostream<CharT, Traits>& ___out, bool_set __b)
       {
 	int __a = __b._M_b;
-	__out << __a;
+	___out << __a;
       }
 
     template<typename CharT, typename Traits>
       friend std::basic_istream<CharT, Traits>&
-      operator>>(std::basic_istream<CharT, Traits>& __in, bool_set& __b)
+      operator>>(std::basic_istream<CharT, Traits>& ___in, bool_set& __b)
       {
 	long __c;
-	__in >> __c;
+	___in >> __c;
 	if (__c >= _S_false && __c < _S_empty)
 	  __b._M_b = static_cast<_Bool_set_val>(__c);
       }
diff --git a/libstdc++-v3/include/tr2/bool_set.tcc b/libstdc++-v3/include/tr2/bool_set.tcc
index 111fcb635ff..0a4e8d14d78 100644
--- a/libstdc++-v3/include/tr2/bool_set.tcc
+++ b/libstdc++-v3/include/tr2/bool_set.tcc
@@ -102,9 +102,9 @@ _GLIBCXX_END_NAMESPACE_VERSION
        *  @param  v  Value to format and insert.
        *  @return  Iterator after reading.
       iter_type
-      get(iter_type __in, iter_type __end, ios_base& __io,
+      get(iter_type ___in, iter_type __end, ios_base& __io,
 	  ios_base::iostate& __err, bool& __v) const
-      { return this->do_get(__in, __end, __io, __err, __v); }
+      { return this->do_get(___in, __end, __io, __err, __v); }
        */
 /*
   template<typename _CharT, typename _InIter>
diff --git a/libstdc++-v3/src/c++11/shared_ptr.cc b/libstdc++-v3/src/c++11/shared_ptr.cc
index 10364198f69..7153dedba27 100644
--- a/libstdc++-v3/src/c++11/shared_ptr.cc
+++ b/libstdc++-v3/src/c++11/shared_ptr.cc
@@ -34,7 +34,7 @@ namespace __gnu_internal _GLIBCXX_VISIBILITY(hidden)
   __gnu_cxx::__mutex&
   get_mutex(unsigned char i)
   {
-#ifdef _GLIBCXX_CAN_ALIGNAS_DESTRUCTIVE_SIZE
+#if defined(_GLIBCXX_CAN_ALIGNAS_DESTRUCTIVE_SIZE) && !defined(__mc68000__)
     // Increase alignment to put each lock on a separate cache line.
     struct alignas(__GCC_DESTRUCTIVE_SIZE) M : __gnu_cxx::__mutex { };
 #else
diff --git a/libstdc++-v3/src/c++17/fast_float/fast_float.h b/libstdc++-v3/src/c++17/fast_float/fast_float.h
index 3da58f2850c..6e5b62d2f72 100644
--- a/libstdc++-v3/src/c++17/fast_float/fast_float.h
+++ b/libstdc++-v3/src/c++17/fast_float/fast_float.h
@@ -102,7 +102,7 @@ from_chars_result from_chars_advanced(const char *first, const char *last,
 #define FASTFLOAT_64BIT 1
 #elif (defined(__i386) || defined(__i386__) || defined(_M_IX86)   \
      || defined(__arm__) || defined(_M_ARM)                   \
-     || defined(__MINGW32__) || defined(__EMSCRIPTEN__))
+     || defined(__MINGW32__) || defined(__EMSCRIPTEN__) || defined(__m68k__))
 #define FASTFLOAT_32BIT 1
 #else
   // Need to check incrementally, since SIZE_MAX is a size_t, avoid overflow.
@@ -2563,7 +2563,7 @@ void round_nearest_tie_even(adjusted_mantissa& am, int32_t shift, callback cb) n
   uint64_t mask;
   uint64_t halfway;
   if (shift == 64) {
-    mask = UINT64_MAX;
+    mask = 0xFFFFFFFFFFFFFFFFULL;
   } else {
     mask = (uint64_t(1) << shift) - 1;
   }
diff --git a/libstdc++-v3/src/c++17/ryu/common.h b/libstdc++-v3/src/c++17/ryu/common.h
index f8ee147db04..c9b966aecaa 100644
--- a/libstdc++-v3/src/c++17/ryu/common.h
+++ b/libstdc++-v3/src/c++17/ryu/common.h
@@ -18,7 +18,7 @@
 #define RYU_COMMON_H
 
 
-#if defined(_M_IX86) || defined(_M_ARM)
+#if defined(_M_IX86) || defined(_M_ARM) || defined(__m68k__)
 #define RYU_32_BIT_PLATFORM
 #endif
 
diff --git a/libstdc++-v3/src/c++98/math_stubs_float.cc b/libstdc++-v3/src/c++98/math_stubs_float.cc
index f4ef81663de..0f10be7c76e 100644
--- a/libstdc++-v3/src/c++98/math_stubs_float.cc
+++ b/libstdc++-v3/src/c++98/math_stubs_float.cc
@@ -28,10 +28,12 @@
 // we use the following crude approximations. We keep saying that we'll do
 // better later, but never do.
 
+#define WEAK __attribute__((weak))
+
 extern "C"
 {
 #ifndef _GLIBCXX_HAVE_FABSF
-  float
+  float WEAK
   fabsf(float x)
   {
     return (float) fabs(x);
@@ -39,7 +41,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_ACOSF
-  float
+  float WEAK
   acosf(float x)
   {
     return (float) acos(x);
@@ -47,7 +49,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_ASINF
-  float
+  float WEAK
   asinf(float x)
   {
     return (float) asin(x);
@@ -55,7 +57,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_ATANF
-  float
+  float WEAK
   atanf(float x)
   {
     return (float) atan(x);
@@ -63,7 +65,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_ATAN2F
-  float
+  float WEAK
   atan2f(float x, float y)
   {
     return (float) atan2(x, y);
@@ -71,7 +73,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_CEILF
-  float
+  float WEAK
   ceilf(float x)
   {
     return (float) ceil(x);
@@ -79,7 +81,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_COSF
-  float
+  float WEAK
   cosf(float x)
   {
     return (float) cos(x);
@@ -87,7 +89,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_COSHF
-  float
+  float WEAK
   coshf(float x)
   {
     return (float) cosh(x);
@@ -95,7 +97,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_EXPF
-  float
+  float WEAK
   expf(float x)
   {
     return (float) exp(x);
@@ -103,7 +105,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_FLOORF
-  float
+  float WEAK
   floorf(float x)
   {
     return (float) floor(x);
@@ -111,7 +113,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_FMODF
-  float
+  float WEAK
   fmodf(float x, float y)
   {
     return (float) fmod(x, y);
@@ -119,7 +121,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_FREXPF
-  float
+  float WEAK
   frexpf(float x, int *exp)
   {
     return (float) frexp(x, exp);
@@ -127,7 +129,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_SQRTF
-  float
+  float WEAK
   sqrtf(float x)
   {
     return (float) sqrt(x);
@@ -135,7 +137,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_HYPOTF
-  float
+  float WEAK
   hypotf(float x, float y)
   {
     float s = fabsf(x) + fabsf(y);
@@ -147,7 +149,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_LDEXPF
-  float
+  float WEAK
   ldexpf(float x, int exp)
   {
     return (float) ldexp(x, exp);
@@ -155,7 +157,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_LOGF
-  float
+  float WEAK
   logf(float x)
   {
     return (float) log(x);
@@ -163,7 +165,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_LOG10F
-  float
+  float WEAK
   log10f(float x)
   {
     return (float) log10(x);
@@ -171,7 +173,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_MODFF
-  float
+  float WEAK
   modff(float x, float *iptr)
   {
     double result, temp;
@@ -183,7 +185,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_POWF
-  float
+  float WEAK
   powf(float x, float y)
   {
     return (float) pow(x, y);
@@ -191,7 +193,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_SINF
-  float
+  float WEAK
   sinf(float x)
   {
     return (float) sin(x);
@@ -199,7 +201,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_SINHF
-  float
+  float WEAK
   sinhf(float x)
   {
     return (float) sinh(x);
@@ -207,7 +209,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_TANF
-  float
+  float WEAK
   tanf(float x)
   {
     return (float) tan(x);
@@ -215,7 +217,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_TANHF
-  float
+  float WEAK
   tanhf(float x)
   {
     return (float) tanh(x);
diff --git a/libstdc++-v3/src/c++98/math_stubs_long_double.cc b/libstdc++-v3/src/c++98/math_stubs_long_double.cc
index fd3107c2902..9637a6f132a 100644
--- a/libstdc++-v3/src/c++98/math_stubs_long_double.cc
+++ b/libstdc++-v3/src/c++98/math_stubs_long_double.cc
@@ -28,10 +28,12 @@
 // we use the following crude approximations. We keep saying that we'll do
 // better later, but never do.
 
+#define WEAK __attribute__((weak))
+
 extern "C"
 {
 #ifndef _GLIBCXX_HAVE_FABSL
-  long double
+  long double WEAK
   fabsl(long double x)
   {
     return fabs((double) x);
@@ -39,7 +41,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_ACOSL
-  long double
+  long double WEAK
   acosl(long double x)
   {
     return acos((double) x);
@@ -47,7 +49,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_ASINL
-  long double
+  long double WEAK
   asinl(long double x)
   {
     return asin((double) x);
@@ -55,7 +57,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_ATANL
-  long double
+  long double WEAK
   atanl(long double x)
   {
     return atan ((double) x);
@@ -63,7 +65,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_ATAN2L
-  long double
+  long double WEAK
   atan2l(long double x, long double y)
   {
     return atan2((double) x, (double) y);
@@ -71,7 +73,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_CEILL
-  long double
+  long double WEAK
   ceill(long double x)
   {
     return ceil((double) x);
@@ -79,7 +81,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_COSL
-  long double
+  long double WEAK
   cosl(long double x)
   {
     return cos((double) x);
@@ -87,7 +89,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_COSHL
-  long double
+  long double WEAK
   coshl(long double x)
   {
     return cosh((double) x);
@@ -95,7 +97,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_EXPL
-  long double
+  long double WEAK
   expl(long double x)
   {
     return exp((double) x);
@@ -103,7 +105,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_FLOORL
-  long double
+  long double WEAK
   floorl(long double x)
   {
     return floor((double) x);
@@ -111,7 +113,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_FMODL
-  long double
+  long double WEAK
   fmodl(long double x, long double y)
   {
     return fmod((double) x, (double) y);
@@ -119,7 +121,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_FREXPL
-  long double
+  long double WEAK
   frexpl(long double x, int *exp)
   {
     return frexp((double) x, exp);
@@ -127,7 +129,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_SQRTL
-  long double
+  long double WEAK
   sqrtl(long double x)
   {
     return  sqrt((double) x);
@@ -135,7 +137,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_HYPOTL
-  long double
+  long double WEAK
   hypotl(long double x, long double y)
   {
     long double s = fabsl(x) + fabsl(y);
@@ -147,7 +149,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_LDEXPL
-  long double
+  long double WEAK
   ldexpl(long double x, int exp)
   {
     return ldexp((double) x, exp);
@@ -155,7 +157,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_LOGL
-  long double
+  long double WEAK
   logl(long double x)
   {
     return log((double) x);
@@ -163,7 +165,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_LOG10L
-  long double
+  long double WEAK
   log10l(long double x)
   {
     return log10((double) x);
@@ -171,7 +173,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_MODFL
-  long double
+  long double WEAK
   modfl(long double x, long double *iptr)
   {
     double result, temp;
@@ -183,7 +185,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_POWL
-  long double
+  long double WEAK
   powl(long double x, long double y)
   {
     return pow((double) x, (double) y);
@@ -191,7 +193,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_SINL
-  long double
+  long double WEAK
   sinl(long double x)
   {
     return sin((double) x);
@@ -199,7 +201,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_SINHL
-  long double
+  long double WEAK
   sinhl(long double x)
   {
     return sinh((double) x);
@@ -207,7 +209,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_TANL
-  long double
+  long double WEAK
   tanl(long double x)
   {
     return tan((double) x);
@@ -215,7 +217,7 @@ extern "C"
 #endif
 
 #ifndef _GLIBCXX_HAVE_TANHL
-  long double
+  long double WEAK
   tanhl(long double x)
   {
     return tanh((double) x);
diff --git a/libstdc++-v3/src/filesystem/ops-common.h b/libstdc++-v3/src/filesystem/ops-common.h
index 4feacfdb932..877e5aea395 100644
--- a/libstdc++-v3/src/filesystem/ops-common.h
+++ b/libstdc++-v3/src/filesystem/ops-common.h
@@ -264,7 +264,7 @@ namespace __gnu_posix
   file_time(const stat_type& st, std::error_code& ec) noexcept
   {
     using namespace std::chrono;
-#ifdef _GLIBCXX_USE_ST_MTIM
+#if defined(_GLIBCXX_USE_ST_MTIM) && !defined(__MINT__)
     time_t s = st.st_mtim.tv_sec;
     nanoseconds ns{st.st_mtim.tv_nsec};
 #else
diff --git a/libtool.m4 b/libtool.m4
index add2d4a1e23..6d340c0d837 100644
--- a/libtool.m4
+++ b/libtool.m4
@@ -1592,6 +1592,12 @@ AC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
+  mint*)
+    # On MiNT this test can take minutes to run, and I'm not sure it's
+    # healthy for this platform. Let's restrict it to 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
   netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
     # This has been around since 386BSD, at least.  Likely further.
     if test -x /sbin/sysctl; then
@@ -1807,7 +1813,7 @@ else
     lt_cv_dlopen_self=yes
     ;;
 
-  mingw* | pw32* | cegcc*)
+  mingw* | msys* | pw32* | cegcc*)
     lt_cv_dlopen="LoadLibrary"
     lt_cv_dlopen_libs=
     ;;
@@ -2283,14 +2289,14 @@ bsdi[[45]]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -2314,7 +2320,7 @@ cygwin* | mingw* | pw32* | cegcc*)
 m4_if([$1], [],[
       sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"])
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -2934,7 +2940,7 @@ if test "$GCC" = yes; then
   # Check if gcc -print-prog-name=ld gives a path.
   AC_MSG_CHECKING([for ld used by $CC])
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -4509,7 +4515,7 @@ _LT_EOF
       fi
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,
       # as there is no search path for DLLs.
       _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
@@ -4882,7 +4888,7 @@ _LT_EOF
       _LT_TAGVAR(export_dynamic_flag_spec, $1)=-rdynamic
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # When not using gcc, we currently assume that we are using
       # Microsoft Visual C++.
       # hardcode_libdir_flag_spec is actually meaningless, as there is
@@ -5826,7 +5832,7 @@ if test "$_lt_caught_CXX_error" != yes; then
         esac
         ;;
 
-      cygwin* | mingw* | pw32* | cegcc*)
+      cygwin* | mingw* | msys* | pw32* | cegcc*)
         # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,
         # as there is no search path for DLLs.
         _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
diff --git a/libvtv/configure b/libvtv/configure
index a7889161c50..2b70f267207 100755
--- a/libvtv/configure
+++ b/libvtv/configure
@@ -6466,7 +6466,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -10042,7 +10042,7 @@ _LT_EOF
       fi
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
       # as there is no search path for DLLs.
       hardcode_libdir_flag_spec='-L$libdir'
@@ -10473,7 +10473,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
       export_dynamic_flag_spec=-rdynamic
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # When not using gcc, we currently assume that we are using
       # Microsoft Visual C++.
       # hardcode_libdir_flag_spec is actually meaningless, as there is
@@ -11421,14 +11421,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -11452,7 +11452,7 @@ cygwin* | mingw* | pw32* | cegcc*)
 
       sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -12097,7 +12097,7 @@ else
     lt_cv_dlopen_self=yes
     ;;
 
-  mingw* | pw32* | cegcc*)
+  mingw* | msys* | pw32* | cegcc*)
     lt_cv_dlopen="LoadLibrary"
     lt_cv_dlopen_libs=
     ;;
@@ -12971,7 +12971,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -13324,7 +13324,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
         esac
         ;;
 
-      cygwin* | mingw* | pw32* | cegcc*)
+      cygwin* | mingw* | msys* | pw32* | cegcc*)
         # _LT_TAGVAR(hardcode_libdir_flag_spec, CXX) is actually meaningless,
         # as there is no search path for DLLs.
         hardcode_libdir_flag_spec_CXX='-L$libdir'
@@ -15149,14 +15149,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -15179,7 +15179,7 @@ cygwin* | mingw* | pw32* | cegcc*)
       soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
 
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -15798,7 +15798,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
 case $host in
-  *-cygwin* | *-mingw*)
+  *-cygwin* | *-mingw* | *-msys*)
     # 'host' will be top-level target in the case of a target lib,
     # we must compare to with_cross_host to decide if this is a native
     # or cross-compiler and select where to install dlls appropriately.
@@ -15938,7 +15938,7 @@ if test "x$VTV_SUPPORTED" = "xyes"; then
 fi
 
 case "$target_os" in
-  cygwin*|mingw32*)
+  cygwin*|mingw*)
     vtv_cygmin="yes"
     ;;
   *)
diff --git a/libvtv/configure.ac b/libvtv/configure.ac
index 50aaadbb3a3..964e29824a5 100644
--- a/libvtv/configure.ac
+++ b/libvtv/configure.ac
@@ -191,7 +191,7 @@ _EOF
 fi
 
 case "$target_os" in
-  cygwin*|mingw32*)
+  cygwin*|mingw*)
     vtv_cygmin="yes"
     ;;
   *)
diff --git a/lto-plugin/configure b/lto-plugin/configure
index 28f5dd79cd7..2e81b84517d 100755
--- a/lto-plugin/configure
+++ b/lto-plugin/configure
@@ -6337,7 +6337,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -9914,7 +9914,7 @@ _LT_EOF
       fi
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
       # as there is no search path for DLLs.
       hardcode_libdir_flag_spec='-L$libdir'
@@ -10345,7 +10345,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
       export_dynamic_flag_spec=-rdynamic
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # When not using gcc, we currently assume that we are using
       # Microsoft Visual C++.
       # hardcode_libdir_flag_spec is actually meaningless, as there is
@@ -11293,14 +11293,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -11324,7 +11324,7 @@ cygwin* | mingw* | pw32* | cegcc*)
 
       sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -11969,7 +11969,7 @@ else
     lt_cv_dlopen_self=yes
     ;;
 
-  mingw* | pw32* | cegcc*)
+  mingw* | msys* | pw32* | cegcc*)
     lt_cv_dlopen="LoadLibrary"
     lt_cv_dlopen_libs=
     ;;
@@ -12596,7 +12596,7 @@ fi
 
 
 case $host in
-  *-cygwin* | *-mingw*)
+  *-cygwin* | *-mingw* | *-msys*)
     # 'host' will be top-level target in the case of a target lib,
     # we must compare to with_cross_host to decide if this is a native
     # or cross-compiler and select where to install dlls appropriately.
diff --git a/zlib/configure b/zlib/configure
index 92c462d04c6..f50584c6e23 100755
--- a/zlib/configure
+++ b/zlib/configure
@@ -4650,7 +4650,7 @@ if test "$GCC" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
-  *-*-mingw*)
+  *-*-mingw*|*-*-msys*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -5009,6 +5009,12 @@ else
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
+  mint*)
+    # On MiNT this test can take minutes to run, and I'm not sure it's
+    # healthy for this platform. Let's restrict it to 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
   amigaos*)
     # On AmigaOS with pdksh, this test takes hours, literally.
     # So we just punt and use a minimum line length of 8192.
@@ -8500,7 +8506,7 @@ _LT_EOF
       fi
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
       # as there is no search path for DLLs.
       hardcode_libdir_flag_spec='-L$libdir'
@@ -8937,7 +8943,7 @@ if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
       export_dynamic_flag_spec=-rdynamic
       ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
+    cygwin* | mingw* | msys* | pw32* | cegcc*)
       # When not using gcc, we currently assume that we are using
       # Microsoft Visual C++.
       # hardcode_libdir_flag_spec is actually meaningless, as there is
@@ -9888,14 +9894,14 @@ bsdi[45]*)
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | msys* | pw32* | cegcc*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,msys* | yes,pw32* | yes,cegcc*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
@@ -9919,7 +9925,7 @@ cygwin* | mingw* | pw32* | cegcc*)
 
       sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
       ;;
-    mingw* | cegcc*)
+    mingw* | msys* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       ;;
@@ -10567,7 +10573,7 @@ else
     lt_cv_dlopen_self=yes
     ;;
 
-  mingw* | pw32* | cegcc*)
+  mingw* | msys* | pw32* | cegcc*)
     lt_cv_dlopen="LoadLibrary"
     lt_cv_dlopen_libs=
     ;;
